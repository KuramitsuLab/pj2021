BLEU score = 79.27
epoch = 44
image = 5

| Train Loss: 0.082 | Train PPL:   1.085 |
| Val. Loss: 0.378 |  Val. PPL:   1.459 |
| Test Loss: 0.378 | Test PPL:   1.459 |

0
src = if count % 15 == 0 :
trg = 無限の整数列を 15 で割った余りが 0 と等しいとき 、
rst = 無限の整数列を 15 で割った余りが 0 と等しいとき 、 <eos>
1
src = dfs ( A [ 0 ] )
trg = dfs ( A [0])
rst = dfs ( A [0]) <eos>
2
src = while A . has_left ( ) and A . left . has_left ( ) :
trg = A . has _ left () かつ A . left . has _ left () の 間 、 次 を 繰り返 す
rst = A . has _ left () かつ A . left () の 間 、 次 を 繰り返 す <eos>
3
src = DFS ( 0 , - 1 )
trg = DFS (0,-1)
rst = DFS (0, -1) <eos>
4
src = for A , B in enumerate ( reversed ( C ) ) :
trg = C を反転した列 に番号付した組の列を順に A 、 B として 、 繰り返 す
rst = C <unk> に番号付した組の列を順に A 、 B として 、 繰り返 す <eos>
5
src = return A [ B * 3 ]
trg = A の B に 3 を掛けた値 番目を返す
rst = A の B に 3 を掛けた値を返す <eos>
6
src = if A . count ( B [ 0 ] ) == 2 :
trg = A 内の B の先頭の出現回数が 2 と等しいとき 、
rst = A 内の B の先頭の出現回数が 2 と等しいとき 、 <eos>
7
src = print ( ' ' * A , B , C [ B ] , D [ B ] )
trg = 空白文字に A を掛けた値 、 B 、 C の B 番目 、 D の B 番目を出力する
rst = 空白文字に A を掛けた値 、 B 、 C の B 番目 、 D の B 番目を出力する <eos>
8
src = if A . _par_ [ B ] == C or A . cdused [ C ] :
trg = A の _ par _ の B 番目が C と等しくまたは A の cdused の C 番目のとき 、
rst = A の _ par _ の B 番目が C と等しくまたは A の cdused の C 番目のとき 、 <eos>
9
src = A . f_val_to_key = { }
trg = 空辞書を A の f _ val _ to _ key に する
rst = 空辞書を A の <unk> に する <eos>
10
src = A , B = 0 , deque ( [ C ] )
trg = 0 、 ( C ) からなる列 の両端キューを A 、 B とする
rst = 0 、 ( C ) からなる列 の両端キューを A 、 B とする <eos>
11
src = print ( A . format ( B [ C ] - 13 ) )
trg = A を書式として B の C 番目から 13 を引いた値 で整形した文字列を出力する
rst = A を書式として B の C 番目から 13 を引いた値 で整形した文字列を出力する <eos>
12
src = A . bit1 = BinaryIndexedTree ( B + 1 )
trg = BinaryIndexedTree ( B +1) を A の bit 1 に する
rst = BinaryIndexedTree ( B +1) を A の bit 1 に する <eos>
13
src = A . add ( B + C + D )
trg = A に B に C を加えた値に D を加えた値 を追加した集まり
rst = A に B に C を加えた値に D を加えた値 を追加した集まり <eos>
14
src = plot ( A + B , C + D )
trg = plot ( A + B , C + D )
rst = compute _ height ( A + B , C + D ) <eos>
15
src = if A < max ( B ) :
trg = A が B の最大値 より小さいとき 、
rst = A が B の最大値 より小さいとき 、 <eos>
16
src = A = B . node . value
trg = B の node の value を A とする
rst = B の node を A とする <eos>
17
src = for A in range ( 2 , - ~ int ( B ** .5 ) ) :
trg = 2 から - B の .5 乗の整数値 の 補 数 未満までの数列を順に A として 、 繰り返 す
rst = 2 から - B の .5 乗の整数値 未満までの数列を順に A として 、 繰り返 す <eos>
18
src = if A [ B - C - 1 ] != D :
trg = A の B から C を引いた値から 1 を引いた値番目が D と等しくないとき 、
rst = A の B から C を引いた値から 1 を引いた値番目が D と等しくないとき 、 <eos>
19
src = A . sort ( key = lambda C : abs ( B // 2 - C ) )
trg = i をパラメータとして B を 2 で割った商から i を引いた値の絶対値を返す関数を key として A をソート する
rst = x をパラメータとして B を 2 で割った商から C を引いた値の絶対値 を返す関数を key として A をソート する <eos>
20
src = A [ B ] [ C ] = D = max ( gen ( B , E ) )
trg = gen ( B , E ) の最大値を D とする を A の B 番目の C 番目に する
rst = gen ( D , B ) を D とする を A の B 番目の C 番目に する <eos>
21
src = A , B = [ 0 ] * 62 , [ 0 ] * 62
trg = (0) からなる列の 62 回分の列 、 (0) からなる列の 62 回分の列を A 、 B とする
rst = (0) からなる列の 62 回分の列 、 (0) からなる列の 62 回分の列を A 、 B とする <eos>
22
src = A . E [ B ] . append ( A . Edge ( C , 0 , len ( A . E [ C ] ) - 1 ) )
trg = A の E の B 番目の末尾に A . Edge ( C ,0, len ( A . E [ C ] )-1) を追加する
rst = A の E の B 番目の末尾に A . Edge ( C ,0, len ( A . E [ C ] )-1) を追加する <eos>
23
src = A . AddNode ( B )
trg = A . AddNode ( B )
rst = A . <unk> ( B ) <eos>
24
src = print ( [ A , B , C , D , E , '' , F , '' , G ] [ H ] )
trg = ( A 、 B 、 C 、 D 、 E 、 空文字列 、 F 、 空文字列 、 G ) からなる列の H 番目を出力する
rst = ( A 、 B 、 C 、 D 、 E 、 ネイピア数 、 F 、 G ) からなる列の H 番目を出力する <eos>
25
src = return A . data & A . masks [ B ] == A . masks [ B ]
trg = A の data と A の masks の B 番目の論理積が A の masks の B 番目と等しいかどうかを返す
rst = A の data と A の masks の B 番目の論理積が A の masks の B 番目と等しいかどうかを返す <eos>
26
src = A , B = C [ 0 ] - 1 , C [ 1 ] - 1
trg = C の先頭から 1 を引いた値 、 C の 1 番目から 1 を引いた値を A 、 B とする
rst = C の先頭から 1 を引いた値 、 C の 1 番目から 1 を引いた値を A 、 B とする <eos>
27
src = A . append ( [ ( B , C ) ] )
trg = A の末尾に ( ( B 、 C ) の組 ) からなる列 を追加する
rst = A の末尾に ( B 、 C ) からなる列 を追加する <eos>
28
src = time += A . pop ( 0 ) * 60 + A . pop ( 0 )
trg = time を A の 0 を取り出した値 に 60 を掛けた値に A の 0 を取り出した値 を加えた値だけ 増 加 させ る
rst = time を A の 0 番目に 60 を掛けた値に A の 0 番目を加えた値を掛けた値だけ 増 加 させ る <eos>
29
src = if A [ B ] & 2 :
trg = A の B 番目と 2 の論理積のとき 、
rst = A の B 番目と 2 の論理積のとき 、 <eos>
30
src = if [ 1 , 10 , 11 , 12 , 13 ] == A :
trg = ( 1 、10、11、12、13 ) からなる列が A と等しいとき 、
rst = ( 1 、10、11、12、13 ) からなる列が A と等しいとき 、 <eos>
31
src = A . clear ( int ( B [ 1 ] ) )
trg = A 、 B の 1 番目の整数値 内の全ての要素を取り除く
rst = A 、 B の 1 番目の整数値 内の全ての要素を取り除く <eos>
32
src = print ( C if par ( A ) == par ( B ) else D )
trg = par ( A ) が par ( B ) と等しいとき C 、 そうでなければ D を出力する
rst = par ( A ) が par ( B ) と等しいとき C 、 そうでなければ D を出力する <eos>
33
src = A += B [ - 1 ]
trg = A を B の末尾だけ 増 加 させ る
rst = A を B の -1 番目だけ 増 加 させ る <eos>
34
src = A [ B ] . right = int ( C )
trg = C の整数値を A の B 番目の right に する
rst = C の整数値を A の B 番目の right に する <eos>
35
src = A [ B ] [ C ] = 0
trg = 0 を A の B 番目の C 番目に する
rst = 0 を A の B 番目の C 番目に する <eos>
36
src = return calc_gcd ( A , B % A )
trg = calc _ gcd ( A , B % A ) を返す
rst = calc _ gcd ( A , B % A ) を返す <eos>
37
src = A [ 0 ] , A [ 1 ] = 2 , 3
trg = 2 、 3 を A の先頭 、 A の 1 番目とする
rst = 2 、 3 を A の先頭 、 A の 1 番目とする <eos>
38
src = print ( {D_1} {D_2} {D_3} {max} )
trg = "{} {} {} {}" を出力する
rst = "{} {} {} {} {} {} \ n {}" を出力する <eos>
39
src = A = int ( B / C + B % C )
trg = B を C で割った値に B を C で割った余り を加えた値の整数値を A とする
rst = B を C で割った値に B を C で割った余りを加えた値を A とする <eos>
40
src = return A [ 4 ]
trg = A の 4 番目を返す
rst = A の 4 番目を返す <eos>
41
src = A [ B ] . left , A [ B ] . right = C
trg = C を展開し 、 それぞれ A の B 番目の left 、 A の B 番目の right とする
rst = C を A の B 番目の left 、 A の B 番目の right に する <eos>
42
src = A [ B ] [ - 1 ] = sum ( A [ B ] [ : - 1 ] )
trg = A の B 番目の末尾 を除いた部分列の総和を A の B 番目の -1 番目に する
rst = A の B 番目の 、 つまり先頭から -1 番目までの部分列の総和を A の B 番目の -1 番目に する <eos>
43
src = print ( min ( A [ 0 ] , A [ 1 ] , A [ 2 ] ) + min ( A [ 3 ] , A [ 4 ] ) - 50 )
trg = A の先頭 、 A の 1 番目 、 A の 2 番目の最小値に A の 3 番目 、 A の 4 番目の最小値 を加えた値から 50 を引いた値 を出力する
rst = A の先頭 、 A の 1 番目 、 A の 2 番目に A の 3 番目 、 A の 4 番目の最小値 から A の 4 番目を引いた値 を出力する <eos>
44
src = return A . format ( B - 1925 , C , D )
trg = A を書式として B から 1925 を引いた値 、 C 、 D で整形した文字列を返す
rst = A を書式として B から 1925 を引いた値 、 C 、 D で整形した文字列を返す <eos>
45
src = A = deque ( [ ( 0 , 0 , 0 , 0 , 0 ) ] )
trg = ( (0、0、0、0、0) の組 ) からなる列 の両端キューを A とする
rst = ( (0、0、0、0、0、0、0 ) からなる列 の両端キューを A とする <eos>
46
src = A = [ sorted ( B [ C ] , key = lambda D : float ( D [ 1 ] ) ) [ : 4 ] for C in range ( 3 ) ]
trg = 0 から 3 未満までの数列の各要素を C とし 、 x をパラメータとして D [1] の浮動小数点数 を返す関数をキーとして B の C 番目をソートした列 の 、 つまり先頭から 4 番目までの部分列 の列を A とする
rst = 0 から 4 未満までの数列の各要素を C とし 、 D の 1 番目の 2 番目の浮動小数点数 を返す関数を適用した列の総和を A とする <eos>
47
src = A [ 0 ] [ B ] = A [ 0 ] [ B - 1 ] + 1
trg = A の先頭の B から 1 を引いた値番目に 1 を加えた値を A の先頭の B 番目に する
rst = A の先頭の B から 1 を引いた値番目に 1 を加えた値を A の先頭の B 番目に する <eos>
48
src = if A + 1 < B [ C ] [ D ] [ E ] :
trg = A に 1 を加えた値が B の C 番目の D 番目の E 番目より小さいとき 、
rst = A に 1 を加えた値が B の C 番目の D 番目の E 番目より小さいとき 、 <eos>
49
src = return A . __lower_bound ( B )
trg = A .__ lower _ bound ( B ) を返す
rst = A ._ add _ id ( B ) を返す <eos>
50
src = A , B = C . rstrip ( ) . split ( ' ' )
trg = C の末尾から 空白改行を取り除いた文字列 を空白文字で分割した字句列 を展開し 、 それぞれ A 、 B とする
rst = C の末尾から 空白改行を取り除いた文字列 を空白文字で分割した字句列 を展開し 、 それぞれ A 、 B とする <eos>
51
src = A . left = _put ( A . left )
trg = _ put ( A . left ) を A の left に する
rst = <unk> ( A . left ) を A の left に する <eos>
52
src = A = min ( A , B - C - D [ E ] )
trg = A 、 B から C を引いた値から D の E 番目 を引いた値の最小値を A とする
rst = A 、 B から C を引いた値から D の E 番目 を引いた値の最小値を A とする <eos>
53
src = if A == 0 and B [ C ] < 0 :
trg = A が 0 と等しくかつ B の C 番目が 0 より小さいとき 、
rst = A が 0 と等しくかつ B の C 番目が 0 より小さいとき 、 <eos>
54
src = str = str [ : A ] + str [ A : B ] [ : : - 1 ] + str [ B : ]
trg = 整数の 、 つまり先頭から A 番目までの部分列に 整数の A 番目から B 番目までの部分列の 、 つまり先頭から 、 つまり末尾までの -1 間隔による部分列を加えた値に 整数の B 番目から 、 つまり末尾までの部分列を加えた値 を 整数 とする
rst = 整数の 、 つまり先頭から A 番目までの部分列に B <unk> A の B 番目から 、 つまり末尾までの -1 間隔による部分列を加えた値に 整数 の B 番目から 、 つまり末尾までの部分列を加えた値 を A とする <eos>
55
src = if A [ B ] [ C + 2 ] :
trg = A の B 番目の C に 2 を加えた値番目のとき 、
rst = A の B 番目の C に 2 を加えた値番目のとき 、 <eos>
56
src = A = B . vec [ C % 2 ]
trg = B の vec の C を 2 で割った余り番目を A とする
rst = B の MOVE _ <unk> の C を 2 で割った余り番目を A とする <eos>
57
src = A = ( 2 * B + C ) / 3
trg = 2 に B を掛けた値に C を加えた値を 3 で割った値を A とする
rst = 2 に B を掛けた値に C を加えた値を 3 で割った値を A とする <eos>
58
src = A . append ( A [ - 1 ] + B - C )
trg = A の末尾に A の末尾に B を加えた値から C を引いた値 を追加する
rst = A の末尾に A の -1 番目に B を加えた値から C を引いた値 を追加する <eos>
59
src = A = - B . dual [ C ]
trg = - B の dual の C 番目を A とする
rst = - B の dual の C 番目を A とする <eos>
60
src = A , B = factor ( )
trg = factor () を展開し 、 それぞれ A 、 B とする
rst = factor () を展開し 、 それぞれ A 、 B とする <eos>
61
src = if A . nums [ B ] != C . nums [ B ] :
trg = A の nums の B 番目が C の nums の B 番目と等しくないとき 、
rst = A の nums の B 番目が C の nums の B 番目と等しくないとき 、 <eos>
62
src = A . tail = A . head
trg = A の head を A の tail に する
rst = A の head を A の tail に する <eos>
63
src = while A != B . elements [ A ] :
trg = A が B の elements の A 番目と等しくない 間 、 次 を 繰り返 す
rst = A が B の elements の A 番目と等しくない 間 、 次 を 繰り返 す <eos>
64
src = A /= B * B
trg = A を B に B を掛けた値 分の 一 に する
rst = A を B に B を掛けた値 分の 一 に する <eos>
65
src = A . append ( ( B + C * D , E + F * D ) )
trg = A の末尾に ( B に C に D を掛けた値を加えた値 、 E に F に D を掛けた値を加えた値 ) の組 を追加する
rst = A の末尾に ( B に C に D を掛けた値を加えた値 、 E に F に D を掛けた値を加えた値 ) の組 を追加する <eos>
66
src = A . extend ( B . sub ( C ) )
trg = B . sub ( C ) を追加して A を 拡張 する
rst = B . sub ( C ) を追加して A を 拡張 する <eos>
67
src = A = [ [ - 1 ] * [ ( B * 2 + 1 ) for C in range ( B * 2 + 1 ) ] ]
trg = ( (-1) からなる列の 0 から B *2 に 1 を加えた値未満までの数列の各要素 を C とし 、 B に 2 を掛けた値に 1 を加えた値の列回分の列 ) からなる列を A とする
rst = ( (-1) からなる列の 0 から B *2 に 1 を加えた値未満までの数列の各要素 を C とし 、 B に 2 を掛けた値に 1 を加えた値の列回分の列 ) からなる列を A とする <eos>
68
src = A = A - B * 3600 - C * 60
trg = A から B に 3600 を掛けた値を引いた値から C に 60 を掛けた値を引いた値を A とする
rst = A から B に 3600 を掛けた値を引いた値から C に 60 を掛けた値を引いた値を A とする <eos>
69
src = A . qtime = B
trg = B を A の qtime に する
rst = B を A の qtime に する <eos>
70
src = if abs ( A ) < 0.00001 :
trg = A の絶対値が 0.00001 より小さいとき 、
rst = A の絶対値が 0.00001 より小さいとき 、 <eos>
71
src = A . append ( int ( str ( B [ 3 ] ) + str ( B [ 0 ] ) ) )
trg = A の末尾に B の 3 番目の文字列に B の先頭の文字列を加えた値 の整数値を追加する
rst = A の末尾に B の 3 番目の文字列に B の先頭の文字列を加えた値 の整数値を追加する <eos>
72
src = print ( '' . join ( A [ B : C ] ) )
trg = 空文字列を間に入れて A の B 番目から C 番目までの部分列 を連結した文字列を出力する
rst = 空文字列を間に入れて A の B 番目から C 番目までの部分列 を連結した文字列を出力する <eos>
73
src = print ( count ( A , 0 , B , C ) )
trg = A から 始 まり 0 、 B 、 C 間隔 で 続 く無限の整数列 を出力する
rst = A と 0 、 B 、 C を出力する <eos>
74
src = A . array = [ ]
trg = 空列を A の array に する
rst = 空列を A の array に する <eos>
75
src = A . lst = [ Lst ( ) for B in range ( C ) ]
trg = 0 から C 未満までの数列の各要素を B とし 、 Lst () の列を A の lst に する
rst = 0 から C 未満までの数列の各要素を B とし 、 Lst () の列を A の lst に する <eos>
76
src = A [ B + C ] . append ( ( B + D , E [ C - D - 1 ] ) )
trg = A の B に C を加えた値番目の末尾に ( B に D を加えた値 、 E の C から D を引いた値から 1 を引いた値番目 ) の組 を追加する
rst = A の B に C を加えた値番目の末尾に ( B に D を加えた値 、 E の C から D を引いた値から 1 を引いた値番目 ) の組 を追加する <eos>
77
src = setDepth ( A [ B ] . left , C + 1 )
trg = setDepth ( A [ B ] . left , C +1)
rst = setDepth ( A [ B ] . left , C +1) <eos>
78
src = A [ min ( B , C ) ] += 1
trg = A の B 、 C の最小値番目を 1 だけ 増 加 させ る
rst = A の B 、 C の最小値番目を 1 だけ 増 加 させ る <eos>
79
src = A = Node ( B , C , D )
trg = Node ( B , C , D ) を A とする
rst = Node ( B , C , D ) を A とする <eos>
80
src = return ( 1 , 0 , 2 )
trg = (1、0、2 ) の組を返す
rst = ( 1 、0、2、3 ) の組を返す <eos>
81
src = A . append ( bmi ( abs ( calc_BMI ( B , C ) - 22 ) , D ) )
trg = A の末尾に bmi ( abs ( calc _ BMI ( B , C ) -2 2 ) , D ) を追加する
rst = A の末尾に <unk> ( abs ( B , C ) , abs _ distance ( D ) を追加する <eos>
82
src = if A [ B - 1 : B + C - 1 ] != [ ' ' ] * C :
trg = A の B から 1 を引いた値から B に C を加えた値から 1 を引いた値までの部分列が ( 、 つまり空白文字 ) からなる列の C 回分の列 と等しくないとき 、
rst = A の B から 1 を引いた値から B に C を加えた値から 1 を引いた値までの部分列に 、 つまり空白文字 と等しくないとき 、 <eos>
83
src = A = ( 1.0 + ( B / 100.0 ) ) ** C
trg = 1.0 に B を 100.0 で割った値を加えた値の C 乗を A とする
rst = 1.0 に B を 10 で割った値の C 乗を加えた値を A とする <eos>
84
src = for A in range ( B + 2 , min ( B + 10 , C + 1 ) ) :
trg = B に 2 を加えた値から B に 10 を加えた値 、 C に 1 を加えた値の最小値 未満までの数列を順に A として 、 繰り返 す
rst = B に 2 を加えた値から B に 10 を加えた値 、 C に 1 を加えた値の最小値 未満までの数列を順に A として 、 繰り返 す <eos>
85
src = A = D if B < C - 1 else E
trg = B が C から 1 を引いた値より小さいとき D 、 そうでなければ E を A とする
rst = B が C から 1 を引いた値より小さいとき D 、 そうでなければ E を A とする <eos>
86
src = appx ( A )
trg = appx ( A )
rst = <unk> ( A ) <eos>
87
src = print ( A - B . count ( 0 ) + 1 )
trg = A から B 内の 0 の出現回数を引いた値に 1 を加えた値を出力する
rst = A から B 内の 0 <unk> 1 を加えた値を出力する <eos>
88
src = print ( reflect ( A , B ) )
trg = reflect ( A , B ) を出力する
rst = reflect ( A , B ) を出力する <eos>
89
src = A = UFT ( )
trg = UFT () を A とする
rst = <unk> () を A とする <eos>
90
src = if A == 1 and B [ 0 ] == C :
trg = A が 1 と等しくかつ B の先頭が C と等しいとき 、
rst = A が 1 と等しくかつ B の 0 番目が C と等しいとき 、 <eos>
91
src = A -= 5 * B
trg = A を 5 に B を掛けた値だけ 減 少 させ る
rst = A を 5 に B を掛けた値だけ 減 少 させ る <eos>
92
src = A = { start : 0 , goal : 0 }
trg = ( ( B , 0)、( C , 0 )) からなる辞書を A とする
rst = ( ( B , 0 )) からなる辞書を A とする <eos>
93
src = A . add ( Edge ( B , C + 1 , 1 ) )
trg = A に Edge ( B , C +1,1) を追加した集まり
rst = A に Edge ( B , C +1,1) を追加した集まり <eos>
94
src = if not A . board . solved ( ) :
trg = A . board . solved () でないとき 、
rst = A . board () でないとき 、 <eos>
95
src = print ( [ 1 + len ( [ A for A in B if A > 0 ] ) , C ] [ max ( B ) < 2 ] )
trg = ( 1 に [ AforAinBifA >0 ] の長さ を加えた値 、 C ) からなる列の B の最大値が 2 より小さいかどうか番目を出力する
rst = A の各要素を B とし 、 A が 0 より大きいとき の 1 の列の総和 、 つまり末尾までの部分列に C の B 番目 を加えた値を出力する <eos>
96
src = A [ 3 ] -= B [ 3 ]
trg = A の 3 番目を B の 3 番目だけ 減 少 させ る
rst = A の 3 番目を B の 3 番目だけ 減 少 させ る <eos>
97
src = update ( A , B - 1 , 2 )
trg = update ( A , B -1,2)
rst = update ( A , B -1, -2) <eos>
98
src = A = B [ 0 ] [ 0 ] + B [ 0 ] [ 1 ] * 3 + B [ 1 ] [ 0 ] * 9 + B [ 1 ] [ 1 ] * 27
trg = B の先頭の 0 番目に B [0] の 1 番目に 3 を掛けた値を加えた値に B の 1 番目の先頭に 9 を掛けた値を加えた値に B の 1 番目の 1 番目に 27 を掛けた値を加えた値を A とする
rst = B の先頭の 0 番目に B の 1 番目の 1 番目を掛けた値を加えた値に B の 1 番目に 3 を掛けた値を加えた値に B の 1 番目に 9 を掛けた値を加えた値に B の先頭を加えた値を A とする <eos>
99
src = if not A [ B ] . get ( C , 0 ) <= D [ B ] . get ( C , 100 ) :
trg = A の B 番目 に対応する値 、 もし存在しなければ C 、0 が D の B 番目 に対応する値 、 もし存在しなければ C 、 100 以下 でないとき 、
rst = A の B 番目内の C に対応する値 、 もし存在しなければ D の B 番目が 、 つまり空文字列 、 C 、 100 ) の組 、0 より大きいとき 、 <eos>
100
src = if A % 3650 == 0 :
trg = A を 3650 で割った余りが 0 と等しいとき 、
rst = A を 3650 で割った余りが 0 と等しいとき 、 <eos>
101
src = A += str ( B )
trg = A を B の文字列 だけ 増 加 させ る
rst = A を B の文字列 だけ 増 加 させ る <eos>
102
src = if A . char :
trg = A の char のとき 、
rst = A の direction のとき 、 <eos>
103
src = write ( A % ( B + C - D ) )
trg = write ( A %( B + C - D ))
rst = write ( A %( B + C - D )) <eos>
104
src = A = [ [ [ None ] * [ 4 for B in range ( C ) ] ] for D in range ( C ) ]
trg = 0 から C 未満までの数列の各要素を D とし 、(( 、 つまり未定値 ) からなる列の 0 から C 未満までの数列の各要素を B とし 、 4 の列回分の列 ) からなる列の列を A とする
rst = 0 から C 未満までの数列の各要素を D とし 、0 から C 未満までの数列の各要素を B とし 、 ( 、 つまり未定値 ) からなる列の 0 から C 未満までの数列の各要素を B とし 、 4 の列回分の列 ) からなる列の列を A とする <eos>
105
src = if A - 1 >= 0 and B [ A - 1 ] in C :
trg = A から 1 を引いた値が 0 以上かつ B の A から 1 を引いた値番目が C に含まれるとき 、
rst = A から 1 を引いた値が 0 以上かつ B の A から 1 を引いた値番目が C に含まれるとき 、 <eos>
106
src = A = [ [ 0 ] + list ( input ( ) ) + [ 0 ] for B in range ( C ) ]
trg = 0 から C 未満までの数列の各要素を B とし 、 (0) からなる列に入力された文字列 のリストを加えた値に (0) からなる列を加えた値の列を A とする
rst = 0 から C 未満までの数列の各要素を B とし 、 (0) からなる列に input ()) のリストを加えた値に (0) からなる列を加えた値の列を A とする <eos>
107
src = A . setroot ( 0 )
trg = A . setroot (0)
rst = A . up (0) <eos>
108
src = A = convert ( A , B , C )
trg = convert ( A , B , C ) を A とする
rst = convert ( A , B , C ) を A とする <eos>
109
src = A += max ( B [ 0 ] - C , 0 )
trg = A を B の 0 番目から C を引いた値 、0 の最大値 だけ 増 加 させ る
rst = A を B の 0 番目から C を引いた値 、0 の最大値 だけ 増 加 させ る <eos>
110
src = A = B . operator_func ( A , B . node [ C - 1 ] )
trg = B . operator _ func ( A , B . node [ C -1]) を A とする
rst = B . node _ B . node ( A , B . node [ C -1]) を A とする <eos>
111
src = A . used [ B ] = True
trg = 真を A の used の B 番目に する
rst = 真を A の used の B 番目に する <eos>
112
src = A . top_left = B
trg = B を A の top _ left に する
rst = B を A の top _ left に する <eos>
113
src = if A . right . value == B :
trg = A の right の value が B と等しいとき 、
rst = A の right の value が B と等しいとき 、 <eos>
114
src = if not A <= B [ C ] <= D :
trg = A が B の C 番目以下かどうかが D 以下 でないとき 、
rst = A が B の C 番目以下かどうかが D 以下 でないとき 、 <eos>
115
src = if A - B <= 0 :
trg = A から B を引いた値が 0 以下のとき 、
rst = A から B を引いた値が 0 以下のとき 、 <eos>
116
src = A = B [ 2 + C ]
trg = B の 2 に C を加えた値番目を A とする
rst = B の 2 に C を加えた値番目を A とする <eos>
117
src = if ( intime ( A ) or intime ( B ) ) and C <= 40 :
trg = intime ( A ) または intime ( B ) かつ C が 40 以下のとき 、
rst = <unk> ( A ) または is _ prime _ <unk> ( B ) かつ 40 が C 以下のとき 、 <eos>
118
src = if A . list [ B ] != C . list [ B ] :
trg = A の list の B 番目が C の list の B 番目と等しくないとき 、
rst = A の list の B 番目が C の idx の B 番目と等しくないとき 、 <eos>
119
src = for A , B in sorted ( [ ( ( sum ( [ 1 << C for C in D ] ) ) , ' ' . join ( map ( str , D ) ) ) for E in [ range ( F + 1 ) for D in combinations ( G , E ) ] ] ) :
trg = G の E 個までの コン ビ ネ ー シ ョ ンの各要素を D とし 、0 から F に 1 を加えた値 未満までの数列の列の各要素を E とし 、 ( D の各要素を C とし 、 1<< C の列の総和 、 空白文字を間に入れて D の各要素に str を適用した列を連結した文字列 ) の組の列をソートした列 を順に A 、 B として 、 繰り返 す
rst = 0 から G 未満までの数列の各要素を F とし 、 D . split () の各要素に int を適用した列を連結した文字列 の各要素を C 、 D とし 、 ( C <unk> 、 D ) <unk> の各要素を C とし 、 1 の列の総和を E で割った値 を引いた値の絶対値の列の最小値を A 、 B として 、 繰り返 す <eos>
120
src = get ( A , B , count , C [ 1 ] )
trg = get ( A , B , count , C [1])
rst = get ( A , B , count , C [1]) のとき 、 <eos>
121
src = if A . isalpha ( ) and A not in B :
trg = A が全て ア ル ファ ベ ット かつ A が B に含まれないとき 、
rst = A が全て ア ル ファ ベ <unk> かつ A が B に含まれないとき 、 <eos>
122
src = E = B [ F ] [ G ]
trg = B の F 番目の G 番目を E とする
rst = B の F 番目の G 番目を E とする <eos>
123
src = while A % B != 0 :
trg = A を B で割った余りが 0 と等しくない 間 、 次 を 繰り返 す
rst = A を B で割った余りが 0 と等しくない 間 、 次 を 繰り返 す <eos>
124
src = A [ B ] . append ( ( 1 << C , B + 1 ) )
trg = A の B 番目の末尾に ( 1 を C だけ左シフトした値 、 B に 1 を加えた値 ) の組 を追加する
rst = A の B 番目の末尾に ( 1 を C だけ左シフトした値 、 B に 1 を加えた値 ) の組 を追加する <eos>
125
src = A = len ( B ) % 5
trg = B の長さを 5 で割った余りを A とする
rst = B の長さを 5 で割った余りを A とする <eos>
126
src = A += term ( )
trg = A を term () だけ 増 加 させ る
rst = A を term () だけ 増 加 させ る <eos>
127
src = if A [ B ] [ C ] == A [ B ] [ C + 1 ] :
trg = A の B 番目の C 番目が A の B 番目の C に 1 を加えた値番目 と等しいとき 、
rst = A の B 番目の C 番目が A の B 番目の C に 1 を加えた値番目 と等しいとき 、 <eos>
128
src = A = B [ 0 ]
trg = B の 0 番目を A とする
rst = B の先頭を A とする <eos>
129
src = A = [ ( B ** 2 + C ** 2 , B , C ) for B in [ range ( 1 , 150 ) for C in range ( B + 1 , 150 ) ] ]
trg = B に 1 を加えた値から 150 未満までの数列の各要素を C とし 、 1 から 150 未満までの数列の列の各要素を B とし 、 ( B の 2 乗に C の 2 乗を加えた値 、 B 、 C ) の組の列を A とする
rst = 0 から B に 1 を加えた値未満までの数列の各要素 を C とし 、 ( B の 2 乗に C の 2 乗を加えた値 、 B 、 C の 2 乗 ) の組の列を A とする <eos>
130
src = A [ B ] = C [ B ] = D * E [ B ]
trg = D に E の B 番目を掛けた値を C の B 番目とするを A の B 番目に する
rst = D に E の B 番目を掛けた値を C の B 番目とするを A の B 番目に する <eos>
131
src = for e , A in B [ C ] :
trg = B の C 番目を順にネイピア数 、 A として 、 繰り返 す
rst = B の C 番目を順に ネイピア数 、 A として 、 繰り返 す <eos>
132
src = A = B . pt1 . y + C / B . abs * B . vector . y
trg = B の pt 1 の y 座標に C を B の abs で割った値に B の vector の y 座標を掛けた値を加えた値を A とする
rst = B の pt 1 の y 座標に C を B の abs で割った値に B の vector を掛けた値を加えた値を A とする <eos>
133
src = A = min ( B [ C : e ] )
trg = B の C 番目から 、 つまりネイピア数番目までの部分列 の最小値を A とする
rst = B の C 番目から 、 つまりネイピア数番目までの部分列 の最小値を A とする <eos>
134
src = A = { 1 : 0 , 2 : 0 , 3 : 0 , 4 : 0 , 5 : 0 , 6 : 0 }
trg = ( (1, 0)、( 2 , 0)、( 3 , 0)、( 4 , 0)、( 5 , 0)、( 6 , 0 )) からなる辞書を A とする
rst = ( (1, 2 000)、( 0 、5、4、 3 000)、( 4 、0、2、3 、5、1) の組 )、( 2 , 0)、( A とする <eos>
135
src = A . extend ( list ( map ( int , input ( ) . split ( ) ) ) )
trg = 入力された文字列 を空白で分割した字句列の各要素に 整数を適用した列のリストを 追加して A を 拡張 する
rst = 入力された文字列 を空白で分割した字句列の各要素に 整数を適用した列のリストを 追加して A を 拡張 する <eos>
136
src = A . append ( [ B , C [ B ] , C [ D ] , E , F ] )
trg = A の末尾に ( B 、 C の B 番目 、 C の D 番目 、 E 、 F ) からなる列 を追加する
rst = A の末尾に ( B 、 C の B 番目 、 C の D 番目 、 E 、 F ) からなる列 を追加する <eos>
137
src = A [ : 4 ] = [ B , C , C , D + E ]
trg = ( B 、 C 、 C 、 D に E を加えた値 ) からなる列を A の 、 つまり先頭から 4 番目までの部分列に する
rst = ( B 、 C 、 C 、 D 、 E ) からなる列を A の 、 つまり先頭から 4 番目までの部分列に する <eos>
138
src = if A [ B ] - A [ B - 1 ] == 2 :
trg = A の B 番目から A の B から 1 を引いた値番目を引いた値が 2 と等しいとき 、
rst = A の B 番目から A の B から 1 を引いた値番目を引いた値が 2 と等しいとき 、 <eos>
139
src = A . s = B [ 1 ]
trg = B の 1 番目を A の s に する
rst = B の 1 番目を A の s に する <eos>
140
src = A . insert ( 0 , B . head . next )
trg = A の 0 に B の head の next を挿入する
rst = A の 0 に B の head の next を挿入する <eos>
141
src = A = F ( * B [ C - 1 ] )
trg = F (* B [ C -1]) を A とする
rst = F (* B [ C -1]) を A とする <eos>
142
src = A [ B ] = min ( C , D + 1 )
trg = C 、 D に 1 を加えた値の最小値を A の B 番目に する
rst = C 、 D に 1 を加えた値の最小値を A の B 番目に する <eos>
143
src = A = B if A == B else reflection ( C , D )
trg = A が B と等しいとき B 、 そうでなければ reflection ( C , D ) を A とする
rst = A が B と等しいとき B 、 そうでなければ reflection ( C , D ) を A とする <eos>
144
src = str = A + B + C
trg = A に B を加えた値に C を加えた値を 整数 とする
rst = A に B を加えた値に C を加えた値を 整数 とする <eos>
145
src = A %= 10 ** B
trg = A を 10 の B 乗で割った余り に する
rst = A を 10 の B 乗 で割った余りに する <eos>
146
src = A = [ 0 , - 1 , 1 ]
trg = ( 0 、-1、1) からなる列を A とする
rst = (0、-1、0、1) からなる列を A とする <eos>
147
src = print ( 0 if A == 1 else f ( A , 0 ) )
trg = A が 1 と等しいとき 0 、 そうでなければ f ( A ,0) を出力する
rst = A が 1 と等しいとき 0 、 そうでなければ f ( A ,0) を出力する <eos>
148
src = A = ( B - C ) * ( D - E ) - ( F - G ) * ( H - I )
trg = B から C を引いた値に D から E を引いた値を掛けた値から F から G を引いた値に H から I を引いた値を掛けた値を引いた値を A とする
rst = B から C を引いた値に D から E を引いた値を掛けた値から F から G を引いた値に H から I を引いた値を掛けた値を引いた値に J を掛けた値を A とする <eos>
149
src = A = [ [ B , C + 1 ] , [ B , C - 1 ] , [ B + 1 , C ] , [ B - 1 , C ] ]
trg = ( ( B 、 C に 1 を加えた値 ) からなる列 、 ( B 、 C から 1 を引いた値 ) からなる列 、 ( B に 1 を加えた値 、 C ) からなる列 、 ( B から 1 を引いた値 、 C ) からなる列 ) からなる列を A とする
rst = ( B 、 C に 1 を加えた値 、 B 、 C から 1 を引いた値 ) からなる列 、 ( B 、 C から 1 を引いた値 ) からなる列 、 ( B 、 C から 1 を引いた値 ) からなる列を A とする <eos>
150
src = if A [ B ] + C + D [ E ] < A [ 1 ] :
trg = A の B 番目に C を加えた値に D の E 番目を加えた値が A の 1 番目より小さいとき 、
rst = A の B 番目に C を加えた値に D の E 番目を加えた値が A の 1 番目より小さいとき 、 <eos>
151
src = A = B . to
trg = B の to を A とする
rst = B の to を A とする <eos>
152
src = A = [ [ B , C ] , [ D , E ] , [ F , G ] ]
trg = ( ( B 、 C ) からなる列 、 ( D 、 E ) からなる列 、 ( F 、 G ) からなる列 ) からなる列を A とする
rst = ( ( B 、 C ) からなる列 、 ( D 、 E ) からなる列 、 ( F 、 G ) からなる列 ) からなる列を A とする <eos>
153
src = A = A [ : B ] + A [ C : D ] + A [ e : C ] + A [ B : e ] + A [ D : ]
trg = A の 、 つまり先頭から B 番目までの部分列に A の C 番目から D 番目までの部分列を加えた値に A の 、 つまりネイピア数番目から C 番目までの部分列を加えた値に A の B 番目から 、 つまりネイピア数番目までの部分列 を加えた値に A の D 番目から 、 つまり末尾までの部分列を加えた値 を A とする
rst = A の 、 つまり先頭から B 番目までの部分列に A の C 番目から D 番目までの部分列を加えた値に A の C 番目から C 番目までの部分列を加えた値に A の B 番目から D 番目までの部分列を加えた値に A の B 番目から D 番目までの部分列を加えた値に A の 、 つまりネイピア数番目から 、 つまり末尾までの部分列を加えた値 を A とする <eos>
154
src = if all ( [ A == B . OUTSIDE for A in C ] ) :
trg = C の各要素を A とし 、 A が B の OUTSIDE と等しいかどうかの列が全てが真 のとき 、
rst = C の各要素を A とし 、 A が B の OUTSIDE と等しいかどうかの列が全てが真 のとき 、 <eos>
155
src = for A in range ( B * B , 32769 , B ) :
trg = B に B を掛けた値から 32769 未満までの B 間隔の数列を順に A として 、 繰り返 す
rst = B に B を掛けた値から <unk> 未満までの B 間隔の数列を順に A として 、 繰り返 す <eos>
156
src = A = B / 1e5
trg = B を 1 e 5 で割った値を A とする
rst = B を <unk> で割った値を A とする <eos>
157
src = A = 1e5
trg = 1 e 5 を A とする
rst = <unk> を A とする <eos>
158
src = A , B = ( 2 * C + D ) / 3 , ( 2 * E + F ) / 3
trg = 2 に C を掛けた値に D を加えた値を 3 で割った値 、 2 に E を掛けた値に F を加えた値を 3 で割った値を A 、 B とする
rst = 2 に C を掛けた値に D を加えた値を 3 で割った値 、 2 に E を掛けた値に F を加えた値を 3 で割った値を A 、 B とする <eos>
159
src = A . delete ( B [ 1 ] )
trg = A . delete ( B [1])
rst = A . delete ( B [1]) <eos>
160
src = A . masks . append ( B )
trg = A の masks の末尾に B を追加する
rst = A の masks の末尾に B を追加する <eos>
161
src = print ( sum_of_digits ( A ) )
trg = sum _ of _ digits ( A ) を出力する
rst = <unk> ( A ) を出力する <eos>
162
src = A [ B ] [ C ] = max ( A [ B - 1 ] [ C ] , A [ B - 1 ] [ C - 1 ] ) + A [ B ] [ C ]
trg = A の B から 1 を引いた値番目の C 番目 、 A の B から 1 を引いた値番目の C から 1 を引いた値番目の最大値に A の B 番目の C 番目を加えた値を A の B 番目の C 番目に する
rst = A の B から 1 を引いた値番目の C 番目 、 A の B から 1 を引いた値番目の C から 1 を引いた値番目の最大値を A の B 番目の C 番目に する <eos>
163
src = if ( 0 == A [ 0 ] ) :
trg = 0 が A の先頭と等しいとき 、
rst = 0 が A の先頭 と等しいとき 、 <eos>
164
src = A = A * 0.01
trg = A に 0.01 を掛けた値を A とする
rst = A に 0.01 を掛けた値を A とする <eos>
165
src = print ( math . floor ( ( 100 - A ) * sum ( B ) / B [ C ] ) )
trg = 100 から A を引いた値に B の総和 を掛けた値を B の C 番目で割った値の切り 捨 て整数値 を出力する
rst = 100 から A を引いた値にネイピア数を掛けた値 に B の総和を B の総和を C で割った値の 2 乗 を加えた値を出力する <eos>
166
src = A = B . par_size [ A ]
trg = B の par _ size の A 番目を A とする
rst = B の par _ size の A 番目を A とする <eos>
167
src = A [ B ] [ C ] += A [ B - 1 ] [ D ]
trg = A の B 番目の C 番目を A の B から 1 を引いた値番目の D 番目だけ 増 加 させ る
rst = A の B 番目の C 番目を A の B から 1 を引いた値番目の D 番目だけ 増 加 させ る <eos>
168
src = for A , B in ( ( 0 , 0 ) , ( 1 , 5 ) , ( 2 , 3 ) , ( 3 , 0 ) ) :
trg = ((0、0) の組 、(1、 5) の組 、 (2、3) の組 、(3、0) の組 ) の組 を順に A 、 B として 、 繰り返 す
rst = ((0、0) の組 、(0、1) の組 、(1、1) の組 <unk> 、3) の組 を順に A 、 B として 、 繰り返 す <eos>
169
src = return ( A - B ) ** 2 + ( C - D ) ** 2
trg = A から B を引いた値の 2 乗に C から D を引いた値の 2 乗を加えた値を返す
rst = A から B を引いた値の 2 乗に C から D を引いた値の 2 乗を加えた値を返す <eos>
170
src = A = max ( A , B [ C ] [ 0 ] )
trg = A 、 B の C 番目の先頭 の最大値を A とする
rst = A 、 B の C 番目の先頭 の最大値を A とする <eos>
171
src = A , B = parse_tag_structure ( C , 0 )
trg = parse _ tag _ structure ( C ,0) を展開し 、 それぞれ A 、 B とする
rst = <unk> ( C ,0) を展開し 、 それぞれ A 、 B とする <eos>
172
src = A = A . zfill ( 8 ) + B
trg = A を長さ 8 に な るように '0' 左 詰め した文字列に B を加えた値を A とする
rst = A を長さ 8 に な るように '0' 左 詰め した文字列に B を加えた値を A とする <eos>
173
src = A = B | ( 1 << C )
trg = B と 1 を C だけ左シフトした値の論理和 を A とする
rst = B と 1 を C だけ左シフトした値の論理和 を A とする <eos>
174
src = A . add_edge ( outC ( B ) , inM ( C ) , 1 )
trg = A . add _ edge ( outC ( B ) , inM ( C ),1)
rst = A . add _ edge ( inH ( B ) , <unk> ( C ),1) <eos>
175
src = while A - B > C :
trg = A から B を引いた値が C より大きい 間 、 次 を 繰り返 す
rst = A から B を引いた値が C より大きい 間 、 次 を 繰り返 す <eos>
176
src = A = B [ C : C + len ( D ) ]
trg = B の C 番目から C に D の長さを加えた値までの部分列 を A とする
rst = B の C 番目から C に D の長さを加えた値までの部分列 を A とする <eos>
177
src = A [ B + 1 ] [ C ] , A [ B + 1 ] [ C + 1 ] = A [ B + 1 ] [ C + 1 ] , A [ B + 1 ] [ C ]
trg = A の B に 1 を加えた値番目の C に 1 を加えた値番目 、 A の B に 1 を加えた値番目の C 番目を A の B に 1 を加えた値番目の C 番目 、 A の B に 1 を加えた値番目の C に 1 を加えた値番目とする
rst = A の B に 1 を加えた値番目の C 番目 、 A の B に 1 を加えた値番目の C に 1 を加えた値番目を A の B に 1 を加えた値番目の C 番目 、 A の B に 1 を加えた値番目の C に 1 を加えた値番目とする <eos>
178
src = A += B . tree [ C ]
trg = A を B の tree の C 番目だけ 増 加 させ る
rst = A を B の tree の C 番目だけ 増 加 させ る <eos>
179
src = def dot ( A , B ) : return ( A . x * B . x + A . y * B . y )
trg = 関数 dot を self 、 p をパラメータとして 定 義 する
rst = 関数 isleap を a 、 b をパラメータとして 定 義 する <eos>
180
src = for A in range ( 99 ) :
trg = 0 から 99 未満までの数列を順に A として 、 繰り返 す
rst = 0 から 99 未満までの数列を順に A として 、 繰り返 す <eos>
181
src = A = B [ C ] * 2 - D [ C ]
trg = B の C 番目に 2 を掛けた値から D の C 番目を引いた値を A とする
rst = B の C 番目に 2 を掛けた値から D の C 番目を引いた値を A とする <eos>
182
src = pi [ 1 ] = int ( pi [ 1 ] )
trg = 円周率の 1 番目の整数値を 円周率の 1 番目に する
rst = 円周率の 1 番目の整数値を 円周率 の 1 番目に する <eos>
183
src = A [ B ] [ C - 1 - D ] = E [ D ] [ B ]
trg = E の D 番目の B 番目を A の B 番目の C から 1 を引いた値から D を引いた値番目に する
rst = E の D 番目の B 番目を A の B 番目の C から 1 を引いた値から D を引いた値番目に する <eos>
184
src = D = B [ C ] [ 0 ]
trg = B の C 番目の先頭を D とする
rst = B の C 番目の先頭を D とする <eos>
185
src = A += B + C + D + 1
trg = A を B に C を加えた値に D を加えた値に 1 を加えた値だけ 増 加 させ る
rst = A を B に C を加えた値に D を加えた値に 1 を加えた値だけ 増 加 させ る <eos>
186
src = if A == [ 2 , 2 , 1 ] :
trg = A が ( 2 、 2 、1) からなる列と等しいとき 、
rst = A が ( 2 、 1、1、1) からなる列と等しいとき 、 <eos>
187
src = A = datetime . date ( 2012 , 12 , 21 ) + timedelta ( B )
trg = datetime 、 2012 、 12、21 の日付に timedelta ( B ) を加えた値を A とする
rst = datetime 、 <unk> の日付を A とする <eos>
188
src = if A < B + C * D :
trg = A が B に C に D を掛けた値を加えた値 より小さいとき 、
rst = A が B に C に D を掛けた値を加えた値 より小さいとき 、 <eos>
189
src = A . append ( ( B [ 0 ] , B [ 1 ] ) )
trg = A の末尾に ( B の先頭 、 B の 1 番目 ) の組 を追加する
rst = A の末尾に ( B の先頭 、 B の 1 番目 ) の組 を追加する <eos>
190
src = A = [ int ( B ) - 1 for B in input ( ) . split ( ' ' ) ]
trg = 入力された文字列を空白 文字で分割した字句列の各要素を B とし 、 B の整数値から 1 を引いた値の列を A とする
rst = 入力された文字列を空白 文字で分割した字句列の各要素を B とし 、 B の整数値から 1 を引いた値の列を A とする <eos>
191
src = A = B // ( 60 * 60 )
trg = B を 60 に 60 を掛けた値で割った商を A とする
rst = B を 60 に 60 を掛けた値で割った商を A とする <eos>
192
src = A = Node ( 1 )
trg = Node (1) を A とする
rst = Node (1) を A とする <eos>
193
src = A , B = [ int ( input ( ) ) for C in range ( 2 ) ]
trg = 0 から 2 未満までの数列の各要素を C とし 、 、 つまり入力された文字列 の整数値の列を展開し 、 それぞれ A 、 B とする
rst = 0 から 2 未満までの数列の各要素を C とし 、 、 つまり入力された文字列 の整数値の列を展開し 、 それぞれ A 、 B とする <eos>
194
src = A . weight [ B ] += A . weight [ A . par [ B ] ]
trg = A の weight の B 番目を A の weight の A の par の B 番目番目だけ 増 加 させ る
rst = A の weight の B 番目を A の weight の A の par の B 番目番目だけ 増 加 させ る <eos>
195
src = print ( bfs ( ) )
trg = bfs () を出力する
rst = bfs () を出力する <eos>
196
src = print ( int ( A ) , int ( B ) )
trg = A の整数値 、 B の整数値を出力する
rst = A の整数値 、 B の整数値を出力する <eos>
197
src = for A in range ( B - C , B ) :
trg = B から C を引いた値から B 未満までの数列を順に A として 、 繰り返 す
rst = B から C を引いた値から B 未満までの数列を順に A として 、 繰り返 す <eos>
198
src = if e [ 0 ] != e [ 1 ] and e [ 1 ] != e [ 2 ] and e [ 2 ] != e [ 0 ] :
trg = ネイピア数の 0 番目が 、 つまりネイピア数の 1 番目と等しくなくかつ 、 つまりネイピア数の 1 番目が 、 つまりネイピア数の 2 番目と等しくなくかつ 、 つまりネイピア数の 2 番目が 、 つまりネイピア数の先頭 と等しくないとき 、
rst = ネイピア数の 0 番目が 、 つまりネイピア数の 1 番目と等しくなくかつ 1 番目が 、 つまりネイピア数の 2 番目と等しくかつ e の 2 番目が e の 2 番目の先頭 と等しくないとき 、 <eos>
199
src = if A < 2 ** ( B - 1 - C ) :
trg = A が 2 の B から 1 を引いた値から C を引いた値乗 より小さいとき 、
rst = A が 2 の B から 1 を引いた値から C を引いた値乗 より小さいとき 、 <eos>
200
src = for A in B [ C ] [ 3 ] :
trg = B の C 番目の 3 番目を順に A として 、 繰り返 す
rst = B の C 番目の 3 番目を順に A として 、 繰り返 す <eos>
201
src = return '' . join ( A )
trg = 空文字列を間に入れて A を連結した文字列を返す
rst = 空文字列を間に入れて A を連結した文字列を返す <eos>
202
src = A = list ( filter ( lambda B : B [ 0 ] > C , D ) )
trg = D の各値を x をパラメータとして B の 0 番目が C より大きいかどうかを返す 関数で フ ィ ルターした列のリスト を A とする
rst = D の各値を x をパラメータとして B の 0 番目が C より大きいかどうか を返す関数を A とする <eos>
203
src = for A in list ( map ( int , input ( ) . split ( ) ) ) [ 1 : ] :
trg = 入力された文字列 を空白で分割した字句列の各要素に 整数を適用した列のリスト の先頭を除いた部分列 を順に A として 、 繰り返 す
rst = 入力された文字列 を空白で分割した字句列 の先頭を除いた部分列 <unk> を順に A として 、 繰り返 す <eos>
204
src = if ( A [ 0 ] , A [ 1 ] , A [ 0 ] + 1 , A [ 1 ] ) not in B and ( A [ 0 ] + 1 , A [ 1 ] , A [ 0 ] , A [ 1 ] ) not in B and A [ 0 ] + 1 <= C :
trg = ( A の先頭 、 A の 1 番目 、 A [0] に 1 を加えた値 、 A の 1 番目 ) の組が B に含まれなくかつ ( A [0] に 1 を加えた値 、 A の 1 番目 、 A の先頭 、 A の 1 番目 ) の組が B に含まれなくかつ A の 0 番目に 1 を加えた値が C 以下のとき 、
rst = ( A の先頭 、 A の 1 番目 、 A の 0 番目に 1 を加えた値 、 A の 1 番目に 1 を加えた値 ) の組が B に含まれなくかつ ( A の先頭 、 A の 1 番目 ) からなる列 に含まれないとき 、 <eos>
205
src = print ( int ( '' . join ( A [ : : - 1 ] ) , 2 ) )
trg = 2 進 表 記 、 つまり空文字列を間に入れて A の逆順を連結した文字列の整数値 を出力する
rst = 2 進 表 記 、 つまり空文字列を間に入れて A の逆順 を出力する <eos>
206
src = A , B = pp ( )
trg = pp () を展開し 、 それぞれ A 、 B とする
rst = <unk> _ <unk> () を展開し 、 それぞれ A 、 B とする <eos>
207
src = print ( sum ( count ) - max ( count ) )
trg = 無限の整数列の総和 から 、 つまり無限の整数列 の最大値を引いた値 を出力する
rst = 入力された文字列の整数値から 、 つまり無限の整数列 の最大値を引いた値 を出力する <eos>
208
src = A . explored_dict [ B ] = False
trg = 偽を A の explored _ dict の B 番目に する
rst = 偽を A の explored _ dict の B 番目に する <eos>
209
src = A = A // 2
trg = A を 2 で割った商を A とする
rst = A を 2 で割った商を A とする <eos>
210
src = if A < B . size * ( B . size - 1 ) :
trg = A が B の size に B の size から 1 を引いた値を掛けた値 より小さいとき 、
rst = A が B の size に B の size から 1 を引いた値より小さいとき 、 <eos>
211
src = e = A // B
trg = A を B で割った商を ネイピア数とする
rst = A を B で割った商を ネイピア数とする <eos>
212
src = if A == 0 or A == B - 1 or C == 0 or C == D - 1 :
trg = A が 0 と等しくまたは A が B から 1 を引いた値と等しくまたは C が 0 と等しくまたは C が D から 1 を引いた値と等しいとき 、
rst = A が 0 と等しくまたは A が B から 1 を引いた値と等しくまたは C が 0 と等しくまたは D から 1 を引いた値と等しいとき 、 <eos>
213
src = A [ 1 ] [ B ] . append ( ( C , D ) )
trg = A の 1 番目の B 番目の末尾に ( C 、 D ) の組 を追加する
rst = A の 1 番目の B 番目の末尾に ( C 、 D ) の組 を追加する <eos>
214
src = if A [ - ( B + 1 ) ] == C :
trg = A の - B に 1 を加えた値番目が C と等しいとき 、
rst = A の - B に 1 を加えた値番目が C と等しいとき 、 <eos>
215
src = A = [ [ B for C in range ( D ) ] for E in range ( 2 ** D ) ]
trg = 0 から 2 の D 乗未満までの数列の各要素を E とし 、0 から D 未満までの数列の各要素を C とし 、 B の列の列を A とする
rst = 0 から 2 の D 乗未満までの数列の各要素を E とし 、0 から D 未満までの数列の各要素を C とし 、 B の列の列を A とする <eos>
216
src = return ( A , sum ( B [ 1 : ] ) )
trg = ( A 、 B の先頭を除いた部分列の総和 ) の組を返す
rst = ( A 、 B の先頭を除いた部分列 ) の組を返す <eos>
217
src = print ( ( A + B ) >> 1 )
trg = A に B を加えた値を 1 だけ右シフトした値 を出力する
rst = A に B を加えた値を 1 だけ右シフトした値 を出力する <eos>
218
src = if A . primeFactorization . get ( 1 , 0 ) == 1 :
trg = A の primeFactorization に対応する値 、 もし存在しなければ 1 、0 が 1 と等しいとき 、
rst = A の primeFactorization に対応する値 、 もし存在しなければ 1 、0 が 1 と等しいとき 、 <eos>
219
src = print ( A [ 1 ] [ 0 ] - A [ 0 ] [ 0 ] + ( 1 if A [ 1 ] [ 1 ] > A [ 0 ] [ 1 ] or ( A [ 1 ] [ 1 ] == A [ 0 ] [ 1 ] and A [ 1 ] [ 2 ] > A [ 0 ] [ 2 ] ) else 0 ) )
trg = A の 1 番目の 0 番目から A の先頭の 0 番目を引いた値に A [1][1] が A [0][1] より大きくまたは A [1][1] == A [0][1] かつ A [1] [2]> A [0] [2] のとき 1 、 そうでなければ 0 を加えた値を出力する
rst = A [0] が A [1] より大きいとき A [1] から A [0] を引いた値 、 そうでなければ A [0] に 1 を加えた値 、 A [1] の 1 番目が A [1] より大きいとき 、 <eos>
220
src = print ( A - ( B + ( C - 10 ) * 125 ) )
trg = A から B に C から 10 を引いた値に 125 を掛けた値を加えた値を引いた値 を出力する
rst = A から B に C から 10 を引いた値に 125 を掛けた値を加えた値 を出力する <eos>
221
src = A [ B ] . append ( ( C , D [ B ] [ C ] ) )
trg = A の B 番目の末尾に ( C 、 D の B 番目の C 番目 ) の組 を追加する
rst = A の B 番目の末尾に ( C 、 D の B 番目の C 番目 ) の組 を追加する <eos>
222
src = A [ 1 ] = B [ 1 ] = A [ 1 ] + 1
trg = A の 1 番目に 1 を加えた値を B の 1 番目とするを A の 1 番目に する
rst = A の 1 番目に 1 を加えた値を B の 1 番目とするを A の 1 番目に する <eos>
223
src = A = Segment ( B , C , D , E )
trg = Segment ( B , C , D , E ) を A とする
rst = Segment ( B , C , D , E ) を A とする <eos>
224
src = A [ 1 ] = False
trg = 偽を A の 1 番目に する
rst = 偽を A の 1 番目に する <eos>
225
src = A , B , C = map ( int , input ( ) . split ( ) )
trg = 入力された文字列 を空白で分割した字句列の各要素に 整数を適用した列を展開し 、 それぞれ A 、 B 、 C とする
rst = 入力された文字列 を空白で分割した字句列の各要素に 整数を適用した列を展開し 、 それぞれ A 、 B 、 C とする <eos>
226
src = A = time [ 3 ] - time [ 0 ]
trg = time の 3 番目から time の先頭を引いた値を A とする
rst = time の 3 番目から time の先頭の 0 番目を引いた値を A とする <eos>
227
src = e = int ( e )
trg = ネイピア数の整数値を ネイピア数とする
rst = ネイピア数を ネイピア数とする <eos>
228
src = andrew ( A )
trg = andrew ( A )
rst = <unk> ( A ) <eos>
229
src = if int ( A [ 1 ] ) <= B :
trg = A の 1 番目の整数値が B 以下のとき 、
rst = A の 1 番目の整数値が B 以下のとき 、 <eos>
230
src = A , B = C [ D - 1 ] [ - 1 ]
trg = C の D から 1 を引いた値番目 の末尾を展開し 、 それぞれ A 、 B とする
rst = C の D から 1 を引いた値番目 番目を展開し 、 それぞれ A 、 B とする <eos>
231
src = A = B = - 10 ** 18
trg = -10 の 18 乗を B とする を A とする
rst = -10 の 18 乗を B とする を A とする <eos>
232
src = if A [ B ] [ C ] and not D [ B ] [ C ] :
trg = A の B 番目の C 番目かつ D の B 番目の C 番目でないとき 、
rst = A の B 番目の C 番目かつ D の B 番目の C 番目でないとき 、 <eos>
233
src = A = 1 << ( B . maxcap . bit_length ( ) - 1 )
trg = 1 を B の maxcap のビット長 から 1 を引いた値だけ左シフトした値 を A とする
rst = 1 を B の maxcap から 1 を引いた値だけ左シフトした値 に 1 を加えた値番目を A とする <eos>
234
src = A = [ ch ( B , int ( input ( ) ) ) for C in range ( int ( input ( ) ) ) ]
trg = 0 から 、 つまり入力された文字列の整数値 未満までの数列の各要素を C とし 、 ch ( B , int ( input ())) の列を A とする
rst = 0 から 、 つまり入力された文字列の整数値 未満までの数列の各要素を C とし 、 <unk> ( B , int ( input ())) の列を A とする <eos>
235
src = for A , B in enumerate ( time ) :
trg = time に番号付した組の列を順に A 、 B として 、 繰り返 す
rst = time に番号付した組の列を順に A 、 B として 、 繰り返 す <eos>
236
src = if A < B . size [ C ] :
trg = A が B の size の C 番目より小さいとき 、
rst = A が B の size の C 番目より小さいとき 、 <eos>
237
src = return expr ( )
trg = expr () を返す
rst = expr () を返す <eos>
238
src = return math . factorial ( A ) // math . factorial ( B ) // math . factorial ( A - B )
trg = A の 階 乗を B の 階 乗で割った商を A から B を引いた値の 階 乗で割った商 を返す
rst = A の 階 乗を B の 階 乗で割った商を A の 階 乗で割った商 を返す <eos>
239
src = A = B [ 0 ] + C
trg = B の 0 番目に C を加えた値を A とする
rst = B の 0 番目に C を加えた値を A とする <eos>
240
src = return ( A , B - 1 - C )
trg = ( A 、 B から 1 を引いた値から C を引いた値 ) の組を返す
rst = ( A 、 B から 1 を引いた値から C を引いた値 ) の組を返す <eos>
241
src = if A . _size is not None :
trg = A の _ size が 、 つまり未定値と等しいとき 、
rst = A の _ size が 、 つまり未定値と等しいとき 、 <eos>
242
src = A . data ^= ( A . masks [ B ] )
trg = A の data を A の masks の B 番目と の排他 的 論理和に する
rst = A の data を A の masks の B 番目と の排他 的 論理和に する <eos>
243
src = A , B = { } , [ ]
trg = 空辞書 、 空列を A 、 B とする
rst = 空辞書 、 空列を A 、 B とする <eos>
244
src = if A % 100 == 0 :
trg = A を 100 で割った余りが 0 と等しいとき 、
rst = A を 100 で割った余りが 0 と等しいとき 、 <eos>
245
src = assert A . root is not None
trg = A の root が 、 つまり未定値と等しく なければ な らな い
rst = A の root が 、 つまり未定値と等しく なければ な らな い <eos>
246
src = for A , B , B in C [ - 1 ] :
trg = C の末尾 を順に A 、 B 、 B として 、 繰り返 す
rst = C の末尾を除いた部分列の各要素を A 、 B として 、 繰り返 す <eos>
247
src = _set_range ( 0 , 0 , A . size // 2 , A . DIVIDED )
trg = _ set _ range (0,0, A . size //2, A . DIVIDED )
rst = _ set (0,0, A . size //2, A . 6) <eos>
248
src = A = [ B + 1 for B in range ( C ) ]
trg = 0 から C 未満までの数列の各要素を B とし 、 B に 1 を加えた値の列を A とする
rst = 0 から C 未満までの数列の各要素を B とし 、 B に 1 を加えた値の列を A とする <eos>
249
src = A . update ( B , C , D * 2 , E , C , F )
trg = B 、 C 、 D に 2 を掛けた値 、 E 、 C 、 F を追加して A を 更新 する
rst = B 、 C 、 D に 2 を掛けた値 、 E 、 C 、 F を追加して A を 更新 する <eos>
250
src = A = max ( A , B [ C ] [ D + 1 ] - E [ D + 1 ] [ F + 1 ] )
trg = A 、 B の C 番目の D に 1 を加えた値番目から E の D に 1 を加えた値番目の F に 1 を加えた値番目 を引いた値の最大値を A とする
rst = A 、 B の C 番目の D に 1 を加えた値番目から E の D に 1 を加えた値番目の F に 1 を加えた値番目 を引いた値の最大値を A とする <eos>
251
src = A = 1 << ( B + 1 )
trg = 1 を B に 1 を加えた値 だけ左シフトした値を A とする
rst = 1 を B に 1 を加えた値 だけ左シフトした値を A とする <eos>
252
src = return A + 11
trg = A に 1 1 を加えた値を返す
rst = A に 1 1 を加えた値を返す <eos>
253
src = A . insert ( Node ( int ( B [ 1 ] ) , None , None ) )
trg = A の Node ( int ( B [1]) , None , None ) に [ MASK ] を挿入する
rst = A の Node ( int ( B [1]) , None ) に [ MASK ] を挿入する <eos>
254
src = print ( pyon ( A , 0 , B , C , D ) )
trg = pyon ( A ,0, B , C , D ) を出力する
rst = <unk> _ <unk> ( A ,0, B , C , D ) を出力する <eos>
255
src = quick_sort ( A , 0 , B - 1 )
trg = quick _ sort ( A ,0, B -1)
rst = <unk> ( A ,0, B -1) <eos>
256
src = A = [ 0 ] + sorted ( [ int ( input ( ) ) for B in range ( C ) ] )
trg = (0) からなる列に 0 から C 未満までの数列の各要素を B とし 、 、 つまり入力された文字列の整数値 の列をソートした列 を加えた値を A とする
rst = (0) からなる列に 0 から C 未満までの数列の各要素を B とし 、 、 つまり入力された文字列の整数値 の列をソートした列を A とする <eos>
257
src = A = max ( A , B [ C ] [ D ] [ 0 ] , B [ C ] [ D ] [ 1 ] , B [ C ] [ D ] [ 2 ] , B [ C ] [ D ] [ 3 ] )
trg = A 、 B の C 番目の D 番目の先頭 、 B の C 番目の D 番目の 1 番目 、 B の C 番目の D 番目の 2 番目 、 B の C 番目の D 番目の 3 番目の最大値を A とする
rst = A 、 B の C 番目の D 番目の先頭 、 B の C 番目の D 番目 、 B の C 番目の 1 番目 、 B の C 番目の D 番目の 2 番目 を加えた値の最大値を A とする <eos>
258
src = sum ( [ sum ( A [ B ] [ C + 1 : D ] ) for B in range ( E + 1 , F ) ] )
trg = E に 1 を加えた値から F 未満までの数列の各要素を B とし 、 A の B 番目の C に 1 を加えた値から D 番目までの部分列の総和の列の総和
rst = E に F を加えた値 、0 から E に 1 を加えた値未満までの数列の各要素 を B とし 、 A の B 番目の C に 1 を加えた値から 、 つまり末尾までの部分列の総和 <unk> <eos>
259
src = A = sum ( [ B [ C ] [ 1 ] - B [ C ] [ 0 ] for C in range ( D ) ] )
trg = 0 から D 未満までの数列の各要素を C とし 、 B の C 番目の 1 番目から B の C 番目の 0 番目 を引いた値の列の総和を A とする
rst = 0 から D 未満までの数列の各要素を C とし 、 B の C 番目の 1 番目から B の C 番目の 0 番目を引いた値に D の C 番目を掛けた値の列の総和を A とする <eos>
260
src = A . weights = [ 0 ] * B
trg = (0) からなる列の B 回分の列を A の weights に する
rst = (0) からなる列の B 回分の列を A の weights に する <eos>
261
src = while A != B + 1 :
trg = A が B に 1 を加えた値 と等しくない 間 、 次 を 繰り返 す
rst = A が B に 1 を加えた値 と等しくない 間 、 次 を 繰り返 す <eos>
262
src = A = path [ B ] [ 1 ] [ : path [ B ] [ 1 ] . index ( C ) + 1 ]
trg = os . path の B 番目の 1 番目の 、 つまり先頭から path の B 番目の 1 番目の C と等しい要素の最初の位置に 1 を加えた値までの部分列を A とする
rst = os . path の B 番目の 1 番目から path の B 番目の先頭の C と等しい要素の最初の位置に 1 を加えた値までの部分列を A とする <eos>
263
src = A = B if not A else A
trg = A でないとき B 、 そうでなければ A を A とする
rst = A でないとき B 、 そうでなければ A を A とする <eos>
264
src = A . append ( tuple ( map ( int , input ( ) . split ( ) ) ) )
trg = A の末尾に入力された文字列 を空白で分割した字句列の各要素に 整数を適用した列の組 を追加する
rst = A の末尾に input () を空白で分割した字句列の各要素 に整数を適用した列の総和 を追加する <eos>
265
src = for A in range ( B + 1 ) :
trg = 0 から B に 1 を加えた値未満までの数列を順に A として 、 繰り返 す
rst = 0 から B に 1 を加えた値未満までの数列を順に A として 、 繰り返 す <eos>
266
src = A = [ [ ] for B in range ( 200 ) ]
trg = 0 から 200 未満までの数列の各要素を B とし 、 、 つまり空列の列を A とする
rst = 0 から 200 未満までの数列の各要素を B とし 、 、 つまり空列の列を A とする <eos>
267
src = A = lambda B : int ( ( B ** 2 + B + 2 ) / 2 )
trg = n をパラメータとして B **2 に B を加えた値に 2 を加えた値を 2 で割った値の整数値 を返す関数を A とする
rst = l をパラメータとして B **2 に B **2 を加えた値を 2 で割った値の整数値 を返す関数を A とする <eos>
268
src = A = - B . y
trg = - B の y 座標を A とする
rst = - B の y 座標を A とする <eos>
269
src = A = Counter ( { k : [ C % 10007 for B , C in D . items ( ) ] } )
trg = ( ( B , D のキーと値の集まりの各要素を B 、 C とし 、 C を 10007 で割った余りの列 )) からなる辞書の 辞書 カ ウ ンタを A とする
rst = ( ( B , D のキーと値の集まりの各要素を B 、 C とし 、 C を 10007 で割った余りの列 )) からなる辞書の 辞書 カ ウ ンタを A とする <eos>
270
src = A . add_edge ( B + C , D + 1 , 1 , 0 )
trg = A . add _ edge ( B + C , D + 1,1,0)
rst = A . add _ edge ( B + C , D + 1,1,0) <eos>
271
src = A += B % 2
trg = A を B を 2 で割った余りだけ 増 加 させ る
rst = A を B を 2 で割った余りだけ 増 加 させ る <eos>
272
src = print ( min ( [ math . ceil ( A / B ) * C , math . ceil ( A / D ) * E ] ) )
trg = ( A / B の切り 上 げ 整数値に C を掛けた値 、 A / D の切り 上 げ 整数値に E を掛けた値 ) からなる列 の最小値 を出力する
rst = ( A を B で割った値の切り 上 げ 整数値 、 C に D を掛けた値を E で割った値の切り 上 げ <unk> A とする <eos>
273
src = A . append ( B . hldnxt [ C ] )
trg = A の末尾に B の hldnxt の C 番目を追加する
rst = A の末尾に B の hldnxt の C 番目を追加する <eos>
274
src = heappush ( A , ( B + 1 , C , D , E ) )
trg = heappush ( A , ( B +1, C , D , E ))
rst = heappush ( A , ( B +1, C , D , E )) <eos>
275
src = if 0 == A % 2 :
trg = 0 が A を 2 で割った余り と等しいとき 、
rst = 0 が A を 2 で割った余り と等しいとき 、 <eos>
276
src = A = get_interest1 ( B , C )
trg = get _ interest 1 ( B , C ) を A とする
rst = <unk> ( B , C ) を A とする <eos>
277
src = for A in range ( B [ C ] [ 0 ] ) :
trg = 0 から B の C 番目の先頭 未満までの数列を順に A として 、 繰り返 す
rst = 0 から B の C 番目の先頭 未満までの数列を順に A として 、 繰り返 す <eos>
278
src = pd *= int ( A ) + 1
trg = pd を A の整数値に 1 を加えた値 倍 に する
rst = pd を A の整数値に 1 を加えた値 倍 に する <eos>
279
src = A = min ( A , B [ C [ D ] ] [ E [ D ] ] [ 1 ] )
trg = A 、 B の C の D 番目番目の E の D 番目番目の 1 番目の最小値を A とする
rst = A 、 B の C の D 番目番目の E の D 番目番目の 1 番目の最小値を A とする <eos>
280
src = if A [ e ] [ B ] > C :
trg = A の 、 つまりネイピア数番目の B 番目が C より大きいとき 、
rst = A の 、 つまりネイピア数の B 番目が C より大きいとき 、 <eos>
281
src = dfs ( A , B + 1 , C )
trg = dfs ( A , B +1, C )
rst = dfs ( A , B +1, C ) <eos>
282
src = print ( gengo ( A , B , C ) )
trg = gengo ( A , B , C ) を出力する
rst = <unk> _ <unk> ( A , B , C ) を出力する <eos>
283
src = if A [ B - 1 ] == C [ D - 1 ] :
trg = A の B から 1 を引いた値番目が C の D から 1 を引いた値番目と等しいとき 、
rst = A の B から 1 を引いた値番目が C の D から 1 を引いた値番目と等しいとき 、 <eos>
284
src = A [ B [ 1 ] ] [ B [ 0 ] ] = B [ 2 ]
trg = B の 2 番目を A の B の 1 番目番目の B の先頭番目に する
rst = B の 2 番目を A の B の 1 番目番目の B の先頭番目に する <eos>
285
src = A = max ( A , dfs ( B , C ) + 1 )
trg = A 、 dfs ( B , C ) に 1 を加えた値の最大値を A とする
rst = A 、 dfs ( B , C ) に 1 を加えた値の最大値を A とする <eos>
286
src = A = [ B + C for B in [ D [ 2 ] for C in D [ 3 ] ] ]
trg = D の 3 番目の各要素を C とし 、 D の 2 番目の列の各要素を B とし 、 B に C を加えた値の列を A とする
rst = D の 3 番目の各要素を C とし 、 D の 2 番目の列の各要素を B とし 、 B に C を加えた値の列を A とする <eos>
287
src = print ( A [ B . index ( C ) ] )
trg = A の B の C と等しい要素の最初の位置番目 を出力する
rst = A の B の C 番目と等しい要素の最初の位置 を出力する <eos>
288
src = A [ B ] [ C ] = D [ 0 ]
trg = D の先頭を A の B 番目の C 番目に する
rst = D の先頭を A の B 番目の C 番目に する <eos>
289
src = if count == 10000 :
trg = 無限の整数列が 10000 と等しいとき 、
rst = 無限の整数列が 10000 と等しいとき 、 <eos>
290
src = return 5.0 * A - 5.0
trg = 5.0 に A を掛けた値から 5.0 を引いた値を返す
rst = 5.0 に A を掛けた値から 5.0 を引いた値を返す <eos>
291
src = write ( A % ( sum ( dfs ( B ) ) % C ) )
trg = write ( A %( sum ( dfs ( B ))% C ))
rst = write ( A % dfs ( ( B )) を C で割った余り ) で割った余り ) <eos>
292
src = if A - B >= 0 and C - B >= 0 :
trg = A から B を引いた値が 0 以上かつ C から B を引いた値が 0 以上のとき 、
rst = A から B を引いた値が 0 以上かつ C から B を引いた値が 0 以上のとき 、 <eos>
293
src = A [ B [ C + 1 ] ] += 1
trg = A の B の C に 1 を加えた値番目番目を 1 だけ 増 加 させ る
rst = A の B の C に 1 を加えた値番目を 1 だけ 増 加 させ る <eos>
294
src = if A [ B ] + A [ C ] <= D :
trg = A の B 番目に A の C 番目を加えた値が D 以下のとき 、
rst = A の B 番目に A の C 番目を加えた値が D 以下のとき 、 <eos>
295
src = if ( A [ B ] , A [ B - 2 ] ) == ( 1 , 1 ) :
trg = ( A の B 番目 、 A の B から 2 を引いた値番目 ) の組が (1、1) の組と等しいとき 、
rst = ( A の B 番目 、 A の B から 2 を引いた値番目 ) の組が (1、1) の組と等しいとき 、 <eos>
296
src = A . append ( list ( map ( int , B ) ) )
trg = A の末尾に B の 各要素に整数を適用した列のリスト を追加する
rst = A の末尾に B の各要素に 整数を適用した列のリストを 追加する <eos>
297
src = A = max ( A , B + 1 )
trg = A 、 B に 1 を加えた値の最大値を A とする
rst = A 、 B に 1 を加えた値の最大値を A とする <eos>
298
src = for A , B in zip ( C [ 0 : ] , C [ 1 : ] + [ C [ 0 ] ] ) :
trg = C の 、 つまり先頭から 、 つまり末尾までの部分列 、 C の 1 番目から 、 つまり末尾までの部分列に ( C の先頭 ) からなる列を加えた値 の要素をそれぞれ組にした列を順に A 、 B として 、 繰り返 す
rst = C の 、 つまり先頭から 、 つまり末尾までの部分列 、 C の 1 番目から 、 つまり末尾までの部分列に ( C の先頭 ) からなる列を加えた値 の要素をそれぞれ組にした列を順に A 、 B として 、 繰り返 す <eos>
299
src = if A [ e ] < 0 :
trg = A の 、 つまりネイピア数番目が 0 より小さいとき 、
rst = A の 、 つまりネイピア数番目が 0 より小さいとき 、 <eos>
300
src = A = str ( 1868 + B - 1 )
trg = 1868 に B を加えた値から 1 を引いた値の文字列を A とする
rst = 1868 に B を加えた値から 1 を引いた値の文字列を A とする <eos>
301
src = A . append ( B + input ( ) + B )
trg = A の末尾に B に入力された文字列を加えた値に B を加えた値 を追加する
rst = A の末尾に B に入力された文字列を加えた値 に B を加えた値 を追加する <eos>
302
src = if A > 25 * B * B - C :
trg = A が 25 に B を掛けた値に B を掛けた値から C を引いた値 より大きいとき 、
rst = A が 25 に B を掛けた値に B を掛けた値から C を引いた値 より大きいとき 、 <eos>
303
src = A . append ( ( B , C + e . weight ) )
trg = A の末尾に ( B 、 C にネイピア数の weight を加えた値 ) の組 を追加する
rst = A の末尾に ( B 、 C にネイピア数を加えた値 ) の組 を追加する <eos>
304
src = A = B . _convert_left ( A )
trg = B ._ convert _ left ( A ) を A とする
rst = B ._ right _ rotate ( A ) を A とする <eos>
305
src = A , B , C = map ( int , input ( ) . split ( D ) )
trg = 入力された文字列を D で分割した字句列の各要素に 整数を適用した列を展開し 、 それぞれ A 、 B 、 C とする
rst = 入力された文字列を D で分割した字句列の各要素に 整数を適用した列を展開し 、 それぞれ A 、 B 、 C とする <eos>
306
src = A [ B ] . append ( 3 * C + D )
trg = A の B 番目の末尾に 3 に C を掛けた値に D を加えた値 を追加する
rst = A の B 番目の末尾に 3 に C を掛けた値に D を加えた値 を追加する <eos>
307
src = A = 2 / 3 * B [ 0 ] + 1 / 3 * C [ 0 ]
trg = 2 を 3 で割った値に B の 0 番目を掛けた値に 1 を 3 で割った値に C の先頭を掛けた値を加えた値を A とする
rst = 2 を 3 で割った値に B の 0 番目を掛けた値に 1 を 3 で割った値に C の先頭を掛けた値を加えた値を A とする <eos>
308
src = A . set ( B )
trg = A . set ( B )
rst = A . set ( B ) <eos>
309
src = if A < 18680908 :
trg = A が 18680908 より小さいとき 、
rst = A が <unk> より小さいとき 、 <eos>
310
src = A [ B ] += [ sum ( A [ B ] ) ]
trg = A の B 番目を ( A の B 番目の総和 ) からなる列 だけ 増 加 させ る
rst = A の B 番目を ( A の B 番目の総和 ) からなる列 だけ 増 加 させ る <eos>
311
src = A , B , C , D = e
trg = ネイピア数を展開し 、 それぞれ A 、 B 、 C 、 D とする
rst = ネイピア数を展開し 、 それぞれ A 、 B 、 C 、 D とする <eos>
312
src = A = [ 0 ] * ( 5 - len ( A ) ) + A
trg = (0) からなる列の 5 から A の長さを引いた値に A を加えた値回分の列を A とする
rst = (0) からなる列の 5 から A の長さを引いた値に A を加えた値回分の列を A とする <eos>
313
src = print ( sum ( [ int ( A ) for A in sys . stdin ] ) )
trg = sys の stdin の各要素を A とし 、 A の整数値の列の総和 を出力する
rst = sys の stdin の各要素を A とし 、 A の整数値の列の総和 を出力する <eos>
314
src = A = spin ( A )
trg = spin ( A ) を A とする
rst = spin ( A ) を A とする <eos>
315
src = A = [ decode ( B , C ) for B in D ]
trg = D の各要素を B とし 、 decode ( B , C ) の列を A とする
rst = D の各要素を B とし 、 decode ( B , C ) の列を A とする <eos>
316
src = if A * B * C == 0 :
trg = A に B を掛けた値に C を掛けた値が 0 と等しいとき 、
rst = A に B を掛けた値に C を掛けた値が 0 と等しいとき 、 <eos>
317
src = for A in range ( B - C - 1 ) :
trg = 0 から B から C を引いた値から 1 を引いた値未満までの数列を順に A として 、 繰り返 す
rst = 0 から B から C を引いた値から 1 を引いた値未満までの数列を順に A として 、 繰り返 す <eos>
318
src = A . right_node_no = B
trg = B を A の right _ node _ no に する
rst = B を A の end _ points に する <eos>
319
src = for A in range ( B , C - 1 + 1 ) :
trg = B から C から 1 を引いた値に 1 を加えた値未満までの数列を順に A として 、 繰り返 す
rst = B から C から 1 を引いた値に 1 を加えた値未満までの数列を順に A として 、 繰り返 す <eos>
320
src = if A [ B ] and A [ B - 2 ] :
trg = A の B 番目かつ A の B から 2 を引いた値番目のとき 、
rst = A の B 番目かつ A の B から 2 を引いた値番目のとき 、 <eos>
321
src = if A [ 2 ] < A [ 0 ] + A [ 1 ] :
trg = A の 2 番目が A の 0 番目に A の 1 番目を加えた値 より小さいとき 、
rst = A の 2 番目が A の 0 番目に A の 1 番目を加えた値 より小さいとき 、 <eos>
322
src = print ( math . factorial ( A + 1 ) + 2 )
trg = A に 1 を加えた値 の 階 乗に 2 を加えた値を出力する
rst = A に 1 を加えた値 の 2 乗に 2 を加えた値を出力する <eos>
323
src = for A in range ( 3 , math . ceil ( math . sqrt ( B + 1 ) ) , 2 ) :
trg = 3 から B に 1 を加えた値 の平方根の切り 上 げ 整数値未満までの 2 間隔の数列を順に A として 、 繰り返 す
rst = 3 から B の平方根の切り 上 げ 整数値に 1 を加えた値未満までの数列を順に A として 、 繰り返 す <eos>
324
src = print ( A // ( B - 2 ) )
trg = A を B から 2 を引いた値で割った商 を出力する
rst = A を B から 2 を引いた値で割った商 を出力する <eos>
325
src = A *= ( B [ C ] [ 0 ] , B [ C ] [ 1 ] ) [ D == C ]
trg = A を ( B の C 番目の先頭 、 B の C 番目の 1 番目 ) の組 の D が C と等しいかどうか番目 倍 に する
rst = A を B の C 番目の先頭 、 B の C 番目の 1 番目から D の C 番目の 1 番目を引いた値 と等しいとき 、 <eos>
326
src = A . flip ( int ( B [ 1 ] ) )
trg = A . flip ( int ( B [1]))
rst = A . flip ( int ( B [1])) <eos>
327
src = if abs ( cross3 ( A [ - 2 ] , A [ - 1 ] , e ) ) < B :
trg = cross 3( A [-2], A [-1], e ) の絶対値が B より小さいとき 、
rst = cross 3( A [-2], A [-1], e ) が B より小さいとき 、 <eos>
328
src = if len ( A . children ) :
trg = A の children の長さ のとき 、
rst = A の children の長さ のとき 、 <eos>
329
src = A = B * 150
trg = B に 150 を掛けた値を A とする
rst = B に 150 を掛けた値を A とする <eos>
330
src = A . e [ B ] . append ( A . Edge ( C , 0 , len ( A . e [ C ] ) - 1 , - D ) )
trg = A の e の B 番目の末尾に A . Edge ( C ,0, len ( A . e [ C ] ) -1,- D ) を追加する
rst = A の e の B 番目の末尾に A . Edge ( C ,0, len ( A . e [ C ] )-1) を追加する <eos>
331
src = A [ B + 1 ] += C
trg = A の B に 1 を加えた値番目を C だけ 増 加 させ る
rst = A の B に 1 を加えた値番目を C だけ 増 加 させ る <eos>
332
src = A = [ ( 1 , 0 ) , ( - 1 , 0 ) , ( 0 , 1 ) , ( 0 , - 1 ) ]
trg = ( (1、0) の組 、(-1、0) の組 、(0、1) の組 、(0、-1) の組 ) からなる列を A とする
rst = ((-1、0) の組 、(0、-1) の組 、(1、0) の組 、(0、1) の組 ) からなる列を A とする <eos>
333
src = print ( math . sqrt ( sum ( [ ( A - B ) ** 2 for A in C ] ) / D ) )
trg = C の各要素を A とし 、 ( A - B )**2 の列の総和を D で割った値の平方根 を出力する
rst = C の各要素を A とし 、 ( A - B )**2 の列の総和を D で割った値の 0.5 乗 を出力する <eos>
334
src = A += [ float ( eval ( B + C + D ) ) ]
trg = A を ( 、 つまり文字列 B に C を加えた値に D を加えた値を 評価 した値の浮動小数点数 ) からなる列 だけ 増 加 させ る
rst = A を ( 、 つまり文字列 B に C を加えた値に D を加えた値を 評価 した値の文字列 ) からなる列 だけ 増 加 させ る <eos>
335
src = return set ( [ ( A + B , A + C ) for B , C in D [ E ] ] )
trg = D の E 番目の各要素を B 、 C とし 、 ( A に B を加えた値 、 A に C を加えた値 ) の組の列の集合を 返す
rst = D の E 番目の各要素を B 、 C とし 、 ( A に B を加えた値 、 A に C を加えた値 ) の組の列の集合を 返す <eos>
336
src = A = list ( str ( B ) . zfill ( 4 ) )
trg = B の文字列を長さ 4 に な るように '0' 左 詰め した文字列 のリストを A とする
rst = B の文字列を長さ 4 に な るように '0' 左 詰め した文字列 のリストを A とする <eos>
337
src = A , B = 0 , C [ D ] [ 0 ]
trg = 0 、 C の D 番目の先頭を A 、 B とする
rst = 0 、 C の D 番目の先頭を A 、 B とする <eos>
338
src = put_dif ( )
trg = put _ dif ()
rst = <unk> () <eos>
339
src = A . order = [ ]
trg = 空列を A の order に する
rst = 空列を A の order に する <eos>
340
src = A , B , C , D , E , F , G , H = map ( float , input ( ) . split ( ) )
trg = 入力された文字列 を空白で分割した字句列の各要素に 浮動小数点数を適用した列を展開し 、 それぞれ A 、 B 、 C 、 D 、 E 、 F 、 G 、 H とする
rst = 入力された文字列 を空白で分割した字句列の各要素に 浮動小数点数を適用した列を展開し 、 それぞれ A 、 B 、 C 、 D 、 E 、 F 、 G 、 H とする <eos>
341
src = if now < A - 1 :
trg = 現在の日時が A から 1 を引いた値より小さいとき 、
rst = 現在の日時が A から 1 を引いた値より小さいとき 、 <eos>
342
src = A = B - C * math . cos ( D )
trg = B から C に D の余弦を掛けた値を引いた値 を A とする
rst = B から C に D <unk> A とする <eos>
343
src = A = sorted ( ( B | C ) - ( B & C ) )
trg = B と C の論理和から B と C の論理積 を引いた値をソートした列を A とする
rst = B と C の論理和 から B と C の論理積の論理和 を A とする <eos>
344
src = if dfs ( 0 , A , deque ( range ( 6 ) ) ) :
trg = dfs (0, A , deque ( range (6) )) のとき 、
rst = dfs (0, A , sorted ) のとき 、 <eos>
345
src = time = 60 * A + B + 60 * C + D + 60 * E + F + 60 * G + H
trg = 60* A + B + 60* C に D を加えた値に 60 に E を掛けた値を加えた値に F を加えた値に 60 に G を掛けた値を加えた値に H を加えた値を time とする
rst = 60 に A を掛けた値に B を加えた値に 60 に C を掛けた値を加えた値に D を加えた値に 60 に E を掛けた値を加えた値に F に G を掛けた値を加えた値に H を加えた値を time とする <eos>
346
src = A [ B ] = [ A [ B ] ]
trg = ( A の B 番目 ) からなる列を A の B 番目に する
rst = ( A の B 番目 ) からなる列を A の B 番目に する <eos>
347
src = A = B + 20000
trg = B に 20000 を加えた値を A とする
rst = B に 20000 を加えた値を A とする <eos>
348
src = setHeapUp_max ( A , 0 )
trg = setHeapUp _ max ( A ,0)
rst = compute _ depth ( A ,0) <eos>
349
src = print ( A . wait )
trg = A の wait を出力する
rst = A の wait を出力する <eos>
350
src = A . rm [ B ] = C
trg = C を A の rm の B 番目に する
rst = C を A の rm の B 番目に する <eos>
351
src = A . heappush ( B , - int ( C [ 1 ] ) )
trg = A . heappush ( B , - int ( C [1]))
rst = A . heappush ( B ,(- C [ 1 ] ) <eos>
352
src = A . add_edge ( B - 1 , C , 1 , - D )
trg = A . add _ edge ( B -1, C ,1,- D )
rst = A . add _ edge ( B -1, C , -1) <eos>
353
src = A = str ( bin ( int ( input ( ) , 16 ) ) ) [ 2 : ]
trg = 16 進 表 記 、 つまり入力された文字列の整数値 の 2 進 数文字列の 文字列の 2 番目から 、 つまり末尾までの部分列を A とする
rst = 入力された文字列の整数値の 2 進 数文字列の 2 番目から 、 つまり末尾までの部分列を A とする <eos>
354
src = A = B . MAXV
trg = B の MAXV を A とする
rst = B の <unk> を A とする <eos>
355
src = write ( A * 5 )
trg = write ( A *5 )
rst = write ( A *5 ) <eos>
356
src = A [ B ] [ 1 ] = C [ B ]
trg = C の B 番目を A の B 番目の 1 番目に する
rst = C の B 番目を A の B 番目の 1 番目に する <eos>
357
src = print ( A ** ( 1 / 3 ) )
trg = A の 1 を 3 で割った値乗 を出力する
rst = A の 1 を 3 で割った値乗 を出力する <eos>
358
src = A = [ [ ] for B in range ( 101 ) ]
trg = 0 から 101 未満までの数列の各要素を B とし 、 、 つまり空列の列を A とする
rst = 0 から 101 未満までの数列の各要素を B とし 、 、 つまり空列の列を A とする <eos>
359
src = A , B = list ( map ( int , C [ : - 1 ] . split ( ) ) )
trg = C の末尾を除いた部分列 を空白で分割した字句列の各要素に 整数を適用した列のリストを展開し 、 それぞれ A 、 B とする
rst = C の末尾を除いた部分列 を空白で分割した字句列の各要素に 整数を適用した列のリストを A 、 B とする <eos>
360
src = A = B [ : : - 1 ]
trg = B の逆順を A とする
rst = B の末尾を除いた部分列を A とする <eos>
361
src = A = sorted ( A . items ( ) , key = lambda B : B [ 1 ] )
trg = i をパラメータとして i の 1 番目を返す関数をキーとして A のキーと値の集まりをソートした列 を A とする
rst = x をパラメータとして x の 1 番目を返す関数をキーとして A のキーと値の集まりをソートした列 を A とする <eos>
362
src = A = [ False for B in range ( C ) ]
trg = 0 から C 未満までの数列の各要素を B とし 、 、 つまり偽の列 を A とする
rst = 0 から C 未満までの数列の各要素を B とし 、 、 つまり偽の列 を A とする <eos>
363
src = if A is None or A < 0 :
trg = A が 、 つまり未定値と等しくなくまたは A が 0 より小さいとき 、
rst = A が 、 つまり未定値と等しくなくまたは A が 0 より小さいとき 、 <eos>
364
src = A = [ B for B , C in A ]
trg = A の各要素を B 、 C とし 、 B の列を A とする
rst = A の各要素を B 、 C とし 、 B の列を A とする <eos>
365
src = for A , B in enumerate ( zip ( C , D , E , F ) ) :
trg = C 、 D 、 E 、 F の要素をそれぞれ組にした列 に番号付した組の列を順に A 、 B として 、 繰り返 す
rst = C 、 D 、 E 、 F の要素をそれぞれ組にした列 に番号付した組の列を順に A 、 B として 、 繰り返 す <eos>
366
src = if A == e == 0 :
trg = A が 、 つまりネイピア数 と等しいかどうかが 0 と等しいとき 、
rst = A が 、 つまりネイピア数 と等しいかどうかが 0 と等しいとき 、 <eos>
367
src = A = B / 3.0
trg = B を 3.0 で割った値を A とする
rst = B を 3.0 で割った値を A とする <eos>
368
src = A . append ( list ( [ ( B [ C ] [ 0 ] , B [ C ] [ 1 ] ) for C in D ] ) )
trg = A の末尾に D の各要素を C とし 、 ( B [ C ] の先頭 、 B [ C ] の 1 番目 ) の組 の列のリストを 追加する
rst = A の末尾に D の各要素を C とし 、 ( B の C 番目の先頭 、 B の C 番目の 1 番目 ) からなる列 を追加する <eos>
369
src = A = ( B * C - D * E ) / ( C * e - F * E )
trg = B に C を掛けた値から D に E を掛けた値を引いた値を C にネイピア数を掛けた値から F に E を掛けた値を引いた値で割った値 を A とする
rst = B に C を掛けた値から D に E を掛けた値を引いた値を C にネイピア数を掛けた値から F に E を掛けた値を引いた値で割った値 を A とする <eos>
370
src = A . end_points = ( B , C )
trg = ( B 、 C ) の組を A の end _ points に する
rst = _ points ( B , C ) を A の end _ points に する <eos>
371
src = A = B . _parent [ C ]
trg = B の _ parent の C 番目を A とする
rst = B の _ parent の C 番目を A とする <eos>
372
src = A += len ( B [ C ] )
trg = A を B の C 番目の長さ だけ 増 加 させ る
rst = A を B の C 番目の長さ だけ 増 加 させ る <eos>
373
src = A = B . Decimal ( C )
trg = B . Decimal ( C ) を A とする
rst = B . Decimal ( C ) を A とする <eos>
374
src = A += 2 * ( input ( ) == B ) - 1
trg = A を 2 に 入力された文字列 が B と等しいかどうかを掛けた値 から 1 を引いた値だけ 増 加 させ る
rst = A を 2 に入力された文字列の整数値 を掛けた値が B から 1 を引いた値と等しいとき 、 <eos>
375
src = A = [ - 3 , - 2 , - 1 , 1 , 2 , 3 ]
trg = ( - 3、-2、-1 、1、2、3) からなる列を A とする
rst = <unk> 、2、0、-2、0、3、0、-3 ) からなる列を A とする <eos>
376
src = A = Point ( 0 , 0 )
trg = Point (0,0) を A とする
rst = Point (0,0) を A とする <eos>
377
src = for A in range ( min ( len ( B [ C ] ) , len ( B [ D ] ) ) - 1 , 0 , - 1 ) :
trg = B の C 番目の長さ 、 B の D 番目の長さの最小値 から 1 を引いた値から 0 未満までの -1 間隔の数列を順に A として 、 繰り返 す
rst = B の C 番目の長さ 、 B の D 番目から 1 を引いた値 、0 の最大値から -1 未満までの -1 間隔の数列を順に A として 、 繰り返 す <eos>
378
src = A [ B [ 0 ] ] [ B [ 1 ] ] = B [ 2 ]
trg = B の 2 番目を A の B の先頭番目の B の 1 番目番目に する
rst = B の 2 番目を A の B の先頭番目の B の 1 番目番目に する <eos>
379
src = search ( A , B , C , D - 1 )
trg = B 、 C 、 D から 1 を引いた値に お いて正規表現 A が最初にマッチする位置
rst = B 、 C 、 D から 1 を引いた値に お いて正規表現 A が最初にマッチする位置 <eos>
380
src = A = [ list ( B ) ]
trg = ( B のリスト ) からなる列を A とする
rst = ( B のリスト ) からなる列を A とする <eos>
381
src = print ( A . index ( B ) , B , len ( A ) - A . index ( B ) )
trg = A の B と等しい要素の最初の位置 、 B 、 A の長さから A の B と等しい要素の最初の位置 を引いた値 を出力する
rst = A の B と等しい要素の最初の位置 、 B 、 A の長さから B を引いた値の A の B と等しい要素の最初の位置 を出力する <eos>
382
src = A = B . ascii_lowercase [ C ]
trg = B の ascii _ lowercase の C 番目を A とする
rst = B の ascii _ lowercase の C 番目を A とする <eos>
383
src = A = item ( B , C )
trg = item ( B , C ) を A とする
rst = item ( B , C ) を A とする <eos>
384
src = A = B [ C - 1 ] [ D + 1 ]
trg = B の C から 1 を引いた値番目の D に 1 を加えた値番目を A とする
rst = B の C から 1 を引いた値番目の D に 1 を加えた値番目を A とする <eos>
385
src = A = [ 0 if B == C else [ float ( D ) for B in range ( E ) ] ]
trg = ( B が C と等しいとき 0 、 そうでなければ 0 から E 未満までの数列の各要素を B とし 、 D の浮動小数点数の列 ) からなる列を A とする
rst = 0 から E 未満までの数列の各要素を B とし 、 B が C と等しいとき 0 、 そうでなければ 0 から E 未満までの数列の各要素を B とし 、0 の列 ) からなる列を A とする <eos>
386
src = A = [ [ ] for B in range ( 5 ) ]
trg = 0 から 5 未満までの数列の各要素を B とし 、 、 つまり空列の列を A とする
rst = 0 から 5 未満までの数列の各要素を B とし 、 、 つまり空列の列を A とする <eos>
387
src = if A >= B - 1 and C < D :
trg = A が B から 1 を引いた値以上かつ C が D より小さいとき 、
rst = A が B から 1 を引いた値と等しくなくかつ C が D より小さいとき 、 <eos>
388
src = print_data ( A , 0 )
trg = print _ data ( A ,0)
rst = print _ data ( A ,0) <eos>
389
src = A = [ Node ( ) for B in range ( C ) ]
trg = 0 から C 未満までの数列の各要素を B とし 、 Node () の列を A とする
rst = 0 から C 未満までの数列の各要素を B とし 、 Node () の列を A とする <eos>
390
src = A . update ( e . cost , e . num )
trg = ネイピア数の cost 、 ネイピア数の num を追加して A を 更新 する
rst = ネイピア数の cost () 、 ネイピア数から 更新 する <eos>
391
src = A = cut ( A , B , C , D )
trg = cut ( A , B , C , D ) を A とする
rst = cut ( A , B , C , D ) を A とする <eos>
392
src = E = F - G * D
trg = F から G に D を掛けた値を引いた値を E とする
rst = F から G に D を掛けた値を引いた値を E とする <eos>
393
src = A [ len ( B ) ] . add ( C )
trg = A の B の長さ番目に C を追加した集まり
rst = A の B の長さに C を追加した集まり <eos>
394
src = for A in range ( min ( B + 1 , C ) ) :
trg = 0 から B に 1 を加えた値 、 C の最小値 未満までの数列を順に A として 、 繰り返 す
rst = 0 から B に 1 を加えた値 、 C の最小値 未満までの数列を順に A として 、 繰り返 す <eos>
395
src = if all ( [ A == B for A , B in zip ( C [ : : 2 ] , C [ 1 : : 2 ] ) ] ) :
trg = C の 、 つまり先頭から 、 つまり末尾までの 2 間隔による部分列 、 C の 1 番目から 、 つまり末尾までの 2 間隔による部分列の 要素をそれぞれ組にした列の各要素 を A 、 B とし 、 A が B と等しいかどうかの列が全てが真 のとき 、
rst = C の 、 つまり先頭から 、 つまり末尾までの 2 間隔による部分列 、 C の 1 番目から 、 つまり末尾までの 2 間隔による部分列 の要素をそれぞれ組にした列 の各要素を A 、 B とし 、 A が B と等しいとき 、 <eos>
396
src = if A . child is None :
trg = A の child が 、 つまり未定値と等しくないとき 、
rst = A の child が 、 つまり未定値と等しくないとき 、 <eos>
397
src = A = B . find ( C , D [ E ] ) + 1
trg = B の位置 D の E 番目から C を探して見つかった位置 に 1 を加えた値を A とする
rst = B の位置 D の E から C を探して見つかった位置を A とする <eos>
398
src = if A == B :
trg = A が B と等しいとき 、
rst = A が B と等しいとき 、 <eos>
399
src = A [ 25 ] = B [ 0 ]
trg = B の先頭を A の 25 番目に する
rst = B の先頭を A の 25 番目に する <eos>
400
src = A = it ( ) - B
trg = it () から B を引いた値を A とする
rst = it () から B を引いた値を A とする <eos>
401
src = A [ B ] [ C ] %= D
trg = A の B 番目の C 番目を D で割った余りに する
rst = A の B 番目の C 番目を D で割った余りに する <eos>
402
src = if A [ B ] != ' ' :
trg = A の B 番目が 、 つまり空白文字 と等しくないとき 、
rst = A の B 番目が 、 つまり空白文字 と等しくないとき 、 <eos>
403
src = A [ B . index ( C ) ] -= 1
trg = A の B の C と等しい要素の最初の位置番目を 1 だけ 減 少 させ る
rst = A の B の C と等しい要素の最初の位置番目を 1 だけ 減 少 させ る <eos>
404
src = print ( A [ B [ 1 ] ] )
trg = A の B の 1 番目 番目を出力する
rst = A の B の 1 番目 番目を出力する <eos>
405
src = A = B . edge [ C * B . n + D ]
trg = B の edge の C に B の n を掛けた値に D を加えた値番目を A とする
rst = B の edge の C に B の n を掛けた値に D を加えた値番目を A とする <eos>
406
src = A = [ [ ] for B in range ( 26 ) ]
trg = 0 から 26 未満までの数列の各要素を B とし 、 、 つまり空列の列を A とする
rst = 0 から 26 未満までの数列の各要素を B とし 、 、 つまり空列の列を A とする <eos>
407
src = print ( sum ( [ ( A - B ) * C for B , C in enumerate ( sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) ) ] ) )
trg = list ( map ( int , input (). split ())) をソートした列 に番号付した組の列の各要素を B 、 C とし 、 A から B を引いた値に C を掛けた値の列の総和を出力する
rst = input (). split () の各要素に int を適用した列のリスト の各要素を B 、 C とし 、 A から B を引いた値に C の出現回数 の列の総和を出力する <eos>
408
src = if A == B [ - 1 ] :
trg = A が B の末尾 と等しいとき 、
rst = A が B の末尾 と等しいとき 、 <eos>
409
src = A = [ B % 2 ] * ( C + 1 )
trg = ( B を 2 で割った余り ) からなる列の C に 1 を加えた値回分の列を A とする
rst = ( B を 2 で割った余りに C に 1 を加えた値を掛けた値を A とする <eos>
410
src = A = max ( A , sum ( [ B [ C ] [ D ] for C in range ( E ) ] ) )
trg = A 、0 から E 未満までの数列の各要素を C とし 、 B の C 番目の D 番目の列の総和 の最大値を A とする
rst = A 、0 から E 未満までの数列の各要素を C とし 、 B の C 番目の D 番目の列の総和 の最大値を A とする <eos>
411
src = A = bl ( B , C ) - 1
trg = bl ( B , C ) から 1 を引いた値を A とする
rst = bl ( B , C ) から 1 を引いた値を A とする <eos>
412
src = A . heappush ( B , ( C , e , D , E ) )
trg = A . heappush ( B , ( C , e , D , E ))
rst = A . heappush ( B , ( C , e , D , E )) <eos>
413
src = print ( bisect_left ( A , B ) , bisect_right ( A , B ) )
trg = ソートされた順序を保ったまま B を A に挿入できる位置 、 ソートされた順序を保ったまま B を A に挿入できる最後の位置 を出力する
rst = ソートされた順序を保ったまま B を A に挿入できる位置 、 ソートされた順序を保ったまま B を出力する <eos>
414
src = for A in range ( 1 , min ( B + 1 , 3 + 1 ) ) :
trg = 1 から B に 1 を加えた値 、 3 に 1 を加えた値の最小値 未満までの数列を順に A として 、 繰り返 す
rst = 1 から B に 1 を加えた値 、 3 の最小値に 1 を加えた値未満までの数列を順に A として 、 繰り返 す <eos>
415
src = A = primes2 ( 10 ** 7 )
trg = primes 2 (10**7) を A とする
rst = primes 2( 10 ) の 7 乗を A とする <eos>
416
src = for A in list ( B ) :
trg = B のリストを順に A として 、 繰り返 す
rst = B のリスト を順に A として 、 繰り返 す <eos>
417
src = dfs ( 0 , 0 , A [ 0 ] [ 0 ] , - 1 )
trg = dfs (0,0, A [0][0], -1)
rst = dfs (0,0, A [0][0], -1) <eos>
418
src = A = [ [ B for B in input ( ) ] for C in range ( D ) ]
trg = 0 から D 未満までの数列の各要素を C とし 、 、 つまり入力された文字列 の各要素を B とし 、 B の列の列を A とする
rst = 0 から D 未満までの数列の各要素を C とし 、 、 つまり入力された文字列の列を A とする <eos>
419
src = while A [ B ] == C [ B + 1 ] [ 1 ] :
trg = A の B 番目が C の B に 1 を加えた値番目の 1 番目と等しい 間 、 次 を 繰り返 す
rst = A の B 番目が C の B に 1 を加えた値番目の 1 番目と等しい 間 、 次 を 繰り返 す <eos>
420
src = if A . parent . value < B :
trg = A の parent の value が B より小さいとき 、
rst = A の parent の value が B より小さいとき 、 <eos>
421
src = A = sum ( [ B * min ( C , D ) for B , D in zip ( E , F ) ] )
trg = E 、 F の要素をそれぞれ組にした列 の各要素を B 、 D とし 、 B に C 、 D の最小値 を掛けた値の列の総和を A とする
rst = E 、 F の要素をそれぞれ組にした列 の各要素を B 、 D とし 、 B に C を掛けた値 、 D の最小値の列を A とする <eos>
422
src = for A in range ( B . N - 1 ) :
trg = 0 から B の N から 1 を引いた値未満までの数列を順に A として 、 繰り返 す
rst = 0 から B の N から 1 を引いた値未満までの数列を順に A として 、 繰り返 す <eos>
423
src = A = 250
trg = 2 50 を A とする
rst = <unk> を A とする <eos>
424
src = A . q [ B ] , A . q [ C ] = A . q [ C ] , A . q [ B ]
trg = A の q の C 番目 、 A の q の B 番目を A の q の B 番目 、 A の q の C 番目とする
rst = A の q の C 番目 、 A の q の B 番目を A の q の B 番目 、 A の q の C 番目とする <eos>
425
src = A . v , A . cost = B , C
trg = B 、 C を A の v 、 A の cost とする
rst = B 、 C を A の v 、 A の cost とする <eos>
426
src = A = not inside_convex_polygon ( B [ 0 ] , C )
trg = inside _ convex _ polygon ( B [0], C ) でない を A とする
rst = inside _ convex _ polygon ( B [0], C ) でない を A とする <eos>
427
src = D = B + E
trg = B に E を加えた値を D とする
rst = B に E を加えた値を D とする <eos>
428
src = A = list ( set ( B ) | set ( C ) )
trg = B の集合と C の集合の論理和 のリストを A とする
rst = B の集合と C <unk> A とする <eos>
429
src = return A . rp [ B ] [ 1 ]
trg = A の rp の B 番目の 1 番目を返す
rst = A の rp の B 番目の 1 番目を返す <eos>
430
src = if A != B and C [ A ] [ D ] == C [ B ] [ D ] :
trg = A が B と等しくなくかつ C の A 番目の D 番目が C の B 番目の D 番目と等しいとき 、
rst = A が B と等しくなくかつ C の A 番目の D 番目が C の B 番目の D 番目と等しいとき 、 <eos>
431
src = A , B = map ( int , input ( ) . split ( ) ) , input ( ) . split ( )
trg = 入力された文字列 を空白で分割した字句列 の各要素に整数を適用した列 、 入力された文字列 を空白で分割した字句列を A 、 B とする
rst = 入力された文字列 を空白で分割した字句列の各要素に 整数を適用した列を展開し 、 それぞれ A 、 B とする <eos>
432
src = A = int ( B . replace ( * C ) )
trg = B 内の C を展開してを [ MASK ] で置き換えた文字列の整数値を A とする
rst = B 内の C を掛けた値を [ MASK ] で置き換えた文字列を A とする <eos>
433
src = while A [ B - 1 ] == C :
trg = A の B から 1 を引いた値番目が C と等しい 間 、 次 を 繰り返 す
rst = A の B から 1 を引いた値番目が C と等しい 間 、 次 を 繰り返 す <eos>
434
src = A = B // 1000 * C
trg = B を 1000 で割った商に C を掛けた値を A とする
rst = B を 1000 で割った商に C を掛けた値を A とする <eos>
435
src = A [ B + 1 ] = A [ B ] [ : ]
trg = A の B 番目のコピーされた列を A の B に 1 を加えた値番目に する
rst = A の B 番目のコピーされた列を A の B に 1 を加えた値番目に する <eos>
436
src = print ( str ( A ) + B + str ( C ) + D + str ( A * C ) )
trg = str ( A ) に B を加えた値に C の文字列を加えた値に D を加えた値に A に C を掛けた値 の文字列を加えた値を出力する
rst = str ( A ) に B を加えた値に C の文字列を加えた値に D を加えた値に A に C を掛けた値を加えた値 を出力する <eos>
437
src = if sgn ( A . dot ( B ) ) == 0 :
trg = sgn ( A . dot ( B )) が 0 と等しいとき 、
rst = sgn ( A . dot ( B )) が 0 と等しいとき 、 <eos>
438
src = print ( len ( set ( list ( map ( int , input ( ) . split ( ) ) ) ) ) )
trg = input (). split () の各要素に int を適用した列のリスト の集合の長さ を出力する
rst = input (). split () の各要素に int <unk> <unk> <unk> を出力する <eos>
439
src = write ( A % B [ 0 ] [ C ] )
trg = write ( A % B [0][ C ] )
rst = write ( A % B [0]) <eos>
440
src = print ( A % B [ C + 1 ] )
trg = A を B の C に 1 を加えた値番目 で割った余りを出力する
rst = A を B の C に 1 を加えた値番目 で割った余りを出力する <eos>
441
src = if ( A [ B ] is None or A [ B ] <= C ) and ( A [ D ] is None or C <= A [ D ] ) :
trg = A の B 番目が 、 つまり未定値と等しくなくまたは A の B 番目が C 以下かつ A の D 番目が 、 つまり未定値と等しくなくまたは C が A の D 番目以下のとき 、
rst = A の B 番目が 、 つまり未定値と等しくなくまたは A の B 番目が C 以下かつ A の D 番目が 、 つまり未定値と等しくないとき 、 <eos>
442
src = A = get_cross_time ( B - C , D - E )
trg = get _ cross _ time ( B - C , D - E ) を A とする
rst = outer _ p ( B - C , D - E ) を A とする <eos>
443
src = A [ B ] . expand ( C )
trg = A [ B ] . expand ( C )
rst = A [ B ] . <unk> ( C ) <eos>
444
src = A = defaultdict ( lambda : defaultdict ( int ) )
trg = defaultdict ( lambda : defaultdict ( int )) を A とする
rst = defaultdict ( int ) を reverse として A とする <eos>
445
src = A = [ 1 , 1 , 1 , 1 , 1 , 2 , 2 , 2 , 3 ]
trg = ( 1、1、1、1、1、2、2、2、 3 ) からなる列を A とする
rst = ( 1 、0、2、3 ) からなる列を A とする <eos>
446
src = C = B . pop
trg = B の先頭を取り出した値を C とする
rst = B の [ MASK ] を取り出した値を C とする <eos>
447
src = A = ( [ ' ' . join ( map ( str , B ) ) for B in A ] )
trg = A の各要素を B とし 、 、 つまり空白文字を間に入れて B の各要素に整数を適用した列 を連結した文字列の列を A とする
rst = A の各要素を B とし 、 、 つまり空白文字を間に入れて B の各要素に整数を適用した列 を連結した文字列の列を A とする <eos>
448
src = A [ B ] *= C
trg = A の B 番目を C 倍 に する
rst = A の B 番目を C 倍 に する <eos>
449
src = if A + B [ C ] * D <= 1000 :
trg = A に B の C 番目に D を掛けた値を加えた値が 1000 以下のとき 、
rst = A に B の C 番目に D を掛けた値を加えた値が 1000 以下のとき 、 <eos>
450
src = A = B [ 0 ] - 1
trg = B の先頭から 1 を引いた値を A とする
rst = B の 0 番目から 1 を引いた値を A とする <eos>
451
src = print ( 0 , 3 )
trg = 0 、 3 を出力する
rst = 0 、 3 を出力する <eos>
452
src = A [ B ] = A [ C ] = A [ D ] = False
trg = 偽を A の D 番目を A の C 番目とするとするを A の B 番目に する
rst = 偽を A の D 番目を C の A の C 番目とするを A の B 番目に する <eos>
453
src = while A and A [ - 1 ] [ 0 ] == B - 1 and B <= C :
trg = A かつ A の末尾の 0 番目が B から 1 を引いた値と等しくかつ B が C 以下の 間 、 次 を 繰り返 す
rst = A かつ A の末尾の 0 番目が B から 1 を引いた値と等しくかつ B が C 以下の 間 、 次 を 繰り返 す <eos>
454
src = A = [ [ B . INFINITY ] * [ C for D in range ( C ) ] ]
trg = ( ( B の INFINITY ) からなる列の 0 から C 未満までの数列の各要素を D とし 、 C の列回分の列 ) からなる列を A とする
rst = ( ( B の INFINITY ) からなる列の 0 から C 未満までの数列の各要素を D とし 、 C の列回分の列 ) からなる列を A とする <eos>
455
src = A . pip [ 0 ] , A . pip [ 2 ] , A . pip [ 3 ] , A . pip [ 5 ] = A . pip [ 2 ] , A . pip [ 5 ] , A . pip [ 0 ] , A . pip [ 3 ]
trg = A の pip の 2 番目 、 A の pip の 5 番目 、 A の pip の先頭 、 A の pip の 3 番目を A の pip の先頭 、 A の pip の 2 番目 、 A の pip の 3 番目 、 A の pip の 5 番目とする
rst = A の pip の先頭 、 A の 4 番目 、 A の 5 番目 、 A の pip の先頭を A の pip の先頭 、 A の 4 番目 、 A の 5 番目 、 A の face の 2 番目 、 A の 5 番目とする <eos>
456
src = A = ( B . p1 . x - B . p2 . x ) * ( C . p1 . y - B . p1 . y ) + ( B . p1 . y - B . p2 . y ) * ( B . p1 . x - C . p1 . x )
trg = B の p 1 の x 座標から B の p 2 の x 座標を引いた値に C の p 1 の y 座標から B の p 1 の y 座標を引いた値を掛けた値 に B の p 1 の y 座標から B の p 2 の y 座標を引いた値に B の p 1 の x 座標から C の p 1 の x 座標を引いた値を掛けた値 を加えた値を A とする
rst = B の p 1 の x 座標から B の p 2 の x 座標を引いた値に C の p 1 の y 座標から B の p 2 の y 座標を引いた値を掛けた値 に B の p 1 の y 座標から B の p 1 の p 2 の x 座標を引いた値に B の p 1
457
src = update ( 2 , [ ( - 1 , - 1 ) , ( 1 , - 1 ) , ( - 1 , 1 ) , ( 1 , 1 ) ] )
trg = update ( 2 ,[(- 1,-1),( 1,-1),( -1,1) , (1, 1)])
rst = update ( 2 ,[(- -1) , ( (1、-1) の組 , ( 1 1)]) <eos>
458
src = A = tuple ( [ B ] + list ( C ) [ : - 1 ] )
trg = ( B ) からなる列に C のリスト の末尾を除いた部分列を加えた値 の組を A とする
rst = ( B ) からなる列に C のリストを加えた値に (-1) からなる列を加えた値を A とする <eos>
459
src = A += B . bit [ C ]
trg = A を B の bit の C 番目だけ 増 加 させ る
rst = A を B の bit の C 番目だけ 増 加 させ る <eos>
460
src = A -= A - 20
trg = A を A から 20 を引いた値だけ 減 少 させ る
rst = A を A から 20 を引いた値だけ 減 少 させ る <eos>
461
src = A = SSSP ( B )
trg = SSSP ( B ) を A とする
rst = <unk> ( B ) を A とする <eos>
462
src = print ( A . format ( B - 1911 ) )
trg = A を書式として B から 1911 を引いた値 で整形した文字列を出力する
rst = A を書式として B から 1911 を引いた値 で整形した文字列を出力する <eos>
463
src = A . print ( )
trg = A . print ()
rst = A . <unk> () を出力する <eos>
464
src = A = [ LinkList ( ) for B in range ( C ) ]
trg = 0 から C 未満までの数列の各要素を B とし 、 LinkList () の列を A とする
rst = 0 から C 未満までの数列の各要素を B とし 、 <unk> () の列を A とする <eos>
465
src = if A < 2 :
trg = A が 2 より小さいとき 、
rst = A が 2 より小さいとき 、 <eos>
466
src = A . status . append ( [ B ] * 8 )
trg = A の status の末尾に ( B ) からなる列の 8 回分の列を 追加する
rst = A の status の末尾に ( B ) からなる列の 8 回分の列を 追加する <eos>
467
src = A = D ( B )
trg = D ( B ) を A とする
rst = D ( B ) を A とする <eos>
468
src = while A >= 100 :
trg = A が 100 以上の 間 、 次 を 繰り返 す
rst = A が 100 以上の 間 、 次 を 繰り返 す <eos>
469
src = if 3 in A and 2 in A :
trg = 3 が A に含まれかつ 2 が A に含まれるとき 、
rst = 3 が A に含まれかつ 2 が A に含まれるとき 、 <eos>
470
src = A = roundup1000 ( A * 1.05 )
trg = roundup 1000 ( A * 1.05 ) を A とする
rst = <unk> ( A ) に 1.05 を掛けた値を A とする <eos>
471
src = C [ : ] = D
trg = D を C の 、 つまり先頭から 、 つまり末尾までの部分列に する
rst = D を C の 、 つまり先頭から 、 つまり末尾までの部分列に する <eos>
472
src = A [ B - 1 ] = 2
trg = 2 を A の B から 1 を引いた値番目に する
rst = 2 を A の B から 1 を引いた値番目に する <eos>
473
src = if A / B < pi :
trg = A を B で割った値が 、 つまり円周率 より小さいとき 、
rst = A を B で割った値が 、 つまり円周率 より小さいとき 、 <eos>
474
src = A = B - ( 7 * C + D ) * E
trg = B から 7 に C を掛けた値に D を加えた値に E を掛けた値を引いた値を A とする
rst = B から 7 に C を掛けた値に D を加えた値を引いた値を A とする <eos>
475
src = print ( ' ' + str ( A [ B + 1 ] ) , end = '' )
trg = 改行せずに空白文字に A の B に 1 を加えた値番目 の文字列を加えた値を出力する
rst = 改行せずに空白文字に A の B に 1 を加えた値番目 の文字列を加えた値を出力する <eos>
476
src = propagates ( * gindex ( A , B ) )
trg = propagates (* gindex ( A , B ))
rst = propagates (* gindex ( A , B )) <eos>
477
src = A = seki ( B , C , A )
trg = seki ( B , C , A ) を A とする
rst = <unk> ( B , C , A ) を A とする <eos>
478
src = print ( str ( A [ 0 ] [ 0 ] ) + B + C . format ( A [ 0 ] [ 1 ] ) , end = '' )
trg = 改行せずに A [0] の先頭の文字列に B を加えた値に C を書式として A の先頭の 1 番目で整形した文字列 を加えた値を出力する
rst = 改行せずに A [0] の先頭の文字列に B を加えた値に C を書式として A の先頭の 1 番目 の文字列を加えた値を出力する <eos>
479
src = A , B = [ 0 ] * 31 , [ ]
trg = (0) からなる列の 31 回分の列 、 空列を A 、 B とする
rst = (0) からなる列の 31 回分の列 、 空列を A 、 B とする <eos>
480
src = A , B = ( E , F ) if C <= D else ( D , G )
trg = C が D 以下のとき ( E 、 F ) の組 、 そうでなければ ( D 、 G ) の組 を展開し 、 それぞれ A 、 B とする
rst = C が D 以下のとき E 、 そうでなければ ( C 、 D ) の組 を展開し 、 それぞれ A 、 B とする <eos>
481
src = if A . list [ 1 ] == B :
trg = A の list の 1 番目が B と等しいとき 、
rst = A の list の 1 番目が B と等しいとき 、 <eos>
482
src = print ( A * B // gcd ( A , B ) // gcd ( A , B ) * C )
trg = A に B を掛けた値を A と B の最大公約数で割った商を A と B の最大公約数で割った商に C を掛けた値を出力する
rst = A に B を掛けた値を A と B <unk> A と B の最大公約数で割った商 を出力する <eos>
483
src = A [ B ] [ C ] = abs ( D [ B ] - D [ C ] ) <= 1
trg = D の B 番目から D の C 番目を引いた値の絶対値が 1 以下かどうかを A の B 番目の C 番目に する
rst = D の B 番目から D の C 番目を引いた値の絶対値を A の B 番目の C 番目に する <eos>
484
src = if A == 0 and B [ C ] [ D ] == 1 :
trg = A が 0 と等しくかつ B の C 番目の D 番目が 1 と等しいとき 、
rst = A が 0 と等しくかつ B の C 番目の D 番目が 1 と等しいとき 、 <eos>
485
src = A , B , C , D , E = F = G . popleft ( )
trg = G . popleft () を F とする を展開し 、 それぞれ A 、 B 、 C 、 D 、 E とする
rst = G . popleft () を F とする を展開し 、 それぞれ A 、 B 、 C 、 D 、 E とする <eos>
486
src = if not ( ( A >> B ) & 1 ) :
trg = A を B だけ右シフトした値と 1 の論理積でないとき 、
rst = A を B だけ右シフトした値と 1 の論理積でないとき 、 <eos>
487
src = A [ B + C - 1 ] . append ( D )
trg = A の B に C を加えた値から 1 を引いた値番目の末尾に D を追加する
rst = A の B に C を加えた値から 1 を引いた値番目の末尾に D を追加する <eos>
488
src = A . REdge = [ [ ] for B in range ( C ) ]
trg = 0 から C 未満までの数列の各要素を B とし 、 、 つまり空列の列を A の REdge に する
rst = 0 から C 未満までの数列の各要素を B とし 、 、 つまり空列の列を A の f _ of _ nodes に する <eos>
489
src = if A + ( B - C ) <= D :
trg = A に B から C を引いた値を加えた値が D 以下のとき 、
rst = A に B から C を引いた値を加えた値が D 以下のとき 、 <eos>
490
src = print ( round ( count / 2 ) )
trg = 無限の整数列を 2 で割った値を 四捨五 入した整数値 を出力する
rst = 無限の整数列を 2 を 四捨五 入した整数値 を出力する <eos>
491
src = A = count ( ( B , C ) , D )
trg = ( B 、 C ) の組 から 始 まり D 間隔 で 続 く無限の整数列 を A とする
rst = ( ( B 、 C ) の組 、 D ) の組を A とする <eos>
492
src = return A + B / ( B + C ) * ( D - A )
trg = A に B を B に C を加えた値で割った値に D から A を引いた値を掛けた値を加えた値 を返す
rst = A に B を B に C を加えた値で割った値に D から A を引いた値を掛けた値を加えた値 を返す <eos>
493
src = if A == [ 1 , 1 , 3 ] :
trg = A が (1、1、 3 ) からなる列と等しいとき 、
rst = A が ( 1 、0、2、3 ) からなる列と等しいとき 、 <eos>
494
src = print ( A . format ( C / 2 if B else 0 ) )
trg = A を書式として B のとき C を 2 で割った値 、 そうでなければ 0 で整形した文字列を出力する
rst = A を書式として C を 2 で割った余りのとき C を 2 で割った値 、 そうでなければ 0 で整形した文字列を出力する <eos>
495
src = A = B . format ( C , D , C * D )
trg = B を書式として C 、 D 、 C に D を掛けた値で整形した文字列を A とする
rst = B を書式として C 、 D 、 C に D を掛けた値 で整形した文字列を A とする <eos>
496
src = A = dist ( B , C , D )
trg = B と C 、 D の ユ ー ク リ ッ ド距離 を A とする
rst = B と C 、 D の ユ ー ク リ ッ ド距離 を A とする <eos>
497
src = while A [ 99 ] == 0 :
trg = A の 99 番目が 0 と等しい 間 、 次 を 繰り返 す
rst = A の 99 番目が 0 と等しい 間 、 次 を 繰り返 す <eos>
498
src = if A >= 7 :
trg = A が 7 以上のとき 、
rst = A が 7 以上のとき 、 <eos>
499
src = A . add ( B [ C ] , 1 )
trg = A に B の C 番目 、 1 を追加した集まり
rst = A に B の C 番目 、 1 を追加した集まり <eos>
500
src = A . process_ink ( B , C + 1 )
trg = A . process _ ink ( B , C +1)
rst = A . process _ ink ( B , C +1) <eos>
501
src = A = Node ( None , None , None )
trg = Node ( None , None , None ) を A とする
rst = Node ( None , None , None ) を A とする <eos>
502
src = A . append ( ( B + C + 1 , D + E + 1 ) )
trg = A の末尾に ( B に C を加えた値に 1 を加えた値 、 D に E を加えた値に 1 を加えた値 ) の組 を追加する
rst = A の末尾に ( B に C を加えた値に 1 を加えた値 、 D に E を加えた値に 1 を加えた値 ) の組 を追加する <eos>
503
src = return cls ( A )
trg = cls ( A ) を返す
rst = cls ( A ) を返す <eos>
504
src = if A < B and C [ A ] > C [ D ] :
trg = A が B より小さくかつ C の A 番目が C の D 番目より大きいとき 、
rst = A が B より小さくかつ C の A 番目が C の D 番目より大きいとき 、 <eos>
505
src = for A in range ( B // 10000 ) :
trg = 0 から B を 10000 で割った商 未満までの数列を順に A として 、 繰り返 す
rst = 0 から B を 10000 で割った商 未満までの数列を順に A として 、 繰り返 す <eos>
506
src = A . end = False
trg = 偽を A の end に する
rst = 偽を A の end に する <eos>
507
src = A = B [ A ]
trg = B の A 番目を A とする
rst = B の A 番目を A とする <eos>
508
src = if all ( [ A != B and C != B for D , A , C in E ] ) :
trg = E の各要素を D 、 A 、 C とし 、 A が B と等しくなくかつ C が B と等しくないかどうかの列 が全てが真のとき 、
rst = E の各要素を A 、 C 、 D 、 A 、 C とし 、 A が B と等しくなくかつ C が B <unk> が全てが真のとき 、 <eos>
509
src = print ( A % B [ C - 1 ] [ 0 ] )
trg = A を B の C から 1 を引いた値番目の先頭 で割った余りを出力する
rst = A を B の C から 1 を引いた値番目の先頭 で割った余りを出力する <eos>
510
src = if A < B - abs ( C - D ) :
trg = A が B から C から D を引いた値の絶対値を引いた値 より小さいとき 、
rst = A が B から C から D を引いた値の絶対値 より小さいとき 、 <eos>
511
src = A = solve3 ( )
trg = solve 3 () を A とする
rst = <unk> () を A とする <eos>
512
src = A = max ( A , min ( B , C , D - C , E ) )
trg = A 、 B 、 C 、 D から C を引いた値 、 E の最小値の最大値 を A とする
rst = A 、 B 、 C 、 D から C を引いた値 、 E の最小値の最大値 を A とする <eos>
513
src = A [ 1 ] = A [ 0 ]
trg = A の先頭を A の 1 番目に する
rst = A の先頭を A の 1 番目に する <eos>
514
src = return ( 0 , 3 )
trg = (0、3) の組を返す
rst = (0、3) の組を返す <eos>
515
src = A = [ None for B in range ( 8 ) ]
trg = 0 から 8 未満までの数列の各要素を B とし 、 、 つまり未定値の列を A とする
rst = 0 から 8 未満までの数列の各要素を B とし 、 、 つまり未定値の列を A とする <eos>
516
src = A = [ [ ( 0 , B ) ] for B in range ( C . v ) ]
trg = 0 から C の v 未満までの数列の各要素を B とし 、 ( (0、 B ) の組 ) からなる列の列を A とする
rst = 0 から C の v 未満までの数列の各要素を B とし 、(0、 B ) の組の列を A とする <eos>
517
src = if all ( [ A <= B for A , B in zip ( [ C , D , E , F ] , G ) ] ) :
trg = ( C 、 D 、 E 、 F ) からなる列 、 G の要素をそれぞれ組にした列 の各要素を A 、 B とし 、 A が B 以下かどうかの列が全てが真 のとき 、
rst = ( C 、 D 、 E 、 F 、 G ) からなる列の各要素を A 、 B とし 、 A が B 以下かどうかの列が全てが真 のとき 、 <eos>
518
src = A = [ B for B in range ( 1 , 11 ) ]
trg = 1 から 1 1 未満までの数列の各要素を B とし 、 B の列を A とする
rst = 1 から 1 1 未満までの数列の各要素を B とし 、 B の列を A とする <eos>
519
src = print ( min ( A , B , C ) + min ( D , e ) - 50 )
trg = A 、 B 、 C の最小値に D 、 ネイピア数 の最小値 を加えた値から 50 を引いた値 を出力する
rst = A 、 B 、 C の最小値に D 、 e から 50 を引いた値の最小値 を出力する <eos>
520
src = A = A / ( 2 ** 7 )
trg = A を 2 の 7 乗で割った値を A とする
rst = A を 2 の 7 乗で割った値 で割った値を A とする <eos>
521
src = A . append ( B [ C ] )
trg = A の末尾に B の C 番目を追加する
rst = A の末尾に B の C 番目を追加する <eos>
522
src = A = D [ B * 2 ] if B * 2 + 1 <= C else None
trg = B に 2 を掛けた値に 1 を加えた値が C 以下のとき D の B に 2 を掛けた値番目 、 そうでなければ 、 つまり未定値 を A とする
rst = B に 2 を掛けた値が C 以下のとき D の B に 2 を掛けた値に 1 を加えた値 、 そうでなければ 、 つまり未定値 を A とする <eos>
523
src = return A . nodes
trg = A の nodes を返す
rst = A の nodes を返す <eos>
524
src = A ^= 1
trg = A を 1 と の排他 的 論理和に する
rst = A を 1 と の排他 的 論理和に する <eos>
525
src = A . cur = A . nil
trg = A の nil を A の cur に する
rst = A の nil を A の cur に する <eos>
526
src = A = Vector ( B . p2 - B . p1 )
trg = Vector ( B . p 2- B . p 1 ) を A とする
rst = Vector ( B . p 2- B . p 1 ) を A とする <eos>
527
src = print ( A [ - 1 ] )
trg = A の末尾 を出力する
rst = A の末尾 を出力する <eos>
528
src = A = B . delete_node ( B . find ( int ( C [ 1 ] ) ) )
trg = B . delete _ node ( B . find ( int ( C [1])) ) を A とする
rst = B . delete _ node ( int ( C [1])) を A とする <eos>
529
src = if A [ B - 1 ] < 0 :
trg = A の B から 1 を引いた値番目が 0 より小さいとき 、
rst = A の B から 1 を引いた値番目が 0 より小さいとき 、 <eos>
530
src = A = closest_pair ( sorted ( B ) )
trg = closest _ pair ( sorted ( B )) を A とする
rst = articulation _ points ( B ) をソートした列を A とする <eos>
531
src = A . slope = float ( B )
trg = B の浮動小数点数を A の slope に する
rst = B の浮動小数点数を A の slope に する <eos>
532
src = A = height ( B [ C [ D . LEFT ] ] )
trg = height ( B [ C [ D . LEFT ] ] ) を A とする
rst = height ( B [ C [ D . LEFT ] ) を A とする <eos>
533
src = if A [ 2 ] == B [ 2 ] or A [ 3 ] == B [ 3 ] :
trg = A の 2 番目が B の 2 番目 と等しくまたは A の 3 番目が B の 3 番目と等しいとき 、
rst = A の 2 番目が B の 2 番目 と等しくまたは A の 3 番目が B の 3 番目と等しいとき 、 <eos>
534
src = if A [ 0 ] == B [ 0 ] [ 0 ] or A [ - 1 ] == C - 1 or any ( [ A [ D ] == A [ D + 1 ] for D in range ( 3 ) ] ) :
trg = A の 0 番目が B の先頭の 0 番目 と等しくまたは A の -1 番目が C から 1 を引いた値と等しくまたは 0 から 3 未満までの数列の各要素を D とし 、 A の D 番目が A の D +1 番目と等しいかどうかの列が 少 なく と も ひ とつは真 のとき 、
rst = A の先頭が B の 0 と等しくまたは A の 1 番目が C から 1 を引いた値と等しくまたは A の D 番目が 3 と等しいとき 、 <eos>
535
src = A . extend ( [ 0 , 0 , 0 ] )
trg = (0、0、0) からなる列を追加して A を 拡張 する
rst = (0、0) からなる列を追加して A を 拡張 する <eos>
536
src = paint ( A , is_right = True , is_up = True )
trg = paint ( A , is _ right = True , is _ up = True )
rst = paint ( A , is _ right = True , is _ up = False ) <eos>
537
src = A += B [ C [ 0 ] ]
trg = A を B の C の先頭 番目だけ 増 加 させ る
rst = A を B の C の先頭番目 だけ 増 加 させ る <eos>
538
src = A [ B ] = min ( A . get ( B , C ) , D )
trg = A に対応する値 、 もし存在しなければ B 、 C 、 D の最小値を A の B 番目に する
rst = A に対応する値 、 もし存在しなければ B 、 C 、 D の最小値を A の B 番目に する <eos>
539
src = A += B * 100
trg = A を B に 100 を掛けた値だけ 増 加 させ る
rst = A を B に 100 を掛けた値だけ 増 加 させ る <eos>
540
src = if A <= B or C [ B ] != D :
trg = A が B 以下または C の B 番目が D と等しくないとき 、
rst = A が B 以下または C の B 番目が D と等しくないとき 、 <eos>
541
src = print ( A + B - C + 1 )
trg = A に B を加えた値から C を引いた値に 1 を加えた値を出力する
rst = A に B を加えた値から C を引いた値に 1 を加えた値を出力する <eos>
542
src = A , B = check ( 0 )
trg = check (0) を展開し 、 それぞれ A 、 B とする
rst = check (0) を展開し 、 それぞれ A 、 B とする <eos>
543
src = A . parent . left = B . NIL
trg = B の NIL を A の parent の left に する
rst = B の NIL を A の parent の left に する <eos>
544
src = A += B [ C + D ]
trg = A を B の C に D を加えた値番目だけ 増 加 させ る
rst = A を B の C に D を加えた値番目だけ 増 加 させ る <eos>
545
src = if A . par [ B ] == C :
trg = A の par の B 番目が C と等しいとき 、
rst = A の par の B 番目が C と等しいとき 、 <eos>
546
src = A = [ B ] * ( C * 2 )
trg = ( B ) からなる列の C に 2 を掛けた値回分の列を A とする
rst = ( B ) からなる列の C に 2 を掛けた値回分の列を A とする <eos>
547
src = A = sum ( B [ C ] )
trg = B の C 番目の総和を A とする
rst = B の C 番目をネイピア数 とする <eos>
548
src = A = 1989 + B - 1
trg = 1989 に B を加えた値から 1 を引いた値を A とする
rst = 1989 に B を加えた値から 1 を引いた値を A とする <eos>
549
src = if A . mp [ B + C ] [ D + E ] == A . mp [ B ] [ D ] :
trg = A の mp の B に C を加えた値番目の D に E を加えた値番目が A の mp の B 番目の D 番目と等しいとき 、
rst = A の mp の B に C を加えた値番目の D に E を加えた値番目が A の mp の B 番目の D 番目と等しいとき 、 <eos>
550
src = D = ( E + F ) / 2
trg = E に F を加えた値を 2 で割った値を D とする
rst = E に F を加えた値を 2 で割った値を D とする <eos>
551
src = if A [ B ] and C < D :
trg = A の B 番目かつ C が D より小さいとき 、
rst = A の B 番目かつ C が D より小さいとき 、 <eos>
552
src = while A > 0 and B [ C ] - B [ A - 1 ] + ( C - A + 1 ) <= D :
trg = A が 0 より大きくかつ B の C 番目から B の A -1 番目を引いた値に C から A を引いた値に 1 を加えた値を加えた値が D 以下の 間 、 次 を 繰り返 す
rst = A が 0 より大きくかつ B の C 番目から B の A から 1 を引いた値番目に C から A <unk> D 以下の 間 、 次 を 繰り返 す <eos>
553
src = if check ( A , B , C + [ ( D , E ) , ( F , G ) ] ) :
trg = check ( A , B , C +[ ( D , E ),( F , G )]) のとき 、
rst = check ( A , B , C + ([ ( D , E ),( F , G )) のとき 、 <eos>
554
src = A = ( E - F [ C ] if B [ C ] == D else E + G [ C ] )
trg = B の C 番目が D と等しいとき E から F の C 番目を引いた値 、 そうでなければ E に G の C 番目を加えた値を A とする
rst = B の C 番目が D と等しいとき E の F から C を引いた値番目 、 そうでなければ E に G の C 番目を加えた値を A とする <eos>
555
src = if A == 3 and abs ( B - C ) < D :
trg = A が 3 と等しくかつ B から C を引いた値の絶対値が D より小さいとき 、
rst = A が 3 と等しくかつ B から C を引いた値の絶対値が D より小さいとき 、 <eos>
556
src = assert A != - 1
trg = A が -1 と等しくなく なければ な らな い
rst = A が -1 と等しくなく なければ な らな い <eos>
557
src = A = list ( map ( str , str ( datetime . date ( 2012 , 12 , 21 ) + datetime . timedelta ( days = B ) ) . split ( C ) ) )
trg = datetime . date (2012,12,21) に datetime . timedelta ( days = B ) を加えた値の文字列を C で分割した字句列の各要素に 整数を適用した列のリストを A とする
rst = <unk> ( e . timedelta ( seconds ) , <unk> = B . timedelta ( hours = C ) を A とする <eos>
558
src = A . push ( B * C )
trg = A . push ( B * C )
rst = A . push ( B * C ) <eos>
559
src = if A != B or C != B :
trg = A が B と等しくなくまたは C が B と等しくないとき 、
rst = A が B と等しくなくまたは C が B と等しくないとき 、 <eos>
560
src = A [ ( B , C ) ] = 1
trg = 1 を A の ( B 、 C ) の組番目に する
rst = 1 を A の ( B 、 C ) の組番目に する <eos>
561
src = A . d [ B ] = A . d [ C ] + D
trg = A の d の C 番目に D を加えた値を A の d の B 番目に する
rst = A の d の C 番目に D を加えた値を A の d の B 番目に する <eos>
562
src = 期末試験の成績
trg = 期 末 試験 の 成績
rst = <unk> を 中断する <eos>
563
src = A [ B ] [ C ] [ D ] = E
trg = E を A の B 番目の C 番目の D 番目に する
rst = E を A の B 番目の C 番目の D 番目に する <eos>
564
src = A = ( B ** 2 + C ** 2 - D ** 2 ) / ( 2 * C )
trg = B の 2 乗に C の 2 乗を加えた値から D の 2 乗を引いた値を 2 に C を掛けた値で割った値を A とする
rst = B の 2 乗に C の 2 乗を加えた値から D の 2 乗を引いた値を 2 に C を掛けた値で割った値を A とする <eos>
565
src = if A [ B ] [ C ] :
trg = A の B 番目の C 番目のとき 、
rst = A の B 番目の C 番目のとき 、 <eos>
566
src = A = B [ C [ 1 ] ] [ C [ 0 ] ]
trg = B の C の 1 番目番目の C の先頭番目を A とする
rst = B の C の 1 番目番目の C の先頭を A とする <eos>
567
src = A . f_key_to_val = { }
trg = 空辞書を A の f _ key _ to _ val に する
rst = 空辞書を A の f _ to _ val に する <eos>
568
src = A = [ int ( B [ 1 ] ) , 0 , 1 ]
trg = ( B の 1 番目の整数値 、0、1) からなる列を A とする
rst = ( B の 1 番目の整数値 、0) からなる列を A とする <eos>
569
src = for A in topological_sort ( B , C ) :
trg = topological _ sort ( B , C ) を順に A として 、 繰り返 す
rst = topological _ sort ( B , C ) を順に A として 、 繰り返 す <eos>
570
src = A = shuffle ( A , B )
trg = A 、 B を ラ ン ダ ムに シ ャ ッ フ ル する を A とする
rst = <unk> ( A , B ) を A とする <eos>
571
src = A . flip_color ( )
trg = A . flip _ color ()
rst = A . dice _ s () <eos>
572
src = A = RKSearch ( B , C )
trg = RKSearch ( B , C ) を A とする
rst = <unk> ( B , C ) を A とする <eos>
573
src = A = [ [ [ B for C in range ( D + 1 ) ] for E in range ( D + 1 ) ] for F in range ( G + 1 ) ]
trg = 0 から G に 1 を加えた値未満までの数列の各要素 を F とし 、0 から D に 1 を加えた値未満までの数列の各要素 を E とし 、0 から D に 1 を加えた値未満までの数列の各要素 を C とし 、 B の列の列の列 を A とする
rst = 0 から G に 1 を加えた値未満までの数列の各要素 を F とし 、0 から D に 1 を加えた値未満までの数列の各要素 を E とし 、0 から D +1 未満までの数列の各要素を C とし 、 B の列の列の列 を A とする <eos>
574
src = if len ( A ) > len ( B ) or ( len ( A ) == len ( B ) and A > B ) :
trg = A の長さが B の長さ より大きくまたは A の長さが B の長さと等しくかつ A が B より大きいとき 、
rst = A の長さが B の長さ以上または A の長さが B と等しくかつ A の長さが B より大きいとき 、 <eos>
575
src = A += ( B // 100 ) - 1
trg = A を B を 100 で割った商から 1 を引いた値だけ 増 加 させ る
rst = A を B を 100 で割った商から 1 を引いた値だけ 増 加 させ る <eos>
576
src = return A [ : B + 1 ] + list ( reversed ( A [ B + 1 : ] ) )
trg = A の 、 つまり先頭から B に 1 を加えた値までの部分列に A の B に 1 を加えた値から 、 つまり末尾までの部分列 を反転した列のリストを加えた値を 返す
rst = A の 、 つまり先頭から B に 1 を加えた値までの部分列に A の B に 1 を加えた値から 、 つまり末尾までの部分列 を加えた値を返す <eos>
577
src = A = max ( A , heappop ( B ) [ 1 ] )
trg = A 、 heappop ( B ) の 1 番目の最大値を A とする
rst = A 、 heappop ( B ) の 1 番目の最大値を A とする <eos>
578
src = for A in gindex ( B , C ) :
trg = gindex ( B , C ) を順に A として 、 繰り返 す
rst = gindex ( B , C ) を順に A として 、 繰り返 す <eos>
579
src = print ( min ( ceil ( A / B ) * C , ceil ( A / D ) * E ) )
trg = A を B で割った値の切り 上 げ 整数値に C を掛けた値 、 A を D で割った値の切り 上 げ 整数値に E を掛けた値の最小値 を出力する
rst = A を B で割った値の切り 上 げ 整数値に C を掛けた値 、 A を D で割った値の切り 上 げ 整数値に E を掛けた値を出力する <eos>
580
src = A . d = [ float ( B ) ] * A . num_of_nodes
trg = ( B の浮動小数点数 ) からなる列の A の num _ of _ nodes 回分の列を A の d に する
rst = ( B の浮動小数点数 ) からなる列の A の num _ of _ nodes 回分の列を A の d に する <eos>
581
src = for A in range ( 1 , 5 ) :
trg = 1 から 5 未満までの数列を順に A として 、 繰り返 す
rst = 1 から 5 未満までの数列を順に A として 、 繰り返 す <eos>
582
src = B = C + 1
trg = C に 1 を加えた値を B とする
rst = C に 1 を加えた値を B とする <eos>
583
src = inf = 1000000007
trg = 1000000007 を 無限大 とする
rst = 1000000007 を 無限大 とする <eos>
584
src = A . sort ( key = lambda B : ( - B . score , B . time , - B . num ) )
trg = team をパラメータとして (- B の score 、 team の time 、 - B の num ) の組を返す関数を key として A をソート する
rst = x をパラメータとして - B の score 、 B の time から B の num <unk> を返す関数を key として A をソート する <eos>
585
src = for A in matrics_vector_multiply ( B , C ) :
trg = matrics _ vector _ multiply ( B , C ) を順に A として 、 繰り返 す
rst = dijkstra 1 ( B , C ) を順に A として 、 繰り返 す <eos>
586
src = A = B . bit2 . sum ( C ) * C + B . bit1 . sum ( C )
trg = B の bit 2 、 C の総和に C を掛けた値に B の bit 1 、 C の総和を加えた値を A とする
rst = B の bit 2 、 C の総和に C を掛けた値に B の bit 1 、 C <unk> A とする <eos>
587
src = A = [ 0.0000000000000000 , 0.00000000000000000 ]
trg = ( 0 . 0000000000000000 、0.0 0000000000000000 ) からなる列を A とする
rst = ( <unk> 、 <unk> からなる列を A とする <eos>
588
src = return A * B + C
trg = A に B を掛けた値に C を加えた値を返す
rst = A に B を掛けた値に C を加えた値を返す <eos>
589
src = if A . same ( B , C ) :
trg = A . same ( B , C ) のとき 、
rst = A . same ( B , C ) のとき 、 <eos>
590
src = return f ( A - 1 ) + f ( A - 2 ) + f ( A - 3 )
trg = f ( A -1) に f ( A -2) を加えた値に f ( A -3) を加えた値を返す
rst = f ( A -1) に f ( A -2) を加えた値に f ( A -3) を加えた値を返す <eos>
591
src = A = ( B [ 1 ] - C [ 1 ] ) / ( B [ 0 ] - C [ 0 ] )
trg = B の 1 番目から C の 1 番目を引いた値を B の 0 番目から C の先頭を引いた値 で割った値を A とする
rst = B の 1 番目から C の 1 番目を引いた値を B の 0 番目から C の先頭 を引いた値で割った値を A とする <eos>
592
src = A = ( B + C ) % D . size
trg = B に C を加えた値を D の size で割った余りを A とする
rst = B に C を加えた値を D の size で割った余りを A とする <eos>
593
src = print ( A // 2 + 1 )
trg = A を 2 で割った商に 1 を加えた値を出力する
rst = A を 2 で割った商に 1 を加えた値を出力する <eos>
594
src = A = str ( int ( B + C ) + 1 ) [ 1 : ]
trg = B に C を加えた値の整数値に 1 を加えた値の文字列 の先頭を除いた部分列を A とする
rst = B に C を加えた値 を掛けた値の整数値に 1 を加えた値を A とする <eos>
595
src = A [ B ] = C [ 2 * B + 2 ]
trg = C の 2 に B を掛けた値に 2 を加えた値番目を A の B 番目に する
rst = C の 2 に B を掛けた値に 2 を加えた値番目を A の B 番目に する <eos>
596
src = A [ B + C ] = A [ D + C ]
trg = A の D に C を加えた値番目を A の B に C を加えた値番目に する
rst = A の D に C を加えた値番目を A の B に C を加えた値番目に する <eos>
597
src = A [ B ] = math . sqrt ( A [ B - 1 ] ** 2 + 1 )
trg = A の B から 1 を引いた値番目の 2 乗に 1 を加えた値の平方根を A の B 番目に する
rst = A の B から 1 を引いた値番目の 2 乗に 1 を加えた値を A の B 番目に する <eos>
598
src = if A % 10 == B // 1000 or A % 10 == ( B % 1000 ) // 100 or A % 10 == ( B % 100 ) // 10 :
trg = A を 10 で割った余りが B を 1000 で割った商 と等しくまたは A を 10 で割った余りが B を 1000 で割った余りを 100 で割った商 と等しくまたは A を 10 で割った余りが B を 100 で割った余りを 10 で割った商 と等しいとき 、
rst = A を 10 で割った余りが B を 1000 で割った商 と等しくまたは A を 10 で割った余りを 100 で割った商が B を 1000 で割った余りを 10 で割った商 と等しいとき 、 <eos>
599
src = A - B - A
trg = A から B を引いた値から A を引いた値
rst = A から B を引いた値から A を引いた値 <eos>
600
src = A , B , C = doChain ( D , B , C )
trg = doChain ( D , B , C ) を展開し 、 それぞれ A 、 B 、 C とする
rst = <unk> ( D , B , C ) を展開し 、 それぞれ A 、 B 、 C とする <eos>
601
src = A = stl1 ( B )
trg = stl 1 ( B ) を A とする
rst = <unk> ( B ) を A とする <eos>
602
src = bomb ( A , B , C - D )
trg = bomb ( A , B , C - D )
rst = bomb ( A , B , C - D ) <eos>
603
src = return ( e , A )
trg = ( 、 つまりネイピア数 、 A ) の組を返す
rst = ( 、 つまりネイピア数 、 A ) の組を返す <eos>
604
src = A . append ( ( - 2 , + 1 ) )
trg = A の末尾に (-2、1 に [ MASK ] を加えた値 ) の組 を追加する
rst = A の末尾に (- 2 に [ MASK ] を加えた値 、 -1) の組 を追加する <eos>
605
src = A . insert ( 0 , [ - 1 ] * ( B + 2 ) )
trg = A の 0 に (-1) からなる列の B に 2 を加えた値回分の列を 挿入する
rst = A の 0 に (-1) からなる列の B に 2 を加えた値回分の列を 挿入する <eos>
606
src = A = [ [ 0 for B in range ( C ) ] for D in range ( 8 ) ]
trg = 0 から 8 未満までの数列の各要素を D とし 、0 から C 未満までの数列の各要素を B とし 、0 の列の列を A とする
rst = 0 から 8 未満までの数列の各要素を D とし 、0 から C 未満までの数列の各要素を B とし 、0 の列の列を A とする <eos>
607
src = A . iter_size = A . get_size ( B )
trg = A . get _ size ( B ) を A の iter _ size に する
rst = A ._ size ( B ) を A の iter _ size に する <eos>
608
src = A . add_edge ( B + C , 2 * B + 1 , 1 , 0 )
trg = A . add _ edge ( B + C ,2* B + 1,1,0)
rst = A . add _ edge ( B + C ,2* B + 1,1,0) <eos>
609
src = create_cache ( A , B )
trg = create _ cache ( A , B )
rst = <unk> ( A , B ) <eos>
610
src = if A [ B ] > 0 and C & B == 0 and len ( D ) < E :
trg = A の B 番目が 0 より大きくかつ C と B の論理積が 0 と等しくかつ D の長さが E より小さいとき 、
rst = A の B 番目が 0 より大きくかつ C と B の論理積が D の長さ と等しくかつ E が D より小さいとき 、 <eos>
611
src = A = ( A [ B : ] + A [ : B ] ) . copy ( )
trg = A の B 番目から 、 つまり末尾までの部分列に A の 、 つまり先頭から B 番目までの部分列を加えた値 のコピー を A とする
rst = A の B 番目から 、 つまり末尾までの部分列に A の 、 つまり先頭から B で置き換えた文字列を A とする <eos>
612
src = A = max ( A , abs ( B - C ) )
trg = A 、 B から C を引いた値の絶対値の最大値を A とする
rst = A 、 B から C を引いた値の絶対値の最小値を A とする <eos>
613
src = if A != - 1 and B != - 1 :
trg = A が -1 と等しくなくかつ B が -1 と等しくないとき 、
rst = A が -1 と等しくなくかつ B が -1 と等しくないとき 、 <eos>
614
src = A [ B + C ] += 1
trg = A の B に C を加えた値番目を 1 だけ 増 加 させ る
rst = A の B に C を加えた値番目を 1 だけ 増 加 させ る <eos>
615
src = add ( A + 1 , 1 )
trg = add ( A +1,1)
rst = add ( A +1,1) <eos>
616
src = A . update ( [ ( B , C , D ) for B in range ( E ) ] )
trg = 0 から E 未満までの数列の各要素を B とし 、 ( B 、 C 、 D ) の組の列 を追加して A を 更新 する
rst = 0 から E 未満までの数列の各要素を B とし 、 ( B 、 C 、 D ) の組の列 を追加して A を 更新 する <eos>
617
src = print ( A . seconds // 3600 , A . seconds % 3600 // 60 , A . seconds % 60 )
trg = A の seconds を 3600 で割った商 、 A の seconds を 3600 で割った余りを 60 で割った商 、 A の seconds を 60 で割った余りを出力する
rst = A の seconds を 3600 で割った商 、 A の seconds を 3600 で割った余りを 60 で割った商 、 A の seconds を 60 で割った余りを出力する <eos>
618
src = if A > 6 * B :
trg = A が 6 に B を掛けた値 より大きいとき 、
rst = A が 6 に B を掛けた値 より大きいとき 、 <eos>
619
src = A , B = C [ ord ( D [ E ] ) - F ] , G [ ord ( D [ E ] ) - F ]
trg = C の D の E 番目の順序数から F を引いた値番目 、 G の D の E 番目の順序数から F を引いた値番目を A 、 B とする
rst = C の D の E 番目の順序数から F を引いた値番目 、 G の D 番目から E の F 番目を引いた値を A 、 B とする <eos>
620
src = A = [ B , C , B + C , B - C ]
trg = ( B 、 C 、 B に C を加えた値 、 B から C を引いた値 ) からなる列を A とする
rst = ( B 、 C 、 B に C を加えた値 、 B から C を引いた値 ) からなる列を A とする <eos>
621
src = A . color = B . WHITE
trg = B の WHITE を A の color に する
rst = B の WHITE を A の color に する <eos>
622
src = A [ 0 ] = [ 2 , 3 ]
trg = (2、3) からなる列を A の 0 番目に する
rst = ( 2 、6) からなる列を A の 0 番目に する <eos>
623
src = A . heappush ( B , ( ( - C << D ) | E , E , C ) )
trg = A . heappush ( B ,((- C << D )| E , E , C ))
rst = A . heappush ( B ,(- C , D )/( E , C )) <eos>
624
src = A [ ( B , C ) ] += [ D + E for D in A [ ( B , C - 1 ) ] ]
trg = A の ( B 、 C ) の組番目を A の ( B 、 C から 1 を引いた値 ) の組番目の各要素を D とし 、 D に E を加えた値の列 だけ 増 加 させ る
rst = A の ( B 、 C ) の組番目を A の ( B 、 C から 1 を引いた値 ) の組番目の各要素を D とし 、 D に E を加えた値の列 だけ 増 加 させ る <eos>
625
src = A [ B + 1 ] [ C + 1 ] = min ( A [ B + 1 ] [ C + 1 ] , D + 1 )
trg = A の B に 1 を加えた値番目の C に 1 を加えた値番目 、 D に 1 を加えた値の最小値を A の B に 1 を加えた値番目の C に 1 を加えた値番目に する
rst = A の B に 1 を加えた値番目の C に 1 を加えた値番目 、 D に 1 を加えた値の最小値を A の B に 1 を加えた値番目の C に 1 を加えた値番目に する <eos>
626
src = A = syou ( B , C , A )
trg = syou ( B , C , A ) を A とする
rst = <unk> ( B , C , A ) を A とする <eos>
627
src = A , B = map ( int , next ( C ) . split ( ) )
trg = next ( C ) を空白で分割した字句列の各要素に 整数を適用した列を展開し 、 それぞれ A 、 B とする
rst = next ( C ) を空白で分割した字句列の各要素に 整数を適用した列を展開し 、 それぞれ A 、 B とする <eos>
628
src = [ print ( sum_n ( A ) ) for A in [ int ( B ) for B in sys . stdin ] ]
trg = sys の stdin の各要素を B とし 、 B の整数値の列 の各要素を A とし 、 sum _ n ( A ) を出力するの列
rst = sys の stdin の各要素を B とし 、 B の整数値の列を展開し 、 それぞれ A を出力するの列 <eos>
629
src = if A . nums [ B ] [ C ] == D :
trg = A の nums の B 番目の C 番目が D と等しいとき 、
rst = A の nums の B 番目の C 番目が D と等しいとき 、 <eos>
630
src = propagates ( * A )
trg = propagates (* A )
rst = propagates (* A ) <eos>
631
src = A [ B ] = C + D [ E ]
trg = C に D の E 番目を加えた値を A の B 番目に する
rst = C に D の E 番目を加えた値を A の B 番目に する <eos>
632
src = for A in B [ C [ D ] ] :
trg = B の C の D 番目番目を順に A として 、 繰り返 す
rst = B の C の D 番目番目を順に A として 、 繰り返 す <eos>
633
src = if A [ 0 ] == B and A [ 1 ] == C :
trg = A の 0 番目が B と等しくかつ A の 1 番目が C と等しいとき 、
rst = A の先頭が B と等しくかつ A の 1 番目が C と等しいとき 、 <eos>
634
src = for A in [ 0 ] * int ( I ( ) ) :
trg = (0) からなる列の I () の整数値回分の列 を順に A として 、 繰り返 す
rst = (0) からなる列の I () の整数値に I を加えた値回分の列 を順に A として 、 繰り返 す <eos>
635
src = A = ( B - 30 ) // 2
trg = B から 30 を引いた値を 2 で割った商を A とする
rst = B から 30 を引いた値を 2 で割った商を A とする <eos>
636
src = A = ( B - 30 ) / 2
trg = B から 30 を引いた値を 2 で割った値を A とする
rst = B から 30 を引いた値を 2 で割った値を A とする <eos>
637
src = A = [ 0 ] * B
trg = (0) からなる列の B 回分の列を A とする
rst = (0) からなる列の B 回分の列を A とする <eos>
638
src = for A in [ B for B in range ( 9 ) if C [ B ] == D ] :
trg = 0 から 9 未満までの数列の各要素を B とし 、 C の B 番目が D と等しいとき の B の列を順に A として 、 繰り返 す
rst = 0 から 9 未満までの数列の各要素を B とし 、 C の B 番目が D と等しいとき の B の列を順に A として 、 繰り返 す <eos>
639
src = A = B . index ( e )
trg = B の 、 つまりネイピア数 と等しい要素の最初の位置を A とする
rst = B の 、 つまりネイピア数番目を A とする <eos>
640
src = print ( A . name )
trg = A の name を出力する
rst = A の name を出力する <eos>
641
src = A = B + timedelta ( days = A )
trg = B に timedelta ( days = A ) を加えた値を A とする
rst = timedelta ( days = A ) を B に timedelta ( hours = A ) を加えた値を A とする <eos>
642
src = count += 1
trg = 無限の整数列を 1 だけ 増 加 させ る
rst = 無限の整数列を 1 だけ 増 加 させ る <eos>
643
src = A . parent [ B ] = A . find ( A . parent [ B ] )
trg = A の先頭から A の parent の B 番目を探して見つかった位置を A の parent の B 番目に する
rst = A の先頭から A の parent の B 番目を探して見つかった位置を A の parent の B 番目に する <eos>
644
src = A [ B ] [ C ] = D [ B ] [ E + C ]
trg = D の B 番目の E に C を加えた値番目を A の B 番目の C 番目に する
rst = D の B 番目の E に C を加えた値番目を A の B 番目の C 番目に する <eos>
645
src = if 0 <= A < 8 and 0 <= B < 8 and C [ B ] [ A ] == D :
trg = 0 が A 以下かどうかが 8 より小さくかつ 0 が B 以下かどうかが 8 より小さくかつ C の B 番目の A 番目が D と等しいとき 、
rst = 0 が A 以下かどうかが 8 より小さくかつ 0 が B 以下かどうかが 8 より小さくかつ C の B 番目の A 番目が D と等しいとき 、 <eos>
646
src = write ( A * B )
trg = write ( A * B )
rst = write ( A * B ) <eos>
647
src = A = A - 3
trg = A から 3 を引いた値を A とする
rst = A から 3 を引いた値を A とする <eos>
648
src = A = B + C [ D ] [ E ] * ( F * 2 + 1 )
trg = B に C の D 番目の E 番目に F に 2 を掛けた値に 1 を加えた値を掛けた値を加えた値を A とする
rst = B に C の D 番目の E 番目に F に 2 を掛けた値を加えた値に 1 を加えた値を掛けた値を A とする <eos>
649
src = print ( int ( '' . join ( map ( str , A ) ) ) - int ( '' . join ( map ( str , B ) ) ) )
trg = 空文字列を間に入れて A の各要素に str を適用した列を連結した文字列 の整数値から 、 つまり空文字列を間に入れて B の各要素に str を適用した列を連結した文字列 の整数値を引いた値 を出力する
rst = 空文字列を間に入れて sorted ( A ) . zfill ( B ) の各要素に整数を適用した列 を連結した文字列の整数値 を出力する <eos>
650
src = A = 1000000009
trg = 1000000009 を A とする
rst = <unk> を A とする <eos>
651
src = return [ 8 , A [ B ] ]
trg = ( 8 、 A の B 番目 ) からなる列を返す
rst = ( 8 、 A の B 番目 ) からなる列を返す <eos>
652
src = print ( int ( A . is_intersected_with ( B ) ) )
trg = A . is _ intersected _ with ( B ) の整数値を出力する
rst = A . unite ( int ( B )) の整数値を出力する <eos>
653
src = play ( )
trg = play ()
rst = <unk> () <eos>
654
src = [ A . add ( ( B [ 2 * C + 1 ] , B [ 2 * C + 2 ] ) ) for C in range ( B [ 0 ] ) ]
trg = 0 から B の先頭 未満までの数列の各要素を C とし 、 A に ( B の 2* C に 1 を加えた値番目 、 B の 2* C に 2 を加えた値番目 ) の組を追加した集まり の列
rst = A に 0 から C 未満までの数列の各要素を B とし 、 B の 2 に C を掛けた値に 1 を加えた値番目 、 B の 2 に C を掛けた値に 1 を加えた値番目 を追加した集まり <eos>
655
src = print ( A % ( B , C [ 0 ] ) )
trg = A を ( B 、 C の先頭 ) の組で割った余り を出力する
rst = A を ( B 、 C の先頭 ) の組で割った余り を出力する <eos>
656
src = A . append ( abs ( B - C ) )
trg = A の末尾に B から C を引いた値の絶対値 を追加する
rst = A の末尾に B から C を引いた値の絶対値 を追加する <eos>
657
src = return A [ B . format ( C , D ) ]
trg = A の B を書式として C 、 D で整形した文字列 番目を返す
rst = A の B を書式として C 、 D で整形した文字列を返す <eos>
658
src = A = math . sqrt ( ( B - C ) ** 2 + ( D - C ) ** 2 + E ** 2 )
trg = B から C を引いた値の 2 乗に D から C を引いた値の 2 乗を加えた値に E の 2 乗を加えた値の平方根を A とする
rst = B から C を引いた値の 2 乗に D から C を引いた値の 2 乗を加えた値に E の 2 乗を加えた値の平方根を A とする <eos>
659
src = A += B * C in D
trg = A を B に C を掛けた値が D に含まれるかどうか だけ 増 加 させ る
rst = A を B に C を掛けた値が D に含まれない D だけ 増 加 させ る <eos>
660
src = A += B [ C ] - B [ D ]
trg = A を B の C 番目から B の D 番目を引いた値だけ 増 加 させ る
rst = A を B の C 番目から B の D 番目を引いた値だけ 増 加 させ る <eos>
661
src = A = ( B + C ) * abs ( D - E )
trg = B に C を加えた値に D から E を引いた値の絶対値を掛けた値を A とする
rst = B に C を加えた値に D から E を引いた値を掛けた値を加えた値 を掛けた値を A とする <eos>
662
src = print ( 1 if on_polygon_line ( A , B ) else 2 if in_polygon ( A , B ) else 0 )
trg = on _ polygon _ line ( A , B ) のとき 1 、 そうでなければ in _ polygon ( A , B ) のとき 2 、 そうでなければ 0 を出力する
rst = <unk> ( A , B ) のとき 1 、 そうでなければ 0 を出力する <eos>
663
src = distant ( A , B , 2 )
trg = distant ( A , B ,2)
rst = distant ( A , B ,2) <eos>
664
src = if A == B or C == B or ( B == D and A == E ) or ( B == F and C == E ) :
trg = A が B と等しくまたは C が B と等しくまたは B が D と等しくかつ A が E と等しくまたは B が F と等しくかつ C が E と等しいとき 、
rst = A が B と等しくまたは C が B と等しくまたは D が E と等しくまたは B が F と等しくかつ B が E と等しいとき 、 <eos>
665
src = for A in [ 0 ] * ( B - 1 ) :
trg = (0) からなる列の B から 1 を引いた値回分の列 を順に A として 、 繰り返 す
rst = (0) からなる列の B から 1 を引いた値回分の列を A として 、 繰り返 す <eos>
666
src = if A + B < C - D or A + C < B - D :
trg = A に B を加えた値が C から D を引いた値 より小さくまたは A に C を加えた値が B から D を引いた値より小さいとき 、
rst = A に B を加えた値が C から D を引いた値より小さくかつ A に C を加えた値に B を加えた値から D を引いた値より小さいとき 、 <eos>
667
src = A = 0.00000000001
trg = 0.00000000001 を A とする
rst = <unk> を A とする <eos>
668
src = A = [ 0 , 0 , 0 , 1 , 1 , 1 , 2 , 2 , 2 ]
trg = (0、0、0、1、 1、1、 2 、 2、2) からなる列を A とする
rst = (0、0、0、1、 1、2、2、3) からなる列を A とする <eos>
669
src = bubblesort ( A , B )
trg = bubblesort ( A , B )
rst = <unk> ( A , B ) <eos>
670
src = print ( calc ( A , B ) )
trg = calc ( A , B ) を出力する
rst = calc ( A , B ) を出力する <eos>
671
src = A , B = 0 , 31
trg = 0 、 31 を A 、 B とする
rst = 0 、 31 を A 、 B とする <eos>
672
src = A = str ( A )
trg = A の文字列を A とする
rst = A の文字列を A とする <eos>
673
src = A = B . count ( B [ C ] )
trg = B 内の B の C 番目の出現回数を A とする
rst = B 内の B の C 番目の出現回数が A とする <eos>
674
src = A = sort_middle_face ( A )
trg = sort _ middle _ face ( A ) を A とする
rst = <unk> ( A ) を A とする <eos>
675
src = if A ** 2 == B ** 2 + C ** 2 :
trg = A の 2 乗が B の 2 乗に C の 2 乗を加えた値と等しいとき 、
rst = A の 2 乗が B の 2 乗に C の 2 乗を加えた値 と等しいとき 、 <eos>
676
src = countingSort ( A , B )
trg = countingSort ( A , B )
rst = <unk> ( A , B ) <eos>
677
src = A = 2 + B + 2 * ( C + D ) + 2 * ( E + F )
trg = 2 に B を加えた値に 2 に C に D を加えた値を掛けた値を加えた値に 2 に E に F を加えた値を掛けた値を加えた値を A とする
rst = 2 に B を加えた値に 2 に C に D を加えた値を掛けた値を加えた値に 2 に E を加えた値に F を加えた値を加えた値を A とする <eos>
678
src = print ( A . upper ( ) , end = '' )
trg = 改行せずに A を英大文字に変換した文字列 を出力する
rst = 改行せずに A を英大文字に変換した文字列 を出力する <eos>
679
src = A = [ B * C for C in range ( D + 1 ) ]
trg = 0 から D に 1 を加えた値未満までの数列の各要素 を C とし 、 B に C を掛けた値の列を A とする
rst = 0 から D に 1 を加えた値未満までの数列の各要素 を C とし 、 B に C を掛けた値の列を A とする <eos>
680
src = A [ B ] = ( B , 0 )
trg = ( B 、0) の組を A の B 番目に する
rst = ( B 、0) の組を A の B 番目に する <eos>
681
src = A [ B ] [ C ] = max ( D , E , F )
trg = D 、 E 、 F の最大値を A の B 番目の C 番目に する
rst = D 、 E 、 F の最大値を A の B 番目の C 番目に する <eos>
682
src = A = list ( map ( int , sys . stdin ) )
trg = sys の stdin の各要素に 整数を適用した列のリストを A とする
rst = sys の stdin の各要素に 整数を適用した列のリストを A とする <eos>
683
src = A = B [ 7 : - 1 ]
trg = B の 7 番目から 、 つまり末尾までの部分列を A とする
rst = B の 7 番目から 、 つまり末尾までの部分列を A とする <eos>
684
src = E = B [ C ] [ F ]
trg = B の C 番目の F 番目を E とする
rst = B の C 番目の F 番目を E とする <eos>
685
src = A . print_all ( )
trg = A . print _ all ()
rst = A . dice _ s () <eos>
686
src = if D[d] ( ) != A :
trg = D [ d ] () が A と等しくないとき 、
rst = b [ i ] () が A と等しくないとき 、 <eos>
687
src = delete ( A , int ( B [ 0 ] ) )
trg = delete ( A , int ( B [0]))
rst = delete ( A , int ( B [0])) <eos>
688
src = buildMaxHeap ( A , B )
trg = buildMaxHeap ( A , B )
rst = <unk> ( A , B ) <eos>
689
src = heappush ( A , ( B + 2 , C + 1 , D ) )
trg = heappush ( A , ( B +2, C +1, D ))
rst = heappush ( A , ( B +2, C +1, D )) <eos>
690
src = A = min ( A , B . E [ C [ D ] ] [ E [ D ] ] . cap )
trg = A 、 B の E の C の D 番目番目の E の D 番目番目の cap の最小値を A とする
rst = A 、 B の E の C の D 番目番目の E の D 番目番目の cap の最小値を A とする <eos>
691
src = A . deg [ e [ 1 ] ] += 1
trg = A の deg の 、 つまりネイピア数の 1 番目番目を 1 だけ 増 加 させ る
rst = A の deg の 、 つまりネイピア数の 1 番目番目を 1 だけ 増 加 させ る <eos>
692
src = return - A
trg = - A を返す
rst = - A を返す <eos>
693
src = print ( A . format ( intersection ( ( 0 , 0 , B ) , C ) ) )
trg = A を書式として intersection ((0,0, B ) , C ) で整形した文字列を出力する
rst = A を書式として intersection _ three _ numbers (0, B ) 、 C で整形した文字列を出力する <eos>
694
src = print ( A , B , C )
trg = A 、 B 、 C を出力する
rst = A 、 B 、 C を出力する <eos>
695
src = if 2 < len ( A [ B ] [ 0 ] ) and len ( A [ B ] [ 0 ] ) < 7 :
trg = 2 が A の B 番目 の先頭の長さより小さくかつ A の B 番目の先頭 の長さが 7 より小さいとき 、
rst = 2 が A の B 番目の先頭の 0 番目が 7 より小さいとき 、 <eos>
696
src = if 0 == cross ( A - B , C - D ) :
trg = 0 が cross ( A - B , C - D ) と等しいとき 、
rst = 0 が cross ( A - B , C - D ) と等しいとき 、 <eos>
697
src = A . d = B - C
trg = B から C を引いた値を A の d に する
rst = B から C を引いた値を A の d に する <eos>
698
src = if int ( A ) - int ( B ) != 0 :
trg = A の整数値から B の整数値を引いた値 が 0 と等しくないとき 、
rst = A の整数値から B の整数値を引いた値 が 0 と等しくないとき 、 <eos>
699
src = A , B , C , D , E = [ int ( C ) for C in input ( ) . split ( ) ]
trg = 入力された文字列 を空白で分割した字句列の各要素を C とし 、 C の整数値の列を展開し 、 それぞれ A 、 B 、 C 、 D 、 E とする
rst = 入力された文字列 を空白で分割した字句列の各要素を C とし 、 C の整数値の列を展開し 、 それぞれ A 、 B 、 C 、 D 、 E とする <eos>
700
src = A += ( ( B - 1 - C ) * D [ C ] ) / ( ( B - 1 ) * E )
trg = A を B から 1 を引いた値から C を引いた値に D の C 番目を掛けた値を B から 1 を引いた値に E を掛けた値で割った値だけ 増 加 させ る
rst = A を B から 1 を引いた値から C を引いた値に D の C 番目を C だけ左シフトした値 から B を引いた値に 1 を加えた値を掛けた値を E だけ 増 加 させ る <eos>
701
src = A = int ( '' . join ( B ) )
trg = 空文字列を間に入れて B を連結した文字列の整数値を A とする
rst = 空文字列を間に入れて B を連結した文字列の整数値を A とする <eos>
702
src = if A <= B [ C ] :
trg = A が B の C 番目以下のとき 、
rst = A が B の C 番目以下のとき 、 <eos>
703
src = A = rotate_cw ( A )
trg = rotate _ cw ( A ) を A とする
rst = <unk> ( A ) を A とする <eos>
704
src = for A in range ( 2 , int ( round ( pow ( B + 1 , 0.5 ) ) ) ) :
trg = 2 から B に 1 を加えた値 の 0.5 乗を 四捨五 入した整数値の整数値 未満までの数列を順に A として 、 繰り返 す
rst = 0 から 2 を 底 とする B に 1 を加えた値 の 0.5 乗の整数値 未満までの数列を順に A として 、 繰り返 す <eos>
705
src = B = { }
trg = 空辞書を B とする
rst = ( < __ main __ . Cammaobjectat 0 x 10 a 1 db 7 c 0> ) の集合を そうでなければ 、 とする <eos>
706
src = A = min ( B [ C ] + D [ E ] , B [ E ] + D [ C ] )
trg = B の C 番目に D の E 番目を加えた値 、 B の E 番目に D の C 番目を加えた値の最小値を A とする
rst = B の C 番目に D の E 番目を加えた値 、 B の E 番目に D の C 番目を加えた値の最小値を A とする <eos>
707
src = print ( {i}x{j}={i*j} )
trg = "{} x {} = {}" を出力する
rst = "{} \ n {} \ n {}" を出力する <eos>
708
src = D = [ B ] * ( C - 1 )
trg = ( B ) からなる列の C から 1 を引いた値回分の列を D とする
rst = ( B ) からなる列の C から 1 を引いた値回分の列を D とする <eos>
709
src = if A [ 0 ] == B and A [ 2 ] == B and A [ 4 ] == C :
trg = A の 0 番目が B と等しくかつ A の 2 番目が B と等しくかつ A の 4 番目が C と等しいとき 、
rst = A の 0 番目が B と等しくかつ A の 2 番目が B と等しくかつ A の 4 番目が C と等しいとき 、 <eos>
710
src = A = min ( A , dfs ( B , C + 1 , 0 , D , 1 , 0 ) )
trg = A 、 dfs ( B , C +1,0, D ,1,0) の最小値を A とする
rst = A 、 dfs ( B , C +1, 0 , D ,0,0,0) の最小値を A とする <eos>
711
src = A [ 0 ] . append ( ( B , 0 ) )
trg = A の先頭の末尾に ( B 、0) の組 を追加する
rst = A の先頭の末尾に ( B 、0) の組 を追加する <eos>
712
src = print ( max ( A ) - min ( A ) )
trg = A の最大値から A の最小値を引いた値 を出力する
rst = A の最大値から A の最小値 を出力する <eos>
713
src = return A . cross ( B ) == 0.0
trg = A . cross ( B ) が 0.0 と等しいかどうかを返す
rst = A . cross ( B ) が 0.0 と等しいかどうかを返す <eos>
714
src = if abs ( A [ B ] [ C ] - D ) > 1 :
trg = A の B 番目の C 番目から D を引いた値の絶対値が 1 より大きいとき 、
rst = A の B 番目の C 番目から D を引いた値の絶対値が 1 より大きいとき 、 <eos>
715
src = A += str ( B ) . rjust ( 4 )
trg = A を str ( B ) . rjust (4) だけ 増 加 させ る
rst = A を str ( B ) . rjust (4) だけ 増 加 させ る <eos>
716
src = A = ( B // ( B & - B ) ) >> 1
trg = B を B と - B の論理積で割った商 を 1 だけ右シフトした値を A とする
rst = B を B と B <unk> 1 だけ右シフトした値を A とする <eos>
717
src = A += B [ C - D * E ]
trg = A を B の C から D に E を掛けた値 を引いた値番目だけ 増 加 させ る
rst = A を B の C から D に E を掛けた値 を引いた値番目だけ 増 加 させ る <eos>
718
src = A += ( B * C ) ** 2 * C
trg = A を B に C を掛けた値 の 2 乗に C を掛けた値だけ 増 加 させ る
rst = A を B に C を掛けた値 の 2 乗に C を掛けた値だけ 増 加 させ る <eos>
719
src = A [ B ] [ C ] = min ( A [ B ] [ C ] , A [ B ] [ D ] + A [ D ] [ C ] + E * F * G )
trg = A の B 番目の C 番目 、 A の B 番目の D 番目に A の D 番目の C 番目を加えた値に E に F を掛けた値に G を掛けた値を加えた値の最小値を A の B 番目の C 番目に する
rst = A の B 番目の C 番目 、 A の B 番目の D 番目に A の D 番目を掛けた値に E の C に F を加えた値番目の C 番目を加えた値の最小値を A の B 番目の C 番目に する <eos>
720
src = A = B . x * sin ( C ) + B . y * cos ( C )
trg = B の x 座標に C の正弦を掛けた値に B の y 座標に C の余弦を掛けた値を加えた値 を A とする
rst = B の x 座標に C を掛けた値に B の y 座標を掛けた値に B の y 座標に C を掛けた値を加えた値を A とする <eos>
721
src = A [ B ] = C
trg = C を A の B 番目に する
rst = C を A の B 番目に する <eos>
722
src = A . tail -= 1
trg = A の tail を 1 だけ 減 少 させ る
rst = A の tail を 1 だけ 減 少 させ る <eos>
723
src = A = [ 0 ] + list ( accumulate ( B ) )
trg = (0) からなる列に accumulate ( B ) のリストを加えた値を A とする
rst = (0) からなる列に accumulate ( B ) のリストを A とする <eos>
724
src = print ( A - sum ( B ) )
trg = A から B の総和を引いた値 を出力する
rst = A から B の総和 を引いた値 を出力する <eos>
725
src = if A < 9 :
trg = A が 9 より小さいとき 、
rst = A が 9 より小さいとき 、 <eos>
726
src = A . append ( B % 1000000007 )
trg = A の末尾に B を 1000000007 で割った余り を追加する
rst = A の末尾に B を 1000000007 で割った余り を追加する <eos>
727
src = print ( sum ( A [ B + 1 : 2 * B + 1 ] ) )
trg = A の B に 1 を加えた値から 2 に B を掛けた値に 1 を加えた値までの部分列の総和 を出力する
rst = A の B に 1 を加えた値から 2 に B を掛けた値に 1 を加えた値までの部分列の総和 を出力する <eos>
728
src = A , e = B . pop ( )
trg = B の先頭を取り出した値 を展開し 、 それぞれ A 、 ネイピア数とする
rst = B の先頭を取り出した値 を展開し 、 それぞれ A 、 ネイピア数とする <eos>
729
src = A , B = cross_point ( C , D )
trg = cross _ point ( C , D ) を展開し 、 それぞれ A 、 B とする
rst = cross _ point ( C , D ) を展開し 、 それぞれ A 、 B とする <eos>
730
src = if A [ 1 ] % A [ 0 ] == 0 :
trg = A の 1 番目を A の 0 番目 で割った余りが 0 と等しいとき 、
rst = A の 1 番目を A の 0 番目 で割った余りが 0 と等しいとき 、 <eos>
731
src = print ( chi_liu_edmonds ( A , B , C ) )
trg = chi _ liu _ edmonds ( A , B , C ) を出力する
rst = <unk> _ <unk> ( A , B , C ) を出力する <eos>
732
src = A . cur . prev . next = B
trg = B を A の cur の prev の next に する
rst = B を A の cur の prev の next に する <eos>
733
src = In_order ( A [ B ] [ 0 ] )
trg = In _ order ( A [ B ][0])
rst = In _ order ( A [ B ][0]) <eos>
734
src = if float ( A [ 0 ] [ 1 ] ) / B > 0.5 :
trg = A の先頭の 1 番目の浮動小数点数を B で割った値が 0.5 より大きいとき 、
rst = A の先頭の 1 番目を B で割った値が 0.5 より大きいとき 、 <eos>
735
src = print ( 1 if A [ B ] == A [ C ] else 0 )
trg = A の B 番目が A の C 番目と等しいとき 1 、 そうでなければ 0 を出力する
rst = A の B 番目が A の C 番目と等しいとき 1 、 そうでなければ 0 を出力する <eos>
736
src = A = [ 0 , 9 , 26 , 50 , 80 , 115 , 154 , 196 , 240 , 285 , 330 ]
trg = (0、 9 、 2 6、5 0、80、1 15 、 154 、196、2 40 、 28 5、33 0 ) からなる列を A とする
rst = <unk> 年 <unk> 月 <unk> <unk> <unk> <unk> <unk> <unk> <unk> 5、4) からなる列を A とする <eos>
737
src = print ( 0 )
trg = 0 を出力する
rst = 0 を出力する <eos>
738
src = A [ B [ C [ D ] ] ] = C [ D ]
trg = C の D 番目を A の B の C の D 番目番目 番目に する
rst = C の D 番目を A の B の C の D 番目番目 番目に する <eos>
739
src = A , B , C = sorted ( [ int ( D ) for D in input ( ) . split ( ) ] )
trg = 入力された文字列 を空白で分割した字句列の各要素を D とし 、 D の整数値の列を ソートした列を展開し 、 それぞれ A 、 B 、 C とする
rst = 入力された文字列 を空白で分割した字句列の各要素を D とし 、 D の整数値の列をソートした列を A 、 B 、 C とする <eos>
740
src = A = D if B <= C else 0
trg = B が C 以下のとき D 、 そうでなければ 0 を A とする
rst = B が C 以下のとき D 、 そうでなければ 0 を A とする <eos>
741
src = A += B . readline ( ) [ 1 : C + 1 ]
trg = A を B から読み込んだ一行 の 1 番目から C に 1 を加えた値までの部分列 だけ 増 加 させ る
rst = A を B から読み込んだ一行 の 1 番目から C に 1 を加えた値までの部分列 だけ 増 加 させ る <eos>
742
src = A += [ 0 ]
trg = A を (0) からなる列 だけ 増 加 させ る
rst = A を (0) からなる列 だけ 増 加 させ る <eos>
743
src = if 0 <= A < len ( B ) :
trg = 0 が A 以下かどうかが B の長さより小さいとき 、
rst = 0 が A 以下かどうかが B の長さより小さいとき 、 <eos>
744
src = return [ 1 , A [ B [ 2 ] ] , A [ B [ 3 ] ] , int ( B [ 4 ] ) ]
trg = ( 1 、 A の B の 2 番目番目 、 A の B の 3 番目番目 、 B の 4 番目の整数値 ) からなる列を返す
rst = (1、1、 A の B の B の 3 番目 、 B の 4 番目の整数値 ) からなる列を返す <eos>
745
src = if A > 20 :
trg = A が 20 より大きいとき 、
rst = A が 20 より大きいとき 、 <eos>
746
src = print ( get ( A [ 1 ] ) )
trg = get ( A [1]) を出力する
rst = get ( A [1]) を出力する <eos>
747
src = print ( int ( A == B ) )
trg = A が B と等しいかどうかの整数値 を出力する
rst = A が B と等しいかどうかの整数値 を出力する <eos>
748
src = A . enqueue ( [ B , int ( C ) ] )
trg = A . enqueue ([ B , int ( C )])
rst = A . enqueue ([ B , int ( C )) <eos>
749
src = A = math . sqrt ( B * ( B - C ) * ( B - D ) * ( B - E ) )
trg = B に B から C を引いた値を掛けた値に B から D を引いた値を掛けた値に B から E を引いた値を掛けた値の平方根を A とする
rst = B に B から C を引いた値を掛けた値に B から D を引いた値を掛けた値に B から E を引いた値を掛けた値の 0.5 乗を加えた値の平方根を A とする <eos>
750
src = sys . exit ( )
trg = プ ログラムを 正 常終了 する
rst = プ ログラムを 正 常終了 する で <unk> する で <unk> する で <unk> する で <unk> する で <unk> する で ログラムを 正 常終了 する <eos>
751
src = A = B . e [ C ] [ B . iter [ C ] ]
trg = B の e の C 番目の B の iter の C 番目番目を A とする
rst = B の e の C 番目の B の iter の C 番目番目を A とする <eos>
752
src = A [ B ] = C [ : D ] + E + C [ D + 5 : ]
trg = C の 、 つまり先頭から D 番目までの部分列に E を加えた値に C の D に 5 を加えた値から 、 つまり末尾までの部分列を加えた値 を A の B 番目に する
rst = C の 、 つまり先頭から D 番目までの部分列に E を加えた値に C の D 番目から D に 5 を加えた値までの部分列を A の B 番目に する <eos>
753
src = A [ 12 ] , A [ 17 ] = B [ 17 ] , B [ 12 ]
trg = B の 17 番目 、 B の 12 番目を A の 12 番目 、 A の 17 番目とする
rst = B の 17 番目 、 B の 12 番目を A の 12 番目 、 A の 17 番目とする <eos>
754
src = A = 2 - A
trg = 2 から A を引いた値を A とする
rst = 2 から A を引いた値を A とする <eos>
755
src = A = tangent_point ( B , ( C , D ) )
trg = tangent _ point ( B , ( C , D )) を A とする
rst = <unk> ( B , ( C , D )) を A とする <eos>
756
src = A = max ( int ( abs ( B - C ) - 0.5 ) , int ( abs ( D - C ) - 0.5 ) )
trg = B から C を引いた値の絶対値から 0.5 を引いた値 の整数値 、 D から C を引いた値の絶対値から 0.5 を引いた値の 整数値の最大値を A とする
rst = B から C を引いた値の絶対値 、 D から C を引いた値の絶対値の 0.5 乗 の最大値を A とする <eos>
757
src = del A [ B : C ]
trg = A の B 番目から C 番目までの部分列を 削 除 する
rst = A の B 番目から C 番目までの部分列を 削 除 する <eos>
758
src = print ( A , B + 1 )
trg = A 、 B に 1 を加えた値を出力する
rst = A 、 B に 1 を加えた値を出力する <eos>
759
src = A = A + B * 15 + C * 15 + D * 15 + E * 7 + F * 2
trg = A に B * 15 を加えた値に C に 15 を掛けた値を加えた値に D に 15 を掛けた値を加えた値に E に 7 を掛けた値を加えた値に F に 2 を掛けた値を加えた値を A とする
rst = A に B に 15 を掛けた値を加えた値に C に 15 を掛けた値を加えた値に D に 850 を掛けた値を加えた値に F に 2 を掛けた値を加えた値を A とする <eos>
760
src = A = str ( B // 3600 ) . zfill ( 2 )
trg = B を 3600 で割った商 の文字列を長さ 2 に な るように '0' 左 詰め した文字列を A とする
rst = B を 3600 で割った商 の文字列を長さ 2 に な るように '0' 左 詰め した文字列を A とする <eos>
761
src = A = B // _pow ( 10 , 4 )
trg = B を _ pow (10,4 ) で割った商を A とする
rst = B を _ pow (10,4 ) で割った商を A とする <eos>
762
src = A [ B ] = C - B
trg = C から B を引いた値を A の B 番目に する
rst = C から B を引いた値を A の B 番目に する <eos>
763
src = A [ 3 ] = copy [ 0 ]
trg = copy の先頭を A の 3 番目に する
rst = copy の先頭を A の 3 番目に する <eos>
764
src = print ( 1 if is_contain_cycle ( A , B ) else 0 )
trg = is _ contain _ cycle ( A , B ) のとき 1 、 そうでなければ 0 を出力する
rst = <unk> ( A , B ) のとき 1 、 そうでなければ 0 を出力する <eos>
765
src = A = 22 - B if 22 > B else B - 22
trg = 2 2 が B より大きいとき 2 2 から B を引いた値 、 そうでなければ B から 2 2 を引いた値を A とする
rst = 2 が B より大きいとき 2 2 から B を引いた値 、 そうでなければ B から 2 を引いた値を A とする <eos>
766
src = A [ B [ C ] ] += 2
trg = A の B の C 番目番目を 2 だけ 増 加 させ る
rst = A の B の C 番目番目を 2 だけ 増 加 させ る <eos>
767
src = A . append ( int ( B [ 0 ] ) )
trg = A の末尾に B の先頭の整数値 を追加する
rst = A の末尾に B の先頭の整数値 を追加する <eos>
768
src = A [ 3 ] = B
trg = B を A の 3 番目に する
rst = B を A の 3 番目に する <eos>
769
src = A . append ( 3 * A [ B ] + 1 )
trg = A の末尾に 3 に A の B 番目を掛けた値に 1 を加えた値 を追加する
rst = A の末尾に 3 に A の B 番目を掛けた値に 1 を加えた値 を追加する <eos>
770
src = print ( A [ 5 * B ] [ C ] )
trg = A の 5 に B を掛けた値番目の C 番目を出力する
rst = A の 5 に B を掛けた値番目の C 番目を出力する <eos>
771
src = A = { start : None }
trg = ( ( B , 未定値 )) からなる辞書を A とする
rst = ( < __ main __ . Cammaobjectat 0 x 10 a 1 e 7 0> ) の集合を A とする <eos>
772
src = B = C * D
trg = C に D を掛けた値を B とする
rst = C に D を掛けた値を B とする <eos>
773
src = print ( A , B . format ( C // 100 , C % 100 ) )
trg = A 、 B を書式として C を 100 で割った商 、 C を 100 で割った余り で整形した文字列を出力する
rst = A 、 B を書式として C を 100 で割った商 、 C を 100 で割った余り で整形した文字列を出力する <eos>
774
src = write ( A % B [ ( convert ( 2004 , C , D ) - convert ( 2004 , 1 , 1 ) + 3 ) % 7 ] )
trg = write ( A % B [ ( convert (2004, C , D ) - convert (2004, 1 ,1) +3) % 7 ] )
rst = write ( A % B % ( convert ( C , D ) , convert ( 1 50) の組 , ( 7 ] % E ) <eos>
775
src = A = ( B + C + D ) / 2
trg = B に C を加えた値に D を加えた値を 2 で割った値を A とする
rst = B に C を加えた値に D を加えた値を 2 で割った値を A とする <eos>
776
src = return [ A [ 4 ] , A [ 0 ] , A [ 2 ] , A [ 3 ] , A [ 5 ] , A [ 1 ] ]
trg = ( A の 4 番目 、 A の先頭 、 A の 2 番目 、 A の 3 番目 、 A の 5 番目 、 A の 1 番目 ) からなる列を返す
rst = ( A の 4 番目 、 A の先頭 、 A の 2 番目 、 A の 3 番目 、 A の 5 番目 、 A の 1 番目 ) からなる列を返す <eos>
777
src = print ( A [ B ] [ C ] , sep = '' , end = '' )
trg = 区 切りなしで改行せずに A の B 番目の C 番目を出力する
rst = 区 切りなしで改行せずに A の B 番目の C 番目を出力する <eos>
778
src = A [ B ] [ C // 2 + 1 ] |= 4
trg = A の B 番目の C を 2 で割った商に 1 を加えた値番目を 4 と の 論理和に する
rst = A の B 番目の C を 2 で割った商に 1 を加えた値番目を 4 と の 論理和に する <eos>
779
src = A = ( B ** 2 + B + 2 ) // 2
trg = B の 2 乗に B を加えた値に 2 を加えた値を 2 で割った商を A とする
rst = B の 2 乗に B を加えた値に 2 を加えた値を 2 で割った商を A とする <eos>
780
src = return search ( A , B , C , D , 0 )
trg = B 、 C 、 D 、0 に お いて正規表現 A が最初にマッチする位置 を返す
rst = B 、 C 、 D 、0 に お いて正規表現 A が最初にマッチする位置 を返す <eos>
781
src = A += B * C - B * D
trg = A を B に C を掛けた値から B に D を掛けた値を引いた値 だけ 増 加 させ る
rst = A を B に C を掛けた値から B に D を掛けた値を引いた値 だけ 増 加 させ る <eos>
782
src = if A [ B ] . isdigit ( ) and A [ B + 1 ] . isdigit ( ) :
trg = A の B 番目が全て数字 かつ A の B に 1 を加えた値 番目が全て数字 のとき 、
rst = A の B 番目が全て数字 かつ A の B に 1 を加えた値番目のとき 、 <eos>
783
src = A = B [ 1 ] % B [ 2 ]
trg = B の 1 番目を B の 2 番目で割った余りを A とする
rst = B の 1 番目を B の 2 番目で割った余りを A とする <eos>
784
src = A = max ( A - B , 0 )
trg = A から B を引いた値 、0 の最大値を A とする
rst = A から B を引いた値 、0 の最大値を A とする <eos>
785
src = print ( dist ( 2 , A , B ) )
trg = 2 と A 、 B の ユ ー ク リ ッ ド距離 を出力する
rst = 2 と A 、 B の ユ ー ク リ ッ ド距離 を出力する <eos>
786
src = A += prod ( B )
trg = A を prod ( B ) だけ 増 加 させ る
rst = A を prod ( B )) だけ 増 加 させ る <eos>
787
src = A = B . flow ( 2 * C , 2 * C + 1 , C )
trg = B . flow (2* C ,2* C +1, C ) を A とする
rst = B . flow (2* C ,2* C +1,1) を A とする <eos>
788
src = A = inner_product ( B , C )
trg = inner _ product ( B , C ) を A とする
rst = inner _ product ( B , C ) を A とする <eos>
789
src = A , B = C [ D - E ]
trg = C の D から E を引いた値番目を展開し 、 それぞれ A 、 B とする
rst = C の D から E を引いた値番目を展開し 、 それぞれ A 、 B とする <eos>
790
src = if A >= 0 and A < 12 and B >= 0 and B < 12 :
trg = A が 0 以上かつ A が 12 より小さくかつ B が 0 以上かつ B が 12 より小さいとき 、
rst = A が 0 以上かつ A が 12 より小さくかつ B が 0 以上かつ B が 12 より小さいとき 、 <eos>
791
src = [ print ( A [ B ] ) for B in range ( C ) ]
trg = 0 から C 未満までの数列の各要素を B とし 、 A の B 番目を出力するの列
rst = 0 から C 未満までの数列の各要素を B とし 、 A の B 番目を出力するの列 <eos>
792
src = if A == False :
trg = A が 、 つまり偽 と等しいとき 、
rst = A が 、 つまり偽 と等しいとき 、 <eos>
793
src = A = ( B [ C ] - D + E , ( F [ C ] [ : - D ] if D else F [ C ] ) + G )
trg = ( B の C 番目から D を引いた値に E を加えた値 、 D のとき F の C 番目の 、 つまり先頭から - D 番目までの部分列 、 そうでなければ F の C 番目に G を加えた値 ) の組を A とする
rst = ( B の C 番目から D を引いた値に E を加えた値 、 F の 、 つまり先頭から D 番目までの部分列 ) の組 、 そうでなければ ( C に G を加えた値 ) の組を A とする <eos>
794
src = A . score = 0
trg = 0 を A の score に する
rst = 0 を A の score に する <eos>
795
src = A = Node ( 2 )
trg = Node (2) を A とする
rst = Node (2) を A とする <eos>
796
src = for A in range ( 25000 ) :
trg = 0 から 25000 未満までの数列を順に A として 、 繰り返 す
rst = 0 から 142 未満までの数列を順に A として 、 繰り返 す <eos>
797
src = if A >= B or C >= B or D >= B :
trg = A が B 以上または C が B 以上または D が B 以上のとき 、
rst = A が B 以上または C が B 以上または D が B 以上のとき 、 <eos>
798
src = A [ 0 ] [ B // 3 ] [ B % 3 ] = 1
trg = 1 を A の先頭の B を 3 で割った商番目の B を 3 で割った余り番目に する
rst = 1 を A の先頭の B を 3 で割った商番目の B を 3 で割った余り番目に する <eos>
799
src = for A in r ( B + 1 , l ( C ) ) [ : : - 1 ] :
trg = r ( B +1, l ( C )) の逆順 を順に A として 、 繰り返 す
rst = r ( B +1, C ) の 、 つまり先頭から - C 番目までの部分列 の各要素に整数を適用した列の総和 未満までの数列を順に A として 、 繰り返 す <eos>
800
src = A . append ( query ( B [ 0 ] , B [ 1 ] + 1 ) )
trg = A の末尾に query ( B [0], B [1]+1) を追加する
rst = A の末尾に query ( B [0], B [1]) に 1 を加えた値 を追加する <eos>
801
src = return A . values [ B - 1 ] [ C - 1 ]
trg = A の値の集まりの B から 1 を引いた値番目の C から 1 を引いた値番目を返す
rst = A の値の集まりの B から 1 を引いた値番目の C から 1 を引いた値番目を返す <eos>
802
src = A = [ read ( ) for B in range ( C - 1 ) ]
trg = 0 から C から 1 を引いた値 未満までの数列の各要素を B とし 、 read () の列を A とする
rst = 0 から C から 1 を引いた値 未満までの数列の各要素を B とし 、 read () の列を A とする <eos>
803
src = A [ B ] , A [ C + D ] = A [ C + D ] , A [ B ]
trg = A の C に D を加えた値番目 、 A の B 番目を A の B 番目 、 A の C に D を加えた値番目とする
rst = A の C に D を加えた値番目 、 A の B 番目を A の B 番目 、 A の C に D を加えた値番目とする <eos>
804
src = A = B + C - 1
trg = B に C を加えた値から 1 を引いた値を A とする
rst = B に C を加えた値から 1 を引いた値を A とする <eos>
805
src = A [ B - C ] += 2
trg = A の B から C を引いた値番目を 2 だけ 増 加 させ る
rst = A の B から C を引いた値番目を 2 だけ 増 加 させ る <eos>
806
src = A = [ [ 0 for B in range ( 3 ) ] for C in range ( 101 ) ]
trg = 0 から 101 未満までの数列の各要素を C とし 、0 から 3 未満までの数列の各要素を B とし 、0 の列の列を A とする
rst = 0 から 101 未満までの数列の各要素を C とし 、0 から 3 未満までの数列の各要素を B とし 、0 の列の列を A とする <eos>
807
src = A [ B + C * D ] . append ( ( E + C * D , F ) )
trg = A の B に C に D を掛けた値を加えた値番目の末尾に ( E に C に D を掛けた値を加えた値 、 F ) の組 を追加する
rst = A の B に C に D を掛けた値を加えた値番目の末尾に ( E に C に D を掛けた値を加えた値 、 F ) の組 を追加する <eos>
808
src = if A . _find ( B ) != A . _find ( C ) :
trg = A ._ find ( B ) が A ._ find ( C ) と等しくないとき 、
rst = A ._ find ( B ) が A ._ find ( C ) と等しくないとき 、 <eos>
809
src = if A [ B + C ] [ D + E ] == 3 :
trg = A の B に C を加えた値番目の D に E を加えた値番目が 3 と等しいとき 、
rst = A の B に C を加えた値番目の D に E を加えた値番目が 3 と等しいとき 、 <eos>
810
src = print ( ( A ** B ) % ( pow ( 10 , 9 ) + 7 ) )
trg = A の B 乗を 10 の 9 乗に 7 を加えた値 で割った余りを出力する
rst = A の B 乗を 10 の 9 乗に 7 を加えた値 で割った余りを出力する <eos>
811
src = A = calc_a ( B [ C ] )
trg = calc _ a ( B [ C ] ) を A とする
rst = <unk> ( B [ C ] ) を A とする <eos>
812
src = time [ A : B ] = [ 1 ] * ( B - A )
trg = (1) からなる列の B から A を引いた値回分の列を time の A 番目から B 番目までの部分列に する
rst = (1) からなる列の B から A を引いた値回分の列を time の A 番目から B 番目までの部分列に する <eos>
813
src = A [ 1 ] = B [ C ] [ D ] [ 1 ] - B [ E - 1 ] [ D ] [ 1 ] - B [ C ] [ F - 1 ] [ 1 ] + B [ E - 1 ] [ F - 1 ] [ 1 ]
trg = B [ C ] の D 番目の 1 番目から B [ E -1 ] の D 番目の 1 番目を引いた値から B の C 番目の F から 1 を引いた値番目の 1 番目を引いた値に B の E から 1 を引いた値番目の F から 1 を引いた値番目の 1 番目を加えた値を A の 1 番目に する
rst = B の C 番目の D 番目の 1 番目から B の E -1 番目の D 番目の 1 を引いた値番目を引いた値から F の B -1 番目の 1 番目を引いた値に 1 を加えた値番目の C から 1 を引いた値番目の F から 1 を引いた値番目を加えた値を A の 1 番目に する <eos>
814
src = for A , B in C [ : : - 1 ] :
trg = C の逆順 を順に A 、 B として 、 繰り返 す
rst = C の逆順 を順に A 、 B として 、 繰り返 す <eos>
815
src = A = bisect . bisect_left ( B , C [ 0 ] )
trg = ソートされた順序を保ったまま C の先頭を B に挿入できる位置を A とする
rst = ソートされた順序を保ったまま C の先頭を B に挿入できる位置を A とする <eos>
816
src = A [ B ] [ C ] = ( A [ B ] [ C ] + A [ B - 1 ] [ C ] * C + A [ B - 1 ] [ C - 1 ] ) % D
trg = A の B 番目の C 番目に A [ B -1 ] の C 番目に C を掛けた値を加えた値に A の B から 1 を引いた値番目の C から 1 を引いた値番目を加えた値を D で割った余りを A の B 番目の C 番目に する
rst = A の B 番目の C 番目に A の B -1 番目の C に 1 を加えた値番目を加えた値を C で割った余りを A の B 番目の C 番目に する <eos>
817
src = A = B [ C [ 0 ] ]
trg = B の C の先頭番目を A とする
rst = B の C の先頭の先頭番目を A とする <eos>
818
src = return add ( A . x * B . x , A . y * B . y )
trg = add ( A . x * B . x , A . y * B . y ) を返す
rst = add ( A . x * B . x , A . y * B ) を返す <eos>
819
src = A . append ( B [ 0 ] [ C ] )
trg = A の末尾に B の先頭の C 番目を追加する
rst = A の末尾に B の先頭の C 番目を追加する <eos>
820
src = return A . format ( B . x , B . y )
trg = A を書式として B の x 座標 、 B の y 座標で整形した文字列 を返す
rst = A を書式として B の x 座標 、 B の y 座標で整形した文字列 を返す <eos>
821
src = A = '' . join ( B ) . split ( C )
trg = 空文字列を間に入れて B を連結した文字列を C で分割した字句列を A とする
rst = 空文字列を間に入れて B を連結した文字列 を A とする <eos>
822
src = A . append ( [ int ( B ) for B in input ( ) . split ( C ) ] )
trg = A の末尾に入力された文字列を C で分割した字句列の各要素を B とし 、 B の整数値の列 を追加する
rst = A の末尾に入力された文字列 を空白で分割した字句列の各要素を B とし 、 B の整数値の列 を追加する <eos>
823
src = A = dist2 ( B , C ) ** .5
trg = dist 2( B , C ) の .5 乗を A とする
rst = dist 2( B , C ) の .5 乗を A とする <eos>
824
src = A [ B ] = D [ C [ B ] ] if C [ B ] != - 1 else - 1
trg = C の B 番目が -1 と等しくないとき D の C の B 番目番目 、 そうでなければ -1 を A の B 番目に する
rst = C の B 番目が -1 と等しくないとき D の C の B 番目番目 、 そうでなければ -1 を A の B 番目に する <eos>
825
src = if ( check ( A [ B ] ) == True ) or ( check ( rev ( A [ B ] ) ) == True ) :
trg = check ( A [ B ] ) が 、 つまり真 と等しくまたは check ( rev ( A [ B ])) が 、 つまり真と等しいとき 、
rst = check ( A [ B ] ) が 、 つまり真と等しいとき 、 <eos>
826
src = A [ B ] [ C ] [ D ] [ E + 1 ] = 0
trg = 0 を A の B 番目の C 番目の D 番目の E に 1 を加えた値番目に する
rst = 0 を A の B 番目の C 番目の D 番目の E に 1 を加えた値番目に する <eos>
827
src = if A . match [ B ] is not None :
trg = A の match の B 番目が 、 つまり未定値と等しいとき 、
rst = A の match の B 番目が 、 つまり未定値と等しいとき 、 <eos>
828
src = D = C % 2
trg = C を 2 で割った余りを D とする
rst = C を 2 で割った余りを D とする <eos>
829
src = A [ 0 ] . add ( B )
trg = A の先頭に B を追加した集まり
rst = A の先頭に B を追加した集まり <eos>
830
src = A = B [ C ] + e [ C ] [ D ] [ 1 ]
trg = B の C 番目にネイピア数の C 番目の D 番目の 1 番目を加えた値を A とする
rst = B の C 番目に ネイピア数の C 番目の D 番目の 1 番目を加えた値を A とする <eos>
831
src = A , B = divmod ( ( C [ 2 ] + C [ 4 ] + C [ 6 ] + C [ 8 ] ) , 60 )
trg = C の 2 番目に C の 4 番目を加えた値に C の 6 番目を加えた値に C の 8 番目を加えた値と 60 を 割った ときの ( 商を展開し 、 それぞれ A 、 B とする
rst = C の 2 番目に C の 4 番目を加えた値に C の 6 番目を加えた値 、 C の 8 番目に 60 を加えた値を A 、 B とする <eos>
832
src = print ( A . format ( B , C , D , E ) )
trg = A を書式として B 、 C 、 D 、 E で整形した文字列を出力する
rst = A を書式として B 、 C 、 D 、 E で整形した文字列を出力する <eos>
833
src = A = A % 500
trg = A を 500 で割った余りを A とする
rst = A を 500 で割った余りを A とする <eos>
834
src = A %= 25
trg = A を 25 で割った余りに する
rst = A を 25 で割った余りに する <eos>
835
src = print ( int ( A & B == B ) )
trg = A と B の論理積が B と等しいかどうかの整数値 を出力する
rst = A と B の論理積が B と等しいとき 、 <eos>
836
src = A = expose ( B )
trg = expose ( B ) を A とする
rst = <unk> ( B ) を A とする <eos>
837
src = for A in range ( 1 , B ) [ : : - 1 ] :
trg = 1 から B 未満までの数列の逆順 を順に A として 、 繰り返 す
rst = 1 から B 未満までの数列の逆順 を順に A として 、 繰り返 す <eos>
838
src = A = Point ( B . y / C , - B . x / C ) * D
trg = Point ( B . y / C , - B . x / C ) に D を掛けた値を A とする
rst = Point ( B . y / C , - B . x / C * D ) を A とする <eos>
839
src = if A [ B ] != A [ len ( A ) - B - 1 ] :
trg = A の B 番目が A の A の長さから B を引いた値から 1 を引いた値番目 と等しくないとき 、
rst = A の B 番目が A の A の長さから B を引いた値から 1 を引いた値番目 と等しくないとき 、 <eos>
840
src = A = '' . join ( map ( str , B ) )
trg = 空文字列を間に入れて B の各要素に整数を適用した列 を連結した文字列を A とする
rst = 空文字列を間に入れて B の各要素に整数を適用した列 を連結した文字列を A とする <eos>
841
src = if sum ( time [ A : B ] ) == 0 :
trg = time の A 番目から B 番目までの部分列の総和が 0 と等しいとき 、
rst = time の A 番目から B 番目までの部分列の総和が 0 と等しいとき 、 <eos>
842
src = if A . value == B :
trg = A の value が B と等しいとき 、
rst = A の value が B と等しいとき 、 <eos>
843
src = ( A , B ) = bubble_sort ( C )
trg = bubble _ sort ( C ) を ( A 、 B ) の組 とする
rst = bubble _ sort ( C ) を展開し 、 それぞれ ( A 、 B ) の組 とする <eos>
844
src = A , B = list ( map ( C , input ( ) . split ( ) ) )
trg = 入力された文字列 を空白で分割した字句列の各要素に C を適用した列のリストを展開し 、 それぞれ A 、 B とする
rst = 入力された文字列 を空白で分割した字句列の各要素に C を適用した列を展開し 、 それぞれ A 、 B とする <eos>
845
src = if figure_in_board ( A , B ) :
trg = figure _ in _ board ( A , B ) のとき 、
rst = <unk> ( A , B ) のとき 、 <eos>
846
src = if A [ 3 ] :
trg = A の 3 番目のとき 、
rst = A の 3 番目のとき 、 <eos>
847
src = A = fib ( B - 1 )
trg = fib ( B -1) を A とする
rst = fib ( B -1) を A とする <eos>
848
src = A [ B ] [ 0 ] = B + 1
trg = B に 1 を加えた値を A の B 番目の 0 番目に する
rst = B に 1 を加えた値を A の B 番目の 0 番目に する <eos>
849
src = koch ( A , ( B , C ) , ( D , E ) )
trg = koch ( A , ( B , C ),( D , E ))
rst = koch ( A , ( B , C ),( D , E )) <eos>
850
src = A += int ( B [ C ] ) * ( C + 1 )
trg = A を B の C 番目の整数値に C に 1 を加えた値を掛けた値だけ 増 加 させ る
rst = A を B の C 番目の整数値に C に 1 を加えた値を掛けた値だけ 増 加 させ る <eos>
851
src = return ( A - B ) ** 2 + ( C - D ) ** 2 <= ( E + F ) ** 2
trg = A から B を引いた値の 2 乗に C から D を引いた値の 2 乗を加えた値が E に F を加えた値 の 2 乗 以下かどうかを返す
rst = A から B を引いた値の 2 乗に C から D を引いた値の 2 乗を加えた値が E に F を加えた値 の 2 乗 を返す <eos>
852
src = print ( C ) if A > B else print ( D )
trg = A が B より大きいとき C を出力する 、 そうでなければ D を出力する
rst = A が B より大きいとき C 、 そうでなければ D を出力する <eos>
853
src = if ( A - 1 , B , C ) in D :
trg = ( A から 1 を引いた値 、 B 、 C ) の組が D に含まれるとき 、
rst = ( A から 1 を引いた値 、 B 、 C ) の組が D に含まれるとき 、 <eos>
854
src = A |= { B }
trg = A を ( < __ main __ . Cammaobjectat 0 x 10 a 10 ed 9 0> ) の集合と の 論理和に する
rst = A を ( < __ main __ . Cammaobjectat 0 x 10 a 10 <unk> 0> ) の集合と の 論理和に する <eos>
855
src = A += B . value [ C ]
trg = A を B の value の C 番目だけ 増 加 させ る
rst = A を B の value の C 番目だけ 増 加 させ る <eos>
856
src = if A + 1 < B and C [ D * 2 ] [ A ] == 0 and E [ D ] [ A + 1 ] > F + 1 :
trg = A に 1 を加えた値が B より小さくかつ C の D *2 番目の A 番目が 0 と等しくかつ E の D 番目の A に 1 を加えた値番目が F に 1 を加えた値 より大きいとき 、
rst = A に 1 を加えた値が B より小さくかつ C の D *2+1 番目の A 番目が 0 と等しくかつ E の D 番目の A に 1 を加えた値番目が F より大きいとき 、 <eos>
857
src = A += B [ C ] * D [ E ] * F [ E ] % G
trg = A を B の C 番目に D の E 番目を掛けた値に F の E 番目を掛けた値を G で割った余りだけ 増 加 させ る
rst = A を B の C 番目に D の E 番目を掛けた値に F の E 番目を掛けた値を G で割った余りだけ 増 加 させ る <eos>
858
src = print ( levenshtein_distance ( A , B ) )
trg = levenshtein _ distance ( A , B ) を出力する
rst = <unk> ( A , B ) を出力する <eos>
859
src = A [ B ] [ C ] = max ( A [ B - 1 ] [ C ] , A [ B ] [ C - D [ B ] [ 1 ] ] + D [ B ] [ 0 ] )
trg = A の B から 1 を引いた値番目の C 番目 、 A の B 番目の C から D [ B ] の 1 番目を引いた値番目に D の B 番目の先頭 を加えた値の最大値を A の B 番目の C 番目に する
rst = A の B から 1 を引いた値番目の C 番目 、 A の B 番目の C から D の B 番目を引いた値番目に D の B 番目の先頭 を加えた値の最大値を A の B 番目の C 番目に する <eos>
860
src = A . size *= 2
trg = A の size を 2 倍 に する
rst = A の size を 2 倍 に する <eos>
861
src = A . append ( B [ C [ D ] ] )
trg = A の末尾に B の C の D 番目 番目を追加する
rst = A の末尾に B の C の D 番目を追加する <eos>
862
src = A [ 5 ] = copy [ 1 ]
trg = copy の 1 番目を A の 5 番目に する
rst = copy の 1 番目を A の 5 番目に する <eos>
863
src = for A in B [ : - 1 ] :
trg = B の末尾を除いた部分列 を順に A として 、 繰り返 す
rst = B の末尾を除いた部分列 を順に A として 、 繰り返 す <eos>
864
src = print ( A [ B ] [ C ] , end = '' )
trg = 改行せずに A の B 番目の C 番目を出力する
rst = 改行せずに A の B 番目の C 番目を出力する <eos>
865
src = A , B = C [ D ] [ E - 1 ]
trg = C の D 番目の E から 1 を引いた値番目を展開し 、 それぞれ A 、 B とする
rst = C の D 番目の E から 1 を引いた値番目を展開し 、 それぞれ A 、 B とする <eos>
866
src = time += A [ 0 ]
trg = time を A の先頭だけ 増 加 させ る
rst = time を A の先頭だけ 増 加 させ る <eos>
867
src = A [ B ] = C [ B - 1 ] + 1
trg = C の B から 1 を引いた値番目に 1 を加えた値を A の B 番目に する
rst = C の B から 1 を引いた値番目に 1 を加えた値を A の B 番目に する <eos>
868
src = if A < B and C [ A ] == D :
trg = A が B より小さくかつ C の A 番目が D と等しいとき 、
rst = A が B より小さくかつ C の A 番目が D と等しいとき 、 <eos>
869
src = A . contents . append ( A . pages [ B ] )
trg = A の contents の末尾に A の pages の B 番目を追加する
rst = A の contents の末尾に A の pages の B 番目を追加する <eos>
870
src = A = list ( [ list ( map ( int , input ( ) . split ( ) ) ) for B in range ( C ) ] )
trg = 0 から C 未満までの数列の各要素を B とし 、 input () を空白で分割した字句列の各要素に 整数を適用した列のリストの列 のリストを A とする
rst = 0 から C 未満までの数列の各要素を B とし 、 、 つまり入力された文字列 を空白で分割した字句列の各要素に 整数を適用した列のリストの列を A とする <eos>
871
src = A , B = C . bottomright
trg = C の bottomright を展開し 、 それぞれ A 、 B とする
rst = C の <unk> を展開し 、 それぞれ A 、 B とする <eos>
872
src = while A [ B + 1 ] == 1 and B < 999999 :
trg = A の B に 1 を加えた値番目が 1 と等しくかつ B が 999999 より小さい 間 、 次 を 繰り返 す
rst = A の B に 1 を加えた値番目が 1 と等しくかつ B が 999999 より小さい 間 、 次 を 繰り返 す <eos>
873
src = for A in range ( min ( len ( B ) , len ( C ) ) ) :
trg = 0 から B の長さ 、 C の長さの最小値 未満までの数列を順に A として 、 繰り返 す
rst = 0 から B の長さ未満までの数列 、 C の長さの最小値 未満までの数列を順に A として 、 繰り返 す <eos>
874
src = A += ( B [ C ] == D - 1 ) + ( E [ C ] == F - 1 ) + ( G [ C ] == H - 1 ) + ( B [ C ] == 0 ) + ( E [ C ] == 0 ) + ( G [ C ] == 0 )
trg = A を ( B [ C ] == D -1) に ( E [ C ] == F -1) を加えた値に G [ C ] が H -1 と等しいかどうかを加えた値に B の C 番目が 0 と等しいかどうかを加えた値に E の C 番目が 0 と等しいかどうかを加えた値に G の C 番目が 0 と等しいかどうか を加えた値だけ 増 加 させ る
rst = A を B の C 番目が D から 1 を引いた値で割った値に E を加えた値に F [ C ] の 0 番目が G と等しいかどうかを加えた値に H が C の E から 1 を引いた値と等しくかつ B の C に 1 を加えた値番目が 0 と等しいかどうか を加えた値だけ 増 加 させ る <eos>
875
src = while A and A [ - 1 ] == B :
trg = A かつ A の -1 番目が B と等しい 間 、 次 を 繰り返 す
rst = A かつ A の末尾が B と等しい 間 、 次 を 繰り返 す <eos>
876
src = if A [ B ] != A [ - B - 1 ] :
trg = A の B 番目が A の - B から 1 を引いた値番目 と等しくないとき 、
rst = A の B 番目が A の - B から 1 を引いた値番目 と等しくないとき 、 <eos>
877
src = A = B . find ( A )
trg = B の先頭から A を探して見つかった位置を A とする
rst = B の先頭から A を探して見つかった位置を A とする <eos>
878
src = print ( A * B , ( A + B ) << 1 )
trg = A に B を掛けた値 、 A に B を加えた値を 1 だけ左シフトした値 を出力する
rst = A に B を掛けた値 、 A に B を加えた値を 1 だけ右シフトした値 を出力する <eos>
879
src = if A [ B ] == 1 :
trg = A の B 番目が 1 と等しいとき 、
rst = A の B 番目が 1 と等しいとき 、 <eos>
880
src = A . root = A . Node ( B )
trg = A . Node ( B ) を A の root に する
rst = A . Node ( B ) を A の root に する <eos>
881
src = return 2 * A + 2 * B - C
trg = 2 に A を掛けた値に 2 に B を掛けた値を加えた値から C を引いた値を返す
rst = 2 に A を掛けた値に 2 に B を掛けた値を加えた値から C を引いた値を返す <eos>
882
src = print ( A if len ( str ( A ) ) <= 80 else B )
trg = A の文字列の長さが 80 以下のとき A 、 そうでなければ B を出力する
rst = A の長さが 80 以下のとき A 、 そうでなければ B を出力する <eos>
883
src = if ( A + B ) % 2 == 0 :
trg = A に B を加えた値を 2 で割った余りが 0 と等しいとき 、
rst = A に B を加えた値を 2 で割った余りが 0 と等しいとき 、 <eos>
884
src = A . color = B . color
trg = B の color を A の color に する
rst = B の color を A の color に する <eos>
885
src = A += B + C . rstrip ( ) + B
trg = A を B に C の末尾から 空白改行を取り除いた文字列 を加えた値に B を加えた値だけ 増 加 させ る
rst = A を B に C から読み込んだ一行の末尾 から空白改行を取り除いた文字列 を加えた値に B を加えた値だけ 増 加 させ る <eos>
886
src = A = [ int ( B . readline ( ) ) for C in range ( D - 1 ) ]
trg = 0 から D から 1 を引いた値 未満までの数列の各要素を C とし 、 B から読み込んだ一行の整数値の列を A とする
rst = 0 から D から 1 を引いた値 未満までの数列の各要素を C とし 、 B から読み込んだ一行 の整数値の列を A とする <eos>
887
src = A = B [ C ] [ 0 ] - D [ - E - 1 ] [ 0 ]
trg = B の C 番目の 0 番目から D の - E から 1 を引いた値番目の先頭 を引いた値を A とする
rst = B の C 番目の 0 番目から D の - E から 1 を引いた値番目の先頭 を A とする <eos>
888
src = print ( A [ B [ 0 ] [ 0 ] ] [ 1 ] )
trg = A の B の先頭の先頭 番目の 1 番目を出力する
rst = A の B の先頭の先頭 番目の 1 番目を出力する <eos>
889
src = if cross3 ( A , B , C ) < 0 :
trg = cross 3( A , B , C ) が 0 より小さいとき 、
rst = cross 3( A , B , C ) が 0 より小さいとき 、 <eos>
890
src = while A != B :
trg = A が B と等しくない 間 、 次 を 繰り返 す
rst = A が B と等しくない 間 、 次 を 繰り返 す <eos>
891
src = print ( A [ - ( B + 1 ) ] , end = ' ' )
trg = 空白文字を 代わ りの行末として A の - B に 1 を加えた値番目 を出力する
rst = 空白文字を 代わ りの行末として A の - B に 1 を加えた値 番目を出力する <eos>
892
src = if A [ B ] [ C ] > 0 :
trg = A の B 番目の C 番目が 0 より大きいとき 、
rst = A の B 番目の C 番目が 0 より大きいとき 、 <eos>
893
src = print ( sum ( A ) // 60 )
trg = A の総和を 60 で割った商 を出力する
rst = A の総和を 60 で割った商 を出力する <eos>
894
src = A = B % 18
trg = B を 18 で割った余りを A とする
rst = B を 18 で割った余りを A とする <eos>
895
src = while ccw ( A [ - 1 ] , A [ - 2 ] , B ) :
trg = ccw ( A [-1], A [-2], B ) の 間 、 次 を 繰り返 す
rst = ccw ( A [-1], A [-2], B ) の 間 、 次 を 繰り返 す <eos>
896
src = A = [ [ [ - 1 ] * [ ( 1 << B ) for C in range ( B ) ] ] for D in range ( B ) ]
trg = 0 から B 未満までの数列の各要素を D とし 、 ( (-1) からなる列の 0 から B 未満までの数列の各要素を C とし 、 1 を B だけ左シフトした値 の列回分の列 ) からなる列の列を A とする
rst = 0 から B 未満までの数列の各要素を D とし 、 ( (-1) からなる列の 0 から B 未満までの数列の各要素を C とし 、 1 を B だけ左シフトした値 の列回分の列 ) からなる列の列を A とする <eos>
897
src = if len ( A [ B ] ) != 0 :
trg = A の B 番目の長さが 0 と等しくないとき 、
rst = A の B 番目の長さが 0 と等しくないとき 、 <eos>
898
src = A = sum ( list ( map ( int , input ( ) . split ( ) ) ) )
trg = 入力された文字列 を空白で分割した字句列の各要素に 整数を適用した列のリストの総和を A とする
rst = 入力された文字列 を空白で分割した字句列の各要素 に整数を適用した列のリストの総和 を A とする <eos>
899
src = while A * A <= B :
trg = A に A を掛けた値が B 以下の 間 、 次 を 繰り返 す
rst = A に A を掛けた値が B 以下の 間 、 次 を 繰り返 す <eos>
900
src = A = 2 + B + ( C + D )
trg = 2 に B を加えた値に C に D を加えた値を加えた値を A とする
rst = 2 に B を加えた値に C に D を加えた値を加えた値を A とする <eos>
901
src = A = [ set ( [ B ] ) , set ( [ C ] ) , set ( [ D ] ) , set ( [ B , C ] ) , set ( [ B , D ] ) , set ( [ C , D ] ) , set ( [ B , C , D ] ) ]
trg = ( ( B ) からなる列の集合 、 ( C ) からなる列の集合 、 ( D ) からなる列の集合 、 ( B 、 C ) からなる列の集合 、 ( B 、 D ) からなる列の集合 、 ( C 、 D ) からなる列の集合 、 ( B 、 C 、 D ) からなる列の集合 ) からなる列を A とする
rst = ( ( B ) からなる列 、 ( C ) からなる列 、 set ( D 、 B ) からなる列 、 ( D 、 つまり集合 、 C 、 B ) からなる列 、 ( D 、 B 、 C ) からなる列 、 ( D 、 つまり集合 、 B 、 集合 ) からなる列 、
902
src = if A is None or len ( A ) != 6 :
trg = A が 、 つまり未定値と等しくなくまたは A の長さが 6 と等しくないとき 、
rst = A が 、 つまり未定値と等しくなくまたは A の長さが 6 と等しくないとき 、 <eos>
903
src = A = sorted ( A . items ( ) , key = lambda A : A [ 1 ] )
trg = x をパラメータとして x の 1 番目を返す関数をキーとして A のキーと値の集まりをソートした列 を A とする
rst = x をパラメータとして x の 1 番目を返す関数をキーとして A のキーと値の集まりをソートした列 を A とする <eos>
904
src = A = 120 * 60 - ( B * 3600 + C * 60 + D )
trg = 120 に 60 を掛けた値から B に 3600 を掛けた値に C に 60 を掛けた値を加えた値に D を加えた値を引いた値を A とする
rst = 120 に 60 を掛けた値から B に 3600 を掛けた値に C に 60 を掛けた値を加えた値に D を加えた値を引いた値を A とする <eos>
905
src = kesu ( ( A [ 0 ] , A [ 1 ] - 1 ) , B , C , D + 1 )
trg = kesu ( ( A [0], A [1]-1) , B , C , D +1)
rst = kesu ( ( A [0], A <unk> , B , C , D +1) <eos>
906
src = write ( A % dfs ( 0 , B , 0 , 0 ) )
trg = write ( A % dfs (0, B ,0,0) )
rst = write ( A % dfs (0, B ,0) <eos>
907
src = A = [ int ( B ) for B in C . strip ( ) . split ( ) ]
trg = C の両端から 空白改行を取り除いた文字列 を空白で分割した字句列の各要素を B とし 、 B の整数値の列を A とする
rst = C の両端から 空白改行を取り除いた文字列 の各要素を B とし 、 B の整数値の列を A とする <eos>
908
src = if A < B :
trg = A が B より小さいとき 、
rst = A が B より小さいとき 、 <eos>
909
src = A = sys . stdin . read ( ) . split ( )
trg = sys の stdin から読み込んだ デ ータを空白で分割した字句列を A とする
rst = sys の stdin から読み込んだ デ ータを英小文字に変換した文字列を A とする <eos>
910
src = return A [ B ] [ C ] [ D ]
trg = A の B 番目の C 番目の D 番目を返す
rst = A の B 番目の C 番目の D 番目を返す <eos>
911
src = write ( A % ( sum ( [ B * C for B , C in zip ( D , E ) ] ) % 10 ) )
trg = write ( A %( sum ([ B * CforB , Cinzip ( D , E )])% 10 ))
rst = write ( A %( '\ n '. join ([ B * C , D <unk> ( E ) forCinrange ( D ])) <eos>
912
src = A , B , C , D = E [ F ] , G [ F ] , E [ H ] , G [ H ]
trg = E の F 番目 、 G の F 番目 、 E の H 番目 、 G の H 番目を A 、 B 、 C 、 D とする
rst = E の F 番目 、 G の H 番目 、 E の H 番目 、 G の H 番目を A 、 B 、 C 、 D とする <eos>
913
src = A = [ int ( B ) for B in input ( ) . strip ( ) ]
trg = 入力された文字列の両端から 空白改行を取り除いた文字列 の各要素を B とし 、 B の整数値の列を A とする
rst = 入力された文字列の両端から 空白改行を取り除いた文字列 の各要素を B とし 、 B の整数値の列を A とする <eos>
914
src = A = DiGraph ( B )
trg = DiGraph ( B ) を A とする
rst = <unk> ( B ) を A とする <eos>
915
src = A . coordinates_ = [ ( [ B for C , B , C in D ] , D ) for D in E ]
trg = E の各要素を D とし 、 ( D の各要素を C 、 B 、 C とし 、 B の列 、 D ) の組の列を A の coordinates _ に する
rst = E の各要素を D とし 、 D の各要素を C 、 B 、 B とし 、 B の列 の集合の論理和を A の <unk> に する <eos>
916
src = A = B - 2
trg = B から 2 を引いた値を A とする
rst = B から 2 を引いた値を A とする <eos>
917
src = print ( A [ B ] . name , end = '' )
trg = 改行せずに A の B 番目の name を出力する
rst = 改行せずに A の B 番目の name を出力する <eos>
918
src = A = 135 * math . pi / 180
trg = 135 に円周率を掛けた値を 180 で割った値を A とする
rst = <unk> に円周率を掛けた値を A とする <eos>
919
src = A [ int ( input ( ) ) - 1 ] = 1
trg = 1 を A の 、 つまり入力された文字列の整数値 から 1 を引いた値番目に する
rst = 1 を A の 、 つまり入力された文字列の整数値 から 1 を引いた値番目に する <eos>
920
src = if len ( A ) < 6 and int ( A , 2 ) == 0 :
trg = A の長さが 6 より小さくかつ 2 進 表 記 A の整数値が 0 と等しいとき 、
rst = A の長さが 6 より小さくかつ ( A 、2) の組 と等しいとき 、 <eos>
921
src = if A != B // 2 :
trg = A が B を 2 で割った商 と等しくないとき 、
rst = A が B を 2 で割った商 と等しくないとき 、 <eos>
922
src = if list ( A ) == B :
trg = A のリスト が B と等しいとき 、
rst = A が B と等しいとき 、 <eos>
923
src = if collision ( A , B , C , D ) :
trg = collision ( A , B , C , D ) のとき 、
rst = is _ match ( A , B , C , D ) のとき 、 <eos>
924
src = for A in range ( B // 2 - 1 ) :
trg = 0 から B を 2 で割った商から 1 を引いた値未満までの数列を順に A として 、 繰り返 す
rst = 0 から B を 2 で割った商から 1 を引いた値未満までの数列を順に A として 、 繰り返 す <eos>
925
src = print ( A [ int ( B [ 1 ] ) ] )
trg = A の B の 1 番目の整数値番目 を出力する
rst = A の B の 1 番目の整数値番目 を出力する <eos>
926
src = A = A [ : int ( B [ 1 ] ) ] + '' . join ( list ( reversed ( A [ int ( B [ 1 ] ) : int ( B [ 2 ] ) + 1 ] ) ) ) + A [ int ( B [ 2 ] ) + 1 : ]
trg = A の 、 つまり先頭から B の 1 番目の整数値までの部分列に 空文字列を間に入れて A [ int ( B [1]) : int ( B [2]) +1] を反転した列のリスト を連結した文字列を加えた値 に A の B の 2 番目の整数値に 1 を加えた値から 、 つまり末尾までの部分列を加えた値 を A とする
rst = A の 、 つまり先頭から B の 1 番目の整数値までの部分列に 2 を加えた値までの部分列の整数値 から B の 1 番目から 、 つまり末尾までの部分列の整数値 番目を加えた値に B の 1 番目の整数値に 1 を加えた値を A とする <eos>
927
src = A = f ( A , B )
trg = f ( A , B ) を A とする
rst = f ( A , B ) を A とする <eos>
928
src = A [ triangle ( B , C , D ) ] += 1
trg = A の triangle ( B , C , D ) 番目を 1 だけ 増 加 させ る
rst = A の triangle ( B , C , D ) 番目を 1 だけ 増 加 させ る <eos>
929
src = A = HeavyLightDecomposition ( B )
trg = HeavyLightDecomposition ( B ) を A とする
rst = <unk> ( B ) を A とする <eos>
930
src = A . append ( ( B , C , D if C else 0 ) )
trg = A の末尾に ( B 、 C 、 C のとき D 、 そうでなければ 0 ) の組 を追加する
rst = A の末尾に ( B 、 C 、 D のとき D 、 そうでなければ 0 ) の組 を追加する <eos>
931
src = print ( min ( A , B , C ) + min ( D , E ) - 50 )
trg = A 、 B 、 C の最小値に D 、 E の最小値 を加えた値から 50 を引いた値 を出力する
rst = A 、 B 、 C の最小値に D 、 E から 50 を引いた値の最小値 を出力する <eos>
932
src = A = ( B - C ) * ( D - e ) / ( E - e ) + C
trg = B から C を引いた値に D から 、 つまりネイピア数 を引いた値を掛けた値を E から 、 つまりネイピア数 を引いた値で割った値に C を加えた値を A とする
rst = B から C を引いた値に D から 、 つまりネイピア数を引いた値を E から 、 つまりネイピア数を引いた値に C を加えた値を掛けた値を 4 で割った値を加えた値を A とする <eos>
933
src = A = PuzzleState ( B . state , depth = B . depth + 1 )
trg = PuzzleState ( B . state , depth = B . depth +1) を A とする
rst = depth _ search ( B . depth , B . depth ) を A とする <eos>
934
src = del A [ : B + C ]
trg = A の 、 つまり先頭から B に C を加えた値までの部分列を 削 除 する
rst = A の 、 つまり先頭から B に C を加えた値までの部分列を 削 除 する <eos>
935
src = for A in range ( B . __leng ) :
trg = 0 から B の __ leng 未満までの数列を順に A として 、 繰り返 す
rst = 0 から B の <unk> 未満までの数列を順に A として 、 繰り返 す <eos>
936
src = reconstruct ( A [ 1 : B + 1 ] , C [ : B ] , D )
trg = reconstruct ( A [1: B +1], C [ : B ] , D )
rst = reconstruct ( A [1:], B +1, C [ B ] , D ) <eos>
937
src = A . suffix ( )
trg = A . suffix ()
rst = A . dice _ s () <eos>
938
src = if A [ B ] > 1 :
trg = A の B 番目が 1 より大きいとき 、
rst = A の B 番目が 1 より大きいとき 、 <eos>
939
src = print ( A % ( B [ C ] , D ) , end = '' )
trg = 改行せずに A を ( B の C 番目 、 D ) の組で割った余り を出力する
rst = 改行せずに A を ( B の C 番目 、 D ) の組で割った余り を出力する <eos>
940
src = A = B + C * D
trg = B に C に D を掛けた値を加えた値を A とする
rst = B に C に D を掛けた値を加えた値を A とする <eos>
941
src = for A in range ( 1 , B * 2 ) :
trg = 1 から B に 2 を掛けた値 未満までの数列を順に A として 、 繰り返 す
rst = 1 から B に 2 を掛けた値 未満までの数列を順に A として 、 繰り返 す <eos>
942
src = A = dfs ( B , C )
trg = dfs ( B , C ) を A とする
rst = dfs ( B , C ) を A とする <eos>
943
src = A [ B + 1 ] = 1
trg = 1 を A の B に 1 を加えた値番目に する
rst = 1 を A の B に 1 を加えた値番目に する <eos>
944
src = for A in range ( 5 , 0 , - 1 ) :
trg = 5 から 0 未満までの -1 間隔の数列を順に A として 、 繰り返 す
rst = 5 から 0 未満までの -1 間隔の数列を順に A として 、 繰り返 す <eos>
945
src = A . t = B * 60 + C
trg = B に 60 を掛けた値に C を加えた値を A の t に する
rst = B に 60 を掛けた値に C を加えた値を A の t に する <eos>
946
src = A . minSpanningTree . append ( ( B , C , D ) )
trg = A の minSpanningTree の末尾に ( B 、 C 、 D ) の組 を追加する
rst = A の minSpanningTree の末尾に ( B 、 C 、 D ) の組 を追加する <eos>
947
src = A = ( B - C ) * ( D - E ) / ( F - E ) + C
trg = B から C を引いた値に D から E を引いた値を掛けた値を F から E を引いた値で割った値に C を加えた値を A とする
rst = B から C を引いた値に D から E を引いた値を掛けた値を F から E を引いた値で割った値に C を加えた値を A とする <eos>
948
src = A . sort ( key = lambda B : B [ 0 ] , reverse = True )
trg = x をパラメータとして x の先頭を返す関数を key として逆順に A をソート する
rst = x をパラメータとして x の先頭を返す関数を key として逆順に A をソート する <eos>
949
src = print ( A . format ( B . get_east_value ( ) ) )
trg = A を書式として B . get _ east _ value () で整形した文字列を出力する
rst = A を書式として B . get _ east _ value () で整形した文字列を出力する <eos>
950
src = counting_sort ( A , B , max ( A ) )
trg = counting _ sort ( A , B , max ( A ))
rst = counting _ sort ( A , B , max ( A ) , max ( A ) ) <eos>
951
src = A [ B ] = C = C * B % D
trg = C に B を掛けた値を D で割った余りを C とする を A の B 番目に する
rst = C に B を掛けた値を D で割った余りを C とする を A の B 番目に する <eos>
952
src = A //= 60
trg = A を 60 分の 一 に する
rst = A を 60 分の 一 に する <eos>
953
src = e [ 1 ] = 1
trg = 1 をネイピア数の 1 番目に する
rst = 1 をネイピア数の 1 番目に する <eos>
954
src = A = ( B * C - D * E ) ** 2 + ( D * F - G * C ) ** 2 + ( G * E - B * F ) ** 2
trg = B に C を掛けた値から D に E を掛けた値を引いた値の 2 乗に D に F を掛けた値から G に C を掛けた値を引いた値の 2 乗を加えた値に G に E を掛けた値から B に F を掛けた値を引いた値の 2 乗を加えた値を A とする
rst = B に C を掛けた値から D に E を掛けた値を引いた値の 2 乗に D に F を掛けた値から C に G を掛けた値を引いた値の 2 乗を加えた値に E を掛けた値から B に F を掛けた値を引いた値の 2 乗を引いた値を A とする <eos>
955
src = A = B % 12
trg = B を 12 で割った余りを A とする
rst = B を 12 で割った余りを A とする <eos>
956
src = return set ( A )
trg = A の集合 を返す
rst = A の集合 を返す <eos>
957
src = print ( B if rec ( 0 , 0 ) <= A else C )
trg = rec (0,0) が A 以下のとき B 、 そうでなければ C を出力する
rst = rec (0,0) が A 以下のとき B 、 そうでなければ C を出力する <eos>
958
src = A = calc ( B , 0 )
trg = calc ( B ,0) を A とする
rst = calc ( B ,0) を A とする <eos>
959
src = if A [ 0 ] > A [ 2 ] :
trg = A の先頭が A の 2 番目より大きいとき 、
rst = A の先頭が A の 2 番目より大きいとき 、 <eos>
960
src = A = float ( A [ - 1 ] )
trg = A の末尾 の浮動小数点数を A とする
rst = A の末尾 の浮動小数点数を A とする <eos>
961
src = A = [ [ B [ C ] + ( D [ C ] + D [ C + 1 ] ) * 2 for C in range ( E ) ] ]
trg = ( 0 から E 未満までの数列の各要素を C とし 、 B の C 番目に D [ C ] に D [ C +1] を加えた値に 2 を掛けた値を加えた値の列 ) からなる列を A とする
rst = 0 から E 未満までの数列の各要素を C とし 、 B の C 番目に D の C 番目に D の C 番目を加えた値に 1 を加えた値 の 2 に D を掛けた値 番目を加えた値の列を A とする <eos>
962
src = if len ( A [ B ] ) != 2 :
trg = A の B 番目の長さが 2 と等しくないとき 、
rst = A の B 番目の長さが 2 と等しくないとき 、 <eos>
963
src = for A in range ( int ( len ( B ) / 3 ) ) :
trg = 0 から B の長さを 3 で割った値の整数値 未満までの数列を順に A として 、 繰り返 す
rst = 0 から B の長さを 3 で割った値の整数値 未満までの数列を順に A として 、 繰り返 す <eos>
964
src = A = B * e - C * D
trg = B にネイピア数を掛けた値から C に D を掛けた値を引いた値を A とする
rst = B にネイピア数を掛けた値から C に D を掛けた値を引いた値を A とする <eos>
965
src = A = [ ( 10 ** 18 , - 1 ) ] * B
trg = ((10 の 18 乗 、 -1) の組 ) からなる列の B 回分の列を A とする
rst = ( 10 の 18 乗 、 -1) からなる列の B 回分の列を A とする <eos>
966
src = open ( 1 , A ) . writelines ( [ B . format ( C [ D ] ) for D in map ( int , open ( 0 ) . read ( ) . split ( ) ) ] )
trg = open (1, A ) . writelines ([ B . format ( C [ D ] ) forDinmap ( int , open (0) . read (). split ())])
rst = open (1, A ) . writelines ([ B . format ([ C [ D ] ) <unk> ] ) <unk> ] . split () ] ) <eos>
967
src = return Vector ( A . x + B . x , A . y + B . y )
trg = Vector ( A . x + B . x , A . y + B . y ) を返す
rst = Vector ( A . x + B . x , A . y + B . y ) を返す <eos>
968
src = A = str [ int ( B ) + 1 : ]
trg = 整数の B の整数値に 1 を加えた値から 、 つまり末尾までの部分列を A とする
rst = 整数の B の整数値に 1 を加えた値から 、 つまり末尾までの部分列を A とする <eos>
969
src = A . append ( tanri ( B , C , D , E ) )
trg = A の末尾に tanri ( B , C , D , E ) を追加する
rst = A の末尾に <unk> ( B , C , D , E ) を追加する <eos>
970
src = heappush ( A , ( 0 , 0 , B , C , 0 ) )
trg = heappush ( A ,(0,0, B , C ,0))
rst = heappush ( A ,(0,0, B , C ,0)) <eos>
971
src = A = B * 5
trg = B に 5 を掛けた値を A とする
rst = B に 5 を掛けた値を A とする <eos>
972
src = print ( + ( len ( A & B ) == C ) )
trg = A と B の論理積の長さが C と等しいかどうかに [ MASK ] を加えた値を出力する
rst = A と B の集合の論理積の長さ が C と等しいとき 、 <eos>
973
src = A . append ( B [ 2 : ] )
trg = A の末尾に B の 2 番目から 、 つまり末尾までの部分列 を追加する
rst = A の末尾に B の 2 番目から 、 つまり末尾までの部分列 を追加する <eos>
974
src = A , B , C , D = 0 , 0 , 0 , 0
trg = 0、0、0、0 を A 、 B 、 C 、 D とする
rst = 0 、0、0、0、0 を A 、 B 、 C 、 D とする <eos>
975
src = return ( ' ' . join ( A ) , ' ' . join ( B ) )
trg = ( 、 つまり空白文字を間に入れて A を連結した文字列 、 空白文字を間に入れて B を連結した文字列 ) の組を返す
rst = 空白文字を間に入れて A を連結した文字列 、 B を連結した文字列を返す <eos>
976
src = A [ B ] = C [ D ]
trg = C の D 番目を A の B 番目に する
rst = C の D 番目を A の B 番目に する <eos>
977
src = A = make_dice ( B )
trg = make _ dice ( B ) を A とする
rst = <unk> ( B ) を A とする <eos>
978
src = A = [ B for B in range ( 8 ) ]
trg = 0 から 8 未満までの数列の各要素を B とし 、 B の列を A とする
rst = 0 から 8 未満までの数列の各要素を B とし 、 B の列を A とする <eos>
979
src = A = ( B * ( B + 1 ) ) / 2
trg = B に B に 1 を加えた値を掛けた値を 2 で割った値を A とする
rst = B に B に 1 を加えた値を掛けた値を 2 で割った値を A とする <eos>
980
src = if A < B - abs ( ( C - D ) - E ) :
trg = A が B から C から D を引いた値から E を引いた値の絶対値を引いた値 より小さいとき 、
rst = A が B から C から D を引いた値の絶対値 より小さいとき 、 <eos>
981
src = A . append ( ( B [ C ^ 1 ] [ D + 2 ] , C ^ 1 , E ) )
trg = A の末尾に ( B の C と 1 の排他論理和番目 の D に 2 を加えた値番目 、 C と 1 の排他論理和 、 E ) の組 を追加する
rst = A の末尾に ( B の C と 1 の排他論理和 番目の D に 2 を加えた値 、 C と 1 の排他論理和 、 E ) の組 を追加する <eos>
982
src = A = math . sqrt ( B ** 2 - C ** 2 )
trg = B の 2 乗から C の 2 乗を引いた値の平方根を A とする
rst = B の 2 乗から C の 2 乗を引いた値の平方根を A とする <eos>
983
src = print ( ' ' . join ( ( B if math . isinf ( A ) else [ str ( A ) for A in C ] ) ) )
trg = 空白文字を間に入れて A が無限大のとき B 、 そうでなければ C の各要素を A とし 、 A の文字列の列を連結した文字列 を出力する
rst = 空白文字を間に入れて ( A が無限大のとき B 、 そうでなければ C の各要素を A とし 、 str ( A ) の列 ) からなる列 を連結した文字列を出力する <eos>
984
src = A . pre_order_search ( )
trg = A . pre _ order _ search ()
rst = A . pre _ order _ search () <eos>
985
src = A , B = - 1 , 0
trg = -1 、0 を A 、 B とする
rst = -1、-1 を A 、 B とする <eos>
986
src = while len ( A ) > B and cross ( C [ A [ - 2 ] ] , C [ A [ - 1 ] ] , C [ D ] ) >= 0 :
trg = A の長さが B より大きくかつ cross ( C [ A [-2]], C [ A [-1]], C [ D ] ) が 0 以上の 間 、 次 を 繰り返 す
rst = A の長さが B より大きくかつ cross ( C [ A [-2], C [ A -1], D ] ) が 0 以上の 間 、 次 を 繰り返 す <eos>
987
src = A [ B ] = A [ C ] = 1
trg = 1 を A の C 番目とするを A の B 番目に する
rst = 1 を A の C 番目とするを A の B 番目に する <eos>
988
src = A = [ [ - 1000 ] * [ B for C in range ( D ) ] ]
trg = ( ( -1000) からなる列の 0 から D 未満までの数列の各要素を C とし 、 B の列回分の列 ) からなる列を A とする
rst = ( ( 1000 ) からなる列の 0 から D 未満までの数列の各要素を C とし 、 B の列回分の列 ) からなる列を A とする <eos>
989
src = return A . contains & B
trg = A の contains と B の論理積 を返す
rst = A の contains と B の論理積を 返す <eos>
990
src = print ( A [ int ( input ( ) ) % 7 ] )
trg = A の 、 つまり入力された文字列の整数値 を 7 で割った余り番目 を出力する
rst = A の 、 つまり入力された文字列の整数値 を 7 で割った余り番目 を出力する <eos>
991
src = A = list ( input ( ) . split ( ) )
trg = 入力された文字列 を空白で分割した字句列のリストを A とする
rst = 入力された文字列 を空白で分割した字句列 のリストを A とする <eos>
992
src = A . right = _put ( A . right )
trg = _ put ( A . right ) を A の right に する
rst = calc _ minimum ( A . right ) を A の right に する <eos>
993
src = print ( sum ( A ) - sum ( A [ B - 1 : : B ] ) )
trg = A の総和から A の B から 1 を引いた値から 、 つまり末尾までの B 間隔による部分列の総和 を引いた値 を出力する
rst = A の総和から A の B から 1 を引いた値から 、 つまり末尾までの部分列の総和を B から 1 を引いた値番目 を出力する <eos>
994
src = A , B , C = D [ : : 2 ]
trg = D の 、 つまり先頭から 、 つまり末尾までの 2 間隔による部分列 を展開し 、 それぞれ A 、 B 、 C とする
rst = D の 、 つまり先頭から 2 番目までの部分列 を展開し 、 それぞれ A 、 B 、 C とする <eos>
995
src = A = B . nodes [ C ]
trg = B の nodes の C 番目を A とする
rst = B の nodes の C 番目を A とする <eos>
996
src = A = max ( 1 , int ( 2 ** ( math . log2 ( B . size + 1 ) - 1 ) ) - 1 )
trg = 1 、 2 の math . log 2( B . size +1) から 1 を引いた値 乗の整数値から 1 を引いた値の最大値を A とする
rst = 1 、 2 の 2 乗に B の size に 1 を加えた値 乗から 1 を引いた値 の対数の切り 上 げ 整数値乗 を A とする <eos>
997
src = A = ( B * C + D * E ) / ( B * B + D * D )
trg = B に C を掛けた値に D に E を掛けた値を加えた値を B に B を掛けた値に D に D を掛けた値を加えた値で割った値 を A とする
rst = B に C を掛けた値に D に E を掛けた値を加えた値を B に D を掛けた値に D を掛けた値を加えた値を A とする <eos>
998
src = A = A or search ( [ B for B in C if B != D ] , E , F , D + 1 , 1 )
trg = A または E 、 F 、 D に 1 を加えた値 、 1 に お いて正規表現 C の各要素を B とし 、 B が D と等しくないときの B の列 が最初にマッチする位置を A とする
rst = A または C の各要素を B 、 B とし 、 B が D と等しくないときの B の列 、 E 、 F 、 D に 1 を加えた値 、 D に 1 を加えた値 の要素をそれぞれ組にした列 を A とする <eos>
999
src = if A [ B : ] . startswith ( C ) :
trg = A の B 番目から 、 つまり末尾までの部分列 の先頭が C で 始 まるとき 、
rst = A の B 番目から 、 つまり末尾までの部分列の C 番目が 、 つまり無限の整数列 と等しくないとき 、 <eos>
1000
src = print ( A , B * ( C - 2 ) , A , sep = '' , end = '' )
trg = 区 切りなしで改行せずに A 、 B に C から 2 を引いた値を掛けた値 、 A を出力する
rst = 区 切りなしで改行せずに A 、 B に C から 2 を引いた値 を出力する <eos>
1001
src = A , B = C [ D ] , E [ D ]
trg = C の D 番目 、 E の D 番目を A 、 B とする
rst = C の D 番目 、 E の D 番目を A 、 B とする <eos>
1002
src = if is_rect ( A ) :
trg = is _ rect ( A ) のとき 、
rst = <unk> ( A ) のとき 、 <eos>
1003
src = if A [ 0 ] > 100000 * 100000 :
trg = A の 0 番目が 100000 に 100000 を掛けた値 より大きいとき 、
rst = A の 0 番目が 100000 に 100000 を掛けた値 より大きいとき 、 <eos>
1004
src = return _range ( A . right )
trg = _ range ( A . right ) を返す
rst = _ range ( A . right ) を返す <eos>
1005
src = A = min ( A * 2 , B )
trg = A に 2 を掛けた値 、 B の最小値を A とする
rst = A に 2 を掛けた値 、 B の最小値を A とする <eos>
1006
src = A = ( B [ C + D ] - B [ C ] * E [ D ] ) % F
trg = B の C に D を加えた値番目から B の C 番目に E の D 番目を掛けた値を引いた値を F で割った余りを A とする
rst = B の C に D を加えた値番目から B の C 番目に E の D 番目を掛けた値を F で割った余りを A とする <eos>
1007
src = for A in range ( 2 , 1001 ) :
trg = 2 から 1001 未満までの数列を順に A として 、 繰り返 す
rst = 2 から 1001 未満までの数列を順に A として 、 繰り返 す <eos>
1008
src = A = open ( 0 )
trg = 0 を開いたファイルストリームを A とする
rst = 0 を開いたファイルストリーム を A とする <eos>
1009
src = A [ B ] [ C ] = sum ( [ D [ B ] [ E ] * D [ E ] [ C ] for E in range ( F ) ] )
trg = 0 から F 未満までの数列の各要素を E とし 、 D の B 番目の E 番目に D の E 番目の C 番目を掛けた値の列の総和を A の B 番目の C 番目に する
rst = 0 から F 未満までの数列の各要素を E とし 、 D の B 番目の E 番目に D の E 番目の C 番目を掛けた値の列の総和を A の B 番目の C 番目に する <eos>
1010
src = print ( A + str ( B + C ) )
trg = A に B に C を加えた値 の文字列を加えた値を出力する
rst = A に B に C を加えた値 の文字列を加えた値を出力する <eos>
1011
src = A . _id [ B ] = C
trg = C を A の _ id の B 番目に する
rst = C を A の _ id の B 番目に する <eos>
1012
src = return ( len ( A ) , len ( B ) )
trg = ( A の長さ 、 B の長さ ) の組を返す
rst = ( A の長さ 、 B の長さ ) の組を返す <eos>
1013
src = if A [ 0 ] != B and A [ 0 ] == A [ 4 ] and A [ 4 ] == A [ 8 ] :
trg = A の 0 番目が B と等しくなくかつ A の 0 番目が A の 4 番目と等しくかつ A の 4 番目が A の 8 番目と等しいとき 、
rst = A の先頭が B と等しくなくかつ A の 0 番目が A の 4 番目と等しくかつ A の 4 番目が A の 8 番目と等しいとき 、 <eos>
1014
src = return A . bel [ B ] [ C ]
trg = A の bel の B 番目の C 番目を返す
rst = A の bel の B 番目の C 番目を返す <eos>
1015
src = return int ( judge ( A ) )
trg = judge ( A ) の整数値を返す
rst = judge ( int ( A )) を返す <eos>
1016
src = A [ B ] |= { C }
trg = A の B 番目を ( < __ main __ . Cammaobjectat 0 x 10 a 10 ed 0 0> ) の集合と の 論理和に する
rst = A の B 番目を ( < __ main __ . Cammaobjectat 0 x 10 a 10 eaf 0> ) の集合と の 論理和に する <eos>
1017
src = for A in range ( 2 ** e ) :
trg = 0 から 2 の 、 つまりネイピア数乗 未満までの数列を順に A として 、 繰り返 す
rst = 0 から 2 の 、 つまりネイピア数 乗 未満までの数列を順に A として 、 繰り返 す <eos>
1018
src = print ( M{y-1867} )
trg = " M {}" を出力する
rst = "{} \ n {} \ n {}" を出力する <eos>
1019
src = A = ( B << 1 ) | 1
trg = B を 1 だけ左シフトした値と 1 の論理和を A とする
rst = B を 1 だけ左シフトした値と 1 の論理和を A とする <eos>
1020
src = print ( str ( oct ( A ) [ 2 : ] ) . translate ( str . maketrans ( B , C ) ) )
trg = str ( oct ( A ) [2:]) . translate ( str . maketrans ( B , C )) を出力する
rst = { 2 : B ] の出現回数 、 translate ( str . maketrans ( B , C )) node ( B , C )) を出力する <eos>
1021
src = A = [ B for B in [ ( C - 1 , D ) , ( C + 1 , D ) , ( C , D - 1 ) , ( C , D + 1 ) ] if ( 0 <= B [ 0 ] and B [ 0 ] < E and 0 <= B [ 1 ] and B [ 1 ] < F ) ]
trg = ( ( C から 1 を引いた値 、 D ) の組 、 ( C に 1 を加えた値 、 D ) の組 、 ( C 、 D から 1 を引いた値 ) の組 、 ( C 、 D に 1 を加えた値 ) の組 ) からなる列の各要素を B とし 、0 が B [0] 以下かつ B [0] が E より小さくかつ 0 が B の 1 番目以下かつ B の 1 番目が F より小さいとき の B の列を A とする
rst = ( C から 1 を引いた値 、 D ) の組 、 ( C に 1 を加えた値 、 D ) の組 、 ( B 、 C に 1 を加えた値 ) の組 、 ( B 、 つまり未定値 ) からなる列 、 D に 1 を加えた値 ) からなる列 、 そうでなければ 0 ) からなる列を B とする
1022
src = print ( B if sum ( A ) / len ( A ) >= 0.5 else C )
trg = A の総和を A の長さで割った値 が 0.5 以上のとき B 、 そうでなければ C を出力する
rst = A の総和を A の長さで割った値 が 0.5 以上のとき B 、 そうでなければ C を出力する <eos>
1023
src = A = [ 100000 * 100 + 1 ] * B
trg = ( 100000 に 100 を掛けた値に 1 を加えた値 ) からなる列の B 回分の列を A とする
rst = ( (100000) からなる列の 100 に 1 を加えた値番目に B を掛けた値を加えた値を A とする <eos>
1024
src = A += B [ C ] * D
trg = A を B の C 番目に D を掛けた値だけ 増 加 させ る
rst = A を B の C 番目に D を掛けた値だけ 増 加 させ る <eos>
1025
src = count . append ( [ A [ B ] , 1 ] )
trg = 無限の整数列の末尾に ( A の B 番目 、1) からなる列 を追加する
rst = 無限の整数列の末尾に ( A の B 番目 、1) からなる列 を追加する <eos>
1026
src = A . vs = [ ]
trg = 空列を A の vs に する
rst = 空列を A の vs に する <eos>
1027
src = A = A + B [ C ] [ D ] * E [ D ]
trg = A に B の C 番目の D 番目に E の D 番目を掛けた値を加えた値を A とする
rst = A に B の C 番目の D 番目に E の D 番目を掛けた値を加えた値を A とする <eos>
1028
src = if not 0 <= A < B or not 0 <= C < D or E [ C ] [ A ] is None :
trg = 0 が A 以下かどうかが B より小さくなくまたは 0 が C 以下かどうかが D より小さくなくまたは E の C 番目の A 番目が 、 つまり未定値と等しくないとき 、
rst = 0 が A 以下かどうかが B より小さくなくまたは 0 が C 以下かどうかが D より小さくなくまたは E の C 番目の A 番目が 、 つまり未定値と等しくないとき 、 <eos>
1029
src = pos ( A )
trg = pos ( A )
rst = pos ( A ) <eos>
1030
src = A . append ( [ 0 for B in range ( 14 ) ] )
trg = A の末尾に 0 から 14 未満までの数列の各要素を B とし 、0 の列 を追加する
rst = A の末尾に 0 から 14 未満までの数列の各要素を B とし 、0 の列 を追加する <eos>
1031
src = A = [ 2 ]
trg = (2) からなる列を A とする
rst = (2) からなる列を A とする <eos>
1032
src = A = 7 if 4 in B else ( 6 if 3 in B and 2 in B else ( 4 if 3 in B else ( 3 if B . count ( 2 ) == 2 else 2 ) ) )
trg = 4 が B に含まれるとき 7 、 そうでなければ 3 が B に含まれかつ 2 が B に含まれるとき 6 、 そうでなければ 3 が B に含まれるとき 4 、 そうでなければ B . count (2) が 2 と等しいとき 3 、 そうでなければ 2 を A とする
rst = B が 6 に含まれるとき 7 ( B [3]) 、 そうでなければ B が 2 と等しいとき 6 、 そうでなければ B 内の 8 の出現回数 、 B 内の 2 と等しいとき 2 、 そうでなければ B を無限の整数列 とする <eos>
1033
src = for A in range ( B [ C - 1 ] + 1 , C + 2 ) :
trg = B の C から 1 を引いた値番目に 1 を加えた値から C に 2 を加えた値未満までの数列を順に A として 、 繰り返 す
rst = B の C から 1 を引いた値番目に 1 を加えた値から C に 2 を加えた値未満までの数列を順に A として 、 繰り返 す <eos>
1034
src = A , B = [ C , D ] if C > D else [ D , C ]
trg = C が D より大きいとき ( C 、 D ) からなる列 、 そうでなければ ( D 、 C ) からなる列を展開し 、 それぞれ A 、 B とする
rst = C が D より大きいとき ( C 、 D ) からなる列 、 そうでなければ ( D 、 C ) からなる列を A 、 B とする <eos>
1035
src = A = segmentTree ( B , C , sentinel = 0 )
trg = segmentTree ( B , C , sentinel =0) を A とする
rst = 0 を <unk> ( B , C ) を A とする <eos>
1036
src = for A in range ( len ( path ) ) :
trg = 0 から os . path の長さ未満までの数列を順に A として 、 繰り返 す
rst = 0 から os . path の長さ未満までの数列を順に A として 、 繰り返 す <eos>
1037
src = print ( A [ B ] [ len ( A [ B ] ) - 1 ] )
trg = A の B 番目の A の B 番目の長さから 1 を引いた値番目 を出力する
rst = A の B 番目の A の B 番目の長さから 1 を引いた値番目 を出力する <eos>
1038
src = print ( sum ( [ A [ B ] [ C ] for B in [ range ( 3 ) for C in range ( 3 ) ] ] ) % 10000 )
trg = range (3) の各要素を C とし 、 range (3) の列の各要素を B とし 、 A [ B ] の C 番目の列の総和を 10000 で割った余りを出力する
rst = 0 から 10000 未満までの数列の各要素を C とし 、0 から 3 未満までの数列の列の各要素を B とし 、 A の B 番目の C 番目の列の最大値 を出力する <eos>
1039
src = A = mirror ( A )
trg = mirror ( A ) を A とする
rst = mirror ( A ) を A とする <eos>
1040
src = count = A [ B ]
trg = A の B 番目 を無限の整数列 とする
rst = A の B 番目を 無限の整数列 とする <eos>
1041
src = A = A | B [ C ]
trg = A と B の C 番目の論理和を A とする
rst = A と B の C 番目の論理和を A とする <eos>
1042
src = rotate_and_print ( A )
trg = rotate _ and _ print ( A )
rst = <unk> ( A ) <eos>
1043
src = A -= B [ C ] [ 2 ]
trg = A を B の C 番目の 2 番目だけ 減 少 させ る
rst = A を B の C 番目の 2 番目だけ 減 少 させ る <eos>
1044
src = A . append ( ( B + 1 , ( C , D ) , E , F ) )
trg = A の末尾に ( B に 1 を加えた値 、 ( C 、 D ) の組 、 E 、 F ) の組 を追加する
rst = A の末尾に ( B に 1 を加えた値 、 ( C 、 D ) の組 、 ( E 、 F ) の組 ) の組 を追加する <eos>
1045
src = print ( {x:.03f} {y:.03f} {r:.03f} )
trg = "{} {} {}" を出力する
rst = "{} {} {} {} \ n {}" を出力する <eos>
1046
src = A [ B ] += list ( range ( C , C + D ) )
trg = A の B 番目を C から C に D を加えた値未満までの数列のリスト だけ 増 加 させ る
rst = A の B 番目を C から C に D を加えた値未満までの数列のリスト だけ 増 加 させ る <eos>
1047
src = print ( A [ 2 ] , end = B )
trg = B を 代わ りの行末として A の 2 番目を出力する
rst = B を 代わ りの行末として A の 2 番目を出力する <eos>
1048
src = A [ B - 1 ] . append ( ( C - 1 , e ) )
trg = A の B から 1 を引いた値番目の末尾に ( C から 1 を引いた値 、 ネイピア数 ) の組 を追加する
rst = A の B から 1 を引いた値番目の末尾に ( C から 1 を引いた値 、 つまりネイピア数 ) の組 を追加する <eos>
1049
src = print ( A % math . sqrt ( pow ( B - C , 2 ) + pow ( D - E , 2 ) ) )
trg = A を B - C の 2 乗に D - E の 2 乗を加えた値の平方根 で割った余りを出力する
rst = A を B から C を引いた値の 2 乗に D から E を引いた値の 2 乗を加えた値の平方根 で割った余りを出力する <eos>
1050
src = A = B [ C ] [ 2 ] * D / E + B [ C ] [ 0 ]
trg = B の C 番目の 2 番目に D を掛けた値を E で割った値に B の C 番目の先頭を加えた値を A とする
rst = B の C 番目の 2 番目に D を掛けた値を E で割った値に B の C 番目の先頭を加えた値を A とする <eos>
1051
src = if A [ B ] == C or A [ B ] == D or A [ B ] == E :
trg = A の B 番目が C と等しくまたは A の B 番目が D と等しくまたは A の B 番目が E と等しいとき 、
rst = A の B 番目が C と等しくまたは A の B 番目が D と等しくまたは A の B 番目が E と等しいとき 、 <eos>
1052
src = A = [ int ( B . readline ( ) ) for C in range ( int ( B . readline ( ) ) ) ]
trg = 0 から B から読み込んだ一行の整数値 未満までの数列の各要素を C とし 、 B から読み込んだ一行の整数値の列を A とする
rst = 0 から B から読み込んだ一行の整数値 未満までの数列の各要素を C とし 、 B から読み込んだ一行 の整数値の列を A とする <eos>
1053
src = return [ A * B for B in C ]
trg = C の各要素を B とし 、 A に B を掛けた値 の列を返す
rst = C の各要素を B とし 、 A に B を掛けた値の列を 返す <eos>
1054
src = if is_zero ( A - B ) :
trg = is _ zero ( A - B ) のとき 、
rst = <unk> ( A - B ) のとき 、 <eos>
1055
src = print ( A % ( D if B < C else E if B > C else F ) )
trg = A を B が C より小さいとき D 、 そうでなければ B が C より大きいとき E 、 そうでなければ F で割った余りを出力する
rst = A を B が C より小さいとき D 、 そうでなければ B が C より大きいとき E 、 そうでなければ F を出力する <eos>
1056
src = for A in range ( B , - 1 , - C ) :
trg = B から -1 未満までの - C 間隔の数列を順に A として 、 繰り返 す
rst = B から -1 未満までの - C 間隔の数列を順に A として 、 繰り返 す <eos>
1057
src = paint ( A , is_right = False , is_up = True )
trg = paint ( A , is _ right = False , is _ up = True )
rst = paint ( A , is _ right = True , is _ up = False ) <eos>
1058
src = A = abs ( ( B - C ) * ( D - E ) - ( F - G ) * ( H - I ) )
trg = B から C を引いた値に D から E を引いた値を掛けた値から F から G を引いた値に H から I を引いた値 を掛けた値を引いた値の絶対値を A とする
rst = B から C を引いた値に D から E を引いた値を掛けた値から F から G を引いた値に H から I を引いた値を掛けた値を引いた値に J を掛けた値を A とする <eos>
1059
src = if A [ ( B * C + D ) * 4 + E ] :
trg = A の B に C を掛けた値に D を加えた値に 4 を掛けた値に E を加えた値番目のとき 、
rst = A の B に C を掛けた値に D を加えた値に 4 を掛けた値に E を加えた値番目のとき 、 <eos>
1060
src = C //= B
trg = C を B 分の 一 に する
rst = C を B 分の 一 に する <eos>
1061
src = A [ B ] [ 1 ] = C
trg = C を A の B 番目の 1 番目に する
rst = C を A の B 番目の 1 番目に する <eos>
1062
src = A += max ( 0 , B - C )
trg = A を 0 、 B から C を引いた値の最大値 だけ 増 加 させ る
rst = A を 0 、 B から C を引いた値の最大値 だけ 増 加 させ る <eos>
1063
src = A = [ B for B in range ( 1 , 16 ) ] + [ 0 ]
trg = 1 から 16 未満までの数列の各要素を B とし 、 B の列に (0) からなる列を加えた値を A とする
rst = 1 から 16 未満までの数列の各要素を B とし 、 B の列を A とする <eos>
1064
src = A [ B ] [ C - 1 ] [ D - 1 ] += E
trg = A の B 番目の C から 1 を引いた値番目の D から 1 を引いた値番目を E だけ 増 加 させ る
rst = A の B 番目の C から 1 を引いた値番目の D から 1 を引いた値番目を E だけ 増 加 させ る <eos>
1065
src = A = [ [ [ B for C in range ( 31 ) ] for D in range ( E ) ] for F in range ( E ) ]
trg = 0 から E 未満までの数列の各要素を F とし 、0 から E 未満までの数列の各要素を D とし 、0 から 31 未満までの数列の各要素を C とし 、 B の列の列の列 を A とする
rst = 0 から E 未満までの数列の各要素を F とし 、0 から E 未満までの数列の各要素を D とし 、0 から 31 未満までの数列の各要素を C とし 、 B の列の列の列 を A とする <eos>
1066
src = A [ 7 ] += 1
trg = A の 7 番目を 1 だけ 増 加 させ る
rst = A の 7 番目を 1 だけ 増 加 させ る <eos>
1067
src = for A in range ( B [ - 1 ] + 2 , 2 * C + 2 , 2 ) :
trg = B の末尾に 2 を加えた値から 2 に C を掛けた値に 2 を加えた値未満までの 2 間隔の数列を順に A として 、 繰り返 す
rst = B の -1 番目に 2 を加えた値から C に 2 を掛けた値 未満までの 2 間隔の数列を順に A として 、 繰り返 す <eos>
1068
src = A += [ A [ 0 ] ]
trg = A を ( A の先頭 ) からなる列 だけ 増 加 させ る
rst = A を ( A の先頭 ) からなる列 だけ 増 加 させ る <eos>
1069
src = A = max ( 0 , B - C ) if B > 0 else min ( 0 , B + C )
trg = B が 0 より大きいとき 0 、 B から C を引いた値の最大値 、 そうでなければ 0 、 B に C を加えた値の最小値を A とする
rst = B が 0 より大きいとき 0 、 B から C を引いた値の最大値 、 そうでなければ B 、 C に 0 を加えた値の最大値を A とする <eos>
1070
src = A = B [ C : D ] + [ 1e10 ]
trg = B の C 番目から D 番目までの部分列に ( 1 e 10 ) からなる列を加えた値を A とする
rst = B の C 番目から D 番目までの部分列に ( time ) からなる列を加えた値を A とする <eos>
1071
src = A = 7200 - C if B else ( 7200 - C ) * 3
trg = B のとき 7200 から C を引いた値 、 そうでなければ 7200 から C を引いた値に 3 を掛けた値を A とする
rst = B から 7200 を引いた値 のとき 7200 から C を引いた値 、 そうでなければ C に 3 を掛けた値を A とする <eos>
1072
src = print ( A + ( B - C * A ) )
trg = A に B から C に A を掛けた値を引いた値 を加えた値を出力する
rst = A に B から C に A を掛けた値を引いた値 を加えた値を出力する <eos>
1073
src = for A , B , C , e in D :
trg = D を順に A 、 B 、 C 、 ネイピア数 として 、 繰り返 す
rst = D を順に A 、 B 、 C 、 ネイピア数 として 、 繰り返 す <eos>
1074
src = if A . parent [ B ] == C :
trg = A の parent の B 番目が C と等しいとき 、
rst = A の parent の B 番目が C と等しいとき 、 <eos>
1075
src = A = TypeVar ( B , int , float )
trg = TypeVar ( B , int , float ) を A とする
rst = <unk> ( int ( B , int ) , float ( prec = A ) を A とする <eos>
1076
src = for A , B in [ [ - 1 , 0 ] , [ 1 , 0 ] , [ 0 , - 1 ] , [ 0 , 1 ] ] :
trg = ((-1、0) からなる列 、(1、0) からなる列 、(0、-1) からなる列 、(0、1) からなる列 ) からなる列 を順に A 、 B として 、 繰り返 す
rst = ((-1、0) からなる列 、(1、0) からなる列 、(0、0) からなる列 、(0、-1) からなる列 、(0、1) からなる列 ) からなる列 を順に A 、 B として 、 繰り返 す <eos>
1077
src = A += B [ C [ D : ] + E * ( 5 - F + D ) ]
trg = A を B の C の D 番目から 、 つまり末尾までの部分列に E に 5 から F を引いた値に D を加えた値を掛けた値を加えた値 番目だけ 増 加 させ る
rst = A を B の C の D 番目から 、 つまり末尾までの部分列に E に F から D を引いた値を掛けた値を加えた値に G を加えた値だけ 増 加 させ る <eos>
1078
src = A = count
trg = 無限の整数列を A とする
rst = 無限の整数列を A とする <eos>
1079
src = A [ B ] [ C ] = max ( [ D [ C - E ] + F [ E ] for E in range ( min ( C + 1 , len ( F ) ) ) ] )
trg = 0 から C に 1 を加えた値 、 F の長さの最小値 未満までの数列の各要素を E とし 、 D の C から E を引いた値番目に F の E 番目を加えた値の列の最大値を A の B 番目の C 番目に する
rst = 0 から F の長さに 1 を加えた値未満までの数列の各要素 を C とし 、 D の C - E 番目に F を加えた値の最大値 の列を A の B 番目の C 番目に する <eos>
1080
src = A = set ( map ( int , input ( ) . split ( ) ) )
trg = 入力された文字列 を空白で分割した字句列の各要素に 整数を適用した列の集合 を A とする
rst = 入力された文字列 を空白で分割した字句列の集合 の各要素に整数を適用した列 の集合を A とする <eos>
1081
src = A = [ B for B in A if B != C ]
trg = A の各要素を B とし 、 B が C と等しくないときの B の列を A とする
rst = A の各要素を B とし 、 B が C と等しくないときの B の列を A とする <eos>
1082
src = A = B . most_common ( ) [ 0 ] [ 0 ]
trg = B の出現 頻 度順の列の先頭の先頭 を A とする
rst = B の上位 <unk> 、 回転する を A とする <eos>
1083
src = A = datetime . datetime ( 1989 , 1 , 8 )
trg = 1989 年 1 月 8 日の日時を A とする
rst = datetime 年 8 月 8 日の日時を A とする <eos>
1084
src = A , B , C = D [ 3 ] , D [ 4 ] , D [ 5 ]
trg = D の 3 番目 、 D の 4 番目 、 D の 5 番目を A 、 B 、 C とする
rst = D の 3 番目 、 D の 4 番目 、 D の 5 番目を A 、 B 、 C とする <eos>
1085
src = A = cut ( A , B )
trg = cut ( A , B ) を A とする
rst = cut ( A , B ) を A とする <eos>
1086
src = A , B = bowling_score ( C )
trg = bowling _ score ( C ) を展開し 、 それぞれ A 、 B とする
rst = <unk> ( C ) を展開し 、 それぞれ A 、 B とする <eos>
1087
src = B = sum ( A )
trg = A の総和を B とする
rst = A の総和を B とする <eos>
1088
src = A = [ - 1 , - 1 , B , - 1 , - 1 ]
trg = (-1、-1、 B 、-1、-1) からなる列を A とする
rst = (-1、-1) からなる列を A とする <eos>
1089
src = if A > e . cap :
trg = A が 、 つまりネイピア数の cap より大きいとき 、
rst = A が 、 つまりネイピア数の cap より大きいとき 、 <eos>
1090
src = A = 120 * 60 * 1 - B
trg = 120 に 60 を掛けた値に 1 を掛けた値から B を引いた値を A とする
rst = 120 に 60 を掛けた値に 1 を掛けた値から B を引いた値を A とする <eos>
1091
src = while A [ B ] . right != - 1 :
trg = A の B 番目の right が -1 と等しくない 間 、 次 を 繰り返 す
rst = A の B 番目の right が -1 と等しくない 間 、 次 を 繰り返 す <eos>
1092
src = A [ B ] [ C ] = sum ( [ A [ B - 1 ] [ C - D ] for D in E [ B ] ] )
trg = E の B 番目の各要素を D とし 、 A の B から 1 を引いた値番目の C から D を引いた値番目の列の総和を A の B 番目の C 番目に する
rst = E の B 番目の各要素を D とし 、 A の B -1 番目の C 番目から D の D 番目 の列を加えた値を A の B 番目の C 番目に する <eos>
1093
src = A [ B ] = C + 2
trg = C に 2 を加えた値を A の B 番目に する
rst = C に 2 を加えた値を A の B 番目に する <eos>
1094
src = A [ B ] = C = [ None ] * 30
trg = ( 、 つまり未定値 ) からなる列の 30 回分の列を C とする を A の B 番目に する
rst = ( 、 つまり未定値 ) からなる列の 30 回分の列を C とする を A の B 番目に する <eos>
1095
src = while A . dfs ( 0 , 1 ) :
trg = A . dfs (0,1) の 間 、 次 を 繰り返 す
rst = A . dfs (0,1) の 間 、 次 を 繰り返 す <eos>
1096
src = print ( Case {i+1}: )
trg = " Case {}:" を出力する
rst = " <unk> {}:" を出力する <eos>
1097
src = A = input ( ) . strip ( ) . lower ( )
trg = 入力された文字列の両端から 空白改行を取り除いた文字列 を英小文字に変換した文字列を A とする
rst = 入力された文字列の両端から 空白改行を取り除いた文字列 を空白で分割した字句列を A とする <eos>
1098
src = A = [ [ 0 for B in range ( C ) ] for B in range ( D ) ]
trg = 0 から D 未満までの数列の各要素を B とし 、0 から C 未満までの数列の各要素を B とし 、0 の列の列を A とする
rst = 0 から D 未満までの数列の各要素を B とし 、0 から C 未満までの数列の各要素を B とし 、0 の列の列を A とする <eos>
1099
src = A += [ A [ 1 ] ]
trg = A を ( A の 1 番目 ) からなる列 だけ 増 加 させ る
rst = A を ( A の 1 番目だけ 増 加 させ る <eos>
1100
src = A , B , C , D , E , F = list ( map ( float , input ( ) . split ( ) ) )
trg = 入力された文字列 を空白で分割した字句列の各要素に 浮動小数点数を適用した列のリスト を展開し 、 それぞれ A 、 B 、 C 、 D 、 E 、 F とする
rst = 入力された文字列 を空白で分割した字句列の各要素に 浮動小数点数を適用した列のリスト を展開し 、 それぞれ A 、 B 、 C 、 D 、 E 、 F とする <eos>
1101
src = A = Counter ( B ) . most_common ( )
trg = B の 辞書 カ ウ ンタ の出現 頻 度順の列を A とする
rst = B の 辞書 カ ウ ンタ の出現 頻 度順の列 を A とする <eos>
1102
src = A [ B ] [ C ] = min ( A [ B ] [ C ] , D )
trg = A の B 番目の C 番目 、 D の最小値を A の B 番目の C 番目に する
rst = A の B 番目の C 番目 、 D の最小値を A の B 番目の C 番目に する <eos>
1103
src = A = convex_cut ( A , ( ( - B / C , D ) , ( - B / C , E ) ) )
trg = convex _ cut ( A ,((- B / C , D ),(- B / C , E ))) を A とする
rst = convex _ cut ( A ,(- B / C , D ),( E , B / C )) を A とする <eos>
1104
src = A . update ( B [ 0 ] , B [ 1 ] , 1 , 0 , C - 1 , B [ 2 ] )
trg = B の先頭 、 B の 1 番目 、1、0 、 C から 1 を引いた値 、 B の 2 番目 を追加して A を 更新 する
rst = B の先頭 、 B の 1 番目 、 C から 1 を引いた値 、 B の 2 番目 、 B の 2 番目で整形した文字列を出力する <eos>
1105
src = print ( A [ 0 ] [ 0 ] , max ( B , key = C ) )
trg = A の先頭の先頭 、 C を key として B の最大値 を出力する
rst = C を A の先頭の先頭 、 B の最大値 を出力する <eos>
1106
src = A = get ( B , C , D , E , E [ 1 ] , 1 ) [ : ]
trg = get ( B , C , D , E , E [1], 1 ) のコピーされた列を A とする
rst = get ( B , C , D , E , io [1]) の 1 番目から 、 つまり末尾までの部分列を A とする <eos>
1107
src = A = 1 / ( B * C - D * E ) * ( - E * e + B * F )
trg = 1 を B に C を掛けた値から D に E を掛けた値を引いた値で割った値に - E にネイピア数を掛けた値 に B に F を掛けた値を加えた値を掛けた値を A とする
rst = 1 を B に C を掛けた値から D に E を掛けた値を引いた値で割った値に - E に F を掛けた値に B を掛けた値を加えた値を A とする <eos>
1108
src = A [ B - 1 ] . append ( ( C , D - 1 ) )
trg = A の B から 1 を引いた値番目の末尾に ( C 、 D から 1 を引いた値 ) の組 を追加する
rst = A の B から 1 を引いた値番目の末尾に ( C 、 D から 1 を引いた値 ) の組 を追加する <eos>
1109
src = A , B = C [ ( D + 2 ) % E ]
trg = C の D に 2 を加えた値を E で割った余り 番目を展開し 、 それぞれ A 、 B とする
rst = C の D に 2 を加えた値を E で割った余り 番目を展開し 、 それぞれ A 、 B とする <eos>
1110
src = if A > 10 :
trg = A が 10 より大きいとき 、
rst = A が 10 より大きいとき 、 <eos>
1111
src = A . append ( ( B ** 2 + C ** 2 , B , C ) )
trg = A の末尾に ( B の 2 乗に C の 2 乗を加えた値 、 B 、 C ) の組 を追加する
rst = A の末尾に ( B の 2 乗に C の 2 乗を加えた値 、 B 、 C ) の組 を追加する <eos>
1112
src = for A in range ( 1 , B [ 0 ] + 1 ) :
trg = 1 から B の先頭に 1 を加えた値未満までの数列を順に A として 、 繰り返 す
rst = 1 から B の先頭に 1 を加えた値未満までの数列を順に A として 、 繰り返 す <eos>
1113
src = A += [ [ now [ 1 ] , B ] ]
trg = A を ( ( 、 つまり現在の日時の 1 番目 、 B ) からなる列 ) からなる列 だけ 増 加 させ る
rst = A を ( 、 つまり現在の日時の 1 番目 、 B ) からなる列 だけ 増 加 させ る <eos>
1114
src = A , B = float ( A ) , float ( B )
trg = A の浮動小数点数 、 B の浮動小数点数を A 、 B とする
rst = A の浮動小数点数 、 B の浮動小数点数を A 、 B とする <eos>
1115
src = A = 2 if B > C else - 2
trg = B が C より大きいとき 2 、 そうでなければ -2 を A とする
rst = B が C より大きいとき 2 、 そうでなければ -2 を A とする <eos>
1116
src = print ( A [ B - 1 ] [ int ( input ( ) ) ] / C [ B - 1 ] )
trg = A の B から 1 を引いた値番目の 、 つまり入力された文字列の整数値 番目を C の B から 1 を引いた値番目で割った値 を出力する
rst = A の B から 1 を引いた値番目の 、 つまり入力された文字列の整数値 を C の B から 1 を引いた値番目 で割った余りを出力する <eos>
1117
src = if isclose ( A , 0.0 , abs_tol = 1e-9 ) :
trg = 1 e -9 を abs _ tol として A と 0.0 が 近 いとき 、
rst = 1 e -9 を abs _ tol として A と 近 いかどうかを返す <eos>
1118
src = A . append ( ( - 1 , None ) )
trg = A の末尾に (-1、 未定値 ) の組 を追加する
rst = A の末尾に (-1、 未定値 ) の組 を追加する <eos>
1119
src = for A in range ( 16 , 18 ) :
trg = 16 から 18 未満までの数列を順に A として 、 繰り返 す
rst = 16 から 18 未満までの数列を順に A として 、 繰り返 す <eos>
1120
src = print ( A + 1911 )
trg = A に 1911 を加えた値を出力する
rst = A に 1911 を加えた値を出力する <eos>
1121
src = if len ( A [ 0 ] [ 1 ] ) == len ( A [ 1 ] [ 1 ] ) == len ( A [ 2 ] [ 1 ] ) == 2 and ( A [ 2 ] [ 1 ] & ( A [ 0 ] [ 1 ] | A [ 1 ] [ 1 ] ) == A [ 2 ] [ 1 ] ) :
trg = A [0][1] の長さが A [1][1] の長さと等しいかどうかが A [2] の 1 番目の長さ と等しいかどうかが 2 と等しくかつ A の 2 番目の 1 番目と A [0] の 1 番目と A [1] の 1 番目 の論理和 の論理積が A の 2 番目の 1 番目と等しいとき 、
rst = A [0] の長さが 1 と等しくまたは A [1] の 1 番目の長さが 1 と等しくかつ A の 2 番目の 1 番目の長さが 1 と等しいとき 、 <eos>
1122
src = if not A [ B - C - 1 ] [ D + C ] :
trg = A の B から C を引いた値から 1 を引いた値番目の D に C を加えた値 番目でないとき 、
rst = A の B から C を引いた値から 1 を引いた値番目の D に C を加えた値 番目でないとき 、 <eos>
1123
src = if A [ B - 1 ] <= A [ B ] :
trg = A の B から 1 を引いた値番目が A の B 番目以下のとき 、
rst = A の B から 1 を引いた値番目が A の B 番目以下のとき 、 <eos>
1124
src = A //= 8
trg = A を 8 分の 一 に する
rst = A を 8 分の 一 に する <eos>
1125
src = if A is None or phase ( A / B ) <= 0 :
trg = A が 、 つまり未定値と等しくなくまたは phase ( A / B ) が 0 以下のとき 、
rst = A が 、 つまり未定値と等しくなくまたは phase ( A / B ) が 0 以下のとき 、 <eos>
1126
src = return A . find ( B * 2 , C , D , E )
trg = A の位置 C 、 D 、 E から B に 2 を掛けた値 を探して見つかった位置 を返す
rst = A の位置 C 、 D 、 E から B に 2 を掛けた値 を探して見つかった位置 を返す <eos>
1127
src = print ( ( A + B ) // 2 )
trg = A に B を加えた値を 2 で割った商 を出力する
rst = A に B を加えた値を 2 で割った商 を出力する <eos>
1128
src = if A [ 0 ] in B :
trg = A の 0 番目が B に含まれるとき 、
rst = A の 0 番目が B に含まれるとき 、 <eos>
1129
src = if binary_search ( A , B ) :
trg = binary _ search ( A , B ) のとき 、
rst = binary _ search ( A , B ) のとき 、 <eos>
1130
src = print ( '\n' . join ( [ A . format ( * B ) for B in C ] ) )
trg = 改行文字を間に入れて C の各要素を B とし 、 A を書式として B を展開してで整形した文字列 の列を連結した文字列を出力する
rst = 改行文字を間に入れて C の各要素を B とし 、 A を書式として B を展開してで整形した文字列 の 列を展開してを出力する <eos>
1131
src = print ( A [ 8 ] )
trg = A の 8 番目を出力する
rst = A の 8 番目を出力する <eos>
1132
src = A , B = C // 100 , C % 100
trg = C を 100 で割った商 、 C を 100 で割った余りを A 、 B とする
rst = C を 100 で割った商 、 C を 100 で割った余りを A 、 B とする <eos>
1133
src = write ( '' . join ( A ) )
trg = write ('' . join ( A ))
rst = write ('' . join ( A )) <eos>
1134
src = A = [ tuple ( map ( int , readline ( ) . split ( ) ) ) + ( B ) for B in range ( int ( readline ( ) ) ) ]
trg = 0 から readline () の整数値未満までの数列の各要素を B とし 、 readline () を空白で分割した字句列の各要素 に整数を適用した列の組に B を加えた値の列を A とする
rst = 0 から readline () の整数値に B とし 、 readline () を空白で分割した字句列の各要素に 整数を適用した列の組の列を A とする <eos>
1135
src = A . add ( ( min ( B , C ) + 1 , D + 1 ) )
trg = A に ( B 、 C の最小値に 1 を加えた値 、 D に 1 を加えた値 ) の組を追加した集まり
rst = A に min ( B , C ) を加えた値に 1 を加えた値 、 D に 1 を加えた値 を追加した集まり <eos>
1136
src = if A != B and A != C :
trg = A が B と等しくなくかつ A が C と等しくないとき 、
rst = A が B と等しくなくかつ A が C と等しくないとき 、 <eos>
1137
src = A [ 3 ] = 0
trg = 0 を A の 3 番目に する
rst = 0 を A の 3 番目に する <eos>
1138
src = return str ( A % 4 )
trg = A を 4 で割った余りの文字列 を返す
rst = A を 4 で割った余りを出力する を返す <eos>
1139
src = A += input ( ) . rstrip ( )
trg = A を入力された文字列 の末尾から 空白改行を取り除いた文字列 だけ 増 加 させ る
rst = A を入力された文字列 の末尾から ひ とつは真 だけ 増 加 させ る <eos>
1140
src = while len ( A ) > 0 or 0 in B [ 1 : ] :
trg = A の長さが 0 より大きくまたは 0 が B の先頭を除いた部分列 に含まれる 間 、 次 を 繰り返 す
rst = A の長さが 0 より大きくまたは B の 1 番目でない 間 、 次 を 繰り返 す <eos>
1141
src = for A in sorted ( B & C ) :
trg = B と C の論理積 をソートした列を順に A として 、 繰り返 す
rst = B と C <unk> A として 、 繰り返 す <eos>
1142
src = A -= B [ C + 1 ]
trg = A を B の C に 1 を加えた値番目だけ 減 少 させ る
rst = A を B の C に 1 を加えた値番目だけ 減 少 させ る <eos>
1143
src = Koch ( A - 1 , B , C )
trg = Koch ( A -1, B , C )
rst = Koch ( A -1, B , C ) <eos>
1144
src = A = ( A // 2 ) ^ B
trg = A を 2 で割った商と B の排他論理和を A とする
rst = A を 2 で割った商 と B の排他論理和を A とする <eos>
1145
src = A = min ( A , B . index ( C ) )
trg = A 、 B の C と等しい要素の最初の位置の最小値 を A とする
rst = A 、 B の C の最小値と等しい要素の最初の位置 を A とする <eos>
1146
src = A = Point ( e , B )
trg = Point ( e , B ) を A とする
rst = Point ( e , B ) を A とする <eos>
1147
src = A = A + B - C
trg = A に B を加えた値から C を引いた値を A とする
rst = A に B を加えた値から C を引いた値を A とする <eos>
1148
src = print ( A . count ( 1 ) )
trg = A 内の 1 の出現回数 を出力する
rst = A 内の 1 の出現回数 を出力する <eos>
1149
src = return len ( A . stack ) == A . tail
trg = A の stack の長さが A の tail と等しいかどうかを返す
rst = A の stack の長さが A の tail と等しいかどうかを返す <eos>
1150
src = if A . count ( A [ B ] ) == 1 :
trg = A 内の A の B 番目の出現回数が 1 と等しいとき 、
rst = A 内の A の B 番目の出現回数が 1 と等しいとき 、 <eos>
1151
src = dump ( A , B [ 1 ] )
trg = dump ( A , B [1])
rst = dump ( A , B [1]) <eos>
1152
src = for A in B . makeBoard ( ) :
trg = B . makeBoard () を順に A として 、 繰り返 す
rst = B . sorted _ nodes () を順に A として 、 繰り返 す <eos>
1153
src = if 2 * A > min ( B , C ) - D :
trg = 2 に A を掛けた値が B 、 C の最小値から D を引いた値 より大きいとき 、
rst = 2 に A を掛けた値が B 、 C の最小値から D を引いた値 より大きいとき 、 <eos>
1154
src = A = A + 39
trg = A に 39 を加えた値を A とする
rst = A に 39 を加えた値を A とする <eos>
1155
src = if A == - 1 and B == - 1 :
trg = A が -1 と等しくかつ B が -1 と等しいとき 、
rst = A が -1 と等しくかつ B が -1 と等しいとき 、 <eos>
1156
src = return min ( A , B [ C ] [ 0 ] )
trg = A 、 B の C 番目の先頭 の最小値 を返す
rst = A 、 B の C 番目の先頭 を返す <eos>
1157
src = for A in symdiff ( B , C , D , E ) :
trg = symdiff ( B , C , D , E ) を順に A として 、 繰り返 す
rst = <unk> _ point ( B , C , D , E ) を順に A として 、 繰り返 す <eos>
1158
src = if A [ B ] != - C :
trg = A の B 番目が - C と等しくないとき 、
rst = A の B 番目が - C と等しくないとき 、 <eos>
1159
src = A = datetime ( 2000 , 1 , 1 , hour = B , minute = C , second = D )
trg = B を hour として C を minute として D を second として datetime を A とする
rst = D を <unk> として B を <unk> として C を second として datetime を A とする <eos>
1160
src = + manhattan ( A . size , B , C )
trg = manhattan ( A . size , B , C ) に [ MASK ] を加えた値
rst = manhattan ( A . size , B , C ) に [ MASK ] を加えた値 <eos>
1161
src = A = B ** 3
trg = B の 3 乗を A とする
rst = B の 3 乗を A とする <eos>
1162
src = A [ B ] = min ( A [ B ] , A [ C ] )
trg = A の B 番目 、 A の C 番目の最小値を A の B 番目に する
rst = A の B 番目 、 A の C 番目の最小値を A の B 番目に する <eos>
1163
src = return [ A * B for A , B in zip ( C , D ) ]
trg = C 、 D の要素をそれぞれ組にした列 の各要素を A 、 B とし 、 A に B を掛けた値 の列を返す
rst = C 、 D の要素をそれぞれ組にした列 の各要素を A 、 B とし 、 A に B を掛けた値の列を 返す <eos>
1164
src = A = adj_height ( A , B )
trg = adj _ height ( A , B ) を A とする
rst = adj _ height ( A , B ) を A とする <eos>
1165
src = A = B . number_of_trailing_zeros ( C )
trg = B . number _ of _ trailing _ zeros ( C ) を A とする
rst = B . get _ <unk> ( C ) を A とする <eos>
1166
src = yaku ( A )
trg = yaku ( A )
rst = <unk> ( A ) <eos>
1167
src = if A == B == C == - 1 :
trg = A が B と等しいかどうかが C と等しいかどうかが -1 と等しいとき 、
rst = A が B と等しいかどうかが C と等しいかどうかが -1 と等しいとき 、 <eos>
1168
src = if search ( A , B ) :
trg = B に お いて正規表現 A が最初にマッチする位置 のとき 、
rst = B に お いて正規表現 A が最初にマッチする位置 のとき 、 <eos>
1169
src = if A >= B :
trg = A が B 以上のとき 、
rst = A が B 以上のとき 、 <eos>
1170
src = A = int ( B [ 1 ] ) - C
trg = B の 1 番目の整数値から C を引いた値を A とする
rst = B の 1 番目の整数値から C を引いた値を A とする <eos>
1171
src = A [ B ] [ C ] = [ D for D in range ( B ) if ( C & ( 1 << D ) ) == 0 ]
trg = 0 から B 未満までの数列の各要素を D とし 、 C と 1 を D だけ左シフトした値の論理積 が 0 と等しいとき の D の列を A の B 番目の C 番目に する
rst = 0 から B 未満までの数列の各要素を D とし 、 C と 1 を D だけ左シフトした値の論理積 が 0 と等しいとき の D の C 番目の列を A の B 番目の C 番目に する <eos>
1172
src = if not inside ( A , B ) :
trg = inside ( A , B ) でないとき 、
rst = polygon _ <unk> ( A , B ) でないとき 、 <eos>
1173
src = A = B . index ( C [ D ] ) - E [ D % F ]
trg = B の C の D 番目と等しい要素の最初の位置 から E の D を F で割った余り番目を引いた値 を A とする
rst = B の C の D 番目から E の D 番目を引いた値を F で割った余り番目を A とする <eos>
1174
src = A , B , C = D / E , ( F . real + G . real ) / 2 , ( F . imag + G . imag ) / 2
trg = D を E で割った値 、 F の real に G の real を加えた値を 2 で割った値 、 F の imag に G の imag を加えた値を 2 で割った値を A 、 B 、 C とする
rst = D を E で割った値 、 F の real に G を加えた値を 2 で割った値 、 F の imag に G を加えた値を 2 で割った値を A 、 B 、 C とする <eos>
1175
src = A [ B + C ] += A [ B ]
trg = A の B に C を加えた値番目を A の B 番目だけ 増 加 させ る
rst = A の B に C を加えた値番目を A の B 番目だけ 増 加 させ る <eos>
1176
src = if A [ B - 1 : B ] :
trg = A の B から 1 を引いた値から B 番目までの部分列 のとき 、
rst = A の B から 1 を引いた値から B 番目までの部分列 番目のとき 、 <eos>
1177
src = if A == B [ 1 ] :
trg = A が B の 1 番目と等しいとき 、
rst = A が B の 1 番目と等しいとき 、 <eos>
1178
src = A += B [ C [ D ] ] [ C [ D + 1 ] ]
trg = A を B の C の D 番目番目の C の D に 1 を加えた値番目 番目だけ 増 加 させ る
rst = A を B の C の D 番目番目の C の D に 1 を加えた値番目だけ 増 加 させ る <eos>
1179
src = count = { char : [ 0 for A in B ] }
trg = ( ( A , B の各要素を A とし 、0 の列 )) からなる辞書を 無限の整数列 とする
rst = ( ( B , B の各要素を A とし 、0 の列 )) からなる辞書を 無限の整数列 とする <eos>
1180
src = A = ( 1000 - e ) % 500 // 100
trg = 1000 から 、 つまりネイピア数を引いた値を 500 で割った余りを 100 で割った商を A とする
rst = 1000 から 、 つまりネイピア数を引いた値を 500 で割った余りを 100 で割った商を A とする <eos>
1181
src = A [ B ] [ C ] = max ( dfs ( B - 1 , C ) + D [ B - 1 ] , dfs ( B , C + 1 ) + D [ C + 1 ] )
trg = dfs ( B -1, C ) に D の B から 1 を引いた値番目を加えた値 、 dfs ( B , C +1) に D の C に 1 を加えた値番目 を加えた値の最大値を A の B 番目の C 番目に する
rst = dfs ( B -1, C ) に D の B -1 番目を加えた値 、 dfs ( C +1, D +1) に B の C 番目の D に 1 を加えた値番目の最大値を A の B 番目の C 番目に する <eos>
1182
src = A = B [ C ] . right
trg = B の C 番目の right を A とする
rst = B の C 番目の right を A とする <eos>
1183
src = if ( A >= B and C <= D ) or ( A <= B and C >= D ) :
trg = A が B 以上かつ C が D 以下または A が B 以下かつ C が D 以上のとき 、
rst = A が B 以上かつ C が D 以下または A が B 以下かつ C が D 以上のとき 、 <eos>
1184
src = if can_construct_q ( A , B + 1 , C ) :
trg = can _ construct _ q ( A , B +1, C ) のとき 、
rst = has _ cycle ( A , B +1, C ) のとき 、 <eos>
1185
src = for A in combinations ( B , r = 5 ) :
trg = 5 を r として B の コン ビ ネ ー シ ョ ン を順に A として 、 繰り返 す
rst = 5 を r として B の コン ビ ネ ー シ ョ ン を順に A として 、 繰り返 す <eos>
1186
src = A . d [ 1 ] , A . d [ 3 ] , A . d [ 6 ] , A . d [ 4 ] = A . d [ 4 ] , A . d [ 1 ] , A . d [ 3 ] , A . d [ 6 ]
trg = A の d の 4 番目 、 A の d の 1 番目 、 A の d の 3 番目 、 A の d の 6 番目を A の d の 1 番目 、 A の d の 3 番目 、 A の d の 6 番目 、 A の d の 4 番目とする
rst = A の d の 4 番目 、 A の d の 3 番目 、 A の d の 4 番目を A の d の 1 番目 、 A の d の 4 番目 、 A の d の 6 番目 、 A の d の 6 番目 、 A の
1187
src = A = sum ( [ 1 for B in range ( len ( C ) - 1 ) if C [ B ] == D and C [ B + 1 ] == E and C [ B + 2 ] == D ] )
trg = 0 から C の長さから 1 を引いた値 未満までの数列の各要素を B とし 、 C [ B ] が D と等しくかつ C [ B +1] が E と等しくかつ C の B +2 番目が D と等しいとき の 1 の列の総和を A とする
rst = 0 から C の長さから 1 を引いた値 未満までの数列の各要素を B とし 、 C [ B ] が D と等しくかつ C [ B +1] が D と等しくかつ C の B +2 番目が D と等しくかつ C の B +2 の列の総和を A とする <eos>
1188
src = if A == B or A == '' :
trg = A が B と等しくまたは A が 、 つまり空文字列 と等しいとき 、
rst = A が B と等しくまたは A が 、 つまり空文字列 と等しいとき 、 <eos>
1189
src = A = [ [ - 1 ] * 3 + input ( ) . split ( ) + [ - 1 ] * [ 3 for B in range ( C ) ] ]
trg = ( (-1) からなる列の 3 に input () を空白で分割した字句列 を加えた値に (-1) からなる列の range ( C ) の各要素を B とし 、 3 の列回分の列 を加えた値回分の列 ) からなる列を A とする
rst = 0 から C 未満までの数列の各要素を B とし 、 (-1) からなる列の input () に input () を掛けた値に <unk> 回分の列 の列の列を A とする <eos>
1190
src = A = B ** 2 - ( C - D ) ** 2
trg = B の 2 乗から C から D を引いた値の 2 乗を引いた値を A とする
rst = B の 2 乗から C から D を引いた値の 2 乗を引いた値を A とする <eos>
1191
src = if check ( A - B ) :
trg = check ( A - B ) のとき 、
rst = check ( A - B ) のとき 、 <eos>
1192
src = print ( - A . flow ( 0 , B + C + 1 , min ( B , C ) ) )
trg = - A . flow (0, B + C +1, min ( B , C )) を出力する
rst = - A . flow (0, B + C +1, min ( B , C )) を出力する <eos>
1193
src = if e [ 3 ] == e [ 4 ] == e [ 5 ] == A :
trg = ネイピア数の 3 番目が 、 つまりネイピア数の 4 番目と等しいかどうかが 、 つまりネイピア数の 5 番目と等しいかどうかが A と等しいとき 、
rst = ネイピア数の 3 番目が 、 つまりネイピア数の 4 番目と等しいかどうかが A の 5 番目と等しいかどうかが A と等しいとき 、 <eos>
1194
src = A = ( B - 1 ) + ( C - 1 ) + 2 - ( D - 1 )
trg = B から 1 を引いた値に C から 1 を引いた値を加えた値に 2 を加えた値から D から 1 を引いた値を引いた値を A とする
rst = B から 1 を引いた値に C から 1 を加えた値を引いた値から D から 1 を引いた値 を加えた値を引いた値を A とする <eos>
1195
src = write ( A % ( B + 1 - sum ( C ) ) )
trg = write ( A %( B +1- sum ( C )))
rst = write ( A %( B +1, C )) <eos>
1196
src = dij ( A [ 1 ] - 1 , A [ 2 ] - 1 , B )
trg = dij ( A [1]-1, A [2] -1, B )
rst = <unk> ( A [1], A [2]) <eos>
1197
src = A [ B ] [ C - D ] = 0
trg = 0 を A の B 番目の C から D を引いた値番目に する
rst = 0 を A の B 番目の C から D を引いた値番目に する <eos>
1198
src = return ( 3 , 0 )
trg = ( 3、0) の組を返す
rst = ( 3 、0) の組を返す <eos>
1199
src = A = list ( range ( 2 , 10000 ) )
trg = 2 から 10000 未満までの数列のリストを A とする
rst = 2 から 10000 未満までの数列のリストを A とする <eos>
1200
src = A = combinations ( B , 2 )
trg = B の 2 個までの コン ビ ネ ー シ ョ ンを A とする
rst = B の 2 個までの コン ビ ネ ー シ ョ ンを A とする <eos>
1201
src = [ print ( A . replace ( B , C ) ) for A in D ]
trg = D の各要素を A とし 、 A 内の B を C で置き換えた文字列を出力する の列
rst = D の各要素を A とし 、 A 内の B を C で置き換えた文字列を出力する <eos>
1202
src = if A == [ ( 0 , 0 ) , ( 1 , - 1 ) , ( 1 , 0 ) , ( 2 , - 1 ) ] :
trg = A が ((0、0) の組 、(1、-1) の組 、(1、0) の組 、(2、-1 ) の組 ) からなる列と等しいとき 、
rst = A が ((0、0) の組 、(1、-1) の組 、(1、0) の組 ) からなる列と等しいとき 、 <eos>
1203
src = A , time = input ( ) . split ( ' ' )
trg = 入力された文字列 を空白文字で分割した字句列 を展開し 、 それぞれ A 、 time とする
rst = 入力された文字列 を空白文字で分割した字句列 を展開し 、 それぞれ A 、 time とする <eos>
1204
src = A , e = list ( map ( int , input ( ) . split ( ' ' ) ) )
trg = 入力された文字列を空白 文字で分割した字句列の各要素に 整数を適用した列のリストを展開し 、 それぞれ A 、 ネイピア数とする
rst = 入力された文字列を空白 文字で分割した字句列の各要素に 整数を適用した列のリストを展開し 、 それぞれ A 、 ネイピア数とする <eos>
1205
src = if A == B . DISTANT :
trg = A が B の DISTANT と等しいとき 、
rst = A が B の <unk> と等しいとき 、 <eos>
1206
src = if A [ 0 : : 4 ] . count ( B ) == 3 or A [ 2 : 7 : 2 ] . count ( B ) == 3 :
trg = A の 、 つまり先頭から 、 つまり末尾までの 4 間隔による部分列内の B の出現回数が 3 と等しくまたは A の 2 番目から 7 番目までの 2 間隔による部分列内の B の出現回数が 3 と等しいとき 、
rst = A の 、 つまり先頭から 4 番目までの 2 と等しくまたは B 内の A の 7 番目の出現回数が 3 と等しいとき 、 <eos>
1207
src = for A , B in zip ( C , C [ - 1 : ] + C [ : - 1 ] ) :
trg = C 、 C の 、 つまり末尾 から 、 つまり末尾までの部分列に C の末尾を除いた部分列を加えた値 の要素をそれぞれ組にした列を順に A 、 B として 、 繰り返 す
rst = C 、 C の -1 番目から 、 つまり末尾までの部分列に C の 、 つまり先頭から 1 番目までの部分列を加えた値 の要素をそれぞれ組にした列を順に A 、 B として 、 繰り返 す <eos>
1208
src = if A [ 0 ] [ B ] != C and D [ B ] != A [ 0 ] [ B ] :
trg = A の先頭の B 番目が C と等しくなくかつ D の B 番目が A の先頭の B 番目と等しくないとき 、
rst = A の先頭の B 番目が C と等しくなくかつ D の B 番目が A の先頭の B 番目と等しくないとき 、 <eos>
1209
src = A . update ( [ B for B , C in D ] )
trg = D の各要素を B 、 C とし 、 B の 列を追加して A を 更新 する
rst = D の各要素を B 、 C とし 、 B の列を A とする <eos>
1210
src = A . append ( ( B + 10 , set ( ) ) )
trg = A の末尾に ( B に 10 を加えた値 、 集合 ) の組 を追加する
rst = A の末尾に ( B に 10 を加えた値 、 つまり集合 ) の組 を追加する <eos>
1211
src = A = min ( C - D if B >= 0 else D , F - G if E >= 0 else G )
trg = B が 0 以上のとき C から D を引いた値 、 そうでなければ D 、 E が 0 以上のとき F から G を引いた値 、 そうでなければ G の最小値を A とする
rst = B が 0 以上のとき C から D を引いた値 、 そうでなければ D から F を引いた値 、 G のとき E 、 そうでなければ 0 を A とする <eos>
1212
src = if A . count ( B ) != A . count ( C ) or A . count ( D ) != A . count ( E ) :
trg = A 内の B の出現回数が A 内の C の出現回数 と等しくなくまたは A 内の D の出現回数が A 内の E の出現回数 と等しくないとき 、
rst = A 内の B の出現回数が A 内の C の出現回数 と等しくなくまたは A 内の D の出現回数が A 内の E の出現回数の最小値 と等しくないとき 、 <eos>
1213
src = if 1 < len ( A ) :
trg = 1 が A の長さより小さいとき 、
rst = 1 が A の長さより小さいとき 、 <eos>
1214
src = A = [ 1 , 1 , 1 , 0 ]
trg = ( 1、1、1 、0) からなる列を A とする
rst = ( 1 、0、2、3 ) からなる列を A とする <eos>
1215
src = A = E if ( B , C ) == D else E + 1
trg = ( B 、 C ) の組が D と等しいとき E 、 そうでなければ E に 1 を加えた値を A とする
rst = ( B 、 C ) の組が D と等しいとき E 、 そうでなければ E に 1 を加えた値を A とする <eos>
1216
src = count = mergeSort ( A , 0 , B )
trg = mergeSort ( A ,0, B ) を無限の整数列 とする
rst = mergeSort ( A ,0, B ) を無限の整数列 とする <eos>
1217
src = A = ( ( - 1 , - 1 ) , ( 0 , - 1 ) , ( 1 , 0 ) , ( 0 , 1 ) , ( - 1 , 1 ) , ( - 1 , 0 ) )
trg = ((-1、-1) の組 、(0、-1) の組 、(1、0) の組 、(0、1) の組 、(-1、1) の組 、(-1、0) の組 ) の組を A とする
rst = ((-1、-1) の組 、(0、-1) の組 、(1、0) の組 、(1、1) の組 、(0、1) の組 、(-1、0) の組 ) の組を A とする <eos>
1218
src = A [ B ] = str ( C )
trg = C の文字列を A の B 番目に する
rst = C の文字列を A の B 番目に する <eos>
1219
src = print ( 1 if is_intersected_ls ( A , B , C , D ) else 0 )
trg = is _ intersected _ ls ( A , B , C , D ) のとき 1 、 そうでなければ 0 を出力する
rst = <unk> ( A , B , C , D ) のとき 1 、 そうでなければ 0 を出力する <eos>
1220
src = A , B , C = D . calc_koch_apex ( E )
trg = D . calc _ koch _ apex ( E ) を展開し 、 それぞれ A 、 B 、 C とする
rst = D . <unk> ( E ) を展開し 、 それぞれ A 、 B 、 C とする <eos>
1221
src = A = ( B >> ( C * 3 ) ) & 7
trg = B を C に 3 を掛けた値 だけ右シフトした値と 7 の論理積を A とする
rst = B を C に 3 を掛けた値 だけ右シフトした値と 7 の論理積を A とする <eos>
1222
src = A = [ True ] * 101
trg = ( 、 つまり真 ) からなる列の 101 回分の列を A とする
rst = ( 、 つまり真 ) からなる列の 101 回分の列を A とする <eos>
1223
src = A = 10
trg = 10 を A とする
rst = 10 を A とする <eos>
1224
src = A . top , A . west , A . bottom , A . east = A . west , A . bottom , A . east , A . top
trg = A の west 、 A の bottom 、 A の east 、 A の top を A の top 、 A の west 、 A の bottom 、 A の east とする
rst = A の east 、 A の bottom 、 A の west 、 A の top を A の top 、 A の east 、 A の west とする <eos>
1225
src = A = 195 * B
trg = 195 に B を掛けた値を A とする
rst = 195 に B を掛けた値を A とする <eos>
1226
src = print ( election ( A , B ) )
trg = election ( A , B ) を出力する
rst = <unk> ( A , B ) を出力する <eos>
1227
src = A , B , C = list ( map ( int , input ( ) . split ( D ) ) )
trg = 入力された文字列を D で分割した字句列の各要素に 整数を適用した列のリストを展開し 、 それぞれ A 、 B 、 C とする
rst = 入力された文字列を D で分割した字句列の各要素に 整数を適用した列のリストを展開し 、 それぞれ A 、 B 、 C とする <eos>
1228
src = if A is None or B is None :
trg = A が 、 つまり未定値と等しくなくまたは B が 、 つまり未定値と等しくないとき 、
rst = A が 、 つまり未定値と等しくなくまたは B が 、 つまり未定値と等しくないとき 、 <eos>
1229
src = for A in range ( B [ C ] , D , E [ C ] ) :
trg = B の C 番目から D 未満までの E の C 番目 間隔の数列を順に A として 、 繰り返 す
rst = B の C 番目から D 未満までの E の C 番目 間隔の数列を順に A として 、 繰り返 す <eos>
1230
src = if A [ 0 ] == B [ 0 ] and A [ 1 ] == B [ 1 ] :
trg = A の 0 番目が B の 0 番目と等しくかつ A の 1 番目が B の 1 番目と等しいとき 、
rst = A の先頭が B の 0 番目と等しくかつ A の 1 番目が B の 1 番目と等しいとき 、 <eos>
1231
src = A = Counter ( map ( int , B . readline ( ) . split ( ) ) )
trg = B から読み込んだ一行 を空白で分割した字句列の各要素に 整数を適用した列の 辞書 カ ウ ンタを A とする
rst = B から読み込んだ一行 の列の 辞書 カ ウ ンタを A とする <eos>
1232
src = A = B = ''
trg = 空文字列を B とする を A とする
rst = 空文字列を B とする を A とする <eos>
1233
src = A . extend ( [ ( B , C ) for D , B in E [ C ] ] )
trg = E の C 番目の各要素を D 、 B とし 、 ( B 、 C ) の組の列 を追加して A を 拡張 する
rst = E の C 番目の各要素を D 、 B とし 、 ( B 、 C ) の組の列 を追加して A を 拡張 する <eos>
1234
src = A . distance = [ [ B ] * [ A . V for C in range ( A . V ) ] ]
trg = ( ( B ) からなる列の 0 から A の V 未満までの数列の各要素を C とし 、 A の V の列回分の列 ) からなる列を A の distance に する
rst = ( ( B ) からなる列の 0 から A の V 未満までの数列の各要素を C とし 、 A の V の列回分の列 ) からなる列を A の distance に する <eos>
1235
src = A . append ( B [ C + 1 ] // D [ C + 1 ] )
trg = A の末尾に B の C に 1 を加えた値番目を D の C に 1 を加えた値番目 で割った商 を追加する
rst = A の末尾に B の C に 1 を加えた値番目を D の C に 1 を加えた値番目 を追加する <eos>
1236
src = A = A * B [ C ]
trg = A に B の C 番目を掛けた値を A とする
rst = A に B の C 番目を掛けた値を A とする <eos>
1237
src = A = max ( A , B [ C ] [ C + 1 ] + B [ C + 1 ] [ D + 1 ] )
trg = A 、 B の C 番目の C に 1 を加えた値番目に B の C に 1 を加えた値番目の D に 1 を加えた値番目 を加えた値の最大値を A とする
rst = A 、 B の C 番目の C に 1 を加えた値番目に B の C に 1 を加えた値番目の D に 1 を加えた値番目 を加えた値の最大値を A とする <eos>
1238
src = A . sort ( )
trg = A をソート する
rst = A をソート する <eos>
1239
src = A . map = B [ : ]
trg = B のコピーされた列を A の map に する
rst = B のコピーされた列を A の map に する <eos>
1240
src = if dfs ( 0 , A [ 0 ] , A [ 1 ] ) :
trg = dfs (0, A [0], A [1]) のとき 、
rst = dfs (0, A [0], A [1]) のとき 、 <eos>
1241
src = A . _size = B
trg = B を A の _ size に する
rst = B を A の _ size に する <eos>
1242
src = A = [ { } for B in range ( 1 << C ) ]
trg = 0 から 1 を C だけ左シフトした値 未満までの数列の各要素を B とし 、 、 つまり空辞書の列 を A とする
rst = 0 から 1 を C だけ左シフトした値 未満までの数列の各要素を B とし 、 、 つまり空辞書の列の列 を A とする <eos>
1243
src = if ord ( A ) <= ord ( B ) and ord ( B ) <= ord ( C ) :
trg = A の順序数が B の順序数 以下かつ B の順序数が C の順序数 以下のとき 、
rst = A <unk> B の順序数以下かどうかが ord ( B ) が C の順序数 以下のとき 、 <eos>
1244
src = if A . n == B :
trg = A の n が B と等しいとき 、
rst = A の n が B と等しいとき 、 <eos>
1245
src = A = B / C * 2.0
trg = B を C で割った値に 2.0 を掛けた値を A とする
rst = B を C で割った値に 2.0 を掛けた値を A とする <eos>
1246
src = A = math . atan2 ( B , C ) + math . pi / 2
trg = math . atan 2( B , C ) に円周率 を 2 で割った値を加えた値を A とする
rst = math . atan 2( B , C ) に [ MASK ] を書き込む を 2 で割った値を A とする <eos>
1247
src = write ( A % polygon_area ( B ) )
trg = write ( A % polygon _ area ( B ))
rst = write ( A % polygon _ area ( B )) <eos>
1248
src = A = int ( '' . join ( A ) )
trg = 空文字列を間に入れて A を連結した文字列の整数値を A とする
rst = 空文字列を間に入れて A を連結した文字列の整数値を A とする <eos>
1249
src = A [ B ] = min ( A [ B ] , C + D )
trg = A の B 番目 、 C に D を加えた値の最小値を A の B 番目に する
rst = A の B 番目 、 C に D を加えた値の最小値を A の B 番目に する <eos>
1250
src = if A [ B ] [ C - 1 ] == 0 :
trg = A の B 番目の C から 1 を引いた値番目が 0 と等しいとき 、
rst = A の B 番目の C から 1 を引いた値番目が 0 と等しいとき 、 <eos>
1251
src = A = bisect . bisect_right ( B , C [ D ] )
trg = ソートされた順序を保ったまま C の D 番目を B に挿入できる最後の位置を A とする
rst = ソートされた順序を保ったまま C の D 番目を B に挿入できる最後の位置を A とする <eos>
1252
src = A . __inorder ( B . right )
trg = A .__ inorder ( B . right )
rst = A .__ inorder ( B . right ) <eos>
1253
src = A = 1299709
trg = 1299709 を A とする
rst = <unk> を A とする <eos>
1254
src = if not A . connected ( e [ 0 ] , e [ 1 ] ) :
trg = A . connected ( e [0], e [1]) でないとき 、
rst = A . connected ( e [0], e [1]) でないとき 、 <eos>
1255
src = A = max ( A , 2 * ( B * C ) ** .5 + D [ E ] )
trg = A 、 2 に B に C を掛けた値 の .5 乗を掛けた値に D の E 番目 を加えた値の最大値を A とする
rst = A 、 2 に B * C を加えた値 の .5 乗を掛けた値に D の E 乗 を加えた値の最大値を A とする <eos>
1256
src = A = ( A + 1 ) % len ( B )
trg = A に 1 を加えた値を B の長さで割った余りを A とする
rst = A に 1 を加えた値を B の長さで割った余りを A とする <eos>
1257
src = if A . is_renew ( B ) :
trg = A . is _ renew ( B ) のとき 、
rst = A ._ <unk> ( B ) のとき 、 <eos>
1258
src = A [ B ] [ C ] . add ( ( D + 1 , E , F ) )
trg = A の B 番目の C 番目に ( D に 1 を加えた値 、 E 、 F ) の組を追加した集まり
rst = A の B 番目の C 番目に ( D に 1 を加えた値 、 E 、 F ) の組を追加した集まり <eos>
1259
src = return A . depth
trg = A の depth を返す
rst = A の depth を返す <eos>
1260
src = A [ B [ 0 ] ] = A [ B [ 1 ] ]
trg = A の B の 1 番目番目を A の B の先頭番目に する
rst = A の B の 1 番目番目を A の B の先頭番目に する <eos>
1261
src = return A . get_root ( ) . key
trg = A . get _ root () の key を返す
rst = A . get _ key () を返す <eos>
1262
src = A , B = C + D [ E ] [ 0 ] , F + D [ E ] [ 1 ]
trg = C に D の E 番目の先頭を加えた値 、 F に D の E 番目の 1 番目を加えた値を A 、 B とする
rst = C に D の E 番目の先頭 を加えた値 、 F に D の E 番目の 1 番目を加えた値を A 、 B とする <eos>
1263
src = A . append ( '\n' . join ( B ) )
trg = A の末尾に 改行文字を間に入れて B を連結した文字列 を追加する
rst = A の末尾に空文字列を間に入れて B を連結した文字列 を追加する <eos>
1264
src = for A in range ( 1 , B + 2 ) :
trg = 1 から B に 2 を加えた値未満までの数列を順に A として 、 繰り返 す
rst = 1 から B に 2 を加えた値未満までの数列を順に A として 、 繰り返 す <eos>
1265
src = if A + B * 5 + C * 10 + D * 50 + e * 100 + E * 500 >= 1000 :
trg = A + B *5 に C *10 を加えた値に D に 50 を掛けた値を加えた値 にネイピア数に 100 を掛けた値を加えた値に E に 500 を掛けた値を加えた値が 1000 以上のとき 、
rst = A に B *5 を加えた値に C に 10 を掛けた値を加えた値に D に 50 を掛けた値を加えた値に D に e を掛けた値を加えた値に E に 100 を掛けた値を加えた値に 500 を掛けた値を加えた値が 1000 以上のとき 、 <eos>
1266
src = print ( A . compute ( B , C ) )
trg = A . compute ( B , C ) を出力する
rst = A . compute ( B , C ) を出力する <eos>
1267
src = print ( A [ ( B [ - 1 ] + 1 , C , D ) ] )
trg = A の ( B の -1 番目に 1 を加えた値 、 C 、 D ) の組 番目を出力する
rst = A の ( B の末尾 番目に 1 を加えた値 、 C 、 D ) の組 番目を出力する <eos>
1268
src = print ( lis ( A ) )
trg = lis ( A ) を出力する
rst = <unk> ( A ) を出力する <eos>
1269
src = A . pv = [ - 1 ] * A . n
trg = (-1) からなる列の A の n 回分の列を A の pv に する
rst = (-1) からなる列の A の n 回分の列を A の pv に する <eos>
1270
src = A . prev = B
trg = B を A の prev に する
rst = B を A の prev に する <eos>
1271
src = [ print ( {shcd} {n} ) for A in [ [ B , C , D , E ] for F in range ( 1 , 14 ) if {shcd} {n} in G ] ]
trg = 1 から 14 未満までの数列の各要素を F とし 、"{} {}" が G に含まれるとき の ( B 、 C 、 D 、 E ) からなる列の列の各要素を A とし 、"{} {}" を出力するの列
rst = 0 から 14 未満までの数列の各要素を F とし 、 ( B 、 C 、 D 、 E 、 F ) の組が G に含まれるとき の ( map ( B 、 C 、 D 、 E ) からなる列の列を A とする <eos>
1272
src = return A . FLAGS & A . Masks [ B ] != 0b00
trg = A の FLAGS と A の Masks の B 番目の論理積が 0 b 0 0 と等しくないかどうかを返す
rst = A の FLAGS と A の Masks の B 番目の論理積が <unk> を返す <eos>
1273
src = if ( A == B or A in C ) and ( D == B or D in E ) and ( F == B or F <= G ) and ( H == B or G <= H ) :
trg = A が B と等しくまたは A が C に含まれかつ D が B と等しくまたは D が E に含まれかつ F が B と等しくまたは F が G 以下かつ H が B と等しくまたは G が H 以下のとき 、
rst = A が B と等しくまたは A が C と等しくかつ D が B と等しくまたは D が E と等しくかつ F が B と等しくまたは G が H と等しいとき 、 <eos>
1274
src = A . right = delete ( A . right , B )
trg = delete ( A . right , B ) を A の right に する
rst = delete ( A . right , B ) を A の right に する <eos>
1275
src = A [ B ] . depth , A [ B ] . height = C , 0
trg = C 、0 を A の B 番目の depth 、 A の B 番目の height とする
rst = C 、0 を A の B 番目の depth 、 A の B 番目の height とする <eos>
1276
src = if A . dice == B . dice :
trg = A の dice が B の dice と等しいとき 、
rst = A の dice が B の dice と等しいとき 、 <eos>
1277
src = A = abs ( B - C )
trg = B から C を引いた値の絶対値を A とする
rst = B から C を引いた値の絶対値を A とする <eos>
1278
src = if A == 2 :
trg = A が 2 と等しいとき 、
rst = A が 2 と等しいとき 、 <eos>
1279
src = print ( ( A - B ) * C )
trg = A から B を引いた値に C を掛けた値を出力する
rst = A から B を引いた値に C を掛けた値を出力する <eos>
1280
src = A [ B + 2 ] [ 2 : 12 ] = list ( map ( int , input ( ) . split ( ) ) )
trg = 入力された文字列 を空白で分割した字句列の各要素に 整数を適用した列のリストを A の B に 2 を加えた値番目の 2 番目から 12 番目までの部分列に する
rst = 入力された文字列 を空白で分割した字句列の各要素に 整数を適用した列のリストに 2 を加えた値を A の B に 2 を加えた値番目の 12 番目に する <eos>
1281
src = A , B , C = 0 , 255 , 255
trg = 0、255、255 を A 、 B 、 C とする
rst = 255、0、255 を A 、 B 、 C とする <eos>
1282
src = A = parent_search ( B , C )
trg = parent _ search ( B , C ) を A とする
rst = <unk> ( B , C ) を A とする <eos>
1283
src = A += B [ C ] * ( D / 100 ) ** E
trg = A を B の C 番目に D を 100 で割った値の E 乗を掛けた値だけ 増 加 させ る
rst = A を B の C 番目に D を 100 で割った値の E 乗を掛けた値だけ 増 加 させ る <eos>
1284
src = while A < len ( B ) :
trg = A が B の長さより小さい 間 、 次 を 繰り返 す
rst = A が B の長さより小さい 間 、 次 を 繰り返 す <eos>
1285
src = decode_node_data ( A )
trg = decode _ node _ data ( A )
rst = <unk> ( A ) <eos>
1286
src = if A >= B and C >= B and A <= ( D - B ) and C <= ( E - B ) :
trg = A が B 以上かつ C が B 以上かつ A が D から B を引いた値以下かつ C が E から B を引いた値以下のとき 、
rst = A が B 以上かつ C が B 以上かつ A が D から B を引いた値以下かつ C が E から B を引いた値以下のとき 、 <eos>
1287
src = A = Bit ( B )
trg = Bit ( B ) を A とする
rst = <unk> ( B ) を A とする <eos>
1288
src = print ( max ( [ A for B in [ C for A in B ] ] ) )
trg = B の各要素を A とし 、 C の列の各要素を B とし 、 A の列の最大値 を出力する
rst = B の各要素を A とし 、 C の列の各要素を B とし 、 A の列の最大値の 列を展開してを出力する <eos>
1289
src = print ( int ( math . log ( int ( input ( ) ) + 1 , 2 ) ) )
trg = 2 を 底 とする input () の整数値に 1 を加えた値 の対数の整数値 を出力する
rst = 2 を 底 とする 、 つまり入力された文字列の整数値 に 1 を加えた値 の対数の切り 上 げ 整数値を出力する <eos>
1290
src = C = B . count ( 2 )
trg = B 内の 2 の出現回数を C とする
rst = B 内の 2 の出現回数を C とする <eos>
1291
src = A [ B ] = min ( B , C [ B ] )
trg = B 、 C の B 番目の最小値を A の B 番目に する
rst = B 、 C の B 番目の最小値を A の B 番目に する <eos>
1292
src = write ( A % B [ C [ 0 ] ] )
trg = write ( A % B [ C [0]])
rst = write ( A % B [ C [0] ] ) <eos>
1293
src = if ( A [ B ] >= C ) and ( D > 0 ) :
trg = A の B 番目が C 以上かつ D が 0 より大きいとき 、
rst = A の B 番目が C 以上かつ D が 0 より大きいとき 、 <eos>
1294
src = A = A + ( B + C )
trg = A に B に C を加えた値を加えた値を A とする
rst = A に B に C を加えた値を加えた値を A とする <eos>
1295
src = A -= 2 * B
trg = A を 2 に B を掛けた値だけ 減 少 させ る
rst = A を 2 に B を掛けた値だけ 減 少 させ る <eos>
1296
src = A [ B [ 0 ] ] = min ( A [ B [ 0 ] ] , A [ C ] + B [ 1 ] )
trg = A の B の先頭番目 、 A の C 番目に B の 1 番目を加えた値の最小値を A の B の先頭番目に する
rst = A の B 番目の先頭 、 A の C 番目の B に 1 を加えた値番目の最小値を A の B の先頭番目に する <eos>
1297
src = for A in B . REdge [ C ] :
trg = B の REdge の C 番目を順に A として 、 繰り返 す
rst = B の MOVE _ <unk> の C 番目を順に A として 、 繰り返 す <eos>
1298
src = return sum ( [ e . flow for e in A . adj ( B ) if e . src == B ] )
trg = A . adj ( B ) の各要素をネイピア数 とし 、 、 つまりネイピア数の src が B と等しいとき の 、 つまりネイピア数の flow の列の総和を返す
rst = A . adj ( e ) の各要素をネイピア数 とし 、 B . other ( e ) が B と等しいとき の 、 <eos>
1299
src = A += min ( B , C - B )
trg = A を B 、 C から B を引いた値の最小値 だけ 増 加 させ る
rst = A を B 、 C から B を引いた値の最小値 だけ 増 加 させ る <eos>
1300
src = if A [ B - 1 ] [ 0 ] + C [ B - 1 ] [ D - A [ B - 1 ] [ 1 ] ] > C [ B - 1 ] [ D ] :
trg = A の B から 1 を引いた値番目の 0 番目に C の B から 1 を引いた値番目の D から A [ B -1 ] の 1 番目を引いた値番目を加えた値が C の B から 1 を引いた値番目の D 番目より大きいとき 、
rst = A の B から 1 を引いた値番目の 0 番目に C の B -1 番目の D から 1 を引いた値番目を加えた値が A の B から 1 を引いた値番目の C から 1 を引いた値番目より大きいとき 、 <eos>
1301
src = if checkA ( A ) :
trg = checkA ( A ) のとき 、
rst = <unk> ( A ) のとき 、 <eos>
1302
src = for A in B . index ( C [ D : D + E ] ) :
trg = B の C の D 番目から D に E を加えた値までの部分列 と等しい要素の最初の位置 を順に A として 、 繰り返 す
rst = B の C の D 番目から D に E を加えた値までの部分列 を順に A として 、 繰り返 す <eos>
1303
src = return Num ( A . x * B . x )
trg = Num ( A . x * B . x ) を返す
rst = Num ( A . x * B . x ) を返す <eos>
1304
src = A , B , e , C , D , E = map ( int , input ( ) . split ( ) )
trg = 入力された文字列 を空白で分割した字句列の各要素に 整数を適用した列を展開し 、 それぞれ A 、 B 、 ネイピア数 、 C 、 D 、 E とする
rst = 入力された文字列 を空白で分割した字句列の各要素に 整数を適用した列を展開し 、 それぞれ A 、 B 、 ネイピア数 、 C 、 D 、 E とする <eos>
1305
src = A = Graph ( B , C , 1 )
trg = Graph ( B , C ,1) を A とする
rst = Graph ( B , C ,1,1) を A とする <eos>
1306
src = A , B = C [ 1 ]
trg = C の 1 番目を展開し 、 それぞれ A 、 B とする
rst = C の 1 番目を展開し 、 それぞれ A 、 B とする <eos>
1307
src = print ( 1 if sum ( [ A <= B for A in C ] ) % 2 or sum ( [ A >= D for A in C ] ) % 2 or sum ( [ B < A and A < D for A in C ] ) else 0 )
trg = sum ([ A <= BforAinC ] ) を 2 で割った余りまたは sum ([ A >= DforAinC ] ) を 2 で割った余りまたは C の各要素を A とし 、 B < AandA < D の列の総和 のとき 1 、 そうでなければ 0 を出力する
rst = A が 0 より小さいとき 1 、 そうでなければ A の各要素を C とし 、 sum ([ A == B ] ) を C で割った余りが 0 より小さくまたは A <=20 ] の総和を B で割った余り 、 そうでなければ A の総和が D より小さいとき の 1 <unk> を加えた値を出力する <eos>
1308
src = return A [ B . y ] [ B . x ] == - 1
trg = A の B の y 座標番目の B の x 座標 番目が -1 と等しいかどうかを返す
rst = A の B の y 座標が B の x 座標 と等しいかどうかを返す <eos>
1309
src = D = min ( E - 1 , B + C * 2 )
trg = E から 1 を引いた値 、 B に C に 2 を掛けた値を加えた値の最小値を D とする
rst = E から 1 を引いた値 、 B に C に 2 を掛けた値を加えた値を D とする <eos>
1310
src = A [ B ] = { C }
trg = ( < __ main __ . Cammaobjectat 0 x 10 a 10 ee 5 0> ) の集合を A の B 番目に する
rst = ( < __ main __ . Cammaobjectat 0 x 10 a 1 db 5 b 0> ) の集合を A の B 番目に する <eos>
1311
src = A = prev_perm ( B [ : ] )
trg = prev _ perm ( B [:]) を A とする
rst = <unk> ( B [:], list ) を A とする <eos>
1312
src = A = isPacked ( B , C , D )
trg = isPacked ( B , C , D ) を A とする
rst = <unk> ( B , C , D ) を A とする <eos>
1313
src = print ( A // ( B + 1 ) + bool ( A % ( B + 1 ) ) )
trg = A を B に 1 を加えた値で割った商に A を B に 1 を加えた値 で割った余りの論理値 を加えた値を出力する
rst = A を B に 1 を加えた値 で割った商に A を B に 1 を加えた値 で割った余りの論理値 を加えた値を出力する <eos>
1314
src = A = [ - 1 , 0 , 1 , 2 ]
trg = (-1、0、1、 2 ) からなる列を A とする
rst = <unk> ) からなる列を A とする <eos>
1315
src = A = ( 0 , 3 , 1 , 4 , 2 , 5 )
trg = ( 0 、3、1、4、2、 5) の組を A とする
rst = (0、0、0、1、 1、2、2、3) の組を A とする <eos>
1316
src = swap ( A [ 0 ] )
trg = swap ( A [0])
rst = swap ( A [0]) <eos>
1317
src = A [ B ] [ C ] = D [ C ]
trg = D の C 番目を A の B 番目の C 番目に する
rst = D の C 番目を A の B 番目の C 番目に する <eos>
1318
src = count += A . lower ( ) . split ( ) . count ( B )
trg = 無限の整数列を A を英小文字に変換した文字列を 空白で分割した字句列内の B の出現回数 だけ 増 加 させ る
rst = 無限の整数列を A 内の 、 つまり真の出現回数 内の B の出現回数 だけ 増 加 させ る <eos>
1319
src = A = int ( ( B % 100 ) / 10 )
trg = B を 100 で割った余りを 10 で割った値の整数値を A とする
rst = B を 100 で割った余りを 10 で割った値の整数値を A とする <eos>
1320
src = print ( ' ' + ' ' . join ( map ( str , A ) ) )
trg = 空白文字に空白文字を間に入れて A の各要素に整数を適用した列 を連結した文字列を加えた値 を出力する
rst = 空白文字に A の各要素に整数を適用した列 を連結した文字列を加えた値 を出力する <eos>
1321
src = D [ B ] = E
trg = E を D の B 番目に する
rst = E を D の B 番目に する <eos>
1322
src = A [ B ] [ 3 ] += A [ B ] [ 4 ] [ C ]
trg = A の B 番目の 3 番目を A の B 番目の 4 番目の C 番目だけ 増 加 させ る
rst = A の B 番目の 3 番目を A の B 番目の 4 番目の C 番目だけ 増 加 させ る <eos>
1323
src = A [ B - 1 ] . append ( ( C - 1 , D ) )
trg = A の B から 1 を引いた値番目の末尾に ( C から 1 を引いた値 、 D ) の組 を追加する
rst = A の B から 1 を引いた値番目の末尾に ( C から 1 を引いた値 、 D ) の組 を追加する <eos>
1324
src = A = cross ( B - C , e - C )
trg = cross ( B - C , e - C ) を A とする
rst = cross ( B - C , e - C ) を A とする <eos>
1325
src = A = B . f ( A , B . segtree [ C - 1 ] )
trg = B . f ( A , B . segtree [ C -1]) を A とする
rst = B . f ( A , B . segtree [ C -1]) を A とする <eos>
1326
src = if len ( A ) < len ( B [ C ] ) :
trg = A の長さが B の C 番目 の長さより小さいとき 、
rst = A の長さが B の C 番目 の長さより小さいとき 、 <eos>
1327
src = A = B . max ( 0 , C - 1 ) + 1
trg = B . max (0, C -1) に 1 を加えた値を A とする
rst = B の位置 C から 1 を引いた値の最大値に 1 を加えた値を A とする <eos>
1328
src = if A . dist [ B ] < C :
trg = A の dist の B 番目が C より小さいとき 、
rst = A の dist の B 番目が C より小さいとき 、 <eos>
1329
src = if time [ 1 ] > time [ 4 ] :
trg = time の 1 番目が time の 4 番目より大きいとき 、
rst = time の 1 番目が time の 4 番目より大きいとき 、 <eos>
1330
src = A . append ( ( B - C ** .5 , D ) )
trg = A の末尾に ( B から C の .5 乗を引いた値 、 D ) の組 を追加する
rst = A の末尾に ( B から C の .5 乗を引いた値 、 D ) の組 を追加する <eos>
1331
src = middle_square ( A )
trg = middle _ square ( A )
rst = <unk> ( A ) <eos>
1332
src = print ( ' ' . join ( [ str ( A ) for A in B [ : : - 1 ] ] ) )
trg = 空白文字を間に入れて B の逆順の各要素を A とし 、 A の文字列の列を連結した文字列 を出力する
rst = 空白文字を間に入れて B の 、 つまり末尾 から 、 つまり末尾までの -1 間隔による部分列の各要素を A とし 、 A の文字列の列を連結した文字列 を出力する <eos>
1333
src = print ( A [ B ] [ 0 ] , A [ B ] [ 2 ] )
trg = A の B 番目の先頭 、 A の B 番目の 2 番目を出力する
rst = A の B 番目の先頭 、 A の B 番目の 2 番目を出力する <eos>
1334
src = A = [ A [ B ] for B in C [ D . readline ( ) . strip ( ) ] ]
trg = C の D から読み込んだ一行 の両端から 空白改行を取り除いた文字列 番目の各要素を B とし 、 A の B 番目の列を A とする
rst = C の D から読み込んだ一行 の両端から 空白改行を取り除いた文字列 の各要素を B とし 、 A の B 番目の列を A とする <eos>
1335
src = A . forest . update ( [ B ] )
trg = ( B ) からなる列を追加して A の forest を 更新 する
rst = ( B ) からなる列を追加して A を 更新 する <eos>
1336
src = for A , B in ( ( C , D ) , ( E , F ) , ( G , H ) ) :
trg = ( ( C 、 D ) の組 、 ( E 、 F ) の組 、 ( G 、 H ) の組 ) の組 を順に A 、 B として 、 繰り返 す
rst = ( ( C 、 D ) の組 、 ( E 、 F ) の組 、 ( G 、 H ) の組 ) の組 ) の組 ) の組 を順に A 、 B として 、 繰り返 す <eos>
1337
src = while A < len ( B ) and B [ A ] != C :
trg = A が B の長さより小さくかつ B の A 番目が C と等しくない 間 、 次 を 繰り返 す
rst = A が B の長さより小さくかつ B の A 番目が C と等しくない 間 、 次 を 繰り返 す <eos>
1338
src = return A . values [ A . top - 1 ]
trg = A の値の集まりの A の top から 1 を引いた値番目を返す
rst = A の値の集まりの A の top から 1 を引いた値番目を返す <eos>
1339
src = A = ( A - B ) % len ( C )
trg = A から B を引いた値を C の長さで割った余りを A とする
rst = A から B を引いた値を C の長さで割った余りを A とする <eos>
1340
src = A . segtree [ A . N - 1 + B ] = C [ B ]
trg = C の B 番目を A の segtree の A の N から 1 を引いた値に B を加えた値番目に する
rst = C の B 番目を A の segtree の A の N から 1 を引いた値に B を加えた値番目に する <eos>
1341
src = push ( ( A , B + 1 , 1 ) )
trg = push ( ( A , B +1,1) )
rst = push ( ( ( A , B +1,1) <eos>
1342
src = return reduce ( lambda E , F : E * F , [ sum ( [ A ** B for B in range ( C + 1 ) ] ) for A , C in D . primeFactorization . items ( ) ] )
trg = D の primeFactorization のキーと値の集まりの各要素を A 、 C とし 、0 から C +1 未満までの数列の各要素を B とし 、 A の B 乗の列の総和の列を x 、 y をパラメータとして x に y を掛けた値を返す関数で集約した列 を返す
rst = 0 から A . primeFactorization を C とし 、 ( B * F , G + D * abs () , map ( B ) を 2. に F を加えた値 だけ左シフトした値の論理積のとき の E 、 <eos>
1343
src = A [ B ] [ 0 ] = None
trg = 未定値を A の B 番目の 0 番目に する
rst = 未定値を A の B 番目の 0 番目に する <eos>
1344
src = A . total -= A . ms [ B ]
trg = A の total を A の ms の B 番目だけ 減 少 させ る
rst = A の total を A の ms の B 番目だけ 減 少 させ る <eos>
1345
src = while A > 4 :
trg = A が 4 より大きい 間 、 次 を 繰り返 す
rst = A が 4 より大きい 間 、 次 を 繰り返 す <eos>
1346
src = A += bisect_right ( B , C ) - bisect_left ( B , C )
trg = A を ソートされた順序を保ったまま C を B に挿入できる最後の位置から 、 つまり ソートされた順序を保ったまま C を B に挿入できる位置を引いた値 だけ 増 加 させ る
rst = A を ソートされた順序を保ったまま C を B に挿入できる最後の位置を A をソート する <eos>
1347
src = for A in permutations ( [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] , B ) :
trg = (0、1 、2、3、4、5、6、7、8、9 ) からなる列の う ち B 個までの順列 を順に A として 、 繰り返 す
rst = <unk> 、5、4、3、2 ) からなる列 の順列を順に A として 、 繰り返 す <eos>
1348
src = print ( A . get_value ( B . _Dice__RIGHT ) )
trg = A . get _ value ( B ._ Dice __ RIGHT ) を出力する
rst = A . get _ value ( B . get _ id ) を出力する <eos>
1349
src = A . E [ e . to ] [ e . rev ] . cap += B
trg = A の E の 、 つまりネイピア数の to 番目の 、 つまりネイピア数の rev 番目の cap を B だけ 増 加 させ る
rst = A の E の 、 つまりネイピア数の to 番目の 、 つまりネイピア数の cap を B だけ 増 加 させ る <eos>
1350
src = if A % 3 == B :
trg = A を 3 で割った余りが B と等しいとき 、
rst = A を 3 で割った余りが B と等しいとき 、 <eos>
1351
src = for A , B , C in [ D . readline ( ) . split ( ) for E in range ( F ) ] :
trg = 0 から F 未満までの数列の各要素を E とし 、 D から読み込んだ一行を 空白で分割した字句列 の列を順に A 、 B 、 C として 、 繰り返 す
rst = 0 から F 未満までの数列の各要素を E とし 、 D から読み込んだ一行 を空白で分割した字句列 の列を順に A 、 B 、 C として 、 繰り返 す <eos>
1352
src = A += half_move ( B - C )
trg = A を half _ move ( B - C ) だけ 増 加 させ る
rst = A を full _ move 2( B - C ) だけ 増 加 させ る <eos>
1353
src = A = erase ( A )
trg = erase ( A ) を A とする
rst = erase ( A ) を A とする <eos>
1354
src = if A [ 0 ] > B :
trg = A の 0 番目が B より大きいとき 、
rst = A の先頭が B より大きいとき 、 <eos>
1355
src = if A . count ( A [ B ] ) > 1 :
trg = A 内の A の B 番目の出現回数が 1 より大きいとき 、
rst = A 内の A の B 番目の出現回数が 1 より大きいとき 、 <eos>
1356
src = A = '' . join ( [ str ( B ) for B in C [ : D ] ] )
trg = 空文字列を間に入れて C の 、 つまり先頭から D 番目までの部分列の各要素を B とし 、 B の文字列の列を連結した文字列を A とする
rst = 空文字列を間に入れて C の 、 つまり先頭から D 番目までの部分列の各要素を B とし 、 B の文字列の列を連結した文字列を A とする <eos>
1357
src = A = 0x03F566ED27179461
trg = 0 x 0 3 F 5 66 ED 27179461 を A とする
rst = <unk> を A とする <eos>
1358
src = print ( {d}: )
trg = "{}:" を出力する
rst = "{} \ n {} \ n {}" を出力する <eos>
1359
src = print ( ( comb ( A + B , min ( A , B ) ) << C ) % 100000007 )
trg = A に B を加えた値と A 、 B の最小値の コン ビ ネ ー シ ョ ンを C だけ左シフトした値を 100000007 で割った余りを出力する
rst = A に B を加えた値 、 A と B の最大公約数 、 C を 100000007 で割った余りを出力する <eos>
1360
src = return A [ B + C ] [ D + E ] == F
trg = A の B に C を加えた値番目の D に E を加えた値番目が F と等しいかどうかを返す
rst = A の B に C を加えた値番目の D に E を加えた値番目が F と等しいかどうかを返す <eos>
1361
src = A = ifprime ( A )
trg = ifprime ( A ) を A とする
rst = <unk> ( A ) を A とする <eos>
1362
src = A = A * ( B - 1 )
trg = A に B から 1 を引いた値を掛けた値を A とする
rst = A に B から 1 を引いた値を掛けた値を A とする <eos>
1363
src = A . update ( 0 , B , C , D , E )
trg = 0 、 B 、 C 、 D 、 E を追加して A を 更新 する
rst = 0 、 B 、 C 、 D 、 E を追加して A を 更新 する <eos>
1364
src = A . bit1 . add ( B , C * B )
trg = A の bit 1 に B 、 C に B を掛けた値 を追加した集まり
rst = A の bit 1 に B 、 C に B を掛けた値 を追加した集まり <eos>
1365
src = A . append ( hukuri ( B , C , float ( D ) , int ( E ) ) )
trg = A の末尾に hukuri ( B , C , float ( D ) , int ( E )) を追加する
rst = A の末尾に <unk> ( B , C , float ( D ) , int ( E )) を追加する <eos>
1366
src = A = ( - B * C + D * E ) / ( D - B )
trg = - B に C を掛けた値に D に E を掛けた値を加えた値を D から B を引いた値で割った値を A とする
rst = - B に C を掛けた値に D に E を掛けた値を加えた値を D から B を引いた値で割った値を A とする <eos>
1367
src = for A in range ( 1 , B . height ) :
trg = 1 から B の height 未満までの数列を順に A として 、 繰り返 す
rst = 1 から B の height 未満までの数列を順に A として 、 繰り返 す <eos>
1368
src = return neg ( B ) if A else B
trg = A のとき neg ( B ) 、 そうでなければ B を返す
rst = A のとき <unk> ( B ) 、 そうでなければ B を返す <eos>
1369
src = if A + B < C [ D ] [ E ] :
trg = A に B を加えた値が C の D 番目の E 番目より小さいとき 、
rst = A に B を加えた値が C の D 番目の E 番目より小さいとき 、 <eos>
1370
src = A = { "T" : C , "L" : E , "U" : G , "R" : I , "D" : K }
trg = ( ( B , C )、( D , E )、( F , G )、( H , I )、( J , K )) からなる辞書を A とする
rst = ( ( B , C )、( D , E )、( F , G )、( H , I )、( J , K )) からなる辞書を A とする <eos>
1371
src = print ( 1 + A * ( A + 1 ) // 2 )
trg = 1 に A に A に 1 を加えた値を掛けた値を 2 で割った商 を加えた値を出力する
rst = 1 に A に ( A +1) を掛けた値を 2 で割った商 を加えた値を出力する <eos>
1372
src = if len ( A ) == B and A not in C :
trg = A の長さが B と等しくかつ A が C に含まれないとき 、
rst = A の長さが B と等しくかつ A が C に含まれないとき 、 <eos>
1373
src = if A [ - B [ C ] ] == 0 :
trg = A の - B の C 番目番目が 0 と等しいとき 、
rst = A の - B の C 番目番目が 0 と等しいとき 、 <eos>
1374
src = if A . isPrime ( B ) :
trg = A . isPrime ( B ) のとき 、
rst = A の isPrime ( B ) のとき 、 <eos>
1375
src = return int ( A <= B )
trg = A が B 以下かどうかの整数値を 返す
rst = A が B 以下かどうか の整数値を返す <eos>
1376
src = A , B = dfs ( C , 0 , 0 , - D , - E )
trg = dfs ( C ,0,0, - D , - E ) を展開し 、 それぞれ A 、 B とする
rst = dfs (0,0,0, - D , E ) を展開し 、 それぞれ A 、 B とする <eos>
1377
src = print ( A . format ( B ) + ' ' . join ( map ( str , prime_factor ( B ) ) ) )
trg = A を書式として B で整形した文字列 に空白文字を間に入れて prime _ factor ( B ) の各要素に整数を適用した列 を連結した文字列を加えた値 を出力する
rst = A を書式として B で整形した文字列 に空白文字を間に入れて B e の各要素に str を適用した列を連結した文字列 で整形した文字列を出力する <eos>
1378
src = A = [ B for B in C . keys ( ) ]
trg = C のキーの集まりの各要素を B とし 、 B の列を A とする
rst = C のキーの集まりの各要素を B とし 、 B の列を A とする <eos>
1379
src = for A , B in itertools . product ( range ( 100 ) , range ( 100 ) ) :
trg = 0 から 100 未満までの数列と 0 から 100 未満までの数列の 直 積 を順に A 、 B として 、 繰り返 す
rst = 0 から 100 未満までの数列の 要素をそれぞれ組にした列のリスト 未満までの数列を順に A 、 B として 、 繰り返 す <eos>
1380
src = if 0 <= A < 12 and 0 <= B < 12 and C [ A ] [ B ] == 1 :
trg = 0 が A 以下かどうかが 12 より小さくかつ 0 が B 以下かどうかが 12 より小さくかつ C の A 番目の B 番目が 1 と等しいとき 、
rst = 0 が A 以下かどうかが 12 より小さくかつ 0 が B 以下かどうかが 12 より小さくかつ C の A 番目の B 番目が 1 と等しいとき 、 <eos>
1381
src = if A == B and A == C and A == D :
trg = A が B と等しくかつ A が C と等しくかつ A が D と等しいとき 、
rst = A が B と等しくかつ A が C と等しくかつ A が D と等しいとき 、 <eos>
1382
src = A [ B ] [ C ] [ 1 ] = 0
trg = 0 を A の B 番目の C 番目の 1 番目に する
rst = 0 を A の B 番目の C 番目の 1 番目に する <eos>
1383
src = A += e [ 2 ]
trg = A をネイピア数の 2 番目だけ 増 加 させ る
rst = A をネイピア数の 2 番目だけ 増 加 させ る <eos>
1384
src = time = sorted ( [ int ( input ( ) ) for A in range ( B ) ] )
trg = 0 から B 未満までの数列の各要素を A とし 、 、 つまり入力された文字列の整数値 の列をソートした列を time とする
rst = 0 から B 未満までの数列の各要素を A とし 、 、 つまり入力された文字列の整数値 の列をソートした列を time とする <eos>
1385
src = A [ B ] [ C ] = A [ B - 1 ] [ C ] + 1
trg = A の B から 1 を引いた値番目の C 番目に 1 を加えた値を A の B 番目の C 番目に する
rst = A の B から 1 を引いた値番目の C 番目に 1 を加えた値を A の B 番目の C 番目に する <eos>
1386
src = A = [ list ( map ( B . __getitem__ , C ) ) for C in D ]
trg = D の各要素を C とし 、 C の各要素に B の __ getitem __ を適用した列のリストの列を A とする
rst = D の各要素を C とし 、 C の各要素に B の __ getitem __ <unk> A とする <eos>
1387
src = if A . parent . left is A :
trg = A の parent の left が A と等しくないとき 、
rst = A の parent の left が A と等しくないとき 、 <eos>
1388
src = print ( A . pip [ 2 ] )
trg = A の pip の 2 番目を出力する
rst = A の pip の 2 番目を出力する <eos>
1389
src = A = [ list ( map ( int , readline ( ) . split ( ) ) ) + [ 1 ] for B in range ( C ) ]
trg = 0 から C 未満までの数列の各要素を B とし 、 readline () を空白で分割した字句列の各要素に 整数を適用した列のリストに (1) からなる列を加えた値の列を A とする
rst = 0 から C 未満までの数列の各要素を B とし 、 readline () を空白で分割した字句列の各要素に 整数を適用した列のリストの列を A とする <eos>
1390
src = if not A . readline ( ) :
trg = A から読み込んだ一行 でないとき 、
rst = A から読み込んだ一行を でないとき 、 <eos>
1391
src = A . birth_num = B
trg = B を A の birth _ num に する
rst = B を A の <unk> に する <eos>
1392
src = A . add_edge ( inM ( B ) , C , 1 )
trg = A . add _ edge ( inM ( B ) , C ,1)
rst = A . add _ edge ( add ( B ) , C ,1,1) <eos>
1393
src = print ( len ( A [ B : C ] ) )
trg = A の B 番目から C 番目までの部分列 の長さ を出力する
rst = A の B 番目から C 番目までの部分列 の長さ を出力する <eos>
1394
src = if not A . rt :
trg = A の rt でないとき 、
rst = A の rt でないとき 、 <eos>
1395
src = A = A // B
trg = A を B で割った商を A とする
rst = A を B で割った商を A とする <eos>
1396
src = A = sorted ( B , key = lambda C : ( C . imag , C . real ) )
trg = x をパラメータとして ( x の imag 、 x の real ) の組を返す関数をキーとして B をソートした列を A とする
rst = x をパラメータとして ( C の imag 、 x の real ) の組を返す関数をキーとして B をソートした列を A とする <eos>
1397
src = def cross ( A , B ) : return A . real * B . imag - A . imag * B . real
trg = 関数 cross を a 、 b をパラメータとして 定 義 する
rst = 関数 cross を self 、 p をパラメータとして 定 義 する <eos>
1398
src = print ( A + str ( B ) . zfill ( 2 ) )
trg = A に B の文字列を長さ 2 に な るように '0' 左 詰め した文字列を加えた値 を出力する
rst = A に B の文字列を長さ 2 に な るように '0' 左 詰め した文字列を出力する <eos>
1399
src = else = ( A / 100 + 1 ) ** B
trg = A を 100 で割った値に 1 を加えた値 の B 乗を そうでなければ 、 とする
rst = A を 100 で割った値に 1 を加えた値 の B 乗を そうでなければ 、 とする <eos>
1400
src = A [ 0 ] += B [ 0 ] + 1
trg = A の 0 番目を B の 0 番目に 1 を加えた値だけ 増 加 させ る
rst = A の 0 番目を B の先頭に 1 を加えた値だけ 増 加 させ る <eos>
1401
src = A . append ( ( B . count ( C ) , B . count ( D ) , B . count ( E ) , B [ 0 ] ) )
trg = A の末尾に ( B 内の C の出現回数 、 B 内の D の出現回数 、 B 内の E の出現回数 、 B の先頭 ) の組 を追加する
rst = A の末尾に ( B 内の C の出現回数 、 B 内の D の出現回数 、 B 内の E の出現回数 、 B 内の 0 の出現回数 ) の組 を追加する <eos>
1402
src = preParse ( A [ B ] . right )
trg = preParse ( A [ B ] . right )
rst = preParse ( A [ B ] . right ) <eos>
1403
src = A = B * C * math . sin ( math . pi * D / 180 ) / 2
trg = B に C を掛けた値に math . pi に D を掛けた値を 180 で割った値の正弦を掛けた値を 2 で割った値を A とする
rst = B に C を掛けた値に math . pi * D を 180 で割った値の正弦を掛けた値を 2 で割った値を A とする <eos>
1404
src = if A + B < ( C + D ) / 2 :
trg = A に B を加えた値が C に D を加えた値を 2 で割った値 より小さいとき 、
rst = A に B を加えた値が C に D を加えた値を 2 で割った値 より小さいとき 、 <eos>
1405
src = A = 9999999999999999
trg = 9999999999999999 を A とする
rst = <unk> を A とする <eos>
1406
src = A = sorted ( B . items ( ) , key = lambda C : ( C [ 1 ] , C [ 0 ] ) , reverse = True )
trg = x をパラメータとして ( x の 1 番目 、 x の先頭 ) の組 を返す関数をキーとして逆順に B のキーと値の集まりをソートした列 を A とする
rst = x をパラメータとして ( C の 1 番目 、 C の先頭 ) の組を返す関数をキーとして B のキーと値の集まりをソートした列 を A とする <eos>
1407
src = A [ B ] = B
trg = B を A の B 番目に する
rst = B を A の B 番目に する <eos>
1408
src = A = B + C + 2 * D
trg = B に C を加えた値に 2 に D を掛けた値を加えた値を A とする
rst = B に C を加えた値に 2 に D を掛けた値を加えた値を A とする <eos>
1409
src = A [ 0 ] -= B . lz
trg = A の 0 番目を B の lz だけ 減 少 させ る
rst = A の 0 番目を B の lz だけ 減 少 させ る <eos>
1410
src = A += time
trg = A を time だけ 増 加 させ る
rst = A を time だけ 増 加 させ る <eos>
1411
src = print ( A , B , C , D )
trg = A 、 B 、 C 、 D を出力する
rst = A 、 B 、 C 、 D を出力する <eos>
1412
src = A = [ 1 for B in range ( 10 ) ]
trg = 0 から 10 未満までの数列の各要素を B とし 、 1 の列を A とする
rst = 0 から 10 未満までの数列の各要素を B とし 、 1 の列を A とする <eos>
1413
src = A = B * sin ( radians ( C ) )
trg = B に C のラジアンの正弦を掛けた値を A とする
rst = B に C のラジアンの正弦を掛けた値 を A とする <eos>
1414
src = A = power ( B * B % C , D // 2 , C )
trg = power ( B * B % C , D //2, C ) を A とする
rst = power ( B * B % C , D //2) を A とする <eos>
1415
src = A . last = A . siz = 0
trg = 0 を A の siz とする を A の last に する
rst = 0 を A の last とする を A の last に する <eos>
1416
src = if A . count ( B ) == 0 or C . count ( B ) != 0 :
trg = A 内の B の出現回数が 0 と等しくまたは C 内の B の出現回数が 0 と等しくないとき 、
rst = A 内の B の出現回数が 0 と等しくまたは C 内の B の出現回数が 0 と等しくないとき 、 <eos>
1417
src = dfs ( A , B , C , D )
trg = dfs ( A , B , C , D )
rst = dfs ( A , B , C , D ) <eos>
1418
src = e = A [ B - C ]
trg = A の B から C を引いた値番目を ネイピア数とする
rst = A の B から C を引いた値をネイピア数とする <eos>
1419
src = A . st [ B ] = max ( A . st [ 2 * B + 1 ] , A . st [ 2 * B + 2 ] )
trg = A の st の 2 に B を掛けた値に 1 を加えた値番目 、 A の st の 2 に B を掛けた値に 2 を加えた値番目の最大値を A の st の B 番目に する
rst = A の st の 2 に B を掛けた値に 1 を加えた値番目 、 A の st の 2 に B を掛けた値に 2 を加えた値番目の最大値を A の st の B 番目に する <eos>
1420
src = A = [ list ( map ( int , I ( ) . split ( ) ) ) for B in range ( C ) ]
trg = 0 から C 未満までの数列の各要素を B とし 、 I () を空白で分割した字句列の各要素に 整数を適用した列のリストの列を A とする
rst = 0 から C 未満までの数列の各要素を B とし 、 I () を空白で分割した字句列の各要素に 整数を適用した列のリストの列を A とする <eos>
1421
src = A [ - 2 ] = A [ - 2 ] * A [ - 1 ]
trg = A の -2 番目に A の末尾を掛けた値を A の -2 番目に する
rst = A の -2 番目に A の -1 番目を掛けた値を A の -2 番目に する <eos>
1422
src = A = [ [ False for B in range ( 13 ) ] for C in range ( 4 ) ]
trg = 0 から 4 未満までの数列の各要素を C とし 、0 から 13 未満までの数列の各要素を B とし 、 、 つまり偽の列の列 を A とする
rst = 0 から 4 未満までの数列の各要素を C とし 、0 から 13 未満までの数列の各要素を B とし 、 、 つまり偽の列の列 の列を A とする <eos>
1423
src = A = dot ( B , C ) / dot ( C , C )
trg = dot ( B , C ) を dot ( C , C ) で割った値を A とする
rst = dot ( B , C ) を dot ( C , C ) で割った値を A とする <eos>
1424
src = A = [ B . s - C + B . w for B in D ]
trg = D の各要素を B とし 、 B の s から C を引いた値に B の w を加えた値の列を A とする
rst = D の各要素を B とし 、 B の s から C を引いた値に B の w を加えた値の列を A とする <eos>
1425
src = A , B = selection_sort ( A )
trg = selection _ sort ( A ) を展開し 、 それぞれ A 、 B とする
rst = selection _ sort ( A ) を展開し 、 それぞれ A 、 B とする <eos>
1426
src = A = ( 1 , 5 , 10 , 50 , 100 , 500 )
trg = (1、5、 10、50、100、500) の組を A とする
rst = ( <unk> の組を A とする <eos>
1427
src = A . v = Vector ( 0 , - B / C )
trg = Vector (0,- B / C ) を A の v に する
rst = Vector (0,0, B / C ) を A の v に する <eos>
1428
src = A += str ( B [ 2 ] * - 1 )
trg = A を B の 2 番目に -1 を掛けた値の文字列 だけ 増 加 させ る
rst = A を B の 2 番目に -1 を掛けた値だけ 増 加 させ る <eos>
1429
src = A -= B . get_weight ( C )
trg = A を B . get _ weight ( C ) だけ 減 少 させ る
rst = A を B . get _ weight ( C ) だけ 減 少 させ る <eos>
1430
src = A = 3 * B + C % 3
trg = 3 に B を掛けた値に C を 3 で割った余りを加えた値を A とする
rst = 3 に B を掛けた値に C を 3 で割った余りを加えた値を A とする <eos>
1431
src = return ( 0 , [ 0 ] )
trg = (0、 (0) からなる列 ) の組を返す
rst = (0、( [0]) の組を返す <eos>
1432
src = A , B , C = int ( D [ 1 ] + D [ 2 ] , 16 ) , int ( D [ 3 ] + D [ 4 ] , 16 ) , int ( D [ 5 ] + D [ 6 ] , 16 )
trg = 16 進 表 記 D の 1 番目に D の 2 番目を加えた値の整数値 、 16 進 表 記 D の 3 番目に D の 4 番目を加えた値の整数値 、 16 進 表 記 D の 5 番目に D の 6 番目を加えた値の整数値を A 、 B 、 C とする
rst = 16 進 表 記 D [1]- D [1], int ( D ) 、 int ( D [1], int ( D ) ] + 16 進 表 記 、 int ( D [ B ] ) を A 、 B 、 C とする <eos>
1433
src = A = [ int ( input ( ) ) for B in range ( 10 ) ]
trg = 0 から 10 未満までの数列の各要素を B とし 、 、 つまり入力された文字列の整数値 の列を A とする
rst = 0 から 10 未満までの数列の各要素を B とし 、 、 つまり入力された文字列の整数値 の列を A とする <eos>
1434
src = A = [ [ [ None ] * [ ( B + 1 ) for C in range ( D + 1 ) ] ] for C in range ( E + 1 ) ]
trg = 0 から E に 1 を加えた値未満までの数列の各要素 を C とし 、(( 、 つまり未定値 ) からなる列の 0 から D +1 未満までの数列の各要素を C とし 、 B に 1 を加えた値の列回分の列 ) からなる列の列を A とする
rst = 0 から E に 1 を加えた値未満までの数列の各要素 を C とし 、 ( 、 つまり未定値 ) からなる列の 0 から D +1 未満までの数列の各要素を C とし 、 B に 1 を加えた値の列回分の列 ) からなる列の列を A とする <eos>
1435
src = if not A & B [ C ] :
trg = A と B の C 番目 の論理積でないとき 、
rst = A と B の C 番目の長さ でないとき 、 <eos>
1436
src = bst_inorder ( A )
trg = bst _ inorder ( A )
rst = bst _ inorder ( A ) <eos>
1437
src = print ( A . format ( B . bottom ) )
trg = A を書式として B の bottom で整形した文字列を出力する
rst = A を書式として B の bottom で整形した文字列を出力する <eos>
1438
src = A = [ 0 , 1 ] [ B == C [ 0 ] ]
trg = (0、1) からなる列の B が C の先頭 と等しいかどうか番目を A とする
rst = (0、1) からなる列の B が C の 0 番目と等しいかどうかが A ) からなる列を A とする <eos>
1439
src = A . number [ 1 ] = B
trg = B を A の number の 1 番目に する
rst = B を A の number の 1 番目に する <eos>
1440
src = if A [ 0 ] == B and A [ 4 ] == B and A [ 8 ] == B :
trg = A の 0 番目が B と等しくかつ A の 4 番目が B と等しくかつ A の 8 番目が B と等しいとき 、
rst = A の 0 番目が B と等しくかつ A の 4 番目が B と等しくかつ A の 8 番目が B と等しいとき 、 <eos>
1441
src = if A == 0 and B >= C :
trg = A が 0 と等しくかつ B が C 以上のとき 、
rst = A が 0 と等しくかつ B が C 以上のとき 、 <eos>
1442
src = A = B . size // 2
trg = B の size を 2 で割った商を A とする
rst = B の size を 2 で割った商を A とする <eos>
1443
src = A . append ( str ( query ( B , C + 1 ) ) )
trg = A の末尾に query ( B , C +1) の文字列 を追加する
rst = A の末尾に query ( B , C +1) を追加する <eos>
1444
src = if A . cur . prev != None :
trg = A の cur の prev が 、 つまり未定値と等しくないとき 、
rst = A の cur の prev が 、 つまり未定値と等しくないとき 、 <eos>
1445
src = A = Counter ( ( [ ( B + C ) % D for B , C in zip ( E , F ) ] ) )
trg = E 、 F の要素をそれぞれ組にした列 の各要素を B 、 C とし 、 B に C を加えた値を D で割った余りの列 の 辞書 カ ウ ンタを A とする
rst = E 、 F の要素をそれぞれ組にした列 の各要素を B 、 C とし 、 B に C を加えた値を D で割った余りの列 の列の 辞書 カ ウ ンタを A とする <eos>
1446
src = print ( int ( A . data == 0 ) )
trg = A の data が 0 と等しいかどうかの整数値 を出力する
rst = A の data が 0 と等しいかどうかの整数値 を出力する <eos>
1447
src = print ( ( ( A - 1 ) // 1000 + 1 ) * B )
trg = A から 1 を引いた値を 1000 で割った商に 1 を加えた値に B を掛けた値を出力する
rst = A から 1 を引いた値を 1000 で割った商に 1 を加えた値に B を掛けた値を出力する <eos>
1448
src = A . append ( sum ( [ 1 << B for B in C ] ) )
trg = A の末尾に C の各要素を B とし 、 1 を B だけ左シフトした値の列の総和を 追加する
rst = A の末尾に C の各要素を B とし 、 1 を B だけ左シフトした値の列の総和を 追加する <eos>
1449
src = A = max ( A , check ( B , C ) )
trg = A 、 check ( B , C ) の最大値を A とする
rst = A 、 check ( B , C ) の最大値を A とする <eos>
1450
src = A . iter = [ 0 ] * A . V
trg = (0) からなる列の A の V 回分の列を A の iter に する
rst = (0) からなる列の A の V 回分の列を A の iter に する <eos>
1451
src = A , B , C = D . pop ( )
trg = D の先頭を取り出した値 を展開し 、 それぞれ A 、 B 、 C とする
rst = D の先頭を取り出した値 を展開し 、 それぞれ A 、 B 、 C とする <eos>
1452
src = return chi_liu_edmonds ( A , B , C [ D ] ) + cycle_cost ( E , F )
trg = chi _ liu _ edmonds ( A , B , C [ D ] ) に cycle _ cost ( E , F ) を加えた値を返す
rst = <unk> ( A , B , C [ D ] ) に <unk> ( E , F ) を加えた値を返す <eos>
1453
src = if A <= B <= C and abs ( ( D - E ) * ( C - A ) - ( B - A ) * ( F - E ) ) < 1e-6 :
trg = A が B 以下かどうかが C 以下かつ ( D - E ) に ( C - A ) を掛けた値から ( B - A ) に ( F - E ) を掛けた値を引いた値の絶対値が 1 e -6 より小さいとき 、
rst = A が B 以下かどうかが C 以下かつ ( D - E ) に ( C - A ) を掛けた値から ( B - E ) に ( F - A ) を掛けた値を引いた値の絶対値が 1 e -6 より小さいとき 、 <eos>
1454
src = if A * 2 <= B :
trg = A に 2 を掛けた値が B 以下のとき 、
rst = A に 2 を掛けた値が B 以下のとき 、 <eos>
1455
src = A , B = ( A , B ) if A < B else ( B , A )
trg = A が B より小さいとき ( A 、 B ) の組 、 そうでなければ ( B 、 A ) の組 を展開し 、 それぞれ A 、 B とする
rst = A が B より小さいとき ( A 、 B ) の組 、 そうでなければ ( B 、 A ) の組 を展開し 、 それぞれ A 、 B とする <eos>
1456
src = A . _add_index ( A . tail . prev )
trg = A ._ add _ index ( A . tail . prev )
rst = A . tail . prev _ roll ( A . tail . prev ) <eos>
1457
src = A = B + C + math . sqrt ( B * B + C * C - 2 * B * C * math . cos ( D ) )
trg = B に C を加えた値に B に B を掛けた値に C に C を掛けた値を加えた値から 2* B に C を掛けた値に D の余弦を掛けた値を引いた値 の平方根を加えた値を A とする
rst = B に C を加えた値に B * B に C * C に 2 を掛けた値を加えた値に D に math . fabs ( B * C ) を掛けた値を引いた値の平方根を A とする <eos>
1458
src = print ( find ( A , B + 1 ) )
trg = find ( A , B +1) を出力する
rst = find ( A , B +1) を出力する <eos>
1459
src = A = ( A + B ) % 4
trg = A に B を加えた値を 4 で割った余りを A とする
rst = A に B を加えた値を 4 で割った余りを A とする <eos>
1460
src = A . append ( ( B + 1 , ( C , D ) ) )
trg = A の末尾に ( B に 1 を加えた値 、 ( C 、 D ) の組 ) の組 を追加する
rst = A の末尾に ( B に 1 を加えた値 、 C 、 D ) の組 を追加する <eos>
1461
src = if A [ 1 ] == int ( B [ 1 ] ) :
trg = A の 1 番目が B の 1 番目の整数値 と等しいとき 、
rst = A の 1 番目が B の 1 番目の整数値 と等しいとき 、 <eos>
1462
src = A = ( 1 , - 1 , B + 2 , - B - 2 )
trg = (1、-1、 B に 2 を加えた値 、 - B から 2 を引いた値 ) の組を A とする
rst = ( 1 から 1 を引いた値 、 B に 2 を加えた値 、 - B から 2 を引いた値 ) の組を A とする <eos>
1463
src = D [ B ] = - 1
trg = -1 を D の B 番目に する
rst = -1 を D の B 番目に する <eos>
1464
src = A = ( 1 , 0 , - 1 , 0 )
trg = (1、0、-1、0) の組を A とする
rst = ( 1 、0、1、-1、1、-1、0、 0 ) の組を A とする <eos>
1465
src = for A in range ( len ( B . graph [ C ] ) ) :
trg = 0 から B の graph の C 番目 の長さ未満までの数列を順に A として 、 繰り返 す
rst = 0 から B の graph の C 番目 の長さ未満までの数列を順に A として 、 繰り返 す <eos>
1466
src = add ( A , B [ 0 ] , - B [ 2 ] * ( B [ 0 ] - 1 ) )
trg = add ( A , B [0], - B [2]* ( B [0]-1) )
rst = add ( A , B [0], - B [2]) に B の 0 番目から 1 を引いた値 を追加した集まり <eos>
1467
src = push ( A , ( B [ C - 2 ] [ D - 1 ] , C - 1 , D ) )
trg = push ( A , ( B [ C -2 ] [ D -1], C -1, D ))
rst = push ( A , ( B [ C -1][ D -1], C -1, D )) <eos>
1468
src = A = setHight ( B , C [ D ] [ 1 ] ) + 1
trg = setHight ( B , C [ D ][1]) に 1 を加えた値を A とする
rst = setHight ( B , C [ D ][1]) に 1 を加えた値を A とする <eos>
1469
src = A = _min ( B , C , D , E )
trg = _ min ( B , C , D , E ) を A とする
rst = _ min ( B , C , D , E ) を A とする <eos>
1470
src = A = [ Piece ( 0 ) ]
trg = ( Piece (0) ) からなる列を A とする
rst = ((0、0) の組 ) からなる列を A とする <eos>
1471
src = A [ B ] += ( C - D )
trg = A の B 番目を C から D を引いた値だけ 増 加 させ る
rst = A の B 番目を C から D を引いた値だけ 増 加 させ る <eos>
1472
src = write ( A % ( B [ 1 ] - 6 ) )
trg = write ( A %( B [1]- 6))
rst = write ( A %( B <unk> ) <eos>
1473
src = print ( ( '' . join ( [ str ( A ) . rjust ( 4 ) for A in B ] ) ) )
trg = 空文字列を間に入れて B の各要素を A とし 、 str ( A ) . rjust (4) の列を連結した文字列を出力する
rst = 空文字列を間に入れて B の各要素を A とし 、 str ( A ) . rjust (4) . rjust (4) の列を連結した文字列を出力する <eos>
1474
src = A = [ ( B + C , D ) ]
trg = ( ( B に C を加えた値 、 D ) の組 ) からなる列を A とする
rst = ( ( B に C を加えた値 、 D ) の組 ) からなる列を A とする <eos>
1475
src = A = [ ( 0 , 0 ) , ( - 1 , 1 ) , ( 0 , 1 ) , ( 1 , 1 ) , ( 0 , 2 ) ]
trg = ((0、0) の組 、(-1、1) の組 、(0、1) の組 、(1、1) の組 、(0、2) の組 ) からなる列を A とする
rst = ((0、0) の組 、(0、-1) の組 、(1、0) の組 、(0、1) の組 、(1、1) の組 ) からなる列を A とする <eos>
1476
src = A , B , C , D , E = map ( int , open ( 0 ) . read ( ) . split ( ) )
trg = 0 を開いたファイルストリーム から読み込んだ デ ータ を空白で分割した字句列の各要素に 整数を適用した列を展開し 、 それぞれ A 、 B 、 C 、 D 、 E とする
rst = 0 を開いたファイルストリーム から読み込んだ デ ータを空白で分割した字句列 の各要素に整数を適用した列を ( A 、 B 、 C 、 D 、 E とする <eos>
1477
src = A += max ( B [ : A + 1 ] )
trg = A を B の 、 つまり先頭から A に 1 を加えた値までの部分列の最大値 だけ 増 加 させ る
rst = A を B の 、 つまり先頭から A に 1 を加えた値までの部分列の最大値 だけ 増 加 させ る <eos>
1478
src = A = check ( B , C )
trg = check ( B , C ) を A とする
rst = check ( B , C ) を A とする <eos>
1479
src = if ( A >> B ) & 1 < 1 :
trg = A を B だけ右シフトした値と 1 の論理積が 1 より小さいとき 、
rst = A を B だけ右シフトした値と 1 の論理積が 1 より小さいとき 、 <eos>
1480
src = if A != 0 and B - C >= 3 :
trg = A が 0 と等しくなくかつ B から C を引いた値が 3 以上のとき 、
rst = A が 0 と等しくなくかつ B から C を引いた値が 3 以上のとき 、 <eos>
1481
src = C = B + A
trg = B に A を加えた値を C とする
rst = B に A を加えた値を C とする <eos>
1482
src = A [ B ] [ C ] = min ( A [ B ] [ C ] , D + E )
trg = A の B 番目の C 番目 、 D に E を加えた値の最小値を A の B 番目の C 番目に する
rst = A の B 番目の C 番目 、 D に E を加えた値の最小値を A の B 番目の C 番目に する <eos>
1483
src = A . node_id = B
trg = B を A の node _ id に する
rst = B を A の <unk> に する <eos>
1484
src = A = cross ( B - C , C - D )
trg = cross ( B - C , C - D ) を A とする
rst = cross ( B - C , C - D ) を A とする <eos>
1485
src = A = max ( [ B [ 1 ] for B in C ] )
trg = C の各要素を B とし 、 B の 1 番目の列の最大値を A とする
rst = C の各要素を B とし 、 B の 1 番目の列の最大値を A とする <eos>
1486
src = print ( ' ' . join ( [ A [ 0 ] for A in B [ : 5 ] ] ) )
trg = 空白文字を間に入れて B の 、 つまり先頭から 5 番目までの部分列の各要素を A とし 、 A の 0 番目 の列を連結した文字列を出力する
rst = 空白文字を間に入れて B の 、 つまり先頭から 5 番目までの部分列の各要素を A とし 、 A の 0 番目 の列を連結した文字列を出力する <eos>
1487
src = A += 9
trg = A を 9 だけ 増 加 させ る
rst = A を 9 だけ 増 加 させ る <eos>
1488
src = A = gcd ( abs ( B - C ) , D )
trg = B から C を引いた値の絶対値と D の最大公約数を A とする
rst = B から C を引いた値の絶対値 の最大公約数を A とする <eos>
1489
src = A . append ( max ( B ) )
trg = A の末尾に B の最大値 を追加する
rst = A の末尾に B の最大値 を追加する <eos>
1490
src = return [ 0 , 0 ]
trg = (0、0) からなる列を返す
rst = (0、0) からなる列を返す <eos>
1491
src = A = int ( B [ 5 : ] )
trg = B の 5 番目から 、 つまり末尾までの部分列の整数値を A とする
rst = B の 5 番目から 、 つまり末尾までの部分列の整数値を A とする <eos>
1492
src = A = { 1 : B , 2 : C , 3 : D , 4 : E , 5 : F }
trg = ( (1, B )、( 2 , C )、( 3 , D ) 、 (4, E )、( 5 , F )) からなる辞書を A とする
rst = ( (1, B )、( 2 , C )、( 3 , D ) 、 (4, E )、( 5 , F )) からなる辞書を A とする <eos>
1493
src = print ( A . format ( B . distance ( C ) ) )
trg = A を書式として B . distance ( C ) で整形した文字列を出力する
rst = A を書式として B . distance ( C ) で整形した文字列を出力する <eos>
1494
src = else = count
trg = 無限の整数列を そうでなければ 、 とする
rst = 無限の整数列を そうでなければ 、 とする <eos>
1495
src = A = [ 0 ] + [ 20 , 19 ] * 5 if B % 3 else [ 0 ] + [ 20 ] * 10
trg = (0) からなる列に ( 2 0、19) からなる列の B を 3 で割った余りのとき 5 、 そうでなければ (0) からなる列に [ 20 ] の 10 回分の列を 加えた値回分の列を加えた値を A とする
rst = (0) からなる列に B を 3 で割った余りのとき 20 に 5 を掛けた値 、 そうでなければ (0) からなる列の B を 3 で割った余りに 550 回分の列を加えた値を A とする <eos>
1496
src = A = [ 0 for B in range ( 2 ** C ) ]
trg = 0 から 2 の C 乗未満までの数列の各要素を B とし 、0 の列を A とする
rst = 0 から 2 の C 乗未満までの数列の各要素を B とし 、0 の列を A とする <eos>
1497
src = if count - A + 1 >= 0 :
trg = 無限の整数列 から A を引いた値に 1 を加えた値が 0 以上のとき 、
rst = 無限の整数列が - A に 1 を加えた値が 0 以上のとき 、 <eos>
1498
src = if ord ( A ) <= ord ( B ) :
trg = A の順序数が B の順序数 以下のとき 、
rst = A <unk> B 以下のとき 、 <eos>
1499
src = if A * B < 0 and C * D < 0 :
trg = A に B を掛けた値が 0 より小さくかつ C に D を掛けた値が 0 より小さいとき 、
rst = A に B を掛けた値が 0 より小さくかつ C に D を掛けた値が 0 より小さいとき 、 <eos>
1500
src = if A . dist <= B :
trg = A の dist が B 以下のとき 、
rst = A の dist が B 以下のとき 、 <eos>
1501
src = A = str ( B [ 0 ] . num )
trg = B の先頭の num の文字列を A とする
rst = B の先頭の num を A とする <eos>
1502
src = A . append ( B [ C . to_hash ( ) ] )
trg = A の末尾に B の C . to _ hash () 番目を追加する
rst = A の末尾に B の C . fold _ all () を追加する <eos>
1503
src = if dfs ( A + 1 , B , C , D ) :
trg = dfs ( A +1, B , C , D ) のとき 、
rst = dfs ( A +1, B , C , D ) のとき 、 <eos>
1504
src = A = str ( B + 1 ) + ' ' + str ( C + 1 )
trg = B に 1 を加えた値 の文字列に空白文字を加えた値に C に 1 を加えた値の文字列を加えた値を A とする
rst = B に 1 を加えた値 の文字列に空白文字を加えた値に C に 1 を加えた値の文字列を加えた値を A とする <eos>
1505
src = A , B = [ int ( A ) for A in input ( ) . split ( ) ]
trg = 入力された文字列 を空白で分割した字句列の各要素を A とし 、 A の整数値の列を展開し 、 それぞれ A 、 B とする
rst = 入力された文字列 を空白で分割した字句列の各要素を A とし 、 A の整数値の列を展開し 、 それぞれ A 、 B とする <eos>
1506
src = if A . cur == A . nil :
trg = A の cur が A の nil と等しいとき 、
rst = A の cur が A の nil と等しいとき 、 <eos>
1507
src = if A [ B ] [ C ] [ D ] != - 1 :
trg = A の B 番目の C 番目の D 番目が -1 と等しくないとき 、
rst = A の B 番目の C 番目の D 番目が -1 と等しくないとき 、 <eos>
1508
src = A = min ( A , 1 )
trg = A 、 1 の最小値を A とする
rst = A 、 1 の最小値を A とする <eos>
1509
src = return A . bgn . add ( B )
trg = A の bgn に B を追加した集まり を返す
rst = A の bgn に B を追加した集まり <eos>
1510
src = add ( '\n' )
trg = add ( '\ n ')
rst = add ( '\ n <unk> <eos>
1511
src = changeBoard ( A , B , C , 1 )
trg = changeBoard ( A , B , C ,1)
rst = <unk> ( A , B , C ,1,1) <eos>
1512
src = A = [ float ( B ) for B in C [ D ] . split ( ) ]
trg = C の D 番目 を空白で分割した字句列の各要素を B とし 、 B の浮動小数点数の列を A とする
rst = C の D 番目 を空白で分割した字句列の各要素を B とし 、 B の浮動小数点数の列を A とする <eos>
1513
src = A += B * ( 5 - len ( A ) % 5 )
trg = A を B に 5 から A の長さを 5 で割った余り を引いた値を掛けた値だけ 増 加 させ る
rst = A を B に 5 から A の長さを 5 で割った余り を引いた値を掛けた値だけ 増 加 させ る <eos>
1514
src = E , F = C [ G ]
trg = C の G 番目を展開し 、 それぞれ E 、 F とする
rst = C の G 番目を展開し 、 それぞれ E 、 F とする <eos>
1515
src = A . prev . next = B . tail
trg = B の tail を A の prev の next に する
rst = B の tail を A の prev の next に する <eos>
1516
src = A = B + C + D [ E ]
trg = B に C を加えた値に D の E 番目を加えた値を A とする
rst = B に C を加えた値に D の E 番目を加えた値を A とする <eos>
1517
src = for A in sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) :
trg = 入力された文字列 を空白で分割した字句列の各要素に 整数を適用した列のリスト をソートした列を順に A として 、 繰り返 す
rst = 入力された文字列 を空白で分割した字句列の各要素に 整数を適用した列のリスト を順に A として 、 繰り返 す <eos>
1518
src = A = B . readline ( ) . split ( ) + [ C , C ]
trg = B から読み込んだ一行を 空白で分割した字句列 に ( C 、 C ) からなる列を加えた値を A とする
rst = B から読み込んだ一行 を空白で分割した字句列の各要素に 整数を適用した列のリストに ( C ) からなる列を加えた値を A とする <eos>
1519
src = register ( A , B , C , 5 )
trg = register ( A , B , C ,5)
rst = register ( A , B , C , 5 ) <eos>
1520
src = print ( A . format ( B , '' . join ( C ) ) )
trg = A を書式として B 、 空文字列を間に入れて C を連結した文字列 で整形した文字列を出力する
rst = A を書式として B 、 空文字列を間に入れて C を連結した文字列 で整形した文字列を出力する <eos>
1521
src = if A == A & B :
trg = A が A と B の論理積 と等しいとき 、
rst = A が A と B の論理積のとき 、 <eos>
1522
src = print ( A . format ( len ( B ) ) + ' ' . join ( [ str ( C [ 1 ] ) for C in B ] ) )
trg = A を書式として B の長さで整形した文字列 に空白文字を間に入れて B の各要素を C とし 、 C [1] の文字列の列を連結した文字列 を加えた値を出力する
rst = A を書式として B の長さ の文字列に空白文字を加えた値に C の 1 番目 の文字列を加えた値を出力する <eos>
1523
src = if A [ - 1 ] == B or A [ - 1 ] == C :
trg = A の -1 番目が B と等しくまたは A の -1 番目が C と等しいとき 、
rst = A の -1 番目が B と等しくまたは A の -1 番目が C と等しいとき 、 <eos>
1524
src = print ( E if in_triangle ( A , B , C , D ) else F )
trg = in _ triangle ( A , B , C , D ) のとき E 、 そうでなければ F を出力する
rst = <unk> ( A , B , C , D ) のとき E 、 そうでなければ F を出力する <eos>
1525
src = A , B , C = map ( int , readline ( ) . split ( ) )
trg = readline () を空白で分割した字句列の各要素に 整数を適用した列を展開し 、 それぞれ A 、 B 、 C とする
rst = readline () を空白で分割した字句列の各要素に 整数を適用した列を展開し 、 それぞれ A 、 B 、 C とする <eos>
1526
src = print ( sum ( [ A * 10 ** ( B + 1 ) // C % 10 for B in range ( D ) ] ) )
trg = 0 から D 未満までの数列の各要素を B とし 、 A *10** ( B +1) を C で割った商を 10 で割った余り の列の総和を出力する
rst = 0 から D 未満までの数列の各要素を B とし 、 A * B +1 の B 乗に C を 10 で割った商 乗 の列の総和を出力する <eos>
1527
src = A = bubble_sort ( B [ : ] )
trg = bubble _ sort ( B [:]) を A とする
rst = bubble _ sort ( B [:]) を A とする <eos>
1528
src = A . face = list ( map ( int , input ( ) . split ( ) ) )
trg = 入力された文字列 を空白で分割した字句列の各要素に 整数を適用した列のリストを A の face に する
rst = 入力された文字列 を空白で分割した字句列の各要素に 整数を適用した列のリストを A の face に する <eos>
1529
src = for A in range ( min ( B + 1 - C , 10 ) ) :
trg = 0 から B に 1 を加えた値から C を引いた値 、 10 の最小値 未満までの数列を順に A として 、 繰り返 す
rst = 0 から B に 1 を加えた値から C を引いた値 、 10 の最小値 未満までの数列を順に A として 、 繰り返 す <eos>
1530
src = A = B . index ( False )
trg = B の 、 つまり偽 と等しい要素の最初の位置を A とする
rst = B の 、 つまり偽の列 を A とする <eos>
1531
src = A = B // 10
trg = B を 10 で割った商を A とする
rst = B を 10 で割った商を A とする <eos>
1532
src = A = B . _flip_colors ( A )
trg = B ._ flip _ colors ( A ) を A とする
rst = B ._ flip _ colors ( A ) を A とする <eos>
1533
src = print ( A . format ( B ) + ' ' + A . format ( C ) )
trg = A を書式として B で整形した文字列 に空白文字を加えた値に A を書式として C で整形した文字列 を加えた値を出力する
rst = A を書式として B で整形した文字列 に空白文字を加えた値に A を書式として C で整形した文字列を出力する <eos>
1534
src = A , B , C , D = list ( map ( int , input ( ) . split ( E ) ) )
trg = 入力された文字列を E で分割した字句列の各要素に 整数を適用した列のリストを展開し 、 それぞれ A 、 B 、 C 、 D とする
rst = 入力された文字列を E で分割した字句列の各要素に 整数を適用した列のリストを展開し 、 それぞれ A 、 B 、 C 、 D とする <eos>
1535
src = A . node [ B ] = min ( A . node [ 2 * B + 1 ] , A . node [ 2 * B + 2 ] )
trg = A の node の 2 に B を掛けた値に 1 を加えた値番目 、 A の node の 2 に B を掛けた値に 2 を加えた値番目の最小値を A の node の B 番目に する
rst = A の node の 2 に B を掛けた値に 1 を加えた値番目 、 A の node の B に 2 を掛けた値に 2 を加えた値番目の最小値を A の node の B 番目に する <eos>
1536
src = if A > B - A :
trg = A が B から A を引いた値 より大きいとき 、
rst = A が B から A を引いた値 より大きいとき 、 <eos>
1537
src = A = vec ( B , C )
trg = vec ( B , C ) を A とする
rst = <unk> ( B , C ) を A とする <eos>
1538
src = A [ B [ 0 ] ] = [ int ( B [ 1 ] ) * 3 + int ( B [ 3 ] ) , - C ]
trg = ( B の 1 番目の整数値に 3 を掛けた値に B の 3 番目の整数値 を加えた値 、 - C ) からなる列を A の B の先頭番目に する
rst = ( B の 1 番目の整数値に 3 を掛けた値に B の 3 番目の整数値 、 B の C から 3 を引いた値番目 ) からなる列を A の B の先頭番目に する <eos>
1539
src = A . append ( [ B + C [ D ] [ 0 ] , E + C [ D ] [ 1 ] ] )
trg = A の末尾に ( B に C の D 番目の先頭を加えた値 、 E に C の D 番目の 1 番目を加えた値 ) からなる列 を追加する
rst = A の末尾に ( B に C の D 番目の先頭 、 E に C の D 番目の 1 番目を加えた値 ) からなる列 を追加する <eos>
1540
src = bomb ( A , B + C , D )
trg = bomb ( A , B + C , D )
rst = bomb ( A , B + C , D ) <eos>
1541
src = A [ 0 ] [ B ] . append ( ( C , D ) )
trg = A の先頭の B 番目の末尾に ( C 、 D ) の組 を追加する
rst = A の先頭の B 番目の末尾に ( C 、 D ) の組 を追加する <eos>
1542
src = A = B . _nodes [ B . cur * 2 - 1 ]
trg = B の _ nodes の B の cur に 2 を掛けた値から 1 を引いた値番目を A とする
rst = B の _ nodes の B の cur に 2 を掛けた値から 1 を引いた値番目を A とする <eos>
1543
src = A = B . _red_left ( A )
trg = B ._ red _ left ( A ) を A とする
rst = B ._ right _ rotate ( A ) を A とする <eos>
1544
src = A = ( B [ C - 1 ] + D - 1 ) % 7
trg = B の C から 1 を引いた値番目に D を加えた値から 1 を引いた値を 7 で割った余りを A とする
rst = B の C から 1 を引いた値番目に D を加えた値から 1 を引いた値を 7 で割った余りを A とする <eos>
1545
src = topologicalSort_w ( A )
trg = topologicalSort _ w ( A )
rst = <unk> ( A ) <eos>
1546
src = del A [ B - 1 ] [ 0 ]
trg = A の B から 1 を引いた値番目の先頭を 削 除 する
rst = A の B から 1 番目の先頭番目を 削 除 する <eos>
1547
src = if A [ B + C ] [ D ] :
trg = A の B に C を加えた値番目の D 番目のとき 、
rst = A の B に C を加えた値番目の D 番目のとき 、 <eos>
1548
src = if count [ A [ B ] ] == 1 and A [ B ] <= C :
trg = 無限の整数列の A の B 番目番目が 1 と等しくかつ A の B 番目が C 以下のとき 、
rst = 無限の整数列の A の B 番目番目が 1 と等しくかつ A の B 番目が C 以下のとき 、 <eos>
1549
src = A = [ - e for e in B ]
trg = B の各要素をネイピア数 とし 、 - 、 つまりネイピア数の列を A とする
rst = B の各要素をネイピア数 とし 、 - 、 つまりネイピア数から B を引いた値の列を A とする <eos>
1550
src = print ( A % ( B , C * D [ B ] ) )
trg = A を ( B 、 C に D の B 番目を掛けた値 ) の組で割った余り を出力する
rst = A を ( B 、 C に D の B 番目を掛けた値を加えた値 ) の組で割った余り を出力する <eos>
1551
src = for A in range ( 31 ) [ : : - 1 ] :
trg = 0 から 31 未満までの数列の逆順 を順に A として 、 繰り返 す
rst = 0 から 31 未満までの数列の逆順 を順に A として 、 繰り返 す <eos>
1552
src = A , B = C [ D ] , D
trg = C の D 番目 、 D を A 、 B とする
rst = C の D 番目 、 D を A 、 B とする <eos>
1553
src = print ( ( A * ( 4 * B * B - A * A ) ** .5 + 2 * B * ( ( B + C ) ** 2 - B * B ) ** .5 ) / 4 )
trg = A に (4* B * B - A * A ) の .5 乗を掛けた値に 2 に B を掛けた値に ( ( B + C ) **2- B * B ) の .5 乗を掛けた値を加えた値を 4 で割った値 を出力する
rst = A に 4* B * B * B から A * * * * * * B に B * B を加えた値 の .5 <unk> B * B に B * C を加えた値を出力する <eos>
1554
src = A [ B + C [ D ] ] = A [ B ] + 1
trg = A の B 番目に 1 を加えた値を A の B に C の D 番目 を加えた値番目に する
rst = A の B 番目に 1 を加えた値を A の B に C の D 番目 を加えた値番目に する <eos>
1555
src = print ( A / 3.305785 )
trg = A を 3.305785 で割った値 を出力する
rst = A を 3.305785 で割った値 を出力する <eos>
1556
src = A = 100
trg = 100 を A とする
rst = 100 を A とする <eos>
1557
src = if A & ( B << 1 ) :
trg = A と B を 1 だけ左シフトした値の論理積のとき 、
rst = A と B を 1 だけ左シフトした値の論理積のとき 、 <eos>
1558
src = D = A - B
trg = A から B を引いた値を D とする
rst = A から B を引いた値を D とする <eos>
1559
src = heappush ( A , ( e , B ) )
trg = heappush ( A , ( e , B ))
rst = heappush ( A , ( e , B )) <eos>
1560
src = A = dfs ( B [ : ] , 4 )
trg = dfs ( B [:], 4) を A とする
rst = dfs ( B [:], 4 ) を A とする <eos>
1561
src = A . e = e
trg = ネイピア数を A の e に する
rst = ネイピア数を A の e に する <eos>
1562
src = A [ B ] [ B + 1 ] = A [ B + 1 ] [ B ] = 1
trg = 1 を A の B に 1 を加えた値番目の B 番目とするを A の B 番目の B に 1 を加えた値番目に する
rst = 1 を A の B に 1 を加えた値番目の B に 1 を加えた値番目とする を A の B 番目の B に 1 を加えた値番目に する <eos>
1563
src = print ( A . format ( B [ C // 2 ] ) , end = '' )
trg = 改行せずに A を書式として B の C を 2 で割った商 番目で整形した文字列を出力する
rst = 改行せずに A を書式として B の C を 2 で割った商 で整形した文字列を出力する <eos>
1564
src = A += B [ C ] [ 0 ] + B [ C ] [ 2 ]
trg = A を B の C 番目の 0 番目に B の C 番目の 2 番目を加えた値 だけ 増 加 させ る
rst = A を B の C 番目の 0 番目に B の C 番目の 2 番目を加えた値 だけ 増 加 させ る <eos>
1565
src = A = [ ( 0 , B ) ]
trg = ((0、 B ) の組 ) からなる列を A とする
rst = ((0、 B ) の組 ) からなる列を A とする <eos>
1566
src = A [ B ] = F if ( ( C >> ( D - B ) ) & 1 ) == E [ B - 1 ] else G
trg = C を D から B を引いた値 だけ右シフトした値と 1 の論理積が E の B から 1 を引いた値番目と等しいとき F 、 そうでなければ G を A の B 番目に する
rst = C を D から B を引いた値 だけ右シフトした値と 1 の論理積が E と等しいとき F 、 そうでなければ F の B から 1 を引いた値番目を A の B 番目に する <eos>
1567
src = A = [ [ 0 , B , C ] + [ 0 ] * [ D for C in range ( E + 1 ) ] ]
trg = ((0、 B 、 C ) からなる列に (0) からなる列の 0 から E +1 未満までの数列の各要素を C とし 、 D の列回分の列を加えた値 ) からなる列を A とする
rst = 0 から E に 1 を加えた値未満までの数列の各要素 を C とし 、(0、 B 、 C ) からなる列の 0 から D +1 未満までの数列の各要素を C とし 、(0、 D の列回分の列 ) からなる列の列を A とする <eos>
1568
src = A . append ( { 'up' : C , 'front' : E , 'right' : G , 'left' : I , 'back' : K , 'bottom' : M } )
trg = A の末尾に ( ( B , C )、( D , E )、( F , G )、( H , I )、( J , K )、( L , M )) からなる辞書を 追加する
rst = A の末尾に ( ( B , C )、( D , E )、( F , G )、( H , I )、( J , K )) からなる辞書を 追加する <eos>
1569
src = A [ B [ C ] ] += 1
trg = A の B の C 番目番目を 1 だけ 増 加 させ る
rst = A の B の C 番目番目を 1 だけ 増 加 させ る <eos>
1570
src = print ( A [ 1 ] , A [ 2 ] )
trg = A の 1 番目 、 A の 2 番目を出力する
rst = A の 1 番目 、 A の 2 番目を出力する <eos>
1571
src = A . add ( ( B , C ) if B <= C else ( C , B ) )
trg = A に B が C 以下のとき ( B 、 C ) の組 、 そうでなければ ( C 、 B ) の組を追加した集まり
rst = A に B を加えた値が C 以下のとき ( B 、 C ) の組 、 そうでなければ ( C 、 B ) の組を追加した集まり <eos>
1572
src = if search ( A , B + 1 , C - 2 , D + 1 , E ) :
trg = B に 1 を加えた値 、 C から 2 を引いた値 、 D に 1 を加えた値 、 E に お いて正規表現 A が最初にマッチする位置 のとき 、
rst = B に 1 を加えた値 、 C から 2 を引いた値 、 D に 1 を加えた値 、 E に お いて正規表現 A が最初にマッチする位置 のとき 、 <eos>
1573
src = A [ B + 1 ] = not A [ B + 1 ]
trg = A の B に 1 を加えた値番目でない を A の B に 1 を加えた値番目に する
rst = A の B に 1 を加えた値番目を A の B に 1 を加えた値番目に する <eos>
1574
src = A = B [ C [ 0 ] : C [ 1 ] ]
trg = B の C の 0 番目から C の 1 番目までの部分列を A とする
rst = B の C の先頭から C の 1 番目までの部分列を A とする <eos>
1575
src = for A in B . preorder ( ) :
trg = B . preorder () を順に A として 、 繰り返 す
rst = B . preorder () を順に A として 、 繰り返 す <eos>
1576
src = A = sum ( B [ - 1 ] )
trg = B の末尾の総和を A とする
rst = B の末尾 の総和を A とする <eos>
1577
src = A [ B ] . append ( C [ D ] )
trg = A の B 番目の末尾に C の D 番目を追加する
rst = A の B 番目の末尾に C の D 番目を追加する <eos>
1578
src = if A [ - 1 ] == 4 :
trg = A の -1 番目が 4 と等しいとき 、
rst = A の -1 番目が 4 と等しいとき 、 <eos>
1579
src = A = list ( format ( B , C ) )
trg = 書式 B を C で フ ォ ーマットした文字列 のリストを A とする
rst = 書式 B を C で フ ォ ーマットした文字列 のリストを A とする <eos>
1580
src = if ( A % B , C , D ) in E :
trg = ( A を B で割った余り 、 C 、 D ) の組が E に含まれるとき 、
rst = ( A を B で割った余り 、 C 、 D ) の組が E に含まれるとき 、 <eos>
1581
src = ans ( * A )
trg = ans (* A )
rst = func [ command [0]]( * A ) <eos>
1582
src = A [ B ] [ C + 1 ] += 1
trg = A の B 番目の C に 1 を加えた値番目を 1 だけ 増 加 させ る
rst = A の B 番目の C に 1 を加えた値番目を 1 だけ 増 加 させ る <eos>
1583
src = A . bit1 = BinaryIndexedTree ( B )
trg = BinaryIndexedTree ( B ) を A の bit 1 に する
rst = BinaryIndexedTree ( B ) を A の bit 1 に する <eos>
1584
src = A = A + 3 ** B
trg = A に 3 の B 乗を加えた値を A とする
rst = A に 3 の B 乗を加えた値を A とする <eos>
1585
src = if [ A , str ( B ) ] not in C :
trg = ( A 、 B の文字列 ) からなる列が C に含まれないとき 、
rst = ( A 、 B ) からなる列が C に含まれないとき 、 <eos>
1586
src = A . append ( chr ( 65 + B ) )
trg = A の末尾に文字 コ ー ド 65 に B を加えた値の文字 を追加する
rst = A の末尾に文字 コ ー ド 65 に B を加えた値の文字 を追加する <eos>
1587
src = print ( 32 * int ( input ( ) ) )
trg = 32 に入力された文字列の整数値 を掛けた値を出力する
rst = 32 に int ( input ())) を掛けた値を出力する <eos>
1588
src = B = list ( B )
trg = B のリストを B とする
rst = B のリストを B とする <eos>
1589
src = A [ B ] = C [ 0 ] + C [ 1 ]
trg = C の 0 番目に C の 1 番目を加えた値を A の B 番目に する
rst = C の 0 番目に C の 1 番目を加えた値を A の B 番目に する <eos>
1590
src = if A * 2 <= B and A * 2 <= C and A * 2 <= D :
trg = A に 2 を掛けた値が B 以下かつ A に 2 を掛けた値が C 以下かつ A に 2 を掛けた値が D 以下のとき 、
rst = A に 2 を掛けた値が B 以下かつ A に 2 を掛けた値が C 以下かつ C が A に D を掛けた値以下のとき 、 <eos>
1591
src = A = set ( B )
trg = B の集合を A とする
rst = B の集合を A とする <eos>
1592
src = A = B . get ( 1 , 0 )
trg = B に対応する値 、 もし存在しなければ 1 、0 を A とする
rst = B に対応する値 、 もし存在しなければ 1 、0 を A とする <eos>
1593
src = for A in range ( 31 ) :
trg = 0 から 31 未満までの数列を順に A として 、 繰り返 す
rst = 0 から 31 未満までの数列を順に A として 、 繰り返 す <eos>
1594
src = for A in B . neighbor_dict [ C ] :
trg = B の neighbor _ dict の C 番目を順に A として 、 繰り返 す
rst = B の neighbor _ dict の C 番目を順に A として 、 繰り返 す <eos>
1595
src = A . node [ B ] = A . operator_func ( A . node [ 2 * B + 1 ] , A . node [ 2 * B + 2 ] )
trg = A . operator _ func ( A . node [2* B +1], A . node [2* B +2] ) を A の node の B 番目に する
rst = A . node の 2 に B を掛けた値に 1 を加えた値番目 、 A の node の B に 2 を掛けた値に B を加えた値番目を A の node の B 番目に する <eos>
1596
src = A = B [ C ] + B [ C + 1 ]
trg = B の C 番目に B の C に 1 を加えた値番目を加えた値を A とする
rst = B の C 番目に B の C に 1 を加えた値番目を加えた値を A とする <eos>
1597
src = if A [ 0 ] == A [ 3 ] :
trg = A の 0 番目が A の 3 番目と等しいとき 、
rst = A の先頭が A の 3 番目と等しいとき 、 <eos>
1598
src = A , B = divmod ( C , 9 * ( 2 ** ( D - 1 ) - 1 ) )
trg = C と 9 に 2 の D から 1 を引いた値乗 から 1 を引いた値を掛けた値を 割った ときの ( 商を展開し 、 それぞれ A 、 B とする
rst = C と 9 に D の 2 乗を加えた値の 1 から 1 を引いた値乗を掛けた値 の最小公倍数を A 、 B とする <eos>
1599
src = A = [ [ [ 0 ] * [ B for C in range ( D ) ] ] for E in range ( 3 ) ]
trg = 0 から 3 未満までの数列の各要素を E とし 、 ( (0) からなる列の 0 から D 未満までの数列の各要素を C とし 、 B の列回分の列 ) からなる列の列を A とする
rst = 0 から 3 未満までの数列の各要素を E とし 、 ( (0) からなる列の 0 から D 未満までの数列の各要素を C とし 、 B の列回分の列 ) からなる列の列を A とする <eos>
1600
src = A = [ 0 , 0 , B - 1 , [ None ] * C ]
trg = (0、0、 B から 1 を引いた値 、 ( 、 つまり未定値 ) からなる列の C 回分の列 ) からなる列を A とする
rst = (0、 B から 1 を引いた値 、 未定値 ) からなる列の C 回分の列を A とする <eos>
1601
src = while len ( A ) > 1 :
trg = A の長さが 1 より大きい 間 、 次 を 繰り返 す
rst = A の長さが 1 より大きい 間 、 次 を 繰り返 す <eos>
1602
src = if A < B . x :
trg = A が B の x 座標 より小さいとき 、
rst = A が B の x 座標 より小さいとき 、 <eos>
1603
src = if A [ B ] != A [ 21 ] :
trg = A の B 番目が A の 2 1 番目と等しくないとき 、
rst = A の B 番目が A の 2 1 番目と等しくないとき 、 <eos>
1604
src = if A in B :
trg = A が B に含まれるとき 、
rst = A が B に含まれるとき 、 <eos>
1605
src = if A [ B ] == 0 :
trg = A の B 番目が 0 と等しいとき 、
rst = A の B 番目が 0 と等しいとき 、 <eos>
1606
src = if A < B . size and B . _nodes [ A ] > B . _nodes [ C ] :
trg = A が B の size より小さくかつ B の _ nodes の A 番目が B の _ nodes の C 番目より大きいとき 、
rst = A が B の size より小さくかつ B の _ nodes の A 番目が B の _ nodes の C 番目より大きいとき 、 <eos>
1607
src = e = input ( ) . strip ( )
trg = 入力された文字列の両端から 空白改行を取り除いた文字列を ネイピア数とする
rst = 入力された文字列の両端から 空白改行を取り除いた文字列を ネイピア数とする <eos>
1608
src = A = sorted ( [ int ( input ( ) ) for B in range ( 10 ) ] , reverse = True )
trg = 逆順に 0 から 10 未満までの数列の各要素を B とし 、 、 つまり入力された文字列の整数値 の列をソートした列を A とする
rst = 逆順に 0 から 10 未満までの数列の各要素を B とし 、 、 つまり入力された文字列の整数値 の列をソートした列を A とする <eos>
1609
src = if len ( A ) % 2 == 1 :
trg = A の長さを 2 で割った余りが 1 と等しいとき 、
rst = A の長さを 2 で割った余りが 1 と等しいとき 、 <eos>
1610
src = A = abs ( cross ( B , ( e - C , D - E ) ) ) / length ( B )
trg = cross ( B , ( e - C , D - E )) の絶対値を length ( B ) で割った値を A とする
rst = cross ( B , e - C , D - E ) の絶対値を length ( B ) で割った値を A とする <eos>
1611
src = A . append ( B % C(t) ( C , e ) )
trg = A の末尾に B を C ( t ) ( C , e ) で割った余り を追加する
rst = A の末尾に B を C で割った余り 、 C 、 つまりネイピア数 を追加する <eos>
1612
src = if A . weights [ B ] < 0 :
trg = A の weights の B 番目が 0 より小さいとき 、
rst = A の weights の B 番目が 0 より小さいとき 、 <eos>
1613
src = A , B = len ( C . haystack ) , len ( C . needle )
trg = C の haystack の長さ 、 C の needle の長さを A 、 B とする
rst = C の haystack の長さ 、 C の needle の長さを A 、 B とする <eos>
1614
src = write ( '' . join ( A [ B - 1 : C ] ) )
trg = write ('' . join ( A [ B -1 : C ]))
rst = write ('' . join ( A [ B -1], C )) <eos>
1615
src = while A . data [ B ] [ C ] != D :
trg = A の data の B 番目の C 番目が D と等しくない 間 、 次 を 繰り返 す
rst = A の data の B 番目の C 番目が D と等しくない 間 、 次 を 繰り返 す <eos>
1616
src = A = Johnson ( B )
trg = Johnson ( B ) を A とする
rst = <unk> ( B ) を A とする <eos>
1617
src = A = [ B ] * C
trg = ( B ) からなる列の C 回分の列を A とする
rst = ( B ) からなる列の C 回分の列を A とする <eos>
1618
src = A = max ( [ B for B , C in D ] )
trg = D の各要素を B 、 C とし 、 B の列の最大値を A とする
rst = D の各要素を B 、 C とし 、 B の列の最大値を A とする <eos>
1619
src = A . ord = [ None for B in range ( A . n ) ]
trg = 0 から A の n 未満までの数列の各要素を B とし 、 、 つまり未定値の列を A の ord に する
rst = 0 から A の n 未満までの数列の各要素を B とし 、 、 つまり未定値の列を A の ord に する <eos>
1620
src = if A . issubset ( B [ C ] ) :
trg = A が B の C 番目 の部分集合のとき 、
rst = A が B の C 番目 の部分集合のとき 、 <eos>
1621
src = A = [ 1 , 1 ]
trg = (1、1) からなる列を A とする
rst = ( 1、1、1) からなる列を A とする <eos>
1622
src = A = [ B for B , C , D in E [ : : F ] ]
trg = E の 、 つまり先頭から 、 つまり末尾までの F 間隔による部分列の各要素を B 、 C 、 D とし 、 B の列を A とする
rst = E の 、 つまり先頭から 、 つまり末尾までの F 間隔による部分列の各要素を B 、 C 、 D とし 、 B の列を A とする <eos>
1623
src = A [ B ] += 1
trg = A の B 番目を 1 だけ 増 加 させ る
rst = A の B 番目を 1 だけ 増 加 させ る <eos>
1624
src = A = B * 7 + C
trg = B に 7 を掛けた値に C を加えた値を A とする
rst = B に 7 を掛けた値に C を加えた値を A とする <eos>
1625
src = while A [ B ] - A [ C ] > D :
trg = A の B 番目から A の C 番目を引いた値が D より大きい 間 、 次 を 繰り返 す
rst = A の B 番目から A の C 番目を引いた値が D より大きい 間 、 次 を 繰り返 す <eos>
1626
src = A [ B - 1 ] [ min ( C - 1 , D - C ) ] ^= 1
trg = A の B から 1 を引いた値番目の C から 1 を引いた値 、 D から C を引いた値の最小値 番目を 1 と の排他 的 論理和に する
rst = A の B から 1 を引いた値番目の C から 1 を引いた値 、 D から C <unk> の排他 的 論理和に する <eos>
1627
src = A = B . _depth ( C . right )
trg = B ._ depth ( C . right ) を A とする
rst = B ._ depth ( C . right ) を A とする <eos>
1628
src = return A * B * ( C + D ) // E
trg = A に B を掛けた値に C に D を加えた値を掛けた値を E で割った商を返す
rst = A に B に C に D を加えた値を掛けた値を E で割った商を返す <eos>
1629
src = print ( ' ' . join ( [ A [ 0 ] for A in B ] ) )
trg = 空白文字を間に入れて B の各要素を A とし 、 A の 0 番目 の列を連結した文字列を出力する
rst = 空白文字を間に入れて B の各要素を A とし 、 A の 0 番目 の列を連結した文字列を出力する <eos>
1630
src = print ( combination ( A , B ) % C )
trg = combination ( A , B ) を C で割った余りを出力する
rst = combination ( A , B ) を C で割った余りを出力する <eos>
1631
src = A = B * ( B + 1 ) // 2 - get_sum ( B )
trg = B に B に 1 を加えた値を掛けた値を 2 で割った商から get _ sum ( B ) を引いた値を A とする
rst = B に B に 1 を加えた値を掛けた値を 2 で割った商から get _ B ) を引いた値を A とする <eos>
1632
src = print ( * sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) )
trg = input (). split () の各要素に int を 適用した列のリストをソートした列 を展開してを出力する
rst = input (). split () の各要素に int を適用した列のリスト を展開してを出力する <eos>
1633
src = print ( ' ' . join ( map ( str , A [ A . index ( B ) + 1 ] ) ) )
trg = 空白文字を間に入れて A の A . index ( B ) に 1 を加えた値番目 の各要素に整数を適用した列 を連結した文字列を出力する
rst = 空白文字を間に入れて A の A . index ( B ) に 1 を加えた値 番目の各要素に整数を適用した列 を連結した文字列を出力する <eos>
1634
src = print ( ' ' . join ( [ str ( A ) for A in reversed ( B ) ] ) )
trg = 空白文字を間に入れて B を反転した列の各要素 を A とし 、 A の文字列の列を連結した文字列 を出力する
rst = 空白文字を間に入れて B <unk> A とし 、 A の文字列の列を連結した文字列 を出力する <eos>
1635
src = if time <= A :
trg = time が A 以下のとき 、
rst = time が A 以下のとき 、 <eos>
1636
src = if A [ 1 ] [ B ] :
trg = A の 1 番目の B 番目のとき 、
rst = A の 1 番目の B 番目のとき 、 <eos>
1637
src = A . m = B
trg = B を A の m に する
rst = B を A の m に する <eos>
1638
src = A [ B - 1 ] = min ( A [ 2 * B - 1 ] , A [ 2 * B ] ) + C [ B - 1 ]
trg = A の 2 に B を掛けた値から 1 を引いた値番目 、 A の 2 に B を掛けた値番目の最小値 に C の B から 1 を引いた値番目を加えた値を A の B から 1 を引いた値番目に する
rst = A の 2 に B を掛けた値から 1 を引いた値番目 、 A の 2 に B を掛けた値から 1 を引いた値番目に C の B から 1 を引いた値番目を加えた値を A の B から 1 を引いた値番目に する <eos>
1639
src = A [ B [ C ] ] [ D [ E ] ] -= 1
trg = A の B の C 番目番目の D の E 番目番目を 1 だけ 減 少 させ る
rst = A の B の C 番目の D の E 番目番目を 1 だけ 減 少 させ る <eos>
1640
src = print ( sum ( [ 1 for A in B . split ( ) if A . casefold ( ) == C ] ) )
trg = B を空白で分割した字句列の各要素を A とし 、 A . casefold () が C と等しいとき の 1 の列の総和を出力する
rst = B を空白で分割した字句列の各要素を A とし 、 A . casefold () が C と等しいとき の 1 の列の総和 を出力する <eos>
1641
src = print ( C if A == B else D )
trg = A が B と等しいとき C 、 そうでなければ D を出力する
rst = A が B と等しいとき C 、 そうでなければ D を出力する <eos>
1642
src = if A [ B ] [ C ] . isdigit ( ) and A [ B ] [ C ] != D :
trg = A の B 番目の C 番目が全て数字 かつ A の B 番目の C 番目が D と等しくないとき 、
rst = A の B 番目の C 番目が全て数字 かつ A の B 番目の C 番目が D と等しくないとき 、 <eos>
1643
src = A = min ( A , abs ( B ** 0.5 - e ) )
trg = A 、 B の 0.5 乗から 、 つまりネイピア数 を引いた値の絶対値の最小値を A とする
rst = A 、 B の 0.5 乗から 、 つまりネイピア数 を引いた値の絶対値を A とする <eos>
1644
src = print ( cost ( A ) )
trg = cost ( A ) を出力する
rst = cost ( A ) を出力する <eos>
1645
src = if A + B <= C and D - ( E + F [ A + B ] ) != C - ( A + B ) :
trg = A に B を加えた値が C 以下かつ D から E に F の A + B 番目を加えた値 を引いた値が C から A に B を加えた値 を引いた値と等しくないとき 、
rst = A に B を加えた値が C 以下かつ D から E を引いた値に F の A + B 番目が C から A に B を加えた値 を引いた値と等しくないとき 、 <eos>
1646
src = A . append ( B . readline ( ) . rstrip ( ) )
trg = A の末尾に B から読み込んだ一行の末尾 から空白改行を取り除いた文字列 を追加する
rst = A の末尾に B から読み込んだ一行の末尾 から空白改行を取り除いた文字列を 追加する <eos>
1647
src = A = [ int ( input ( ) ) for B in range ( C // 4 ) ]
trg = 0 から C を 4 で割った商 未満までの数列の各要素を B とし 、 、 つまり入力された文字列の整数値 の列を A とする
rst = 0 から C を 4 で割った商 未満までの数列の各要素を B とし 、 、 つまり入力された文字列の整数値 の列を A とする <eos>
1648
src = if int ( A ) + 0.5 <= A :
trg = A の整数値に 0.5 を加えた値が A 以下のとき 、
rst = A の整数値に 0.5 を加えた値が A 以下のとき 、 <eos>
1649
src = A [ B ] [ B + C - D ] += E
trg = A の B 番目の B に C を加えた値から D を引いた値番目を E だけ 増 加 させ る
rst = A の B 番目の B に C を加えた値から D を引いた値番目を E だけ 増 加 させ る <eos>
1650
src = A , B = 0 , 32
trg = 0 、 32 を A 、 B とする
rst = 0 、 32 を A 、 B とする <eos>
1651
src = A . tree [ e [ 0 ] ] . append ( ( e [ 1 ] , e [ 2 ] ) )
trg = A の tree の 、 つまりネイピア数の先頭番目 の末尾に ( 、 つまりネイピア数の 1 番目 、 ネイピア数の 2 番目 ) の組 を追加する
rst = A の tree の 、 つまりネイピア数の 0 番目を ( 、 つまりネイピア数 、 つまりネイピア数の 1 番目 ) の組 を追加する <eos>
1652
src = A += bisect ( B [ C - 1 ] , D - 1 ) - bisect ( B [ C - 1 ] , E - 1 )
trg = A を bisect から bisect を引いた値だけ 増 加 させ る
rst = A を bisect から 1 を引いた値から D から 1 を引いた値 、 B の C から 1 を引いた値番目 、 E から 1 を引いた値 ) の組 だけ 増 加 させ る <eos>
1653
src = if A [ B [ 1 ] ] == A [ B [ 2 ] ] :
trg = A の B の 1 番目番目が A の B の 2 番目 番目と等しいとき 、
rst = A の B の 1 番目番目が A の B の 2 番目と等しいとき 、 <eos>
1654
src = for A in range ( 10005 ) :
trg = 0 から 10005 未満までの数列を順に A として 、 繰り返 す
rst = 0 から 142 未満までの数列を順に A として 、 繰り返 す <eos>
1655
src = A = { [ C for C in range ( 1 , 10 ) ] } - set ( B )
trg = ( < __ main __ . Cammaobjectat 0 x 10 a 1 b 7 0 7 0> ) の集合から B の集合を引いた値を A とする
rst = ( < __ main __ . Cammaobjectat 0 x 10 a 1 db 6 d 0> ) の集合を A とする <eos>
1656
src = A = pi * B * C / 180
trg = 円周率に B を掛けた値に C を掛けた値を 180 で割った値を A とする
rst = 円周率に B を掛けた値に C を掛けた値を 180 で割った値を A とする <eos>
1657
src = A = B [ 0 ] * B [ 4 ]
trg = B の 0 番目に B の 4 番目を掛けた値を A とする
rst = B の先頭に B の 4 番目を掛けた値を A とする <eos>
1658
src = A = B . get ( C )
trg = B に対応する値 、 もし存在しなければ C を A とする
rst = B に対応する値 、 もし存在しなければ C を A とする <eos>
1659
src = A [ B [ : C ] ] = True
trg = 真を A の B の 、 つまり先頭から C 番目までの部分列番目に する
rst = 真を A の B の 、 つまり先頭から C 番目までの部分列に する <eos>
1660
src = A += A % 50
trg = A を A を 50 で割った余りだけ 増 加 させ る
rst = A を A を 50 で割った余りだけ 増 加 させ る <eos>
1661
src = A , B , C , D , E = heappop ( F )
trg = heappop ( F ) を展開し 、 それぞれ A 、 B 、 C 、 D 、 E とする
rst = heappop ( F ) を展開し 、 それぞれ A 、 B 、 C 、 D 、 E とする <eos>
1662
src = A = compress ( B , C )
trg = compress ( B , C ) を A とする
rst = compress ( B , C ) を A とする <eos>
1663
src = print ( '' , A . value , end = '' )
trg = 改行せずに空文字列 、 A の value を出力する
rst = 改行せずに空文字列 、 A の value を出力する <eos>
1664
src = A = fix ( int ( B ) * C )
trg = fix ( int ( B )* C ) を A とする
rst = fix ( int ( B ) * C ) を A とする <eos>
1665
src = print ( A + B . compute ( C , D , B . inf ) )
trg = A に B . compute ( C , D , B . inf ) を加えた値を出力する
rst = A に B . compute ( C , D , B . inf ) を加えた値を出力する <eos>
1666
src = if int ( A [ B - 1 ] [ 1 ] ) > int ( A [ B ] [ 1 ] ) :
trg = A の B から 1 を引いた値番目の 1 番目の整数値が A の B 番目の 1 番目の整数値 より大きいとき 、
rst = A の B から 1 を引いた値番目の 1 番目の整数値が A の B 番目の 1 番目の整数値 より大きいとき 、 <eos>
1667
src = A = set_front ( A , B )
trg = set _ front ( A , B ) を A とする
rst = <unk> ( A , B ) を A とする <eos>
1668
src = A = [ [ B ] * ( C + 2 ) ] + [ [ B ] + list ( input ( ) ) + [ B ] for D in range ( E ) ] + [ [ B ] * ( C + 2 ) ]
trg = ( ( B ) からなる列の C に 2 を加えた値回分の列 ) からなる列に 0 から E 未満までの数列の各要素を D とし 、 [ B ] に list ( input ()) を加えた値に ( B ) からなる列を加えた値の列 を加えた値に ( ( B ) からなる列の C に 2 を加えた値回分の列 ) からなる列を加えた値を A とする
rst = ( ( B ) からなる列の C に 2 を加えた値回分の列 ) からなる列に ( B +2) からなる列に (0) からなる列の range ( D ) の各要素を E とし 、 B +2) の列回分の列 ) からなる列を加えた値を A とする <eos>
1669
src = A = [ B . count ( C ) for C in B ]
trg = B の各要素を C とし 、 B 内の C の出現回数の列 を A とする
rst = B の各要素を C とし 、 B 内の C の出現回数の列 を A とする <eos>
1670
src = print ( mod_pow ( A , B ) )
trg = mod _ pow ( A , B ) を出力する
rst = <unk> ( A , B ) を出力する <eos>
1671
src = A = chr ( ord ( B ) + C )
trg = 文字 コ ー ド B の順序数に C を加えた値の文字を A とする
rst = 文字 コ ー ド B の順序数に C を加えた値を A とする <eos>
1672
src = A = { e : [ B for B , e in enumerate ( C ) ] }
trg = ( ( ネイピア数 , C に番号付した組の列の各要素を B 、 ネイピア数とし 、 B の列 )) からなる辞書を A とする
rst = ( ( ネイピア数 , C に番号付した組の列の各要素を B 、 ネイピア数とし 、 B の列 )) からなる辞書を A とする <eos>
1673
src = A = is_solved ( B + 1 , C ) or is_solved ( B + 1 , C - D [ B ] )
trg = is _ solved ( B +1, C ) または is _ solved ( B +1, C - D [ B ] ) を A とする
rst = is _ parallel ( B +1, C ) または is _ orthogonal ( B +1, C - D [ B ] ) を A とする <eos>
1674
src = A = B . v - len ( C )
trg = B の v から C の長さを引いた値を A とする
rst = B の v から C の長さを引いた値を A とする <eos>
1675
src = A . degree = B
trg = B を A の degree に する
rst = B を A の degree に する <eos>
1676
src = if A [ B + C ] [ D + E ] :
trg = A の B に C を加えた値番目の D に E を加えた値番目のとき 、
rst = A の B に C を加えた値番目の D に E を加えた値番目のとき 、 <eos>
1677
src = A = B * C + D
trg = B に C に D を加えた値を掛けた値を A とする
rst = B に C を掛けた値に D を加えた値を A とする <eos>
1678
src = print ( str ( A // 3600 ) + B + str ( A % 3600 // 60 ) + B + str ( A % 60 ) )
trg = str ( A //3600 ) に B を加えた値に A %3600//60 の文字列を加えた値に B を加えた値に A を 60 で割った余り の文字列を加えた値を出力する
rst = A を 3600 で割った商 の文字列に空白文字を加えた値に B を 3600 で割った余りを 60 で割った商 の文字列を加えた値を出力する <eos>
1679
src = [ print ( sum ( [ A ** 2 for A in range ( int ( e ) , 600 , int ( e ) ) ] ) * int ( e ) ) for e in sys . stdin ]
trg = sys の stdin の各要素をネイピア数 とし 、 range ( int ( e ) , 600 , int ( e )) の各要素を A とし 、 A **2 の列の総和に ネイピア数 の整数値を掛けた値を出力する の列
rst = stdin の各要素を e とし 、 e 、 int ( e ) から 123 未満までの数列の各要素を A とし 、 A を出力するの列 <eos>
1680
src = B += C
trg = B を C だけ 増 加 させ る
rst = B を C だけ 増 加 させ る <eos>
1681
src = A = max ( B [ 0 ] - 1 , C - B [ D - 1 ] )
trg = B の先頭から 1 を引いた値 、 C から B の D から 1 を引いた値番目 を引いた値の最大値を A とする
rst = B の 0 番目から 1 を引いた値 、 C から B の D から 1 を引いた値番目の最大値を A とする <eos>
1682
src = return sum ( map ( A , B , C ) )
trg = B 、 C の各要素に A を適用した列の総和 を返す
rst = B の各要素に A を適用した列の総和 を返す <eos>
1683
src = A = cos ( B )
trg = B の余弦を A とする
rst = B の余弦に B を加えた値を A とする <eos>
1684
src = for A in B . TopologicalSort ( ) [ : : - 1 ] :
trg = B . TopologicalSort () の逆順 を順に A として 、 繰り返 す
rst = B . sorted _ nodes () の逆順 を順に A として 、 繰り返 す <eos>
1685
src = if 0 <= A + 1 < B and 0 <= C < D and E [ A + 1 ] [ C ] == 1 :
trg = 0 が A に 1 を加えた値以下かどうかが B より小さくかつ 0 が C 以下かどうかが D より小さくかつ E の A に 1 を加えた値番目の C 番目が 1 と等しいとき 、
rst = 0 が A に 1 を加えた値以下かどうかが B より小さくかつ 0 が C 以下かどうかが D より小さくかつ E の A に 1 を加えた値番目の C 番目が 1 と等しいとき 、 <eos>
1686
src = A = B . intersection ( * C )
trg = B と C を展開しての 共通 部分を A とする
rst = B と C を展開しての 共通 <unk> A とする <eos>
1687
src = A . values . append ( B )
trg = A の値の集まり の末尾に B を追加する
rst = A の値の集まり の末尾に B を追加する <eos>
1688
src = print ( sum ( sorted ( [ int ( input ( ) ) for A in range ( 4 ) ] ) [ 1 : ] ) + max ( [ int ( input ( ) ) for A in range ( 2 ) ] ) )
trg = [ int ( input ()) forAinrange (4) ] をソートした列 の先頭を除いた部分列の総和に 0 から 2 未満までの数列の各要素を A とし 、 input () の整数値の列 の最大値 を加えた値を出力する
rst = 0 から 4 未満までの数列の各要素を A とし 、 input () の整数値の列をソートした列の 、 つまり先頭から 4 番目までの 2 間隔による部分列 を出力する <eos>
1689
src = A , B , C = int ( input ( ) ) , int ( input ( ) ) , list ( map ( int , input ( ) . split ( ) ) )
trg = 入力された文字列の整数値 、 入力された文字列の整数値 、 入力された文字列 を空白で分割した字句列の各要素に 整数を適用した列のリストを A 、 B 、 C とする
rst = 入力された文字列の整数値 、 入力された文字列の整数値 、 入力された文字列 を空白で分割した字句列の各要素に 整数を適用した列のリストを A 、 B 、 C とする <eos>
1690
src = A . left = B . right
trg = B の right を A の left に する
rst = B の right を A の left に する <eos>
1691
src = A [ int ( B ) ] . extend ( C )
trg = C を追加して A の B の整数値番目を 拡張 する
rst = C を追加して A の B 番目の整数値を 拡張 する <eos>
1692
src = A [ B + C ] += D * ( 0 <= B + C <= 20 )
trg = A の B に C を加えた値番目を D に 0 が B に C を加えた値以下かどうかが 20 以下かどうかを掛けた値 だけ 増 加 させ る
rst = A の B に C を加えた値番目を D に 0 が B に C を加えた値以下かどうかが 20 以下のとき 、 <eos>
1693
src = A . p . add ( B , C * B )
trg = A の p に B 、 C に B を掛けた値 を追加した集まり
rst = A の p に B 、 C に B を掛けた値 を追加した集まり <eos>
1694
src = A = B . sub ( C . bgn )
trg = B . sub ( C . bgn ) を A とする
rst = B . sub ( C . bgn ) を A とする <eos>
1695
src = A , dict = { } , { }
trg = 空辞書 、 空辞書を A 、 辞書 とする
rst = 空辞書 、 空辞書を A 、 無限の整数列 とする <eos>
1696
src = A [ 1 ] = B
trg = B を A の 1 番目に する
rst = B を A の 1 番目に する <eos>
1697
src = A = A - B + C
trg = A から B を引いた値に C を加えた値を A とする
rst = A から B を引いた値に C を加えた値を A とする <eos>
1698
src = print ( mst_kruskal ( A ) )
trg = mst _ kruskal ( A ) を出力する
rst = <unk> ( A ) を出力する <eos>
1699
src = while A [ B ] != - 1 :
trg = A の B 番目が -1 と等しくない 間 、 次 を 繰り返 す
rst = A の B 番目が -1 と等しくない 間 、 次 を 繰り返 す <eos>
1700
src = A = { 'insert' : C . appendleft , 'delete' : C . remove , 'deleteFirst' : C . popleft , 'deleteLast' : C . pop }
trg = ( ( B , C の先頭に [ MASK ] を追加する )、( D , C 内の [ MASK ] と等しい要素を取り除く )、( E , C の popleft )、( F , C の先頭を取り出した値 )) からなる辞書を A とする
rst = ( ( B , C の <unk> )、( C の <unk> 、 C の <unk> 、 <unk> 、 C の <unk> ) からなる列 )、( E , ( F 、 C の <unk> )) からなる辞書を A とする <eos>
1701
src = A = B . left if B . left else B . right
trg = B の left のとき B の left 、 そうでなければ B の right を A とする
rst = B の left のとき B の left 、 そうでなければ B の right を A とする <eos>
1702
src = print ( ' ' . join ( [ str ( A ) for A in sorted ( B ) ] ) )
trg = 空白文字を間に入れて B をソートした列の各要素を A とし 、 A の文字列の列を連結した文字列 を出力する
rst = 空白文字を間に入れて B <unk> A とし 、 A の文字列の列を連結した文字列 を出力する <eos>
1703
src = A = Poker ( B )
trg = Poker ( B ) を A とする
rst = <unk> ( B ) を A とする <eos>
1704
src = for A in map ( int , input ( ) . split ( ) [ 1 : ] ) :
trg = 入力された文字列 を空白で分割した字句列 の先頭を除いた部分列 の各要素に整数を適用した列を順に A として 、 繰り返 す
rst = 入力された文字列 を空白で分割した字句列 の先頭を除いた部分列 の各要素に整数を適用した列を順に A として 、 繰り返 す <eos>
1705
src = A . left = A . left . right
trg = A の left の right を A の left に する
rst = A の left の right を A の left に する <eos>
1706
src = print ( A [ A . index ( B ) - 3 ] , end = '' )
trg = 改行せずに A の A の B と等しい要素の最初の位置から 3 を引いた値番目 を出力する
rst = 改行せずに A の A の B と等しい要素の最初の位置から 3 を引いた値番目 を出力する <eos>
1707
src = A = sin ( radians ( B ) )
trg = B のラジアンの正弦を A とする
rst = B のラジアンを A とする <eos>
1708
src = print ( A . query ( 0 , B - 1 , C - 1 ) )
trg = A . query (0, B -1, C -1) を出力する
rst = A . query (0, B -1, C -1) を出力する <eos>
1709
src = A = [ { } for B in range ( C ) ]
trg = 0 から C 未満までの数列の各要素を B とし 、 、 つまり空辞書の列 を A とする
rst = 0 から C 未満までの数列の各要素を B とし 、 、 つまり空辞書の列 を A とする <eos>
1710
src = A , B = map ( lambda C : int ( C ) - 1 , input ( ) . split ( ) )
trg = 入力された文字列 を空白で分割した字句列の各要素に x をパラメータとして x の整数値から 1 を引いた値を 返す関数を適用した列を展開し 、 それぞれ A 、 B とする
rst = 入力された文字列 を空白で分割した字句列の各要素に x をパラメータとして x の整数値から 1 を引いた値 を返す関数を適用した列の組を A 、 B とする <eos>
1711
src = A [ B ] [ C ] = D [ B - 1 ] [ 0 ] + A [ B - 1 ] [ C - D [ B - 1 ] [ 1 ] ]
trg = D の B から 1 を引いた値番目の 0 番目に A の B から 1 を引いた値番目の C から D の B -1 番目の 1 番目 を引いた値番目を加えた値を A の B 番目の C 番目に する
rst = D の B から 1 を引いた値番目の 0 番目に A の B から 1 を引いた値番目の C から 1 番目を加えた値から D の B から 1 を引いた値番目の 1 番目を引いた値を A の B 番目の C 番目に する <eos>
1712
src = A = calc ( B , C , - 1 , 1 )
trg = calc ( B , C , -1,1) を A とする
rst = calc ( B , C ,-1,-1) を A とする <eos>
1713
src = A , B = map ( int , C . split ( ) )
trg = C を空白で分割した字句列の各要素に 整数を適用した列を展開し 、 それぞれ A 、 B とする
rst = C を空白で分割した字句列 の各要素に整数を適用した列を A 、 B とする <eos>
1714
src = A = A * ( 10 ** B )
trg = A に 10 の B 乗を掛けた値を A とする
rst = A に 10 の B 乗を掛けた値を A とする <eos>
1715
src = if A [ 1 ] is not None :
trg = A の 1 番目が 、 つまり未定値と等しいとき 、
rst = A の 1 番目が 、 つまり未定値と等しいとき 、 <eos>
1716
src = print ( power ( A , B , C ) )
trg = power ( A , B , C ) を出力する
rst = power ( A , B , C ) を出力する <eos>
1717
src = time = A * B
trg = A に B を掛けた値を time とする
rst = A に B を掛けた値を time とする <eos>
1718
src = A = A + B . t
trg = A に B の t を加えた値を A とする
rst = A に B の t を加えた値を A とする <eos>
1719
src = if A [ B ] [ C + 2 ] == D :
trg = A の B 番目の C に 2 を加えた値番目が D と等しいとき 、
rst = A の B 番目の C に 2 を加えた値番目が D と等しいとき 、 <eos>
1720
src = write ( A % ( get ( B ) % C ) )
trg = write ( A %( get ( B )% C ))
rst = write ( A %( get ( B )) <eos>
1721
src = A = ( 0 , 6000 , 4000 , 3000 , 2000 )
trg = (0、 6000 、4000、3000、2000) の組を A とする
rst = 0 、 6 、 rec 、 4 、 2000 の日付を A とする <eos>
1722
src = A [ B ] [ C + 1 ] . add ( D )
trg = A の B 番目の C に 1 を加えた値番目に D を追加した集まり
rst = A の B 番目の C に 1 を加えた値番目に D を追加した集まり <eos>
1723
src = return [ A [ 0 ] - B [ 0 ] , A [ 1 ] - B [ 1 ] ]
trg = ( A の 0 番目から B の先頭を引いた値 、 A の 1 番目から B の 1 番目を引いた値 ) からなる列を返す
rst = ( A の先頭から B の先頭を引いた値 、 A の 1 番目から B の 1 番目を引いた値 ) からなる列を返す <eos>
1724
src = if len ( A ) >= 2 :
trg = A の長さが 2 以上のとき 、
rst = A の長さが 2 以上のとき 、 <eos>
1725
src = print ( A [ check_stable ( B , C ) ] )
trg = A の check _ stable ( B , C ) 番目を出力する
rst = A の <unk> ( B , C ) 番目を出力する <eos>
1726
src = A = B [ C ] [ 1 ] - 2 * D [ C ] [ 1 ]
trg = B の C 番目の 1 番目から 2 に D の C 番目の 1 番目を掛けた値を引いた値を A とする
rst = B の C 番目の 1 番目から 2 に D の C 番目の 1 番目を掛けた値を加えた値を A とする <eos>
1727
src = for A in range ( 1 , B - C + 1 + 1 ) :
trg = 1 から B から C を引いた値に 1 を加えた値に 1 を加えた値未満までの数列を順に A として 、 繰り返 す
rst = 1 から B から C を引いた値に 1 を加えた値未満までの数列を順に A として 、 繰り返 す <eos>
1728
src = return ( A . p1 . x , B . a * A . p1 . x + B . b )
trg = ( A の p 1 の x 座標 、 B の a に A の p 1 の x 座標を掛けた値に B の b を加えた値 ) の組を返す
rst = ( A の p 1 の x 座標 、 B の a に B の p 1 の x 座標を掛けた値に A の b ) の組を返す <eos>
1729
src = heappush ( A , [ - B , C ] )
trg = heappush ( A , [ - B , C ] )
rst = heappush ( A , ([ - B , C ] ) <eos>
1730
src = A += 5
trg = A を 5 だけ 増 加 させ る
rst = A を 5 だけ 増 加 させ る <eos>
1731
src = A . append ( e [ 0 ] )
trg = A の末尾にネイピア数の先頭 を追加する
rst = A の末尾にネイピア数の 0 番目を追加する <eos>
1732
src = A [ 1 ] . add ( B )
trg = A の 1 番目に B を追加した集まり
rst = A の 1 番目に B を追加した集まり <eos>
1733
src = A = max ( A , B + C [ D ] [ E ] [ F ] [ G ] )
trg = A 、 B に C [ D ] の E 番目の F 番目の G 番目 を加えた値の最大値を A とする
rst = A 、 B に C の D 番目の E 番目の F 番目の G 番目の最大値を A とする <eos>
1734
src = if A . hasNegativeCycle ( ) :
trg = A . hasNegativeCycle () のとき 、
rst = A . is _ correct () のとき 、 <eos>
1735
src = A = B [ - C : ]
trg = B の - C 番目から 、 つまり末尾までの部分列を A とする
rst = B の - C 番目から 、 つまり末尾までの部分列を A とする <eos>
1736
src = E = B [ C ]
trg = B の C 番目を E とする
rst = B の C 番目を E とする <eos>
1737
src = if A . right . is_red ( ) :
trg = A . right . is _ red () のとき 、
rst = A . right . is _ red () のとき 、 <eos>
1738
src = A . append ( C(t) ( B ) )
trg = A の末尾に C ( t ) ( B ) を追加する
rst = A の末尾に C ( B ) を追加する <eos>
1739
src = A [ B ] [ C ] = ( D [ C - 1 ] + C * D [ C ] ) % E
trg = D の C から 1 を引いた値番目に C に D の C 番目を掛けた値を加えた値を E で割った余りを A の B 番目の C 番目に する
rst = D の C から 1 を引いた値番目に C に D を掛けた値に C を掛けた値を加えた値を E で割った余りを A の B 番目の C 番目に する <eos>
1740
src = return A + 2 * ( project ( B , A ) - A )
trg = A に 2 に project ( B , A ) から A を引いた値を掛けた値を加えた値 を返す
rst = A に 2 に project ( B , A ) から A を引いた値を掛けた値を加えた値 を返す <eos>
1741
src = A [ B [ C ] [ 0 ] - 1 ] [ B [ C ] [ 1 ] - 1 ] [ B [ C ] [ 2 ] - 1 ] += B [ C ] [ 3 ]
trg = A の B [ C ] の先頭から 1 を引いた値番目の B の C 番目の 1 番目から 1 を引いた値番目の B の C 番目の 2 番目から 1 を引いた値番目を B の C 番目の 3 番目だけ 増 加 させ る
rst = A の B の C 番目の 0 番目から 1 を引いた値番目の B の C から 1 を引いた値番目の 1 番目から 1 を引いた値番目の 2 番目を B の C から 1 を引いた値番目の 3 番目だけ 増 加 させ る <eos>
1742
src = print ( A * ( A + 1 ) // 2 - B . query ( A - 1 ) )
trg = A に A に 1 を加えた値を掛けた値を 2 で割った商から B . query ( A -1) を引いた値 を出力する
rst = A に A に 1 を加えた値を掛けた値を 2 で割った商から B . query ( A -1) を引いた値 を出力する <eos>
1743
src = A = E if B < C < D else F
trg = B が C より小さいかどうかが D より小さいとき E 、 そうでなければ F を A とする
rst = B が C より小さいとき E 、 そうでなければ D を A とする <eos>
1744
src = print ( A % ( B [ 1 ] [ 1 ] , B [ 1 ] [ 2 ] ) )
trg = A を ( B の 1 番目の 1 番目 、 B の 1 番目の 2 番目 ) の組で割った余り を出力する
rst = A を ( B の 1 番目 、 B の 1 番目 、 B の 2 番目 ) の組で割った余り を出力する <eos>
1745
src = A . d = [ B . INFINITY ] * C
trg = ( B の INFINITY ) からなる列の C 回分の列を A の d に する
rst = ( B の INFINITY ) からなる列の C 回分の列を A の d に する <eos>
1746
src = while A * B < 10010 :
trg = A に B を掛けた値が 10010 より小さい 間 、 次 を 繰り返 す
rst = A に B を掛けた値が <unk> より小さい 間 、 次 を 繰り返 す <eos>
1747
src = A = 1e9
trg = 1 e 9 を A とする
rst = <unk> を A とする <eos>
1748
src = return ( A . pos [ B ] [ 0 ] , C , D + E , E , F )
trg = ( A の pos の B 番目の先頭 、 C 、 D に E を加えた値 、 E 、 F ) の組を返す
rst = ( A の pos の B 番目の先頭 、 C 、 D に E を加えた値 、 F ) の組を返す <eos>
1749
src = if sys . version [ 0 ] == A :
trg = sys の version の 0 番目が A と等しいとき 、
rst = sys の <unk> の先頭が A と等しいとき 、 <eos>
1750
src = A = { B }
trg = ( < __ main __ . Cammaobjectat 0 x 10 a 1 db 7 3 0> ) の集合を A とする
rst = ( < __ main __ . Cammaobjectat 0 x 10 a 1 db 9 a 0> ) の集合を A とする <eos>
1751
src = for A in range ( B * B , 1000000 , B ) :
trg = B に B を掛けた値から 1000000 未満までの B 間隔の数列を順に A として 、 繰り返 す
rst = B に B を掛けた値から 1000000 未満までの B 間隔の数列を順に A として 、 繰り返 す <eos>
1752
src = A = - B . x
trg = - B の x 座標を A とする
rst = - B の x 座標を A とする <eos>
1753
src = A = 720 - B
trg = 720 から B を引いた値を A とする
rst = - B を A とする <eos>
1754
src = A . append ( B // 30 + 1 )
trg = A の末尾に B を 30 で割った商に 1 を加えた値 を追加する
rst = A の末尾に B を 30 で割った商に 1 を加えた値 を追加する <eos>
1755
src = A . fct [ B + 1 ] = A . fct [ B ] * ( B + 1 ) % C
trg = A の fct の B 番目に B に 1 を加えた値を掛けた値を C で割った余りを A の fct の B に 1 を加えた値番目に する
rst = A の fct の B 番目に B に 1 を加えた値を掛けた値を C で割った余りを A の fct の B に 1 を加えた値番目に する <eos>
1756
src = A += B + ' '
trg = A を B に空白文字を加えた値 だけ 増 加 させ る
rst = A を B に空白文字を加えた値に A を加えた値だけ 増 加 させ る <eos>
1757
src = if cross ( A , B , C , D ) > E :
trg = cross ( A , B , C , D ) が E より大きいとき 、
rst = cross ( A , B , C , D ) が E より大きいとき 、 <eos>
1758
src = if e > A :
trg = ネイピア数が A より大きいとき 、
rst = ネイピア数が A より大きいとき 、 <eos>
1759
src = A = gcd ( B , 10 )
trg = B と 10 の最大公約数を A とする
rst = B と 10 の最大公約数を A とする <eos>
1760
src = A [ B . index ( C ) ] += int ( D )
trg = A の B の C と等しい要素の最初の位置番目を D の整数値だけ 増 加 させ る
rst = A の B の C と等しい要素の最初の位置番目を D の整数値だけ 増 加 させ る <eos>
1761
src = print ( A . format ( optimal_cost ( B , C , D ) ) )
trg = A を書式として optimal _ cost ( B , C , D ) で整形した文字列を出力する
rst = A を書式として convex _ diameter ( B , C , D ) で整形した文字列を出力する <eos>
1762
src = A = lca ( B , C , 0 , D )
trg = lca ( B , C ,0, D ) を A とする
rst = lca ( B , C ,0, D ) を A とする <eos>
1763
src = A . ord [ B ] = A . cnt
trg = A の cnt を A の ord の B 番目に する
rst = A の cnt を A の ord の B 番目に する <eos>
1764
src = print ( mean ( A ) )
trg = mean ( A ) を出力する
rst = mean ( A ) を出力する <eos>
1765
src = if A < 35.5 :
trg = A が 35.5 より小さいとき 、
rst = A が 35.5 より小さいとき 、 <eos>
1766
src = serch ( A + 1 )
trg = serch ( A +1)
rst = serch ( A +1) <eos>
1767
src = A = min ( A , dfs ( B + 1 , C , D ) + abs ( E - F ) * ( G + H ) )
trg = A 、 dfs ( B +1, C , D ) に E から F を引いた値の絶対値に G に H を加えた値 を掛けた値を加えた値の最小値を A とする
rst = A 、 dfs ( B +1, C , D ) に E から F を引いた値の絶対値に G に H を加えた値 を掛けた値を加えた値の最小値を A とする <eos>
1768
src = A = B - C - 1
trg = B から C を引いた値から 1 を引いた値を A とする
rst = B から C を引いた値から 1 を引いた値を A とする <eos>
1769
src = A . space = B . index ( 0 )
trg = B の 0 と等しい要素の最初の位置を A の space に する
rst = B の 0 と等しい要素の最初の位置を A の space に する <eos>
1770
src = A = B // C + B % C
trg = B を C で割った商に B を C で割った余りを加えた値を A とする
rst = B を C で割った商に B を C で割った余りの論理値を加えた値を A とする <eos>
1771
src = from collections import A
trg = collections モ ジ ュー ル を 用 い る
rst = decimal モ ジ ュー ル を 用 い る <eos>
1772
src = A = B [ C - D + 1 : C + D + 1 ]
trg = B の C から D を引いた値に 1 を加えた値から C に D を加えた値に 1 を加えた値までの部分列を A とする
rst = B の C から D を引いた値に 1 を加えた値から C に D を加えた値に 1 を加えた値までの部分列を A とする <eos>
1773
src = A = Vector ( B , C . vertices [ D ] )
trg = Vector ( B , C . vertices [ D ] ) を A とする
rst = Vector ( B , C . vertices [ ( D ] ) を A とする <eos>
1774
src = if dfs ( A + 1 , B , C , D , E , A + 1 ) :
trg = dfs ( A +1, B , C , D , E , A +1) のとき 、
rst = dfs ( A +1, B , C , D , E , A +1) のとき 、 <eos>
1775
src = A = tuple ( map ( int , readline ( ) . split ( ) ) )
trg = readline () を空白で分割した字句列の各要素に 整数を適用した列の組を A とする
rst = readline () を空白で分割した字句列の各要素に 整数を適用した列の組を A とする <eos>
1776
src = A , B = search ( 0 , 0 , None )
trg = 0 、 未定値 に お いて正規表現 0 が最初にマッチする位置 を展開し 、 それぞれ A 、 B とする
rst = 0 、 未定値 、 未定値を A 、 B とする <eos>
1777
src = return ( A . hldid [ B ] , A . hldid [ B ] + A . size [ B ] )
trg = ( A の hldid の B 番目 、 A の hldid の B 番目に A の size の B 番目を加えた値 ) の組を返す
rst = ( A の hldid の B 番目 、 A の hldid の B 番目に A の size の B 番目を加えた値 ) の組を返す <eos>
1778
src = A = B [ 0 : C + D - E ]
trg = B の 、 つまり先頭から C に D を加えた値から E を引いた値までの部分列を A とする
rst = B の 、 つまり先頭から C に D を加えた値から E を引いた値までの部分列を A とする <eos>
1779
src = A . append ( 1000000007 )
trg = A の末尾に 1000000007 を追加する
rst = A の末尾に 1000000007 を追加する <eos>
1780
src = A [ 1 ] = None
trg = 未定値を A の 1 番目に する
rst = 未定値を A の 1 番目に する <eos>
1781
src = return 4280 - ( 1150 + f1 ( 10 ) + f2 ( 10 ) + f3 ( A - 30 ) )
trg = 4280 から 1150 に f 1 (10) を加えた値に f 2 (10) を加えた値に f 3( A -30) を加えた値 を引いた値を返す
rst = 4280 から 1150 に f 2( f -10 ) を加えた値に f 2( A + 50 ) を加えた値 を引いた値を返す <eos>
1782
src = A [ 2 ] -= ( B * C [ 2 ] )
trg = A の 2 番目を B に C の 2 番目を掛けた値だけ 減 少 させ る
rst = A の 2 番目を B に C の 2 番目を掛けた値だけ 減 少 させ る <eos>
1783
src = swap ( A [ 1 ] )
trg = swap ( A [1])
rst = swap ( A [1]) <eos>
1784
src = A . node = [ A . e ] * ( 2 * B )
trg = ( A の e ) からなる列の 2 に B を掛けた値回分の列を A の node に する
rst = ( A の e ) からなる列の 2 に B を掛けた値回分の列を A の node に する <eos>
1785
src = if A > B [ C ] [ 2 ] :
trg = A が B の C 番目の 2 番目より大きいとき 、
rst = A が B の C 番目の 2 番目より大きいとき 、 <eos>
1786
src = A = B // C * D // C * E
trg = B を C で割った商に D を掛けた値を C で割った商に E を掛けた値を A とする
rst = B を C で割った商に D を掛けた値を C で割った商に E を掛けた値を A とする <eos>
1787
src = if A . par [ B ] == B :
trg = A の par の B 番目が B と等しいとき 、
rst = A の par の B 番目が B と等しいとき 、 <eos>
1788
src = A . pre_order_traversal ( )
trg = A . pre _ order _ traversal ()
rst = A . dice _ s () <eos>
1789
src = return ( A - B . heading ) % 4
trg = A から B の heading を引いた値を 4 で割った余りを返す
rst = A から B の heading を引いた値を 4 で割った余りを返す <eos>
1790
src = A = 33554393
trg = 33554393 を A とする
rst = <unk> を A とする <eos>
1791
src = A <<= 4
trg = A を 4 だけ左シフト する
rst = A を 4 だけ左シフト する <eos>
1792
src = A = ( 1 + B / 100 ) ** C
trg = 1 に B を 100 で割った値を加えた値の C 乗を A とする
rst = 1 に B を 100 で割った値を加えた値の C 乗を A とする <eos>
1793
src = write ( A % ( B ** 3 - C ) )
trg = write ( A %( B **3 - C ))
rst = write ( A %( B <unk> ) <eos>
1794
src = while len ( A ) <= B :
trg = A の長さが B 以下の 間 、 次 を 繰り返 す
rst = A の長さが B 以下の 間 、 次 を 繰り返 す <eos>
1795
src = A [ B ] [ C & D ] += E
trg = A の B 番目の C と D の論理積 番目を E だけ 増 加 させ る
rst = A の B 番目の C と D の論理和番目を E だけ 増 加 させ る <eos>
1796
src = A = B . NIL
trg = B の NIL を A とする
rst = B の NIL を A とする <eos>
1797
src = A = pow ( B , C , 1000000007 )
trg = B の C 乗に対する 1000000007 の 剰 余を A とする
rst = B の C 乗を A とする <eos>
1798
src = return bfs ( A , B , C )
trg = bfs ( A , B , C ) を返す
rst = bfs ( A , B , C ) を返す <eos>
1799
src = while A % B == 0 and C % B == 0 :
trg = A を B で割った余りが 0 と等しくかつ C を B で割った余りが 0 と等しい 間 、 次 を 繰り返 す
rst = A を B で割った余りが 0 と等しくかつ C を B で割った余りが 0 と等しい 間 、 次 を 繰り返 す <eos>
1800
src = return GCD ( min ( A , B ) , max ( A , B ) % min ( A , B ) )
trg = GCD ( min ( A , B ) , max ( A , B )% min ( A , B )) を返す
rst = GCD ( A , B ) 、 min ( A , B ) 、 max ( A , B ) の最小値 を返す <eos>
1801
src = if A >= 1900000 :
trg = A が 1900000 以上のとき 、
rst = A が <unk> 以上のとき 、 <eos>
1802
src = A = ( len ( B ) - 1 ) % len ( C )
trg = B の長さから 1 を引いた値を C の長さで割った余りを A とする
rst = B の長さから 1 を引いた値を C の長さで割った余りを A とする <eos>
1803
src = return ( A [ B - 1 ] <= C and A [ B ] > C )
trg = A の B から 1 を引いた値番目が C 以下かつ A の B 番目が C より大きいかどうかを返す
rst = A の B から 1 を引いた値番目が C 以下かつ A の B 番目が C より大きいかどうかを返す <eos>
1804
src = A += 2 ** B [ C ]
trg = A を 2 の B の C 番目 乗だけ 増 加 させ る
rst = A を 2 の B の C 乗だけ 増 加 させ る <eos>
1805
src = while A [ B + 1 ] < C - D :
trg = A の B に 1 を加えた値番目が C から D を引いた値より小さい 間 、 次 を 繰り返 す
rst = A の B に 1 を加えた値番目が C から D を引いた値より小さい 間 、 次 を 繰り返 す <eos>
1806
src = super ( ) . __init__ ( A . x , A . y )
trg = super () .__ init __( A . x , A . y )
rst = super () .__ init __( A . x , A . y ) <eos>
1807
src = A . append ( B [ C : : D ] )
trg = A の末尾に B の C 番目から 、 つまり末尾までの D 間隔による部分列 を追加する
rst = A の末尾に B の C 番目から 、 つまり末尾までの部分列 を追加する <eos>
1808
src = A . sink . par = None
trg = 未定値を A の sink の par に する
rst = 未定値を A の sink の par に する <eos>
1809
src = A . cap -= B
trg = A の cap を B だけ 減 少 させ る
rst = A の cap を B だけ 減 少 させ る <eos>
1810
src = A , B = A - 1 , 0
trg = A から 1 を引いた値 、0 を A 、 B とする
rst = A から 1 を引いた値 、0 を A 、 B とする <eos>
1811
src = A = cipher ( B , C )
trg = cipher ( B , C ) を A とする
rst = <unk> ( B , C ) を A とする <eos>
1812
src = A [ B * C ] = 1
trg = 1 を A の B に C を掛けた値番目に する
rst = 1 を A の B に C を掛けた値番目に する <eos>
1813
src = A , B = C / D , D
trg = C を D で割った値 、 D を A 、 B とする
rst = C を D で割った値 、 D を A 、 B とする <eos>
1814
src = print ( sum ( [ max ( 40 , int ( input ( ) ) ) for A in range ( 5 ) ] ) // 5 )
trg = 0 から 5 未満までの数列の各要素を A とし 、 40 、 int ( input ()) の最大値の列の総和を 5 で割った商 を出力する
rst = 0 から 5 未満までの数列の各要素を A とし 、 40 、 入力された文字列の整数値 の最大値 、 40 の最大値の列の総和を 5 で割った商 を出力する <eos>
1815
src = A , B = pop ( )
trg = pop () を展開し 、 それぞれ A 、 B とする
rst = pop () を展開し 、 それぞれ A 、 B とする <eos>
1816
src = A = A . replace ( B , '' ) . replace ( C , '' )
trg = A 内の B を空文字列で置き換えた文字列内の C を空文字列で置き換えた文字列を A とする
rst = A 内の B を空文字列で置き換えた文字列内の C を空文字列で置き換えた文字列 を空白で分割した字句列を A とする <eos>
1817
src = print ( * [ A . format ( B [ 0 ] , B [ 1 ] ) for B in C ] )
trg = C の各要素を B とし 、 A を書式として B の先頭 、 B の 1 番目 で整形した文字列の列 を展開してを出力する
rst = C の各要素を B とし 、 A を書式として B の先頭 、 B の 1 番目で整形した文字列を出力する の列 <eos>
1818
src = A = 1013
trg = 1013 を A とする
rst = <unk> を A とする <eos>
1819
src = A += ( B - 10 ) * 125
trg = A を B から 10 を引いた値に 125 を掛けた値だけ 増 加 させ る
rst = A を B から 10 を引いた値に 125 を掛けた値だけ 増 加 させ る <eos>
1820
src = if A == 0 or B [ C ] >= B [ D ] :
trg = A が 0 と等しくまたは B の C 番目が B の D 番目以上のとき 、
rst = A が 0 と等しくまたは B の C 番目が B の D 番目以上のとき 、 <eos>
1821
src = A . append ( B [ ( C [ D ] - 1 ) % 4 + 22 ] )
trg = A の末尾に B の C [ D ] から 1 を引いた値を 4 で割った余りに 2 2 を加えた値番目 を追加する
rst = A の末尾に B の C [ D ] 番目から 1 を引いた値を 4 で割った余りに 2 を加えた値 を追加する <eos>
1822
src = A = B [ C ] * B [ D ]
trg = B の C 番目に B の D 番目を掛けた値を A とする
rst = B の C 番目に B の D 番目を掛けた値を A とする <eos>
1823
src = A = [ B for B in C if B [ 1 ] == D ] [ 0 ]
trg = C の各要素を B とし 、 B の 1 番目が D と等しいとき の B の列の先頭を A とする
rst = C の各要素を B とし 、 B の 1 番目が D と等しいとき の B の列を A とする <eos>
1824
src = A [ B ] = ( B * C + D ) % E
trg = B に C を掛けた値に D を加えた値を E で割った余りを A の B 番目に する
rst = B に C を掛けた値に D を加えた値を E で割った余りを A の B 番目に する <eos>
1825
src = path . append ( 0 )
trg = os . path の末尾に 0 を追加する
rst = os . path の末尾に 0 を追加する <eos>
1826
src = for A , B in sorted ( C . items ( ) , key = lambda D : D [ 1 ] ) [ : : - 1 ] :
trg = x をパラメータとして x の 1 番目を返す関数をキーとして C のキーと値の集まりをソートした列 の逆順 を順に A 、 B として 、 繰り返 す
rst = x をパラメータとして x の 1 番目を返す関数をキーとして C のキーと値の集まりをソートした列 を順に A 、 B として 、 繰り返 す <eos>
1827
src = A [ int ( B [ 1 ] ) ] += 1
trg = A の B の 1 番目の整数値番目を 1 だけ 増 加 させ る
rst = A の B の 1 番目の整数値だけ 増 加 させ る <eos>
1828
src = A [ B ] [ C ] = D [ B ] [ C ] + min ( A [ B - 1 ] [ C ] , A [ B ] [ C - 1 ] )
trg = D の B 番目の C 番目に A の B から 1 を引いた値番目の C 番目 、 A の B 番目の C から 1 を引いた値番目の最小値 を加えた値を A の B 番目の C 番目に する
rst = D の B 番目の C 番目に A の B から 1 を引いた値番目の C 番目を加えた値 、 A の B から 1 を引いた値番目の C から 1 を引いた値番目の最小値を A の B 番目の C 番目に する <eos>
1829
src = if A >= 190.0 :
trg = A が 190.0 以上のとき 、
rst = A が <unk> 以上のとき 、 <eos>
1830
src = print ( ' ' . join ( sorted ( A ) ) )
trg = 空白文字を間に入れて A をソートした列を連結した文字列 を出力する
rst = 空白文字を間に入れて A をソートした列 を連結した文字列を出力する <eos>
1831
src = A . append ( ( f ( B , C , 0 ) + D / E , B , C , D , E ) )
trg = A の末尾に ( f ( B , C ,0) に D を E で割った値を加えた値 、 B 、 C 、 D 、 E ) の組 を追加する
rst = A の末尾に f ( B , C ,0, D ) に E を ( B 、 C 、 D 、 E ) の組 を追加する <eos>
1832
src = while A . count ( B ) == 1 :
trg = A 内の B の出現回数が 1 と等しい 間 、 次 を 繰り返 す
rst = A 内の B の出現回数が 1 と等しい 間 、 次 を 繰り返 す <eos>
1833
src = A [ e ] = B
trg = B を A の 、 つまりネイピア数番目に する
rst = B を A の 、 つまりネイピア数番目に する <eos>
1834
src = A = [ [ - 2 , 0 ] , [ - 1 , - 1 ] , [ - 1 , 0 ] , [ - 1 , 1 ] , [ 0 , - 2 ] , [ 0 , - 1 ] , [ 0 , 0 ] , [ 0 , 1 ] , [ 0 , 2 ] , [ 1 , - 1 ] , [ 1 , 0 ] , [ 1 ,
trg = ((-2、0) からなる列 、(-1、-1) からなる列 、(-1、0) からなる列 、(-1、1) からなる列 、(0、-2) からなる列 、(0、-1) からなる列 、(0、0) からなる列 、(0、1) からなる列 、(0、2) からなる列 、(1、-1) からなる列 、(1、0) からなる列 、(1、1) からなる列 、(2、0) からなる列 ) からなる列を A とする
rst = ((- 3、0) からなる列 、(-1、0) からなる列 、(1、0) からなる列 、(0、-1) からなる列 、(0、1) からなる列 、(0、0) からなる列 、(0、1) からなる列 ) からなる列を A とする <eos>
1835
src = A = 2000 * B
trg = 2000 に B を掛けた値を A とする
rst = 2000 に B を掛けた値を A とする <eos>
1836
src = if A [ 2 ] == 1 :
trg = A の 2 番目が 1 と等しいとき 、
rst = A の 2 番目が 1 と等しいとき 、 <eos>
1837
src = for A in B . list :
trg = B の list を順に A として 、 繰り返 す
rst = B の list を順に A として 、 繰り返 す <eos>
1838
src = if A < 160.0 :
trg = A が 160.0 より小さいとき 、
rst = A が 160.0 より小さいとき 、 <eos>
1839
src = if A [ B ] and C + B <= 20 :
trg = A の B 番目かつ C に B を加えた値が 20 以下のとき 、
rst = A の B 番目かつ C に B を加えた値が 20 以下のとき 、 <eos>
1840
src = A = A [ : : - 1 ]
trg = A の逆順を A とする
rst = A の末尾を除いた部分列を加えた値を A とする <eos>
1841
src = A += math . factorial ( B ) / math . factorial ( C ) / math . factorial ( B - C )
trg = A を B の 階 乗を C の 階 乗で割った値を B から C を引いた値の 階 乗で割った値 だけ 増 加 させ る
rst = A を B で割った値の C 乗を B から C を引いた値の 階 乗で割った商を B から C を引いた値の 階 乗だけ 増 加 させ る <eos>
1842
src = A . append ( ( B [ 0 ] + 1 , B [ 1 ] ) )
trg = A の末尾に ( B の先頭に 1 を加えた値 、 B の 1 番目 ) の組 を追加する
rst = A の末尾に ( B の先頭に 1 を加えた値 、 B の 1 番目 ) の組 を追加する <eos>
1843
src = A [ 4 ] = A [ 3 ]
trg = A の 3 番目を A の 4 番目に する
rst = A の 3 番目を A の 4 番目に する <eos>
1844
src = A = [ B for C in range ( D . n ) ]
trg = 0 から D の n 未満までの数列の各要素を C とし 、 B の列を A とする
rst = 0 から D の n 未満までの数列の各要素を C とし 、 B の列を A とする <eos>
1845
src = A [ B ] -= abs ( C )
trg = A の B 番目を C の絶対値だけ 減 少 させ る
rst = A の B 番目を C の絶対値だけ 減 少 させ る <eos>
1846
src = print ( A , time )
trg = A 、 time を出力する
rst = A 、 time を出力する <eos>
1847
src = A = [ [ 0 for B in range ( 15 ) ] for C in range ( 15 ) ]
trg = 0 から 15 未満までの数列の各要素を C とし 、0 から 15 未満までの数列の各要素を B とし 、0 の列の列を A とする
rst = 0 から 15 未満までの数列の各要素を C とし 、0 から 15 未満までの数列の各要素を B とし 、0 の列の列を A とする <eos>
1848
src = return A . top >= len ( A . S ) - 1
trg = A の top が A の S の長さから 1 を引いた値以上かどうか を返す
rst = A の top が A の S の長さから 1 を引いた値以上のとき 、 <eos>
1849
src = if not A [ 1 ] :
trg = A の 1 番目でないとき 、
rst = A の 1 番目でないとき 、 <eos>
1850
src = if A [ e ] < B :
trg = A の 、 つまりネイピア数番目が B より小さいとき 、
rst = A の 、 つまりネイピア数番目が B より小さいとき 、 <eos>
1851
src = print ( A [ B [ 0 ] : B [ 1 ] ] . count ( B [ 2 ] ) )
trg = A の B の先頭から B の 1 番目までの部分列内の B の 2 番目の出現回数 を出力する
rst = A の B の先頭から B の 1 番目 内の B の 2 番目の出現回数が B の 2 番目 の出現回数 を出力する <eos>
1852
src = if A == ( - 1 , 0 ) :
trg = A が (-1、0) の組と等しいとき 、
rst = A が (0、-1) の組と等しいとき 、 <eos>
1853
src = A = [ 0 ] * ( ( B - 1 ) // 2 )
trg = (0) からなる列の B から 1 を引いた値を 2 で割った商 回分の列を A とする
rst = (0) からなる列の B から 1 を引いた値を 2 だけ左シフトした値回分の列 を A とする <eos>
1854
src = if A . count ( B ) == 0 :
trg = A 内の B の出現回数が 0 と等しいとき 、
rst = A 内の B の出現回数が 0 と等しいとき 、 <eos>
1855
src = A = Graph[int] ( B )
trg = Graph [ int ] ( B ) を A とする
rst = <unk> ( B ) を A とする <eos>
1856
src = A = [ Node ( char = B , value = C ) for B , C in D . items ( ) ]
trg = D のキーと値の集まりの各要素を B 、 C とし 、 Node ( char = B , value = C ) の列を A とする
rst = D のキーと値の集まりの各要素を B 、 C とし 、 Node ( B , value = C ) の列を A とする <eos>
1857
src = A = [ ( B / C , D / E ) for B , C , D , E in F ]
trg = F の各要素を B 、 C 、 D 、 E とし 、 ( B を C で割った値 、 D を E で割った値 ) の組の列を A とする
rst = F の各要素を B 、 C 、 D 、 E 、 D とし 、 ( B を C で割った値 、 D を E で割った値 ) の組の列を A とする <eos>
1858
src = path = [ [ 0 for A in range ( 26 ) ] for B in range ( 26 ) ]
trg = 0 から 26 未満までの数列の各要素を B とし 、0 から 26 未満までの数列の各要素を A とし 、0 の列の列を os . path とする
rst = 0 から 26 未満までの数列の各要素を B とし 、0 から 26 未満までの数列の各要素を A とし 、0 の列の列を os . path とする <eos>
1859
src = A . append ( tuple ( map ( int , B . readline ( ) . split ( ) ) ) )
trg = A の末尾に B から読み込んだ一行 を空白で分割した字句列の各要素に 整数を適用した列の組 を追加する
rst = A の末尾に B から読み込んだ一行 を空白で分割した字句列の各要素に 整数を適用した列の組 を追加する <eos>
1860
src = if A . mp [ B ] [ C ] != D :
trg = A の mp の B 番目の C 番目が D と等しくないとき 、
rst = A の mp の B 番目の C 番目が D と等しくないとき 、 <eos>
1861
src = return [ A , path ]
trg = ( A 、 os . path ) からなる列を返す
rst = ( A 、 os . path ) からなる列を返す <eos>
1862
src = return A . query ( ( B - 1 ) // 2 , C , D )
trg = A . query ( ( B -1)//2 , C , D ) を返す
rst = A . query ( ( B -1)//2 , C , D ) を返す <eos>
1863
src = if A is not None and 0 <= A < B :
trg = A が 、 つまり未定値と等しくかつ 0 が A 以下かどうかが B より小さいとき 、
rst = A が 、 つまり未定値と等しくかつ 0 が A 以下かどうかが B より小さいとき 、 <eos>
1864
src = A |= 1 << ( B - 1 )
trg = A を 1 を B から 1 を引いた値 だけ左シフトした値との 論理和に する
rst = A を 1 を B から 1 を引いた値だけ左シフトした値 と の 論理和に する <eos>
1865
src = if A == B or C & ( 1 << B ) :
trg = A が B と等しくまたは C と 1 を B だけ左シフトした値の論理積のとき 、
rst = A が B と等しくまたは C と 1 を B だけ左シフトした値の論理積のとき 、 <eos>
1866
src = A , B , C , D , E = map ( int , input ( ) . split ( ) )
trg = 入力された文字列 を空白で分割した字句列の各要素に 整数を適用した列を展開し 、 それぞれ A 、 B 、 C 、 D 、 E とする
rst = 入力された文字列 を空白で分割した字句列の各要素に 整数を適用した列を展開し 、 それぞれ A 、 B 、 C 、 D 、 E とする <eos>
1867
src = A . delete ( A . head . next )
trg = A . delete ( A . head . next )
rst = A . delete ( A . head ) <eos>
1868
src = if A [ B ] [ 0 ] is not None :
trg = A の B 番目の 0 番目が 、 つまり未定値と等しいとき 、
rst = A の B 番目の 0 番目が 、 つまり未定値と等しいとき 、 <eos>
1869
src = print ( A . format ( sum ( [ int ( B ) for B in C ] ) ) )
trg = A を書式として C の各要素を B とし 、 B の整数値の列の総和 で整形した文字列を出力する
rst = A を書式として C の各要素を B とし 、 B の整数値の列の総和 で整形した文字列を出力する <eos>
1870
src = A = B . GetNodes ( )
trg = B . GetNodes () を A とする
rst = B . GetNodes () を A とする <eos>
1871
src = print ( A . run ( 0 , B - 1 ) )
trg = A . run (0, B -1) を出力する
rst = A . run (0, B -1) を出力する <eos>
1872
src = A = 100000.0
trg = 100000.0 を A とする
rst = <unk> を A とする <eos>
1873
src = for A in range ( int ( B / 2 ) , - 1 , - 1 ) :
trg = B を 2 で割った値の整数値から -1 未満までの -1 間隔の数列を順に A として 、 繰り返 す
rst = B を 2 で割った値から -1 未満までの -1 間隔の数列を順に A として 、 繰り返 す <eos>
1874
src = ice_search ( A , B , C )
trg = ice _ search ( A , B , C )
rst = <unk> ( A , B , C ) <eos>
1875
src = print ( format ( A ^ B , C ) )
trg = 書式 A と B の排他論理和を C で フ ォ ーマットした文字列 を出力する
rst = 書式 A と B の排他論理和を C で フ ォ ーマットした文字列 を出力する <eos>
1876
src = A . sizes = [ 1 for B in range ( C ) ]
trg = 0 から C 未満までの数列の各要素を B とし 、 1 の列を A の sizes に する
rst = 0 から C 未満までの数列の各要素を B とし 、 1 の列を A の sizes に する <eos>
1877
src = if math . isinf ( A [ B ] [ 0 ] ) :
trg = A の B 番目の先頭 が無限大のとき 、
rst = A の B 番目の先頭 が無限大のとき 、 <eos>
1878
src = return ( A , B , gcd ( C , D ) )
trg = ( A 、 B 、 C と D の最大公約数 ) の組を返す
rst = ( A 、 B 、 C と D の最小公倍数 ) の組を返す <eos>
1879
src = delete_node ( A , B . key )
trg = delete _ node ( A , B . key )
rst = delete _ node ( A , B . key ) <eos>
1880
src = print ( math . sqrt ( min ( map ( A , range ( B + 1 ) ) ) ) )
trg = 0 から B +1 未満までの数列の各要素に A を適用した列の最小値 の平方根 を出力する
rst = 0 から B に 1 を加えた値未満までの数列 の各要素に整数を適用した列 の平方根 を出力する <eos>
1881
src = A = magic_square ( B )
trg = magic _ square ( B ) を A とする
rst = <unk> ( B ) を A とする <eos>
1882
src = A = floor ( sqrt ( B ) )
trg = B の平方根の切り 捨 て整数値を A とする
rst = B の平方根の切り 捨 て整数値を A とする <eos>
1883
src = A = B ** 2 + C ** 2 + D ** 2
trg = B の 2 乗に C の 2 乗を加えた値に D の 2 乗を加えた値を A とする
rst = B の 2 乗に C の 2 乗を加えた値に D の 2 乗を加えた値を A とする <eos>
1884
src = A = B // 4
trg = B を 4 で割った商を A とする
rst = B を 4 で割った商を A とする <eos>
1885
src = for A in range ( max ( B , 0 ) , min ( C , D ) + 1 ) :
trg = B 、0 の最大値から C 、 D の最小値に 1 を加えた値未満までの数列を順に A として 、 繰り返 す
rst = B 、0 の最大値から C 、 D の最小値に 1 を加えた値未満までの数列を順に A として 、 繰り返 す <eos>
1886
src = A [ len ( B ) ] = [ ]
trg = 空列を A の B の長さ番目に する
rst = 空列を A の B の長さ 番目に する <eos>
1887
src = preorder_tree_walk ( A , A [ B ] . right_node_no , C )
trg = preorder _ tree _ walk ( A , A [ B ] . right _ node _ no , C )
rst = preorder _ tree _ walk ( A , A [ B ] . right _ node _ no , C ) <eos>
1888
src = if not A > B :
trg = A が B より大きく ないとき 、
rst = A が B より大きいとき 、 <eos>
1889
src = return A % 10 + A // 10
trg = A を 10 で割った余りに A を 10 で割った商を加えた値 を返す
rst = A を 10 で割った余りに A を 10 で割った商を加えた値 を返す <eos>
1890
src = A . append ( ( B . right , C + D ) )
trg = A の末尾に ( B の right 、 C に D を加えた値 ) の組 を追加する
rst = A の末尾に ( B の right 、 C に D を加えた値 ) の組 を追加する <eos>
1891
src = if A [ : B ] != C [ : B ] :
trg = A の 、 つまり先頭から B 番目までの部分列が C の 、 つまり先頭から B 番目までの部分列 と等しくないとき 、
rst = A の 、 つまり先頭から B 番目までの部分列が C の 、 つまり先頭から B 番目までの部分列 と等しくないとき 、 <eos>
1892
src = for A in range ( B ) [ : 0 : - 1 ] :
trg = 0 から B 未満までの数列の 、 つまり先頭から 、 つまり先頭までの -1 間隔による部分列 を順に A として 、 繰り返 す
rst = 0 から B 未満までの数列の逆順 を順に A として 、 繰り返 す <eos>
1893
src = スクリーンキーボード
trg = ス ク リー ン キー ボ ー ド
rst = <unk> を 中断する <eos>
1894
src = A . pointer = min ( A . length , A . pointer + 1 )
trg = A の length 、 A の pointer に 1 を加えた値の最小値を A の pointer に する
rst = A の length 、 A の pointer に 1 を加えた値の最小値を A の pointer に する <eos>
1895
src = A = [ [ - 1 for B in range ( C ) ] for B in range ( D ) ]
trg = 0 から D 未満までの数列の各要素を B とし 、0 から C 未満までの数列の各要素を B とし 、 -1 の列の列を A とする
rst = 0 から D 未満までの数列の各要素を B とし 、0 から C 未満までの数列の各要素を B とし 、 -1 の列の列を A とする <eos>
1896
src = if A <= B and ( A & 1 ) and C [ A ] == 0 :
trg = A が B 以下かつ A と 1 の論理積かつ C の A 番目が 0 と等しいとき 、
rst = A が B 以下かつ A と 1 の論理積かつ C の A 番目が 0 と等しいとき 、 <eos>
1897
src = A = B [ C + 1 ] - B [ C ]
trg = B の C に 1 を加えた値番目から B の C 番目を引いた値を A とする
rst = B の C に 1 を加えた値番目から B の C 番目を引いた値を A とする <eos>
1898
src = print ( A , B - 1912 + 1 , C , D )
trg = A 、 B から 1912 を引いた値に 1 を加えた値 、 C 、 D を出力する
rst = A 、 B から 1912 を引いた値に 1 を加えた値 、 C 、 D を出力する <eos>
1899
src = A = [ [ [ ] for B in range ( 2 ) ] for C in range ( D ) ]
trg = 0 から D 未満までの数列の各要素を C とし 、0 から 2 未満までの数列の各要素を B とし 、 、 つまり空列 の列の列を A とする
rst = 0 から D 未満までの数列の各要素を C とし 、0 から 2 未満までの数列の各要素を B とし 、 、 つまり空列 の列の列を A とする <eos>
1900
src = A . height = max ( [ B . height + 1 for B in A . children ( ) ] )
trg = A . children () の各要素を B とし 、 B の height に 1 を加えた値の列の最大値を A の height に する
rst = A の children の各要素を B とし 、 B の height に 1 を加えた値 の列の最大値を A の height に する <eos>
1901
src = process_node_data ( A )
trg = process _ node _ data ( A )
rst = <unk> ( A ) <eos>
1902
src = A . put ( [ B , C , D + 1 ] )
trg = A . put ([ B , C , D +1])
rst = A . put ([ B , C , D +1) <eos>
1903
src = if A . mm < 10 :
trg = A の mm が 10 より小さいとき 、
rst = A の mm が 10 より小さいとき 、 <eos>
1904
src = if A [ B ] < C - 1 :
trg = A の B 番目が C から 1 を引いた値より小さいとき 、
rst = A の B 番目が C から 1 を引いた値より小さいとき 、 <eos>
1905
src = A = B . LifoQueue ( )
trg = B . LifoQueue () を A とする
rst = B . get _ next _ <unk> _ point () を A とする <eos>
1906
src = A = max ( tax ( B , C ) + tax ( D , C ) , A )
trg = tax ( B , C ) に tax ( D , C ) を加えた値 、 A の最大値を A とする
rst = tax ( B , C ) に tax ( D , C ) を加えた値 、 A の最大値を A とする <eos>
1907
src = A [ B + C ] [ D + 1 ] = max ( A [ B + C ] [ D + 1 ] , A [ B ] [ D ] + E )
trg = A の B に C を加えた値番目の D に 1 を加えた値番目 、 A の B 番目の D 番目に E を加えた値の最大値を A の B に C を加えた値番目の D に 1 を加えた値番目に する
rst = A の B に C を加えた値番目の D に 1 を加えた値番目 、 A の B 番目の D 番目に E を加えた値の最大値を A の B に C を加えた値番目の D に 1 を加えた値番目に する <eos>
1908
src = if cross ( A , B , C , D ) < - E :
trg = cross ( A , B , C , D ) が - E より小さいとき 、
rst = cross ( A , B , C , D ) が - E より小さいとき 、 <eos>
1909
src = A . show_status ( )
trg = A . show _ status ()
rst = A . dice _ s () <eos>
1910
src = A = int ( B ) - 1
trg = B の整数値から 1 を引いた値を A とする
rst = B の整数値から 1 を引いた値を A とする <eos>
1911
src = if ( A . d [ 1 ] != B . d [ 1 ] or A . d [ 2 ] != B . d [ 2 ] or A . d [ 3 ] != B . d [ 3 ] or A . d [ 4 ] != B . d [ 4 ] or A . d [ 5 ] != B . d [ 5 ] or A . d [ 6 ] != B
trg = A . d [1] != B . d [1] または A . d [2] != B . d [2] または A . d [3] が B . d [3] と等しくなくまたは A . d の 4 番目が B . d の 4 番目と等しくなくまたは A の d の 5 番目が B の d の 5 番目と等しくなくまたは A の d の 6 番目が B の d の 6 番目と等しくないとき 、
rst = A . d [1]== B . d [1] または A . d [2] != B . d [2] != B . d [2] または A . d の 4 番目が B . d の 4 番目と等しくなくまたは A の d の 5 番目が B の 6 番目 と等しくないとき 、 <eos>
1912
src = G_choice ( A )
trg = G _ choice ( A )
rst = <unk> ( A ) <eos>
1913
src = A += dfs ( B , 1 << B , C , ( D , E ) , ( F , G ) )
trg = A を dfs ( B ,1<< B , C , ( D , E ),( F , G )) だけ 増 加 させ る
rst = A を dfs ( B , 1 を B , C , ( D , E ),( F , G )) だけ 増 加 させ る <eos>
1914
src = A . append ( set ( [ frozenset ( B ) for B in C ] ) )
trg = A の末尾に C の各要素を B とし 、 B の イ ミ ュー タ ブ ルな集合 の列の集合を 追加する
rst = A の末尾に C の各要素を B とし 、 <unk> ( B ) の列 を追加する <eos>
1915
src = print ( ( A + B + 360 * ( abs ( A - B ) > 180 ) ) / 2 % 360 )
trg = A に B を加えた値に 360 に ( abs ( A - B ) > 180) を掛けた値を加えた値を 2 で割った値を 360 で割った余りを出力する
rst = A に B を加えた値に 360 に A から B <unk> 2 を引いた値を 360 で割った余りを 360 で割った値 で割った余りを出力する <eos>
1916
src = A [ int ( B ) ] = [ C . index ( B ) , D ]
trg = ( C の B と等しい要素の最初の位置 、 D ) からなる列を A の B の整数値番目に する
rst = ( C の B と等しい要素の最初の位置 、 D ) からなる列を A の B の整数値番目に する <eos>
1917
src = input = sys . stdin . buffer . readline
trg = sys の stdin の buffer から読み込んだ一行を 入力された文字列 とする
rst = sys の stdin の buffer から読み込んだ一行を 入力された文字列 とする <eos>
1918
src = A . data &= ~ ( 1 << int ( B ) )
trg = A の data を 1 を B の整数値だけ左シフトした値の 補 数と の論理積 に する
rst = A の data を 1 を B の整数値だけ左シフトした値との <unk> 的 論理和に する <eos>
1919
src = A [ B - 1 ] [ C - 1 ] -= 1
trg = A の B から 1 を引いた値番目の C から 1 を引いた値番目を 1 だけ 減 少 させ る
rst = A の B から 1 を引いた値番目の C から 1 を引いた値番目を 1 だけ 減 少 させ る <eos>
1920
src = for A in range ( 0 , B * 2 , 2 ) :
trg = 0 から B に 2 を掛けた値未満までの 2 間隔の数列を順に A として 、 繰り返 す
rst = 0 から B に 2 を掛けた値 未満までの 2 間隔の数列を順に A として 、 繰り返 す <eos>
1921
src = A = calc_height ( B , C )
trg = calc _ height ( B , C ) を A とする
rst = calc _ height ( B , C ) を A とする <eos>
1922
src = put_queen_in_row ( 0 )
trg = put _ queen _ in _ row (0)
rst = <unk> (0) <eos>
1923
src = if len ( A [ - 1 ] ) == 7 :
trg = A の末尾 の長さが 7 と等しいとき 、
rst = A の -1 番目の長さが 7 と等しいとき 、 <eos>
1924
src = A = sorted ( list ( map ( int , input ( ) . split ( B ) ) ) )
trg = 入力された文字列を B で分割した字句列の各要素に 整数を適用した列のリストを ソートした列を A とする
rst = input () を空白で分割した字句列の各要素に <unk> ソートした列を A とする <eos>
1925
src = if A [ B ] < A [ B + 1 ] - 1 :
trg = A の B 番目が A の B に 1 を加えた値番目から 1 を引いた値より小さいとき 、
rst = A の B 番目が A の B に 1 を加えた値番目から 1 を引いた値より小さいとき 、 <eos>
1926
src = while A and A [ 0 ] [ 0 ] == B :
trg = A かつ A の先頭の 0 番目が B と等しい 間 、 次 を 繰り返 す
rst = A かつ A の先頭の 0 番目が B と等しい 間 、 次 を 繰り返 す <eos>
1927
src = if not A - B < C < D - A + B or not A - B < E < F - A + B :
trg = A から B を引いた値が C より小さいかどうかが D から A を引いた値に B を加えた値より小さくなくまたは A から B を引いた値が E より小さいかどうかが F から A を引いた値に B を加えた値 より小さくないとき 、
rst = A から B を引いた値が C より小さいかどうかが D から A を引いた値より小さくかつ B に A を加えた値が B から E を引いた値から F に A を加えた値 より小さくないとき 、 <eos>
1928
src = A [ 0 ] -= ( B // C ) * D [ 0 ]
trg = A の先頭を B を C で割った商に D の先頭を掛けた値だけ 減 少 させ る
rst = A の 0 番目を B を C で割った商に D の先頭を掛けた値だけ 減 少 させ る <eos>
1929
src = A , B , C , D , E , F = list ( map ( G , input ( ) . split ( ) ) )
trg = 入力された文字列 を空白で分割した字句列の各要素に G を適用した列のリストを展開し 、 それぞれ A 、 B 、 C 、 D 、 E 、 F とする
rst = 入力された文字列 を空白で分割した字句列の各要素に 整数を適用した列のリストを展開し 、 それぞれ A 、 B 、 C 、 D 、 E 、 F とする <eos>
1930
src = while A < B and C > 0 :
trg = A が B より小さくかつ C が 0 より大きい 間 、 次 を 繰り返 す
rst = A が B より小さくかつ C が 0 より大きい 間 、 次 を 繰り返 す <eos>
1931
src = if A [ - 1 ] == B :
trg = A の末尾が B と等しいとき 、
rst = A の -1 番目が B と等しいとき 、 <eos>
1932
src = A , B = C [ 1 ] [ 1 ] + 1 , C [ 0 ] [ 1 ]
trg = C の 1 番目の 1 番目に 1 を加えた値 、 C の先頭の 1 番目を A 、 B とする
rst = C の 1 番目の 1 番目に 1 を加えた値 、 C の先頭の 1 番目を A 、 B とする <eos>
1933
src = A . remove ( [ B , C - 1 ] )
trg = A 内の ( B 、 C から 1 を引いた値 ) からなる列 と等しい要素を取り除く
rst = A 内の ( B 、 C から 1 を引いた値 ) からなる列 と等しい要素を取り除く <eos>
1934
src = A . length = 0
trg = 0 を A の length に する
rst = 0 を A の length に する <eos>
1935
src = if A [ 0 ] == B [ 5 ] :
trg = A の先頭が B の 5 番目と等しいとき 、
rst = A の先頭が B の 5 番目と等しいとき 、 <eos>
1936
src = if e is None :
trg = ネイピア数が 、 つまり未定値と等しくないとき 、
rst = ネイピア数が 、 つまり未定値と等しくないとき 、 <eos>
1937
src = A . low [ B ] = min ( A . low [ B ] , A . ord [ C ] )
trg = A の low の B 番目 、 A の ord の C 番目の最小値を A の low の B 番目に する
rst = A の low の B 番目 、 A の low の C 番目の最小値を A の low の B 番目に する <eos>
1938
src = print ( ' ' . join ( A ) )
trg = 空白文字を間に入れて A を連結した文字列を出力する
rst = 空白文字を間に入れて A を連結した文字列を出力する <eos>
1939
src = A , B , C = extended_gcd ( D , E )
trg = extended _ gcd ( D , E ) を展開し 、 それぞれ A 、 B 、 C とする
rst = segment _ line _ <unk> ( D , E ) を展開し 、 それぞれ A 、 B 、 C とする <eos>
1940
src = if is_prime_number ( A ) :
trg = is _ prime _ number ( A ) のとき 、
rst = <unk> ( A ) のとき 、 <eos>
1941
src = A . construct_lca ( )
trg = A . construct _ lca ()
rst = A . dice _ s () <eos>
1942
src = if A [ B ] != 1 and C [ D ] [ B ] != - 1 and E [ B ] > C [ D ] [ B ] :
trg = A の B 番目が 1 と等しくなくかつ C の D 番目の B 番目が -1 と等しくなくかつ E の B 番目が C の D 番目の B 番目より大きいとき 、
rst = A の B 番目が 1 と等しくなくかつ C の D 番目の B 番目が -1 と等しくなくかつ E の B 番目が C の D 番目の B 番目より大きいとき 、 <eos>
1943
src = print ( A . area ( ) )
trg = A . area () を出力する
rst = A . area () を出力する <eos>
1944
src = A . set_renew ( B , A . get_lf ( C + 1 ) )
trg = A . set _ renew ( B , A . get _ lf ( C +1))
rst = A . <unk> ( B , A . <unk> ( C +1) <eos>
1945
src = A = [ ( B , C ) ]
trg = ( ( B 、 C ) の組 ) からなる列を A とする
rst = ( ( B 、 C ) の組 ) からなる列を A とする <eos>
1946
src = A , B , C , time = D . popleft ( )
trg = D . popleft () を展開し 、 それぞれ A 、 B 、 C 、 time とする
rst = D . popleft () を展開し 、 それぞれ A 、 B 、 C 、 time とする <eos>
1947
src = A . extend ( [ ( B , C , D ) for D in range ( 4 ) ] )
trg = 0 から 4 未満までの数列の各要素を D とし 、 ( B 、 C 、 D ) の組の列 を追加して A を 拡張 する
rst = 0 から 4 未満までの数列の各要素を D とし 、 ( B 、 C 、 D ) の組の列 を追加して A を 拡張 する <eos>
1948
src = 間違い
trg = 間 違 い
rst = <unk> を 中断する <eos>
1949
src = A = sorted ( [ math . ceil ( B [ 1 ] / B [ 3 ] ) , math . ceil ( B [ 2 ] / B [ 4 ] ) ] )
trg = ( B の 1 番目を B の 3 番目で割った値の切り 上 げ 整数値 、 B の 2 番目を B の 4 番目で割った値の切り 上 げ 整数値 ) からなる列をソートした列を A とする
rst = ( B の 1 番目を B の 3 番目で割った値の切り 上 げ 整数値 、 B の 2 番目を B の 4 番目で割った値の切り 上 げ 整数値の最大値を A とする <eos>
1950
src = if len ( A [ B ] . children ) == 0 :
trg = A の B 番目の children の長さが 0 と等しいとき 、
rst = A の B 番目の children の長さが 0 と等しいとき 、 <eos>
1951
src = A = ' '
trg = 空白文字を A とする
rst = 空白文字を A とする <eos>
1952
src = A , B = divmod ( C , 10 )
trg = C と 10 を 割った ときの ( 商を展開し 、 それぞれ A 、 B とする
rst = C と 10 を 割った ときの ( 商を展開し 、 それぞれ A 、 B とする <eos>
1953
src = A = set ( bfs ( B , C ) . keys ( ) )
trg = bfs ( B , C ) のキーの集まりの集合 を A とする
rst = bfs ( B , C ) のキーの集まりの集合 を A とする <eos>
1954
src = A = B [ 3 ] [ C ] [ D ] [ 0 ] + B [ E - 1 ] [ F ] [ C ] [ 0 ]
trg = B の 3 番目の C 番目の D 番目の 0 番目に B の E -1 番目の F 番目の C 番目の先頭を加えた値を A とする
rst = B の 3 番目の C 番目の D 番目の 0 番目に B の E -1 番目の 1 番目を加えた値から F の C 番目の 0 番目を引いた値を A とする <eos>
1955
src = return max ( A [ 0 ] [ 1 ] , A [ 1 ] [ 1 ] )
trg = A の先頭の 1 番目 、 A の 1 番目の 1 番目の最大値 を返す
rst = A の先頭の 1 番目 、 A の 1 番目の 1 番目 の最大値を返す <eos>
1956
src = print ( A . dist [ B ] if A . dist [ B ] != inf else C )
trg = A の dist の B 番目が 、 つまり無限大と等しくないとき A の dist の B 番目 、 そうでなければ C を出力する
rst = A の dist の B 番目が 、 つまり無限大と等しくないとき A の dist の B 番目 、 そうでなければ C を出力する <eos>
1957
src = print ( A + B * ( C - 2 ) + A )
trg = A に B に C から 2 を引いた値に A を加えた値を掛けた値を加えた値 を出力する
rst = A に B に C から 2 を引いた値を掛けた値を加えた値に A を加えた値を出力する <eos>
1958
src = for A in range ( 1 , 181 ) :
trg = 1 から 181 未満までの数列を順に A として 、 繰り返 す
rst = 1 から <unk> 未満までの数列を順に A として 、 繰り返 す <eos>
1959
src = A , B [ C ] [ 0 ] , D , B [ C ] [ 1 ] = map ( int , input ( ) . split ( ) )
trg = 入力された文字列 を空白で分割した字句列の各要素に 整数を適用した列を展開し 、 それぞれ A 、 B の C 番目の先頭 、 D 、 B の C 番目の 1 番目とする
rst = 入力された文字列 を空白で分割した字句列の各要素に 整数を適用した列を展開し 、 それぞれ A 、 B の C 番目の先頭 、 D 、 B の C 番目の 1 番目とする <eos>
1960
src = A -= B * 9 * 10 ** ( B - 1 )
trg = A を B に 9 を掛けた値に 10 の B から 1 を引いた値乗を掛けた値だけ 減 少 させ る
rst = A を B に 9 を掛けた値に 10 の B から 1 を引いた値乗を掛けた値 だけ 減 少 させ る <eos>
1961
src = A . rank = [ 0 ] * ( B + 1 )
trg = (0) からなる列の B に 1 を加えた値回分の列を A の rank に する
rst = (0) からなる列の B に 1 を加えた値回分の列を A の rank に する <eos>
1962
src = A = [ None ] * len ( B )
trg = ( 、 つまり未定値 ) からなる列の B の長さ回分の列を A とする
rst = ( 、 つまり未定値 ) からなる列の B の長さ回分の列を A とする <eos>
1963
src = print ( A . format ( B , C * D [ B ] ) )
trg = A を書式として B 、 C に D の B 番目を掛けた値 で整形した文字列を出力する
rst = A を書式として B 、 C に D の B 番目を掛けた値 で整形した文字列を出力する <eos>
1964
src = return ( 0 <= A - B ) & ( A + B <= C )
trg = 0 が A から B を引いた値 以下かどうかと A に B を加えた値が C 以下かどうか の論理積 を返す
rst = 0 が A から B を引いた値と A に B を加えた値が C 以下かどうかを返す <eos>
1965
src = A . right = B . insert ( A . right , C , D )
trg = B の A の right に C 、 D を挿入する を A の right に する
rst = B の A の right に C 、 D を挿入する を A の right に する <eos>
1966
src = print ( syakkin ( A ) )
trg = syakkin ( A ) を出力する
rst = <unk> ( A ) を出力する <eos>
1967
src = A . append ( float ( B [ C ] ) )
trg = A の末尾に B の C 番目の浮動小数点数 を追加する
rst = A の末尾に B の C 番目の浮動小数点数 を追加する <eos>
1968
src = if A . _is_valid ( B ) and B . y < C :
trg = A ._ is _ valid ( B ) かつ B の y 座標が C より小さいとき 、
rst = A . <unk> ( B ) かつ B の y 座標が C より小さいとき 、 <eos>
1969
src = print ( diameter ( A ) )
trg = diameter ( A ) を出力する
rst = diameter ( A ) を出力する <eos>
1970
src = A . _paths [ B ] = create_path ( B )
trg = create _ path ( B ) を A の _ paths の B 番目に する
rst = <unk> ( B ) を A の _ par _ の B 番目に する <eos>
1971
src = if A == 4 :
trg = A が 4 と等しいとき 、
rst = A が 4 と等しいとき 、 <eos>
1972
src = if A < get ( B ^ e , 17 ) :
trg = A が get ( B ^ e , 17) より小さいとき 、
rst = A が get ( B ^ 17) より小さいとき 、 <eos>
1973
src = if not A [ B ] and C > 0 :
trg = A の B 番目でなくかつ C が 0 より大きいとき 、
rst = A の B 番目でなくかつ C が 0 より大きいとき 、 <eos>
1974
src = A = max ( A , B [ C ] [ D ] [ E ] )
trg = A 、 B の C 番目の D 番目の E 番目の最大値を A とする
rst = A 、 B の C 番目の D 番目の E 番目の最大値を A とする <eos>
1975
src = A = find ( B , C + 1 , 0 , 0 , D )
trg = find ( B , C +1,0,0, D ) を A とする
rst = find ( B , C +1,0,0, D ) を A とする <eos>
1976
src = A = [ B , C ] [ D ]
trg = ( B 、 C ) からなる列の D 番目を A とする
rst = ( B 、 C ) からなる列の D 番目を A とする <eos>
1977
src = A = Dice ( * B )
trg = Dice (* B ) を A とする
rst = Dice (* B ) を A とする <eos>
1978
src = heappush ( A , ( B , time , C , D , E ) )
trg = heappush ( A , ( B , time , C , D , E ))
rst = heappush ( A , ( B , time , C , D , E )) <eos>
1979
src = A = [ [ 0 , B + 1 ] for B in range ( C ) ]
trg = 0 から C 未満までの数列の各要素を B とし 、(0、 B に 1 を加えた値 ) からなる列の列を A とする
rst = 0 から C 未満までの数列の各要素を B とし 、(0、 B に 1 を加えた値 ) からなる列の列を A とする <eos>
1980
src = return int ( ( A * B ) / calc_gcd ( A , B ) )
trg = A に B を掛けた値を calc _ gcd ( A , B ) で割った値の整数値を返す
rst = calc _ gcd ( A * B ) を calc ( A , B ) の整数値を返す <eos>
1981
src = A = magicall ( B , 0 , 0 )
trg = magicall ( B ,0,0) を A とする
rst = PathSum 2( B ,0) を A とする <eos>
1982
src = print_inorder ( A )
trg = print _ inorder ( A )
rst = print _ inorder ( A ) <eos>
1983
src = A , B , C = 0 , 1 , 3
trg = 0 、1、3 を A 、 B 、 C とする
rst = 0、1、2、3 を A 、 B 、 C とする <eos>
1984
src = A = ( A + B [ A ] ) % C
trg = A に B の A 番目を加えた値を C で割った余りを A とする
rst = A に B の A 番目を加えた値を C で割った余りを A とする <eos>
1985
src = A += chr ( ( ord ( B ) - ord ( C ) + 1 ) % 26 + ord ( C ) )
trg = A を 文字 コ ー ド ord ( B ) から ord ( C ) を引いた値に 1 を加えた値を 26 で割った余りに C の順序数を加えた値の文字 だけ 増 加 させ る
rst = A を 文字 コ ー ド ord ( B ) から ord ( C ) を引いた値に 1 を加えた値を 26 で割った余りに C の順序数を加えた値の文字 だけ 増 加 させ る <eos>
1986
src = A , B = map ( lambda C : int ( '' . join ( C . split ( D ) ) ) , input ( ) . split ( ) )
trg = 入力された文字列 を空白で分割した字句列の各要素に x をパラメータとして 空文字列を間に入れて C を D で分割した字句列を連結した文字列 の整数値を返す関数を適用した列 を展開し 、 それぞれ A 、 B とする
rst = 入力された文字列 を空白で分割した字句列の各要素に x をパラメータとして C を D で分割した字句列の各要素を C とし 、 、 つまり入力された文字列 の整数値の列を展開し 、 それぞれ A 、 B とする <eos>
1987
src = print ( poly_area ( A , B ) )
trg = poly _ area ( A , B ) を出力する
rst = <unk> ( A , B ) を出力する <eos>
1988
src = A = A . _replace ( right = _delete ( B ) )
trg = A ._ replace ( right = _ delete ( B )) を A とする
rst = A ._ replace ( right = _ delete ( B )) を A とする <eos>
1989
src = if sum ( A ) < B :
trg = A の総和が B より小さいとき 、
rst = A の総和が B より小さいとき 、 <eos>
1990
src = A = 1000 - int ( input ( ) )
trg = 1000 から 、 つまり入力された文字列の整数値 を引いた値を A とする
rst = 1000 から 、 つまり入力された文字列の整数値 を引いた値を A とする <eos>
1991
src = A [ B ] . parent = C
trg = C を A の B 番目の parent に する
rst = C を A の B 番目の parent に する <eos>
1992
src = A , B = C [ D ] - 1 , C [ D + 1 ] - 1
trg = C の D 番目から 1 を引いた値 、 C の D に 1 を加えた値番目から 1 を引いた値を A 、 B とする
rst = C の D 番目から 1 を引いた値 、 C の D に 1 を加えた値番目から 1 を引いた値を A 、 B とする <eos>
1993
src = if A >= B * C - 1 :
trg = A が B に C を掛けた値から 1 を引いた値以上のとき 、
rst = A が B に C を掛けた値から 1 を引いた値以上のとき 、 <eos>
1994
src = A = 10 ** 18
trg = 10 の 18 乗を A とする
rst = 10 の 18 乗を A とする <eos>
1995
src = return all ( [ A >= 0 for A in B ] ) or all ( [ A <= 0 for A in B ] )
trg = B の各要素を A とし 、 A が 0 以上かどうかの列が全てが真または B の各要素を A とし 、 A が 0 以下かどうかの列が全てが真 かどうかを返す
rst = B の各要素を A とし 、 A が 0 <unk> B の各要素を A とし 、 A が 0 以上の 間 、 次 を 繰り返 す <eos>
1996
src = A = abs ( max ( B ) - min ( B ) )
trg = B の最大値から B の最小値 を引いた値の絶対値を A とする
rst = B の最大値から B の絶対値 を引いた値を A とする <eos>
1997
src = A = Edge ( B . lt [ C ] , 1 )
trg = Edge ( B . lt [ C ],1) を A とする
rst = Edge ( B . lt [ C ] ,1) を A とする <eos>
1998
src = A , B = check ( min ( C + D [ E ] , F ) , G )
trg = check ( min ( C + D [ E ] , F ) , G ) を展開し 、 それぞれ A 、 B とする
rst = check ( C + D [ E ] , F , G ) を展開し 、 それぞれ A 、 B とする <eos>
1999
src = return abs ( A / B ** .5 )
trg = A を B の .5 乗で割った値 の絶対値を返す
rst = A を B の .5 乗で割った値を返す <eos>
2000
src = A . append ( e [ 2 ] )
trg = A の末尾にネイピア数の 2 番目を追加する
rst = A の末尾に ネイピア数の 2 番目を追加する <eos>
2001
src = if A < B or C < D :
trg = A が B より小さくまたは C が D より小さいとき 、
rst = A が B より小さくまたは C が D より小さいとき 、 <eos>
2002
src = while A . key != B :
trg = A の key が B と等しくない 間 、 次 を 繰り返 す
rst = A の key が B と等しくない 間 、 次 を 繰り返 す <eos>
2003
src = if is_intersection ( A , B , C , D ) :
trg = is _ intersection ( A , B , C , D ) のとき 、
rst = is _ intersection ( A , B , C , D ) のとき 、 <eos>
2004
src = A = 2 * B - A
trg = 2 に B を掛けた値から A を引いた値を A とする
rst = 2 に B を掛けた値から A を引いた値を A とする <eos>
2005
src = A = [ ( B [ 0 ] , '' ) ]
trg = ( ( B の先頭 、 空文字列 ) の組 ) からなる列を A とする
rst = ( ( B の先頭 、 空文字列 ) の組 ) からなる列を A とする <eos>
2006
src = add ( A , B + C + 1 , 1 )
trg = add ( A , B + C +1,1)
rst = add ( A , B + C +1,1) <eos>
2007
src = if A - B < C - D :
trg = A から B を引いた値が C から D を引いた値より小さいとき 、
rst = A から B を引いた値が C から D を引いた値より小さいとき 、 <eos>
2008
src = A [ B ] , C [ B ] , D [ B ] = map ( int , input ( ) . split ( ) )
trg = 入力された文字列 を空白で分割した字句列の各要素に 整数を適用した列を展開し 、 それぞれ A の B 番目 、 C の B 番目 、 D の B 番目とする
rst = 入力された文字列 を空白で分割した字句列の各要素に 整数を適用した列を展開し 、 それぞれ A の B 番目 、 C の B 番目 、 D の B 番目とする <eos>
2009
src = A . sort ( key = lambda B : atan2 ( B [ 1 ] - C , B [ 0 ] ) )
trg = p をパラメータとして atan 2( B [1]- C , B [0]) を返す関数を key として A をソート する
rst = p 2( B [1]- C , B [0]) を key として A をソート する <eos>
2010
src = A = B [ C // 2 if C % 2 else C // 2 - 1 ]
trg = B の C を 2 で割った余りのとき C を 2 で割った商 、 そうでなければ C を 2 で割った商から 1 を引いた値番目を A とする
rst = C を 2 で割った余りのとき B の C を 2 で割った商番目 、 そうでなければ C を 2 で割った商から 1 を引いた値番目を A とする <eos>
2011
src = [ print ( A . format ( B , C , B * C ) ) for B in [ range ( 1 , 10 ) for C in range ( 1 , 10 ) ] ]
trg = 1 から 10 未満までの数列の各要素を C とし 、 1 から 10 未満までの数列の列の各要素を B とし 、 A を書式として B 、 C 、 B に C を掛けた値で整形した文字列 を出力するの列
rst = 1 から 10 未満までの数列の各要素を C とし 、 1 から 10 未満までの数列の列の各要素を B とし 、 A を書式として B 、 C 、 B 、 C 、 B で整形した文字列の列 <eos>
2012
src = A = B + abs ( C - D ) / E
trg = B に C から D を引いた値の絶対値を E で割った値を加えた値を A とする
rst = B に C から D を引いた値の絶対値を E で割った値を加えた値を A とする <eos>
2013
src = A = B - time
trg = B から time を引いた値を A とする
rst = B から time を引いた値を A とする <eos>
2014
src = dict [ A ] = 0
trg = 0 を辞書の A 番目に する
rst = 0 を辞書の A 番目に する <eos>
2015
src = A [ B + C ] = A . get ( B + C , 0 ) + 1
trg = A に対応する値 、 もし存在しなければ B に C を加えた値 、0 に 1 を加えた値を A の B に C を加えた値番目に する
rst = A に対応する値 、 もし存在しなければ B に C を加えた値 、0 に 1 を加えた値を A の B に C を加えた値番目に する <eos>
2016
src = A = Simulator ( B , C , D )
trg = Simulator ( B , C , D ) を A とする
rst = <unk> ( B , C , D ) を A とする <eos>
2017
src = A . _edges = [ [ ] for B in range ( C ) ]
trg = 0 から C 未満までの数列の各要素を B とし 、 、 つまり空列の列を A の _ edges に する
rst = 0 から C 未満までの数列の各要素を B とし 、 、 つまり空列の列を A の _ edges に する <eos>
2018
src = if A . y > B . y :
trg = A の y 座標が B の y 座標 より大きいとき 、
rst = A の y 座標が B の y 座標 より大きいとき 、 <eos>
2019
src = if all ( map ( lambda D : D == A [ B ] , A [ B : B + C ] ) ) :
trg = A の B 番目から B に C を加えた値までの部分列の各要素に x をパラメータとして x が A の B 番目と等しいかどうか を返す関数を適用した列 が全てが真のとき 、
rst = C の各要素に <unk> をパラメータとして A の B 番目から 、 つまり末尾までの部分列 を返す関数を適用した列の総和を A とする <eos>
2020
src = A = list ( map ( int , list ( B ) ) )
trg = B のリストの各要素 に整数を適用した列のリストを A とする
rst = B の各要素に 整数を適用した列のリストを A とする <eos>
2021
src = A = A . format ( B , C )
trg = A を書式として B 、 C で整形した文字列を A とする
rst = A を書式として B 、 C で整形した文字列を A とする <eos>
2022
src = if 0 == ( A % B ) :
trg = 0 が A を B で割った余り と等しいとき 、
rst = 0 が A を B で割った余り と等しいとき 、 <eos>
2023
src = A = [ B . strip ( C ) for B in input ( ) . split ( ' ' ) ]
trg = 入力された文字列を空白 文字で分割した字句列の各要素を B とし 、 B の両端から C を取り除いた文字列 の列を A とする
rst = 入力された文字列を空白 文字で分割した字句列の各要素を B とし 、 B の両端から C の整数値の列を A とする <eos>
2024
src = if A [ 0 ] >= B :
trg = A の 0 番目が B 以上のとき 、
rst = A の 0 番目が B 以上のとき 、 <eos>
2025
src = if A + ( B - A * C ) // D < E :
trg = A に B から A に C を掛けた値を引いた値を D で割った商を加えた値が E より小さいとき 、
rst = A に B から A に C を掛けた値を引いた値を D で割った商が E より小さいとき 、 <eos>
2026
src = print ( isSolved ( A ) )
trg = isSolved ( A ) を出力する
rst = <unk> ( A ) を出力する <eos>
2027
src = print ( A [ B ] [ 1 ] , '' , end = '' )
trg = 改行せずに A の B 番目の 1 番目 、 空文字列 を出力する
rst = 改行せずに A の B 番目の 1 番目 、 空文字列 を出力する <eos>
2028
src = A = ( B [ 0 ] - C [ 0 ] , B [ 1 ] - C [ 1 ] )
trg = ( B の 0 番目から C の先頭を引いた値 、 B の 1 番目から C の 1 番目を引いた値 ) の組を A とする
rst = ( B の 0 番目から C の先頭を引いた値 、 B の 1 番目から C の 1 番目を引いた値 ) の組を A とする <eos>
2029
src = A = max ( B )
trg = B の最大値を A とする
rst = B の最大値を A とする <eos>
2030
src = print ( A [ B ] )
trg = A の B 番目を出力する
rst = A の B 番目を出力する <eos>
2031
src = funcs[int(op)] ( A )
trg = funcs [ int ( op ) ] ( A )
rst = <unk> ( A ) <eos>
2032
src = A . valuelist . append ( [ A . valuelist [ 0 ] [ 0 ] , A . valuelist [ 0 ] [ 1 ] - time ] )
trg = A の valuelist の末尾に ( A の valuelist の先頭の先頭 、 A . valuelist の先頭の 1 番目から time を引いた値 ) からなる列 を追加する
rst = A の valuelist の末尾に ( A の valuelist の先頭の先頭 、 A の valuelist の先頭の 1 番目から time を引いた値 ) からなる列 を追加する <eos>
2033
src = A = B ** 2 + 1
trg = B の 2 乗に 1 を加えた値を A とする
rst = B の 2 乗に 1 を加えた値を A とする <eos>
2034
src = if A . root [ B ] < 0 :
trg = A の root の B 番目が 0 より小さいとき 、
rst = A の root の B 番目が 0 より小さいとき 、 <eos>
2035
src = A = ( C if B else D )
trg = B のとき C 、 そうでなければ D を A とする
rst = B のとき C 、 そうでなければ D を A とする <eos>
2036
src = A [ B ] [ 0 ] [ 0 ] = 0
trg = 0 を A の B 番目の先頭の 0 番目に する
rst = 0 を A の B 番目の先頭の 0 番目に する <eos>
2037
src = A = [ 0 , 1 , - 1 , 0 ]
trg = (0、1、-1、0 ) からなる列を A とする
rst = (0、-1、0、1) からなる列を A とする <eos>
2038
src = push ( A )
trg = push ( A )
rst = push ( ( A ) <eos>
2039
src = if find ( A , B , C ) :
trg = find ( A , B , C ) のとき 、
rst = find ( A , B , C ) のとき 、 <eos>
2040
src = A [ B ] = C - len ( D )
trg = C から D の長さを引いた値を A の B 番目に する
rst = C から D の長さを引いた値を A の B 番目に する <eos>
2041
src = A . x = B [ 0 ]
trg = B の先頭を A の x 座標に する
rst = B の先頭を A の x 座標に する <eos>
2042
src = A = B [ 0 ] [ 1 ]
trg = B の先頭の 1 番目を A とする
rst = B の先頭の 1 番目を A とする <eos>
2043
src = if A . count ( B ) == 2 :
trg = A 内の B の出現回数が 2 と等しいとき 、
rst = A 内の B の出現回数が 2 と等しいとき 、 <eos>
2044
src = print ( B if A [ 1 ] & 1 and A [ 2 ] & 1 else C )
trg = A の 1 番目と 1 の論理積かつ A の 2 番目と 1 の論理積のとき B 、 そうでなければ C を出力する
rst = A の 1 番目と 1 の論理積かつ A の 2 番目と 1 の論理積のとき B 、 そうでなければ C を出力する <eos>
2045
src = if A >= 0 and A < 8 :
trg = A が 0 以上かつ A が 8 より小さいとき 、
rst = A が 0 以上かつ A が 8 より小さいとき 、 <eos>
2046
src = print ( A . join ( map ( str , B [ C ] . children ) ) , end = '' )
trg = 改行せずに A を間に入れて B の C 番目の children の各要素に整数を適用した列 を連結した文字列を出力する
rst = 改行せずに A を間に入れて B の C 番目の children の各要素に整数を適用した列 を連結した文字列を出力する <eos>
2047
src = solve ( A )
trg = solve ( A )
rst = solve ( A ) <eos>
2048
src = if not A and B == 0 :
trg = A でなくかつ B が 0 と等しいとき 、
rst = A でなくかつ B が 0 と等しいとき 、 <eos>
2049
src = A = [ B for B in C if B <= D ]
trg = C の各要素を B とし 、 B が D 以下のとき の B の列を A とする
rst = C の各要素を B とし 、 B が D 以下のとき の B の列を A とする <eos>
2050
src = if A < B or C < A :
trg = A が B より小さくまたは C が A より小さいとき 、
rst = A が B より小さくまたは C が A より小さいとき 、 <eos>
2051
src = if A [ B - 1 ] == C :
trg = A の B から 1 を引いた値番目が C と等しいとき 、
rst = A の B から 1 を引いた値番目が C と等しいとき 、 <eos>
2052
src = A = ( ( 0 , 1 , 2 , 3 ) , ( 1 , 2 , 3 , 0 ) , ( 2 , 3 , 0 , 1 ) , ( 3 , 0 , 1 , 2 ) )
trg = ( (0、1、2、3 ) の組 、 (1、2、3、0) の組 、 (2、3、0、1) の組 、 (3、0、1、2) の組 ) の組を A とする
rst = <unk> の組 、(-1、3 ) の組 、(1、 -3) の組 、 2、3、3 、3) の組を A とする <eos>
2053
src = A = merge_sort ( B , 0 , C )
trg = merge _ sort ( B ,0, C ) を A とする
rst = merge _ sort ( B ,0, C ) を A とする <eos>
2054
src = if A [ B ] [ 1 ] < 10 :
trg = A の B 番目の 1 番目が 10 より小さいとき 、
rst = A の B 番目の 1 番目が 10 より小さいとき 、 <eos>
2055
src = print ( * A [ 0 ] )
trg = A の先頭 を展開してを出力する
rst = A の先頭 を展開してを出力する <eos>
2056
src = A = search ( B - 1 , C , D , E )
trg = C 、 D 、 E に お いて正規表現 B から 1 を引いた値が最初にマッチする位置 を A とする
rst = C 、 D 、 E に お いて正規表現 B から 1 を加えた値が最初にマッチする位置 を A とする <eos>
2057
src = del A [ A . index ( 0 ) ]
trg = A の A の 0 と等しい要素の最初の位置番目を 削 除 する
rst = A の A の 0 と等しい要素の最初の位置番目を 削 除 する <eos>
2058
src = A [ ( 6 , 4 ) ] = B
trg = B を A の (6、4) の組番目に する
rst = B を A の ( 6 、4) の組番目に する <eos>
2059
src = A = bin ( B ) [ - len ( C ) : ] . count ( D )
trg = B の 2 進 数文字列の - C の長さから 、 つまり末尾までの部分列内の D の出現回数を A とする
rst = B の -2 進 数文字列内の C の出現回数 より大きいかどうかを D とする <eos>
2060
src = A = B [ C + 1 : ]
trg = B の C に 1 を加えた値から 、 つまり末尾までの部分列を A とする
rst = B の C に 1 を加えた値から 、 つまり末尾までの部分列を A とする <eos>
2061
src = A = len ( B ) * ( 16 ** C )
trg = B の長さに 16 の C 乗を掛けた値を A とする
rst = B の長さに 16 の C 乗を掛けた値を A とする <eos>
2062
src = if A [ B ] > A [ B + 1 ] :
trg = A の B 番目が A の B に 1 を加えた値番目 より大きいとき 、
rst = A の B 番目が A の B に 1 を加えた値 番目より大きいとき 、 <eos>
2063
src = if A + B < get ( C & D , 17 ) :
trg = A に B を加えた値が get ( C & D , 17) より小さいとき 、
rst = A に B を加えた値が get ( C ^ D , 17) より小さいとき 、 <eos>
2064
src = A += min ( B , 2 * C )
trg = A を B 、 2 に C を掛けた値の最小値 だけ 増 加 させ る
rst = A を B 、 2 に C を掛けた値の最小値 だけ 増 加 させ る <eos>
2065
src = A = - 2 ** 31
trg = - 2 の 31 乗を A とする
rst = - 2 の 31 乗を A とする <eos>
2066
src = A = [ 1 , 0 , 0 ]
trg = (1、0、0) からなる列を A とする
rst = ( 1、0、0、1 ) からなる列を A とする <eos>
2067
src = A = 5 * ( ( B % 1461 ) // 4 ) + 2
trg = 5 に B を 1461 で割った余りを 4 で割った商を掛けた値に 2 を加えた値を A とする
rst = 5 に B を 4 で割った余りを 2 で割った商に 2 を加えた値を A とする <eos>
2068
src = A , B , C = .5 , 1 , 1
trg = .5 、 1 、 1 を A 、 B 、 C とする
rst = (1、5、 1 、 1 を A 、 B 、 C とする <eos>
2069
src = A . append ( [ B , - C ] )
trg = A の末尾に ( B 、 - C ) からなる列 を追加する
rst = A の末尾に ( B 、 - C ) からなる列 を追加する <eos>
2070
src = A , B , C = D [ D . index ( ( E ** 2 + F ** 2 , E , F ) ) + 1 ]
trg = D の D の ( E **2 に F **2 を加えた値 、 E 、 F ) の組 と等しい要素の最初の位置に 1 を加えた値番目を展開し 、 それぞれ A 、 B 、 C とする
rst = D の E の 2 乗に F の 2 乗を加えた値 、 E に F を加えた値 と等しい要素の最初の位置 を加えた値 、 E の 2 乗に 1 を加えた値を A 、 B 、 C とする <eos>
2071
src = D , E = pi [ ( C + 1 ) % F ]
trg = 円周率の C に 1 を加えた値を F で割った余り 番目を展開し 、 それぞれ D 、 E とする
rst = 円周率の C に 1 を加えた値を F で割った余り番目を D 、 E とする <eos>
2072
src = A = map ( B , C )
trg = C の各要素に B を適用した列を A とする
rst = C の各要素に B を適用した列を A とする <eos>
2073
src = A [ - 1 ] -= B [ now ]
trg = A の -1 番目を B の 、 つまり現在の日時番目 だけ 減 少 させ る
rst = A の -1 番目を B の 、 つまり現在の日時 番目だけ 減 少 させ る <eos>
2074
src = A [ ( B - 1 ) * C + ( D + 1 ) ] . append ( ( ( B - 1 ) * C + D , E + 1 ) )
trg = A の B から 1 を引いた値に C を掛けた値に D に 1 を加えた値 を加えた値番目の末尾に ( B から 1 を引いた値に C を掛けた値に D を加えた値 、 E に 1 を加えた値 ) の組 を追加する
rst = A の B から 1 を引いた値に C を掛けた値に D に 1 を加えた値を加えた値 を加えた値番目の末尾に ( B から 1 を引いた値に C を掛けた値に D を加えた値 、 E ) の組 を追加する <eos>
2075
src = print ( A [ 0 ] , B )
trg = A の先頭 、 B を出力する
rst = A の先頭 、 B を出力する <eos>
2076
src = A [ 0 ] , A [ 1 ] , A [ 5 ] , A [ 4 ] = A [ 1 ] , A [ 5 ] , A [ 4 ] , A [ 0 ]
trg = A の 1 番目 、 A の 5 番目 、 A の 4 番目 、 A の先頭を A の先頭 、 A の 1 番目 、 A の 5 番目 、 A の 4 番目とする
rst = A の 1 番目 、 A の 5 番目 、 A の先頭 、 A の 4 番目を A の先頭 、 A の 1 番目 、 A の 5 番目 、 A の 4 番目とする <eos>
2077
src = e = 0
trg = 0 をネイピア数とする
rst = 0 をネイピア数とする <eos>
2078
src = return A - 1
trg = A から 1 を引いた値を返す
rst = A から 1 を引いた値を返す <eos>
2079
src = if A [ B ] [ 1 ] < A [ B - 1 ] [ 1 ] :
trg = A の B 番目の 1 番目が A の B から 1 を引いた値番目の 1 番目より小さいとき 、
rst = A の B 番目の 1 番目が A の B から 1 を引いた値番目の 1 番目より小さいとき 、 <eos>
2080
src = dfs ( 1 , A , B , C )
trg = dfs (1, A , B , C )
rst = dfs (1, A , B , C ) <eos>
2081
src = if A [ 0 ] [ B ] == C and A [ 1 ] [ B ] == C and A [ 2 ] [ B ] == C :
trg = A の先頭の B 番目が C と等しくかつ A の 1 番目の B 番目が C と等しくかつ A の 2 番目の B 番目が C と等しいとき 、
rst = A の先頭の B 番目が C と等しくかつ A の 1 番目の B 番目が C と等しくかつ A の 2 番目の B 番目が C と等しいとき 、 <eos>
2082
src = A = [ ( 0 , 0 , pi ) , ( 1 , 0 , B ) ]
trg = ((0、0、 円周率 ) の組 、(1、 0 、 B ) の組 ) からなる列を A とする
rst = ((0、0、 、 つまり円周率 ) の組 、 ( 、 1 、 B ) の組 ) からなる列を A とする <eos>
2083
src = if Step_Check ( A ) :
trg = Step _ Check ( A ) のとき 、
rst = <unk> ( A ) のとき 、 <eos>
2084
src = A = ( 2 * 60 * 60 - time ) * 3
trg = 2 に 60 を掛けた値に 60 を掛けた値から time を引いた値に 3 を掛けた値を A とする
rst = 2 に 60 を掛けた値に 60 を掛けた値から time を引いた値を A とする <eos>
2085
src = A [ B | C ] = max ( A [ B | C ] , A [ B ] + D )
trg = A の B と C の論理和番目 、 A の B 番目に D を加えた値の最大値を A の B と C の論理和 番目に する
rst = A の B と C の論理和番目 、 A の B 番目に D を加えた値の最大値を A の B と C の論理和 番目に する <eos>
2086
src = if not 0 <= A < B or not 0 <= C < B :
trg = 0 が A 以下かどうかが B より小さくなくまたは 0 が C 以下かどうかが B より小さくないとき 、
rst = 0 が A 以下かどうかが B より小さくなくまたは 0 が C 以下かどうかが B より小さくないとき 、 <eos>
2087
src = A = B - ( B ** 3 - C ) / ( 3 * B ** 2 )
trg = B から B の 3 乗から C を引いた値を 3 に B の 2 乗を掛けた値で割った値 を引いた値を A とする
rst = B から B の 3 乗から C を引いた値を 3 に B の 2 乗を掛けた値で割った値 を引いた値を A とする <eos>
2088
src = A [ B ] = [ C for C in D ]
trg = D の各要素を C とし 、 C の列を A の B 番目に する
rst = D の各要素を C とし 、 C の列を A の B 番目に する <eos>
2089
src = A [ B * C + D ] = E [ B ] [ D ]
trg = E の B 番目の D 番目を A の B に C を掛けた値に D を加えた値番目に する
rst = E の B 番目の D 番目を A の B に C を掛けた値に D を加えた値番目に する <eos>
2090
src = A [ B ] . append ( [ 0 , C , D ] )
trg = A の B 番目の末尾に (0、 C 、 D ) からなる列 を追加する
rst = A の B 番目の末尾に (0、 C 、 D ) からなる列 を追加する <eos>
2091
src = A [ B - 1 ] [ : ] = C
trg = C を A の B から 1 を引いた値番目の 、 つまり先頭から 、 つまり末尾までの部分列に する
rst = C を A の B から 1 を引いた値番目の 、 つまり先頭から 、 つまり末尾までの部分列 番目に する <eos>
2092
src = if A > 60 :
trg = A が 60 より大きいとき 、
rst = A が 60 より大きいとき 、 <eos>
2093
src = A = [ [ [ inf ] * [ 31 for B in range ( C ) ] ] for D in range ( C ) ]
trg = 0 から C 未満までの数列の各要素を D とし 、(( 、 つまり無限大 ) からなる列の 0 から C 未満までの数列の各要素を B とし 、 31 の列回分の列 ) からなる列の列を A とする
rst = 0 から C 未満までの数列の各要素を D とし 、(( 、 つまり無限大 ) からなる列の 0 から C 未満までの数列の各要素を B とし 、 31 の列回分の列 ) からなる列の列を A とする <eos>
2094
src = A , B = C [ 0 ] . split ( )
trg = C の先頭 を空白で分割した字句列 を展開し 、 それぞれ A 、 B とする
rst = C の先頭 を空白で分割した字句列 を展開し 、 それぞれ A 、 B とする <eos>
2095
src = A [ B [ C ] ] = A [ B [ C ] ] + 1
trg = A の B の C 番目番目に 1 を加えた値を A の B の C 番目番目に する
rst = A の B の C 番目番目に 1 を加えた値を A の B の C 番目番目に する <eos>
2096
src = A = min ( A , ( B [ 0 ] + abs ( C [ D ] - C [ E ] ) / 2000 * ( F ) , [ E ] + B [ 1 ] ) )
trg = A 、 ( B の 0 番目に abs ( C [ D ] - C [ E ] ) を 2000 で割った値に F を掛けた値を加えた値 、 ( E ) からなる列に B の 1 番目を加えた値 ) の組 の最小値を A とする
rst = A 、 B の 0 番目に C [ D ] から C [ E ] を引いた値の絶対値を E で割った値 、 F に B の 1 番目を掛けた値に E の F の C 番目を加えた値の最小値を A とする <eos>
2097
src = A = max ( [ B for C , B in D ] )
trg = D の各要素を C 、 B とし 、 B の列の最大値を A とする
rst = D の各要素を C 、 B とし 、 B の列の最大値を A とする <eos>
2098
src = saizo ( list ( map ( int , input ( ) . split ( ) ) ) )
trg = saizo ( list ( map ( int , input (). split ())))
rst = 入力された文字列 を空白で分割した字句列の各要素に 整数を適用した列のリストに <unk> <eos>
2099
src = A . q = BIT ( B + 1 )
trg = BIT ( B +1) を A の q に する
rst = BIT ( B +1) を A の q に する <eos>
2100
src = if A . score == B . score :
trg = A の score が B の score と等しいとき 、
rst = A の score が B の score と等しいとき 、 <eos>
2101
src = A , B = [ 0 ] * 128 , [ 0 ] * 128
trg = (0) からなる列の 128 回分の列 、 (0) からなる列の 128 回分の列を A 、 B とする
rst = (0) からなる列の 128 回分の列 、0 を A 、 B とする <eos>
2102
src = print ( A [ ( B . real , B . imag ) ] , end = '' )
trg = 改行せずに A の ( B の real 、 B の imag ) の組 番目を出力する
rst = 改行せずに A の B の imag 、 B の imag を出力する <eos>
2103
src = A += 7 * B + C
trg = A を 7 に B を掛けた値に C を加えた値だけ 増 加 させ る
rst = A を 7 に B を掛けた値に C を加えた値だけ 増 加 させ る <eos>
2104
src = A = B . projection ( Point ( C , D ) )
trg = B . projection ( Point ( C , D )) を A とする
rst = B . projection ( Point ( C , D )) を A とする <eos>
2105
src = A = { [ tuple ( map ( int , input ( ) . split ( ) ) ) for B in range ( C ) ] }
trg = ( < __ main __ . Cammaobjectat 0 x 10 a 2034 3 0> ) の集合を A とする
rst = ( < __ main __ . Cammaobjectat 0 x 10 a 000 e 2 0> ) の集合を A とする <eos>
2106
src = A |= ( A + 1 )
trg = A を A に 1 を加えた値と の 論理和に する
rst = A を A に 1 を加えた値 番目との 論理和に する <eos>
2107
src = return translate ( int ( A / 4 ) ) + str ( A % 4 )
trg = translate ( int ( A /4) ) に A を 4 で割った余りの文字列 を加えた値を返す
rst = translate ( int ( A / 4 )) を返す <eos>
2108
src = A += ryoukin ( B , C , D , E )
trg = A を ryoukin ( B , C , D , E ) だけ 増 加 させ る
rst = A を <unk> ( B , C , D , E ) だけ 増 加 させ る <eos>
2109
src = return ( A [ B + C ] * ( B - C + 1 ) % D ) * ( E [ C ] * E [ B + 1 ] % D ) % D
trg = A の B + C 番目に B - C に 1 を加えた値を掛けた値を D で割った余りに E の C 番目に E の B +1 番目を掛けた値を D で割った余りを掛けた値を D で割った余りを返す
rst = A の B に C を加えた値番目に B から C を引いた値に 1 を加えた値を掛けた値を D で割った余りに E の C 番目を掛けた値を加えた値を D で割った余りを加えた値を D で割った余りを返す <eos>
2110
src = A [ str ( B ) ] [ str ( C [ D ] ) ] = C [ D + 1 ]
trg = C の D に 1 を加えた値番目を A の B の文字列番目の C の D 番目の文字列 番目に する
rst = C の D に 1 を加えた値番目を A の B の文字列 番目の C の D の文字列 番目に する <eos>
2111
src = A = create_prime_list ( 999999 )
trg = create _ prime _ list ( 999999) を A とする
rst = create _ prime _ list (10000) を A とする <eos>
2112
src = A = A + C if B == C else A + ' '
trg = B が C と等しいとき A に C を加えた値 、 そうでなければ A に空白文字を加えた値を A とする
rst = B が C と等しいとき A に C を加えた値 、 そうでなければ A に空白文字を加えた値を A とする <eos>
2113
src = while A <= abs ( B [ 0 ] ) :
trg = A が B の先頭の絶対値 以下の 間 、 次 を 繰り返 す
rst = A が B <unk> 間 、 次 を 繰り返 す <eos>
2114
src = for A in range ( B - 1 , C + 1 , - 1 ) :
trg = B から 1 を引いた値から C に 1 を加えた値未満までの -1 間隔の数列を順に A として 、 繰り返 す
rst = B から 1 を引いた値から C に 1 を加えた値未満までの -1 間隔の数列を順に A として 、 繰り返 す <eos>
2115
src = A [ find ( B ) ] = C
trg = C を A の find ( B ) 番目に する
rst = C を A の find ( B ) 番目に する <eos>
2116
src = print ( levenshtein ( A , B ) )
trg = levenshtein ( A , B ) を出力する
rst = <unk> ( A , B ) を出力する <eos>
2117
src = A = sum ( [ pow ( abs ( B - C ) , D ) for B , C in zip ( E , F ) ] )
trg = E 、 F の要素をそれぞれ組にした列 の各要素を B 、 C とし 、 B から C を引いた値の絶対値の D 乗の列の総和を A とする
rst = E 、 F の要素をそれぞれ組にした列 の各要素を B 、 C とし 、 B から C を引いた値の絶対値 の列の総和を D とする <eos>
2118
src = print ( D if A < B < C else E )
trg = A が B より小さいかどうかが C より小さいとき D 、 そうでなければ E を出力する
rst = A が B より小さいとき D 、 そうでなければ C を出力する <eos>
2119
src = A . sort ( key = lambda B : B [ 1 ] - B [ 0 ] )
trg = c をパラメータとして c の 1 番目から c の先頭 を引いた値を返す関数を key として A をソート する
rst = x をパラメータとして x の 1 番目から x の先頭 を引いた値を返す関数を key として A をソート する <eos>
2120
src = A . pop ( A . index ( max ( A ) ) )
trg = A の A の A の最大値と等しい要素の最初の位置 を取り出した値
rst = A の A の A の最大値と等しい要素の最初の位置 を取り出した値 <eos>
2121
src = A = Segment ( e , B , C , D )
trg = Segment ( e , B , C , D ) を A とする
rst = Segment ( e , B , C , D ) を A とする <eos>
2122
src = if not ( A [ 0 ] + B , A [ 1 ] + C ) in D :
trg = ( A の 0 番目に B を加えた値 、 A の 1 番目に C を加えた値 ) の組が D に含まれないとき 、
rst = A の 0 番目に B を加えた値 、 A の 1 番目に C を加えた値が D に含まれないとき 、 <eos>
2123
src = A = B [ C : C + 3 ]
trg = B の C 番目から C に 3 を加えた値までの部分列を A とする
rst = B の C 番目から C に 3 を加えた値までの部分列を A とする <eos>
2124
src = A = min ( B , C ) - D
trg = B 、 C の最小値から D を引いた値を A とする
rst = B 、 C の最小値から D を引いた値を A とする <eos>
2125
src = if A [ B // 2 ] not in [ C , D ] :
trg = A の B を 2 で割った商番目が ( C 、 D ) からなる列 に含まれないとき 、
rst = A の B を 2 で割った商番目が ( C 、 D ) からなる列 に含まれないとき 、 <eos>
2126
src = A . x = B . x - C . x
trg = B の x 座標から C の x 座標を引いた値を A の x 座標に する
rst = B の x 座標から C の x 座標を引いた値を A の x 座標に する <eos>
2127
src = if A [ 1 ] <= B and A [ 2 ] <= C and A [ 3 ] <= D and E <= F :
trg = A の 1 番目が B 以下かつ A の 2 番目が C 以下かつ A の 3 番目が D 以下かつ E が F 以下のとき 、
rst = A の 1 番目が B 以下かつ A の 2 番目が C 以下かつ A の 3 番目が D 以下かつ E が F 以下のとき 、 <eos>
2128
src = [ print ( A . format ( str ( B [ C ] [ D ] ) ) , end = '' ) for D in range ( E + 1 ) ]
trg = 0 から E に 1 を加えた値未満までの数列の各要素 を D とし 、 、 つまり 改行せずに A を書式として B [ C ] の D 番目の文字列で整形した文字列 を出力するの列
rst = 改行せずに E に 1 を加えた値未満までの数列の各要素 を D とし 、 A を書式として B [ C ] [ D ] で整形した文字列 番目で整形した文字列を出力する の列 <eos>
2129
src = A = cross ( B , C ) / 2
trg = cross ( B , C ) を 2 で割った値を A とする
rst = cross ( B , C ) を 2 で割った値を A とする <eos>
2130
src = bisect . insort_left ( A , B [ 1 ] )
trg = B の 1 番目を A にソート順で 挿入する
rst = B の 1 番目を A にソート順で 挿入する <eos>
2131
src = if A [ - 1 ] == 0 :
trg = A の -1 番目が 0 と等しいとき 、
rst = A の -1 番目が 0 と等しいとき 、 <eos>
2132
src = print ( allocate ( A , B ) )
trg = allocate ( A , B ) を出力する
rst = <unk> ( A , B ) を出力する <eos>
2133
src = for A in range ( 1 , min ( B , C - B ) ) :
trg = 1 から B 、 C から B を引いた値の最小値 未満までの数列を順に A として 、 繰り返 す
rst = 1 から B 、 C から B を引いた値の最小値 未満までの数列を順に A として 、 繰り返 す <eos>
2134
src = A , B = ( input ( ) + C ) . split ( ) [ : 2 ]
trg = 入力された文字列 に C を加えた値 を空白で分割した字句列の 、 つまり先頭から 2 番目までの部分列を展開し 、 それぞれ A 、 B とする
rst = 入力された文字列 に C を加えた値 を空白で分割した字句列の 、 つまり先頭から 2 番目までの部分列を展開し 、 それぞれ A 、 B とする <eos>
2135
src = A = len ( B . pos )
trg = B の pos の長さを A とする
rst = B の pos の長さを A とする <eos>
2136
src = if A [ B ] == float ( C ) :
trg = A の B 番目が C の浮動小数点数 と等しいとき 、
rst = A の B 番目が C の浮動小数点数 と等しいとき 、 <eos>
2137
src = if A == [ ( 0 , 0 ) , ( 0 , 1 ) , ( 1 , 0 ) , ( 1 , 1 ) ] :
trg = A が ((0、0) の組 、(0、1) の組 、(1、0) の組 、(1、1) の組 ) からなる列と等しいとき 、
rst = A が ((0、0) の組 、(0、1) の組 、(1、0) の組 、(1、1) の組 ) からなる列と等しいとき 、 <eos>
2138
src = A = 2 ** 32
trg = 2 の 32 乗を A とする
rst = 2 の 32 乗を A とする <eos>
2139
src = A -= ( A - 1 ) % 5
trg = A を A から 1 を引いた値を 5 で割った余りだけ 減 少 させ る
rst = A を A から 1 を引いた値を 5 で割った余りだけ 減 少 させ る <eos>
2140
src = if A % 2 == 0 and B < 10 :
trg = A を 2 で割った余りが 0 と等しくかつ B が 10 より小さいとき 、
rst = A を 2 で割った余りが 0 と等しくかつ B が 10 より小さいとき 、 <eos>
2141
src = return ( A . station_count - A . init + B ) % A . station_count
trg = A の station _ count から A の init を引いた値に B を加えた値を A の station _ count で割った余りを返す
rst = A の <unk> から A の init を引いた値に B を加えた値を A の <unk> を返す <eos>
2142
src = A [ 17 ] , A [ 15 ] = A [ 15 ] , A [ 17 ]
trg = A の 15 番目 、 A の 17 番目を A の 17 番目 、 A の 15 番目とする
rst = A の 15 番目 、 A の 17 番目を A の 17 番目 、 A の 15 番目とする <eos>
2143
src = A ^= B
trg = A を B と の排他 的 論理和に する
rst = A を B と の排他 的 論理和に する <eos>
2144
src = A = { B , C , D }
trg = ( < __ main __ . Cammaobjectat 0 x 109 e 4 1 37 0> ) の集合を A とする
rst = ( < __ main __ . Cammaobjectat 0 x 10 a 0 179 a 0> ) の集合を A とする <eos>
2145
src = A , B , C = f ( D , E , 1 ) , f ( F , G , 1 ) , f ( H , I , 1 )
trg = f ( D , E ,1) 、 f ( F , G ,1) 、 f ( H , I ,1) を A 、 B 、 C とする
rst = f ( D , E , 1 ) 、 f ( F , G , H , I , J ) を展開し 、 それぞれ A 、 B 、 C とする <eos>
2146
src = print ( A * ( B == 1 ) + C * ( B == 2 ) + D * ( B == 3 ) + E * ( B == 4 ) + F * ( B == 5 ) + G * ( B == 6 ) + H * ( B == 7 ) + I )
trg = A に B が 1 と等しいかどうかに C に ( B == 2 ) に D *( B == 3)+ E *( B == 4 )+ F *( B == 5)+ G *( B == 6 )+ H *( B == 7 )+ I を加えた値を掛けた値を加えた値 を掛けた値を出力する
rst = A に B が 1 と等しいかどうかを掛けた値に C に ( B +2) を掛けた値に D に B が 3 と等しいかどうかを加えた値に E に B が F に B を掛けた値を加えた値を G に 7 を掛けた値を加えた値 と等しいとき 、 <eos>
2147
src = A = namedtuple ( B , C )
trg = namedtuple ( B , C ) を A とする
rst = namedtuple ( B , C ) を A とする <eos>
2148
src = A = 1
trg = 1 を A とする
rst = 1 を A とする <eos>
2149
src = while A != B . NIL :
trg = A が B の NIL と等しくない 間 、 次 を 繰り返 す
rst = A が B の NIL と等しくない 間 、 次 を 繰り返 す <eos>
2150
src = if A == 0 and e == 2 :
trg = A が 0 と等しくかつ 、 つまりネイピア数が 2 と等しいとき 、
rst = A が 0 と等しくかつ 、 つまりネイピア数が 2 と等しいとき 、 <eos>
2151
src = return sorted ( [ list ( map ( float , input ( ) . split ( ) ) ) for A in range ( 8 ) ] , key = lambda B : B [ 1 ] )
trg = x をパラメータとして x の 1 番目を返す関数をキーとして 0 から 8 未満までの数列の各要素を A とし 、 input () を空白で分割した字句列の各要素に 浮動小数点数を適用した列のリスト の列をソートした列 を返す
rst = x をパラメータとして - x の 1 番目を返す関数をキーとして 0 から B 未満までの数列の各要素を A とし 、 input () を空白で分割した字句列の各要素に 整数を適用した列のリストの列を ソートした列を A とする <eos>
2152
src = A = fix ( A * B )
trg = fix ( A * B ) を A とする
rst = fix ( A * B ) を A とする <eos>
2153
src = A . lt = [ ]
trg = 空列を A の lt に する
rst = 空列を A の lt に する <eos>
2154
src = e = A / abs ( A )
trg = A を A の絶対値で割った値を ネイピア数とする
rst = A を A の絶対値で割った値を返す <eos>
2155
src = if A and B == [ 10 , 11 , 12 , 13 , 14 ] :
trg = A かつ B が ( 10、11、12、13、14 ) からなる列と等しいとき 、
rst = A かつ B が ( 10 、10、11、12、13 ) からなる列と等しいとき 、 <eos>
2156
src = if can_construct_q ( A , B + 1 , C + D [ B ] ) :
trg = can _ construct _ q ( A , B +1, C + D [ B ] ) のとき 、
rst = <unk> ( A , B +1, C + D [ B ] ) のとき 、 <eos>
2157
src = A [ - 1 ] *= B
trg = A の -1 番目を B 倍 に する
rst = A の -1 番目を B 倍 に する <eos>
2158
src = D = - 1
trg = -1 を D とする
rst = -1 を D とする <eos>
2159
src = A [ 0 ] += 3
trg = A の 0 番目を 3 だけ 増 加 させ る
rst = A の 0 番目を 3 だけ 増 加 させ る <eos>
2160
src = A . append ( [ B , C - 1 ] )
trg = A の末尾に ( B 、 C から 1 を引いた値 ) からなる列 を追加する
rst = A の末尾に ( B 、 C から 1 を引いた値 ) からなる列 を追加する <eos>
2161
src = A [ B ] [ C ] = min ( A [ B - 1 ] [ C ] , A [ B ] [ C - 1 ] , A [ B - 1 ] [ C - 1 ] ) + 1
trg = A の B から 1 を引いた値番目の C 番目 、 A の B 番目の C から 1 を引いた値番目 、 A の B から 1 を引いた値番目の C から 1 を引いた値番目の最小値に 1 を加えた値を A の B 番目の C 番目に する
rst = A の B から 1 を引いた値番目の C 番目 、 A の B 番目の C から 1 を引いた値番目の最小値に 1 を加えた値を A の B 番目の C 番目に する <eos>
2162
src = A = [ 0 ] * 12
trg = (0) からなる列の 12 回分の列を A とする
rst = (0) からなる列の 12 回分の列を A とする <eos>
2163
src = A . _add_index_left ( B )
trg = A ._ add _ index _ left ( B )
rst = A . <unk> ( B ) <eos>
2164
src = if ( A . pop ( ) != - B [ C ] ) :
trg = A の先頭を取り出した値 が - B の C 番目と等しくないとき 、
rst = A の先頭を取り出した値 が - B の C 番目と等しくないとき 、 <eos>
2165
src = if A in B . _cache :
trg = A が B の _ cache に含まれるとき 、
rst = A が B の _ cache に含まれるとき 、 <eos>
2166
src = if all ( [ e <= 0 for e in A ] ) or all ( [ e >= 0 for e in A ] ) :
trg = A の各要素をネイピア数 とし 、 、 つまりネイピア数が 0 以下かどうかの列が全てが真 または A の各要素をネイピア数 とし 、 、 つまりネイピア数が 0 以上かどうかの列が全てが真 のとき 、
rst = A の各要素をネイピア数 とし 、 、 つまりネイピア数が 0 <unk> A の各要素をネイピア数 とし 、 、 つまりネイピア数が 0 以上のとき 、 <eos>
2167
src = if ( A <= B ** 2 ) :
trg = A が B の 2 乗 以下のとき 、
rst = A が B の 2 乗 以下のとき 、 <eos>
2168
src = if A [ 0 ] > 0 :
trg = A の 0 番目が 0 より大きいとき 、
rst = A の先頭が 0 より大きいとき 、 <eos>
2169
src = A = sum ( B [ : C ] )
trg = B の 、 つまり先頭から C 番目までの部分列の総和を A とする
rst = B の 、 つまり先頭から C 番目までの部分列の総和を A とする <eos>
2170
src = if A <= B and A >= C :
trg = A が B 以下かつ A が C 以上のとき 、
rst = A が B 以下かつ A が C 以上のとき 、 <eos>
2171
src = print ( - A [ B [ 0 ] ] [ 0 ] )
trg = - A の B の先頭番目の先頭 を出力する
rst = - A の B の先頭番目の先頭 を出力する <eos>
2172
src = A [ B ] [ 1 ] += ( C * D )
trg = A の B 番目の 1 番目を C に D を掛けた値だけ 増 加 させ る
rst = A の B 番目の 1 番目を C に D を掛けた値だけ 増 加 させ る <eos>
2173
src = A = full_move1 ( B - 1 ) * 3 + 2
trg = full _ move 1 ( B -1) に 3 を掛けた値に 2 を加えた値を A とする
rst = full _ move 1 ( B -1) に 3 を掛けた値に 2 を加えた値を A とする <eos>
2174
src = A = reachable ( B , C ) . difference ( reachable ( D , E ) )
trg = reachable ( B , C ) と reachable ( D , E ) の 差 を A とする
rst = <unk> ( B , C ) . difference ({ D <unk> E ) を A とする <eos>
2175
src = print ( eval ( A ) )
trg = 文字列 A を 評価 した値を出力する
rst = 文字列 A を 評価 した値の整数値 を出力する <eos>
2176
src = return len ( A . tree )
trg = A の tree の長さを返す
rst = A の tree の長さを返す <eos>
2177
src = print ( A . max_flow ( 0 , B - 1 ) )
trg = A . max _ flow (0, B -1) を出力する
rst = A . max _ flow (0, B -1) を出力する <eos>
2178
src = A , B = C . split ( )
trg = C を空白で分割した字句列 を展開し 、 それぞれ A 、 B とする
rst = C を空白で分割した字句列 を展開し 、 それぞれ A 、 B とする <eos>
2179
src = print ( len ( set ( A ) ) - 1 )
trg = A の集合の長さ から 1 を引いた値 を出力する
rst = A の集合の長さ から 1 を引いた値 を出力する <eos>
2180
src = e = [ A - B for B , A in zip ( C , C [ 1 : ] + [ C [ 0 ] ] ) ]
trg = C 、 C の先頭を除いた部分列 に ( C の先頭 ) からなる列を加えた値 の要素をそれぞれ組にした列 の各要素を B 、 A とし 、 A から B を引いた値の列を ネイピア数とする
rst = C の 1 番目から 、 つまり末尾までの部分列に ( C の 、 つまり先頭から 1 を加えた値までの部分列の総和 を加えた値を A とする <eos>
2181
src = A = B . readline ( )
trg = B から読み込んだ一行を A とする
rst = B から読み込んだ一行を A とする <eos>
2182
src = return chr ( A + B + 26 ) . upper ( )
trg = 文字 コ ー ド A に B を加えた値に 26 を加えた値の文字 を英大文字に変換した文字列を返す
rst = 文字 コ ー ド A に B を加えた値に 26 を加えた値の文字 を英大文字に変換した文字列を返す <eos>
2183
src = return lambda A , C : sqrt ( ( A - B ) ** 2 + ( C - D ) ** 2 )
trg = x 、 y をパラメータとして A から B を引いた値の 2 乗に C から D を引いた値の 2 乗を加えた値の平方根 を返す関数を 返す
rst = A 、 C から A を引いた値の 2 乗に C から D を引いた値の 2 乗を加えた値の平方根 を返す <eos>
2184
src = if A < B [ C ] [ 0 ] and D < B [ C ] [ 1 ] :
trg = A が B の C 番目の 0 番目より小さくかつ D が B の C 番目の 1 番目より小さいとき 、
rst = A が B の C 番目の 0 番目より小さくかつ D が B の C 番目の 1 番目より小さいとき 、 <eos>
2185
src = A = sum ( [ B * C for B , C in [ map ( int , input ( ) . split ( ) ) for D in range ( int ( input ( ) ) ) ] ] )
trg = 0 から input () の整数値未満までの数列の各要素を D とし 、 input () を空白で分割した字句列 の各要素に整数を適用した列 の列の各要素を B 、 C とし 、 B に C を掛けた値の列の総和を A とする
rst = 0 から 、 つまり入力された文字列の整数値 未満までの数列の各要素を D とし 、 、 つまり入力された文字列 を B とし 、 B に C を掛けた値 の列の列を A とする <eos>
2186
src = A = B + 1 + 2 * ( B * C - C * ( C + 1 ) * ( D - 1 ) // 2 + C )
trg = B に 1 を加えた値に 2 に B に C を掛けた値から C *( C +1)*( D -1) を 2 で割った商を引いた値に C を加えた値を掛けた値を加えた値を A とする
rst = B に 1 を加えた値に 2 に B に C から 1 を引いた値を掛けた値を加えた値に C に 1 を加えた値を掛けた値に D から 1 を加えた値を掛けた値を 2 で割った商を加えた値を A とする <eos>
2187
src = A [ 1 ] , A [ 2 ] = A [ 2 ] , A [ 1 ]
trg = A の 2 番目 、 A の 1 番目を A の 1 番目 、 A の 2 番目とする
rst = A の 2 番目 、 A の 1 番目を A の 1 番目 、 A の 2 番目とする <eos>
2188
src = A = min ( A , dfs ( B + 1 , C | D [ B ] ) + 1 )
trg = A 、 dfs ( B +1, C | D [ B ] ) に 1 を加えた値の最小値を A とする
rst = A 、 dfs ( B +1, C | D [ B ] ) に 1 を加えた値の最小値を A とする <eos>
2189
src = A [ B [ C ] [ 1 ] - 1 ] , A [ B [ C ] [ 2 ] - 1 ] = A [ B [ C ] [ 2 ] - 1 ] , A [ B [ C ] [ 1 ] - 1 ]
trg = A の B の C 番目の 2 番目から 1 を引いた値番目 、 A の B の C 番目の 1 番目から 1 を引いた値番目を A の B の C 番目の 1 番目から 1 を引いた値番目 、 A の B の C 番目の 2 番目から 1 を引いた値番目とする
rst = A の B の C から 1 を引いた値番目の 1 番目 、 A の B の C から 1 を引いた値番目の 2 番目 、 A の B の C から 1 を引いた値番目の 1 番目を A の B の C 番目の 1 番目 、 A の B の 2 番目から 1 を引いた値番目とする <eos>
2190
src = if int ( A ) <= B :
trg = A の整数値が B 以下のとき 、
rst = A の整数値が B 以下のとき 、 <eos>
2191
src = if A // 2 < B + 1 :
trg = A を 2 で割った商が B に 1 を加えた値より小さいとき 、
rst = A を 2 で割った商が B に 1 を加えた値より小さいとき 、 <eos>
2192
src = A = B . dot ( C - D . p1 ) / B . norm ( )
trg = B . dot ( C - D . p 1 ) を B . norm () で割った値を A とする
rst = B . dot ( C - D . p 1 ) を B . norm () で割った値を A とする <eos>
2193
src = A = 24
trg = 24 を A とする
rst = 24 を A とする <eos>
2194
src = if A == - 1 and B == - 1 and C == - 1 and D == - 1 :
trg = A が -1 と等しくかつ B が -1 と等しくかつ C が -1 と等しくかつ D が -1 と等しいとき 、
rst = A が -1 と等しくかつ B が -1 と等しくかつ C が -1 と等しくかつ D が -1 と等しいとき 、 <eos>
2195
src = A = A [ : B ] + list ( reversed ( A [ B : e ] ) ) + A [ e : ]
trg = A の 、 つまり先頭から B 番目までの部分列に A の B 番目から e 番目までの部分列を反転した列 のリストを加えた値に A の 、 つまりネイピア数番目から 、 つまり末尾までの部分列を加えた値 を A とする
rst = A の 、 つまり先頭から B 番目までの部分列に A の B 番目から 、 つまりネイピア数番目までの部分列 <unk> A の 、 つまりネイピア数番目から 、 つまり末尾までの部分列を加えた値 を A とする <eos>
2196
src = A += acos ( B [ 0 ] * C / B [ D ] )
trg = A を acos ( B [0]* C / B [ D ] ) だけ 増 加 させ る
rst = A を acos ( B の先頭に C を掛けた値を B [ D ] ) だけ 増 加 させ る <eos>
2197
src = if e . cap > 0 and A [ B ] - C [ e . to ] < A [ e . to ] - e . cost - C [ B ] :
trg = ネイピア数の cap が 0 より大きくかつ A の B 番目から C の e の to 番目を引いた値が A の e . to 番目から e の cost を引いた値から C の B 番目を引いた値 より小さいとき 、
rst = ネイピア数の cap が 0 より大きくかつ A の B 番目から C の 、 つまりネイピア数の to 番目を引いた値が A の 、 つまりネイピア数の to 番目から 、 つまりネイピア数の to 番目を引いた値 より小さいとき 、 <eos>
2198
src = A = { v : [ C for C , B in enumerate ( list ( map ( int , input ( ) . split ( ) ) ) ) ] }
trg = ( ( B , map ( int , input (). split ()) のリスト に番号付した組の列の各要素を C 、 B とし 、 C の列 )) からなる辞書を A とする
rst = ( ( B , map ( int , input (). split ())) に番号付した組の列の各要素を C 、 B とし 、 C の列 )) からなる辞書を A とする <eos>
2199
src = push ( pop ( - 2 ) - pop ( - 1 ) )
trg = push ( pop (-2) - pop (-1) )
rst = push ( pop (-( -1) ) <eos>
2200
src = for A , B in enumerate ( [ 48.0 , 51.0 , 54.0 , 57.0 , 60.0 , 64.0 , 69.0 , 75.0 , 81.0 , 91.0 , 150.0 ] ) :
trg = ( 48.0、 51.0 、 54.0 、 57.0 、 60.0 、 64.0 、 69.0 、 75.0、81.0、91.0、1 50.0 ) からなる列 に番号付した組の列を順に A 、 B として 、 繰り返 す
rst = <unk> 、 <unk> 、 <unk> 、 <unk> 、 <unk> 、 <unk> 、 <unk> 、 <unk> 、 <unk> 、 <unk> 、 <unk> 、 <unk> 、 <unk> を A 、 B として 、 繰り返 す <eos>
2201
src = A += B . weights [ C ]
trg = A を B の weights の C 番目だけ 増 加 させ る
rst = A を B の weights の C 番目だけ 増 加 させ る <eos>
2202
src = postorder ( A )
trg = postorder ( A )
rst = postorder ( A ) <eos>
2203
src = A [ 0 ] , A [ 2 ] = A [ 2 ] , A [ 0 ]
trg = A の先頭と A の 2 番目を 入れ 替 え る
rst = A の 2 番目 、 A の先頭を A の先頭 、 A の 2 番目とする <eos>
2204
src = A [ B + 1 ] [ 0 ] [ B + 1 ] += A [ B ] [ 2 ] [ C ] * ( B - C + 1 )
trg = A の B に 1 を加えた値番目の先頭の B に 1 を加えた値番目を A の B 番目の 2 番目の C 番目に B から C を引いた値に 1 を加えた値を掛けた値だけ 増 加 させ る
rst = A の B に 1 を加えた値番目の 0 番目を B に 1 を加えた値番目を A の B 番目の 2 番目に C から 1 を引いた値 を加えた値だけ 増 加 させ る <eos>
2205
src = print ( A , B . index ( A ) )
trg = A 、 B の A と等しい要素の最初の位置 を出力する
rst = A 、 B の A と等しい要素の最初の位置 を出力する <eos>
2206
src = print ( A . compute ( 0 , B - 1 , C ) )
trg = A . compute (0, B -1, C ) を出力する
rst = A . compute (0, B -1, C ) を出力する <eos>
2207
src = A = [ [ 0 , 0 , B + 1 ] for B in range ( C ) ]
trg = 0 から C 未満までの数列の各要素を B とし 、(0、0、 B に 1 を加えた値 ) からなる列の列を A とする
rst = 0 から C 未満までの数列の各要素を B とし 、(0、 B に 1 を加えた値 ) からなる列の列を A とする <eos>
2208
src = A [ e ] = ( B , C * D )
trg = ( B 、 C に D を掛けた値 ) の組を A の 、 つまりネイピア数番目に する
rst = ( B 、 C に D を掛けた値 ) の組を A の 、 つまりネイピア数番目に する <eos>
2209
src = A = ( B + e ) * ( C - 1 )
trg = B にネイピア数を加えた値に C から 1 を引いた値を掛けた値を A とする
rst = B にネイピア数を加えた値に C から 1 を引いた値を掛けた値を A とする <eos>
2210
src = A . addEdge ( B , C , D )
trg = A . addEdge ( B , C , D )
rst = A . move _ out ( B , C , D ) <eos>
2211
src = A = rightRotate ( A )
trg = rightRotate ( A ) を A とする
rst = <unk> ( A ) を A とする <eos>
2212
src = A [ B ] [ C ] [ D ] = E % 2
trg = E を 2 で割った余りを A の B 番目の C 番目の D 番目に する
rst = E を 2 で割った余りを A の B 番目の C 番目の D 番目に する <eos>
2213
src = A [ B ] = A [ B - C ] + D
trg = A の B から C を引いた値番目に D を加えた値を A の B 番目に する
rst = A の B から C を引いた値番目に D を加えた値を A の B 番目に する <eos>
2214
src = A . siz += 1
trg = A の siz を 1 だけ 増 加 させ る
rst = A の siz を 1 だけ 増 加 させ る <eos>
2215
src = for A in sorted ( [ A for A in B if B [ A ] == max ( B . values ( ) ) ] ) :
trg = B の各要素を A とし 、 B の A 番目が B の値の集まりの最大値 と等しいとき の A の列をソートした列 を順に A として 、 繰り返 す
rst = B の各要素を A とし 、 A が B の A 番目と等しいかどうか <unk> B とし 、 B の列の 辞書 カ ウ ンタを A として 、 繰り返 す <eos>
2216
src = A = intersection01 ( 0 , 0 , B , C , D , E , F )
trg = intersection 0 1 (0,0, B , C , D , E , F ) を A とする
rst = PathSum (0,0,0, B , C , D , E , F ) を A とする <eos>
2217
src = A = [ ( ( B . r - C ) ** 2 + ( B . g - D ) ** 2 + ( B . b - E ) ** 2 ) for B in F ]
trg = F の各要素を B とし 、 B . r から C を引いた値の 2 乗に B . g から D を引いた値の 2 乗を加えた値に B の b から E を引いた値の 2 乗を加えた値 の列を A とする
rst = F の各要素を B とし 、 B の r から C を引いた値の 2 乗に B . r から D を引いた値の 2 乗を加えた値に E から B の seconds を引いた値の 2 乗を加えた値に E から F を引いた値の 2 乗を加えた値を A とする <eos>
2218
src = A = [ A ] + [ int ( input ( ) ) for B in range ( 4 ) ]
trg = ( A ) からなる列に 0 から 4 未満までの数列の各要素を B とし 、 、 つまり入力された文字列の整数値 の列を加えた値を A とする
rst = ( A ) からなる列に 0 から 4 未満までの数列の各要素を B とし 、 、 つまり入力された文字列の整数値 の列を加えた値を A とする <eos>
2219
src = heappush ( A . heap , B )
trg = heappush ( A . heap , B )
rst = heappush ( A . heap , B ) <eos>
2220
src = A = 10 ** 6
trg = 10 の 6 乗を A とする
rst = 10 の 6 乗を A とする <eos>
2221
src = preorder_bfs ( A [ B ] . left )
trg = preorder _ bfs ( A [ B ] . left )
rst = preorder _ bfs ( A [ B ] . left ) <eos>
2222
src = count += len ( A ) - B - 1
trg = 無限の整数列を A の長さから B を引いた値から 1 を引いた値だけ 増 加 させ る
rst = 無限の整数列を A の長さから B を引いた値から 1 を引いた値だけ 増 加 させ る <eos>
2223
src = A = B [ C ] [ D ] - B [ C ] [ E ]
trg = B の C 番目の D 番目から B の C 番目の E 番目を引いた値を A とする
rst = B の C 番目の D 番目から B の C 番目の E 番目を引いた値を A とする <eos>
2224
src = A [ B - C + 7 ] = False
trg = 偽を A の B から C を引いた値に 7 を加えた値番目に する
rst = 偽を A の B から C を引いた値に 7 を加えた値番目に する <eos>
2225
src = A = myhash ( B )
trg = myhash ( B ) を A とする
rst = <unk> ( B ) を A とする <eos>
2226
src = print ( A . find ( int ( B [ 1 ] ) ) )
trg = A の先頭から B の 1 番目の整数値 を探して見つかった位置を出力する
rst = A の位置 B の 1 番目の整数値から A を探して見つかった位置のとき 、 <eos>
2227
src = A . heappush ( B , ( C . distance [ D ] , D ) )
trg = A . heappush ( B , ( C . distance [ D ] , D ))
rst = A . heappush ( B , ( C . distance [ D ] , D )) <eos>
2228
src = A . cur = A . end
trg = A の end を A の cur に する
rst = A の end を A の cur に する <eos>
2229
src = A = distf ( * B [ C ] )
trg = distf (* B [ C ] ) を A とする
rst = func [ t ] (* B [ C ] ) を A とする <eos>
2230
src = A = ( B + 1 ) * 2
trg = B に 1 を加えた値に 2 を掛けた値を A とする
rst = B に 1 を加えた値に 2 を掛けた値を A とする <eos>
2231
src = A = input ( ) . replace ( B , C ) . replace ( D , E )
trg = 入力された文字列内の B を C で置き換えた文字列内の D を E で置き換えた文字列を A とする
rst = 入力された文字列内の B を C で置き換えた文字列内の D を E で置き換えた文字列を A とする <eos>
2232
src = A = float ( B ) / float ( C )
trg = B の浮動小数点数を C の浮動小数点数で割った値を A とする
rst = B の浮動小数点数を C の浮動小数点数で割った値を A とする <eos>
2233
src = A = B [ C ] + B [ C + 1 ] + B [ C + 2 ]
trg = B の C 番目に B の C に 1 を加えた値番目を加えた値に B の C に 2 を加えた値番目を加えた値を A とする
rst = B の C 番目に B の C に 1 を加えた値番目を加えた値に B の C に 2 を加えた値番目を加えた値を A とする <eos>
2234
src = A = [ 4 ] * 6
trg = (4) からなる列の 6 回分の列を A とする
rst = ( 4 ) からなる列の 6 回分の列を A とする <eos>
2235
src = update ( A + 1 , B + C + 1 )
trg = update ( A +1, B + C +1)
rst = update ( A +1, B + C +1) <eos>
2236
src = A [ B ] = C = A [ D ] + E
trg = A の D 番目に E を加えた値を C とする を A の B 番目に する
rst = A の D 番目に E を加えた値を C とする を A の B 番目に する <eos>
2237
src = for A , B in time :
trg = time を順に A 、 B として 、 繰り返 す
rst = time を順に A 、 B として 、 繰り返 す <eos>
2238
src = A [ : ] = B [ : C * D ]
trg = B の 、 つまり先頭から C に D を掛けた値までの部分列 を A の 、 つまり先頭から 、 つまり末尾までの部分列に する
rst = B の 、 つまり先頭から C に D を掛けた値番目を A の 、 つまり先頭から 、 つまり末尾までの部分列に する <eos>
2239
src = A [ B + 1 ] [ C + 1 ] = - 1 if A [ B + 1 ] [ C + 1 ] == - 1 else 1
trg = A の B に 1 を加えた値番目の C に 1 を加えた値番目が -1 と等しいとき -1 、 そうでなければ 1 を A の B に 1 を加えた値番目の C に 1 を加えた値番目に する
rst = A の B に 1 を加えた値番目の C に 1 を加えた値番目が -1 と等しいとき -1 、 そうでなければ 1 を A の B に 1 を加えた値番目の C に 1 を加えた値番目に する <eos>
2240
src = A = ( [ map ( int , B . readline ( ) . split ( ) ) for C in range ( D ) ] )
trg = 0 から D 未満までの数列の各要素を C とし 、 B から読み込んだ一行 を空白で分割した字句列の各要素に 整数を適用した列の列を A とする
rst = 0 から D 未満までの数列の各要素を C とし 、 B から読み込んだ一行 を空白で分割した字句列の各要素に 整数を適用した列の列を A とする <eos>
2241
src = A = ( A + 1 ) % B
trg = A に 1 を加えた値を B で割った余りを A とする
rst = A に 1 を加えた値を B で割った余りを A とする <eos>
2242
src = A = set1 ( B )
trg = set 1 ( B ) を A とする
rst = <unk> ( B ) を A とする <eos>
2243
src = if A < B - 1 and C [ A + 1 ] [ D ] == E :
trg = A が B から 1 を引いた値より小さくかつ C の A に 1 を加えた値番目の D 番目が E と等しいとき 、
rst = A が B から 1 を引いた値より小さくかつ C の A に 1 を加えた値番目の D 番目が E と等しいとき 、 <eos>
2244
src = A = calc ( B , C , D , E )
trg = calc ( B , C , D , E ) を A とする
rst = calc ( B , C , D , E ) を A とする <eos>
2245
src = A [ B ] = 40
trg = 40 を A の B 番目に する
rst = 40 を A の B 番目に する <eos>
2246
src = A = int ( B ) * 200 + int ( C ) * 300
trg = B の整数値に 200 を掛けた値に C の整数値に 300 を掛けた値を加えた値を A とする
rst = B の整数値に 200 を掛けた値に C の整数値に 300 を掛けた値を加えた値を A とする <eos>
2247
src = return ( f ( int ( A / 4 ) ) + str ( A % 4 ) )
trg = f ( int ( A /4) ) に A を 4 で割った余りの文字列 を加えた値を返す
rst = f ( int ( A / 4 ) に A を 4 で割った余り の文字列を加えた値 の整数値を返す <eos>
2248
src = A . x = ( B . x - C . x ) * cos ( D ) - ( B . y - C . y ) * sin ( D ) + C . x
trg = B の x 座標から C の x 座標を引いた値に D の余弦を掛けた値から B の y 座標から C の y 座標を引いた値に D の正弦を掛けた値を引いた値 に C の x 座標 を加えた値を A の x 座標に する
rst = B の x 座標から C の x 座標を引いた値に D の正弦を掛けた値に B の y 座標から C の y 座標を引いた値に D の余弦を掛けた値を加えた値 に C の x 座標 を加えた値を A の x 座標に する <eos>
2249
src = if A != - 1 and B + len ( C ) <= len ( D ) :
trg = A が -1 と等しくなくかつ B に C の長さを加えた値が D の長さ以下のとき 、
rst = A が -1 と等しくなくかつ B に C <unk> が D の長さ 以下のとき 、 <eos>
2250
src = A = map ( B , itertools . combinations_with_replacement ( C , 2 ) )
trg = C の 2 個までの 重複 コン ビ ネ ー シ ョ ンの各要素に B を適用した列を A とする
rst = C の 2 個までの コン ビ ネ ー シ ョ ンを A とする <eos>
2251
src = A [ 2 ] * A [ 6 ] - A [ 3 ] * A [ 7 ]
trg = A の 2 番目に A の 6 番目を掛けた値から A の 3 番目に A の 7 番目を掛けた値を引いた値
rst = A の 2 番目に A の 6 番目を掛けた値から A の 3 番目に A の 7 番目を掛けた値を引いた値 <eos>
2252
src = A = B . most_common ( )
trg = B の出現 頻 度順の列を A とする
rst = B の上位 [ MASK ] 個 の出現 頻 度順の列を A とする <eos>
2253
src = A += [ B * C + D [ E ] for E , C in enumerate ( F ) ]
trg = A を F に番号付した組の列の各要素を E 、 C とし 、 B に C を掛けた値に D の E 番目を加えた値の列 だけ 増 加 させ る
rst = A を F に番号付した組の列の各要素を E 、 C とし 、 B に C を掛けた値に D の E 番目を加えた値の列を A とする <eos>
2254
src = A = B [ C ] . get_type ( )
trg = B [ C ] . get _ type () を A とする
rst = B [ C ] . get _ max () を A とする <eos>
2255
src = A , B = map ( int , B . split ( C ) )
trg = B を C で分割した字句列の各要素に 整数を適用した列を展開し 、 それぞれ A 、 B とする
rst = B を C で分割した字句列の各要素に 整数を適用した列を展開し 、 それぞれ A 、 B とする <eos>
2256
src = A = ( B [ 0 ] - C [ 0 ] ) * math . sqrt ( 3 ) / 2 + ( B [ 1 ] - C [ 1 ] ) / 2 + C [ 1 ]
trg = B [0] から C [0] を引いた値に 3 の平方根を掛けた値を 2 で割った値に B の 1 番目から C の 1 番目を引いた値を 2 で割った値を加えた値に C の 1 番目を加えた値を A とする
rst = B の 0 番目から C の先頭を引いた値に D の正弦を掛けた値に B の 1 番目を C の 1 番目に 2 を加えた値 の 1 番目から C の 1 番目を引いた値の 2 で割った値を加えた値を A とする <eos>
2257
src = write ( A % B [ C . index ( 1 ) ] )
trg = write ( A % B [ C . index (1) ] )
rst = write ( A % B [ C . index (1) ) <eos>
2258
src = A = Counter ( input ( ) )
trg = 入力された文字列 の 辞書 カ ウ ンタを A とする
rst = 入力された文字列の整数値の 辞書 カ ウ ンタを A とする <eos>
2259
src = if A [ 0 ] == 2 :
trg = A の 0 番目が 2 と等しいとき 、
rst = A の先頭が 2 と等しいとき 、 <eos>
2260
src = if A + B * C in D :
trg = A に B に C を掛けた値を加えた値が D に含まれるとき 、
rst = A に B に C を掛けた値を加えた値が D に含まれるとき 、 <eos>
2261
src = if A [ B ] [ C ] == 1 :
trg = A の B 番目の C 番目が 1 と等しいとき 、
rst = A の B 番目の C 番目が 1 と等しいとき 、 <eos>
2262
src = A = B [ C + 1 ] [ D ] [ E - 1 ] [ F ] + 1
trg = B の C +1 番目の D 番目の E から 1 を引いた値番目の F 番目に 1 を加えた値を A とする
rst = B の C に 1 を加えた値番目の D 番目の E から 1 を引いた値番目の F に 1 を加えた値番目を A とする <eos>
2263
src = A = str ( A % 39 )
trg = A を 39 で割った余りの文字列を A とする
rst = A を 39 で割った余りを A とする <eos>
2264
src = if A * 1500 + B * 1200 + C * 1000 + D * 500 + E * 300 + F * 200 == G :
trg = A * 1 500+ B * 1200 に C * 1000 を加えた値に D に 500 を掛けた値を加えた値に E に 300 を掛けた値を加えた値に F に 200 を掛けた値を加えた値が G と等しいとき 、
rst = A に 1500 を掛けた値に B に C を掛けた値を加えた値に 1000 を掛けた値を加えた値に D に 500 を掛けた値を加えた値に E に F を掛けた値を加えた値に G を掛けた値を加えた値を 200 と等しいとき 、 <eos>
2265
src = while len ( A ) >= 2 and f ( A [ 0 ] , B ) >= f ( A [ 1 ] , B ) :
trg = A の長さが 2 以上かつ f ( A [0], B ) が f ( A [1], B ) 以上の 間 、 次 を 繰り返 す
rst = A の長さが 2 以上かつ f ( A [0], B ) が f ( A [1], B ) 以上の 間 、 次 を 繰り返 す <eos>
2266
src = if A [ B + 1 ] [ C + 1 ] :
trg = A の B に 1 を加えた値番目の C に 1 を加えた値番目のとき 、
rst = A の B に 1 を加えた値番目の C に 1 を加えた値番目のとき 、 <eos>
2267
src = A += [ B [ 0 ] * 3 ** ( 1 / 2 ) / 2 + B [ 1 ] / 2 ]
trg = A を ( B の先頭に 3 の ( 1 /2) 乗を掛けた値を 2 で割った値に B の 1 番目を 2 で割った値を加えた値 ) からなる列 だけ 増 加 させ る
rst = A を ( B の先頭に 3 の 1 /2) 乗を掛けた値を 2 で割った値を引いた値 ) からなる列 だけ 増 加 させ る <eos>
2268
src = if A [ e ] == 0 and B [ e ] == False :
trg = A の 、 つまりネイピア数番目が 0 と等しくかつ B の 、 つまりネイピア数番目が 、 つまり偽 と等しいとき 、
rst = A の 、 つまりネイピア数番目が 0 と等しくかつ B の 、 つまりネイピア数番目が 、 つまり偽 と等しいとき 、 <eos>
2269
src = A [ B ] = min ( [ C for D in [ E [ B ] for C in D ] ] , key = F . itemgetter ( 0 ) )
trg = F . itemgetter (0) を key として D の各要素を C とし 、 E の B 番目の列の各要素を D とし 、 C の列の最小値を A の B 番目に する
rst = itemgetter (0) を key として F の各要素を D とし 、 D の E 番目の各要素を C とし 、 D の B 番目のときの C 番目の列の最小値 の列を A の B 番目に する <eos>
2270
src = A = ( B + C ) // 2
trg = B に C を加えた値を 2 で割った商を A とする
rst = B に C を加えた値を 2 で割った商を A とする <eos>
2271
src = A = B . sum ( C - 1 )
trg = B 、 C から 1 を引いた値の総和を A とする
rst = B 、 C から 1 を引いた値を取り出した値を A とする <eos>
2272
src = A [ int ( B [ 1 ] ) : int ( B [ 2 ] ) + 1 ] = C
trg = C を A の B の 1 番目の整数値から B の 2 番目の整数値に 1 を加えた値までの部分列に する
rst = C を A の B の 1 番目の整数値から B の 2 番目の整数値に 1 を加えた値までの部分列に する <eos>
2273
src = A = - 10 ** 18
trg = -10 の 18 乗を A とする
rst = -10 の 18 乗を A とする <eos>
2274
src = return A . swapcase ( )
trg = A の 英大 小文字 を 交 換した文字列 を返す
rst = A の 英大 小文字 を 交 換した文字列 を返す <eos>
2275
src = for A in count ( 0 ) :
trg = 0 から 始 まる無限の整数列 を順に A として 、 繰り返 す
rst = 無限の整数列 を順に A として 、 繰り返 す <eos>
2276
src = if 2 * A <= B :
trg = 2 に A を掛けた値が B 以下のとき 、
rst = 2 に A を掛けた値が B 以下のとき 、 <eos>
2277
src = A = list ( B . nums )
trg = B の nums のリストを A とする
rst = B の nums のリストを A とする <eos>
2278
src = B = ( ( C ** 2 + D ** 2 ) / ( 2 * C ) if C <= D else D )
trg = C が D 以下のとき C の 2 乗に D の 2 乗を加えた値を 2 に C を掛けた値で割った値 、 そうでなければ D を B とする
rst = C が 2 以下のとき C の 2 乗に D の 2 乗を加えた値を 2 に C を掛けた値で割った値 、 そうでなければ D を B とする <eos>
2279
src = print ( reduce ( A , B , ( - float ( C ) , float ( C ) ) ) [ 0 ] )
trg = B を (- float ( C ) 、 C の浮動小数点数 ) の組を 初 期 値として A で集約した列 の先頭を出力する
rst = B から C の浮動小数点数 を引いた値を C で分割した字句列の各要素に 浮動小数点数を適用した列 を出力する <eos>
2280
src = A . E [ B ] . append ( A . Edge ( C , 0 , len ( A . E [ C ] ) - 1 , - D ) )
trg = A の E の B 番目の末尾に A . Edge ( C ,0, len ( A . E [ C ] ) -1,- D ) を追加する
rst = A の E の B 番目の末尾に A . Edge ( C ,0, len ( A . E [ C ] )-1) を追加する <eos>
2281
src = A -= min ( 24 , ( A - 1 ) // 1461 ) * 1461
trg = A を 24 、 A から 1 を引いた値を 1461 で割った商の最小値に 1461 を掛けた値だけ 減 少 させ る
rst = A を 24 、 A から 1 を引いた値を 1461 で割った商の最小値に 1461 を掛けた値だけ 減 少 させ る <eos>
2282
src = A = int ( '' . join ( B ) ) - int ( '' . join ( C ) )
trg = 空文字列を間に入れて B を連結した文字列の整数値 から 、 つまり空文字列を間に入れて C を連結した文字列の整数値 を引いた値を A とする
rst = 空文字列を間に入れて B の整数値から 、 つまり空文字列を間に入れて C を連結した文字列の整数値 を引いた値を A とする <eos>
2283
src = A [ B . index ( C ) ] [ int ( D ) - 1 ] = True
trg = 真を A の B の C と等しい要素の最初の位置番目の D の整数値から 1 を引いた値番目に する
rst = 真を A の B の C と等しい要素の最初の位置 番目の D の整数値から 1 を引いた値番目に する <eos>
2284
src = print ( A . format ( B // 3600 , B // 60 % 60 , B % 60 ) )
trg = A を書式として B を 3600 で割った商 、 B を 60 で割った商を 60 で割った余り 、 B を 60 で割った余り で整形した文字列を出力する
rst = A を書式として B を 3600 で割った商 、 B を 60 で割った商を 60 で割った余り 、 B を 60 で割った余り で整形した文字列を出力する <eos>
2285
src = for A in range ( 1 , 26 , 2 ) :
trg = 1 から 26 未満までの 2 間隔の数列を順に A として 、 繰り返 す
rst = 1 から 26 未満までの 2 間隔の数列を順に A として 、 繰り返 す <eos>
2286
src = A [ B ] [ C ] = min ( A [ B - 1 ] [ C ] , A [ B - 1 ] [ max ( 0 , C - D ) ] + E , A [ B ] [ max ( 0 , C - D ) ] + E )
trg = A の B から 1 を引いた値番目の C 番目 、 A の B から 1 を引いた値番目の 0 、 C から D を引いた値の最大値 番目に E を加えた値 、 A の B 番目の 0 、 C から D を引いた値の最大値 番目に E を加えた値の最小値を A の B 番目の C 番目に する
rst = A の B から 1 を引いた値番目の C 番目 、 A の B -1 番目の C 番目 、0 の最大値 、 - D の B -1 番目の C 番目 、 E の最大値を A の B 番目の C 番目に する <eos>
2287
src = print ( abs ( A - sum ( [ len ( B ) for B in C ] ) - len ( C ) ) )
trg = A から [ len ( B ) forBinC ] の総和を引いた値から C の長さを引いた値の絶対値 を出力する
rst = A から C の長さから len ( B ) を引いた値 未満までの数列の各要素を B とし 、 B <unk> を出力する <eos>
2288
src = A = calc ( B - 1 , C [ 1 : ] , 0 ) + [ - D ]
trg = calc ( B -1, C [1:], 0 ) に (- D ) からなる列を加えた値を A とする
rst = calc ( B -1, C [1: 、 つまり先頭から <unk> D ) からなる列を加えた値を A とする <eos>
2289
src = if A < B . real :
trg = A が B の real より小さいとき 、
rst = A が B の real より小さいとき 、 <eos>
2290
src = stableCheck ( A , B )
trg = stableCheck ( A , B )
rst = <unk> ( A , B ) <eos>
2291
src = pi = 3.141592653589793238
trg = 3.141592653589 793238 を円周率 とする
rst = <unk> を円周率 とする <eos>
2292
src = A [ B [ 0 ] ] [ B [ 1 ] ] = C
trg = C を A の B の先頭番目の B の 1 番目番目に する
rst = C を A の B の先頭番目の B の 1 番目番目に する <eos>
2293
src = A [ B ] -= C [ B ]
trg = A の B 番目を C の B 番目だけ 減 少 させ る
rst = A の B 番目を C の B 番目だけ 減 少 させ る <eos>
2294
src = A = [ [ 0 for B in range ( C ) ] for D in range ( E ) ]
trg = 0 から E 未満までの数列の各要素を D とし 、0 から C 未満までの数列の各要素を B とし 、0 の列の列を A とする
rst = 0 から E 未満までの数列の各要素を D とし 、0 から C 未満までの数列の各要素を B とし 、0 の列の列を A とする <eos>
2295
src = def connected ( A , B , C ) : return A . find ( B ) == A . find ( C )
trg = 関数 connected を self 、 x 、 y をパラメータとして 定 義 する
rst = 関数 connected を self 、 p 、 q をパラメータとして 定 義 する <eos>
2296
src = A = [ 0 ] * 26
trg = (0) からなる列の 26 回分の列を A とする
rst = (0) からなる列の 26 回分の列を A とする <eos>
2297
src = A = [ B for B in C if B % 2 == 1 ]
trg = C の各要素を B とし 、 B を 2 で割った余りが 1 と等しいとき の B の列を A とする
rst = C の各要素を B とし 、 B を 2 で割った余りが 1 と等しいとき の B の列を A とする <eos>
2298
src = if not put_queen_in_row ( A + 1 ) :
trg = put _ queen _ in _ row ( A +1) でないとき 、
rst = put _ polygon ( A +1) でないとき 、 <eos>
2299
src = if A [ B ] == 10 :
trg = A の B 番目が 10 と等しいとき 、
rst = A の B 番目が 10 と等しいとき 、 <eos>
2300
src = A = ( B , [ ] )
trg = ( B 、 空列 ) の組を A とする
rst = ( B 、 空列 ) の組を A とする <eos>
2301
src = for count in range ( A - 1 ) :
trg = 0 から A から 1 を引いた値未満までの数列を順に 無限の整数列 として 、 繰り返 す
rst = 0 から A から 1 を引いた値未満までの数列を順に 無限の整数列 として 、 繰り返 す <eos>
2302
src = write ( A % ( B [ 0 ] + 1 ) )
trg = write ( A %( B [0] +1))
rst = write ( A %( B [0]+ 1 )) <eos>
2303
src = print ( A [ B - 2 ] [ 0 ] )
trg = A の B から 2 を引いた値番目の先頭 を出力する
rst = A の B から 2 を引いた値番目の先頭 を出力する <eos>
2304
src = A = B * C if B * C < A else A
trg = B に C を掛けた値が A より小さいとき B に C を掛けた値 、 そうでなければ A を A とする
rst = B に C を掛けた値が A より小さいとき B に C を掛けた値 、 そうでなければ A を A とする <eos>
2305
src = A . nskip = None
trg = 未定値を A の nskip に する
rst = 未定値を A の nskip に する <eos>
2306
src = print ( A [ B >> 1 ] )
trg = A の B を 1 だけ右シフトした値番目 を出力する
rst = A の B を 1 だけ右シフトした値 番目を出力する <eos>
2307
src = A = length ( B , C )
trg = length ( B , C ) を A とする
rst = length ( B , C ) を A とする <eos>
2308
src = A . hldrev [ B ] = C
trg = C を A の hldrev の B 番目に する
rst = C を A の f _ val の B 番目に する <eos>
2309
src = A = ( B [ C ] - 1 ) % 3
trg = B の C 番目から 1 を引いた値を 3 で割った余りを A とする
rst = B の C 番目から 1 を引いた値を 3 で割った余りを A とする <eos>
2310
src = A += max ( B ) - min ( B )
trg = A を B の最大値から B の最小値を引いた値 だけ 増 加 させ る
rst = A を B の最大値から B を引いた値の最大値 だけ 増 加 させ る <eos>
2311
src = A = int ( B [ : : - 1 ] )
trg = B の逆順 の整数値を A とする
rst = B の末尾を除いた部分列 の整数値を A とする <eos>
2312
src = A . right = B . Node ( C )
trg = B . Node ( C ) を A の right に する
rst = B . Node ( C ) を A の right に する <eos>
2313
src = update ( A , B , A [ 1 ] )
trg = update ( A , B , A [1])
rst = update ( A , B , A [1]) <eos>
2314
src = print ( len ( set ( A ) & set ( input ( ) . split ( ) ) ) )
trg = A の集合と input () を空白で分割した字句列 の集合の論理積の長さ を出力する
rst = A の集合と input ()) を英大文字に変換した文字列 を出力する <eos>
2315
src = A [ B ] [ C - B ] = 0
trg = 0 を A の B 番目の C から B を引いた値番目に する
rst = 0 を A の B 番目の C から B を引いた値番目に する <eos>
2316
src = A = ( B - 1 ) * 4 + C - 1
trg = B から 1 を引いた値に 4 を掛けた値に C を加えた値から 1 を引いた値を A とする
rst = B から 1 を引いた値に 4 を掛けた値に C を加えた値から 1 を引いた値を A とする <eos>
2317
src = print ( ' ' . join ( map ( str , sorted ( [ len ( A ) for A in B ] ) ) ) , len ( C ) )
trg = 空白文字を間に入れて B の各要素を A とし 、 len ( A ) の列をソートした列 の各要素に整数を適用した列 を連結した文字列 、 C の長さ を出力する
rst = 空白文字を間に入れて B の各要素に lambdaA : C <unk> に番号付した組の列の各要素を A 、 B とし 、 A の文字列の列を連結した文字列 を出力する <eos>
2318
src = if A * B + C * D < 0 :
trg = A に B を掛けた値に C に D を掛けた値を加えた値が 0 より小さいとき 、
rst = A に B を掛けた値に C に D を掛けた値を加えた値が 0 より小さいとき 、 <eos>
2319
src = A . append ( ( B , C ) if B <= C else ( C , B ) )
trg = A の末尾に B が C 以下のとき ( B 、 C ) の組 、 そうでなければ ( C 、 B ) の組 を追加する
rst = A の末尾に B が C 以下のとき ( B 、 C ) の組 、 そうでなければ ( C 、 B ) の組 を追加する <eos>
2320
src = if A == 0 or B < 0 :
trg = A が 0 と等しくまたは B が 0 より小さいとき 、
rst = A が 0 と等しくまたは B が 0 より小さいとき 、 <eos>
2321
src = A = [ list ( input ( ) ) for B in range ( 8 ) ]
trg = 0 から 8 未満までの数列の各要素を B とし 、 、 つまり入力された文字列のリスト の列を A とする
rst = 0 から 8 未満までの数列の各要素を B とし 、 、 つまり入力された文字列のリスト の列を A とする <eos>
2322
src = A [ ( B + C [ B ] ) % D ] . append ( B )
trg = A の B に C の B 番目を加えた値を D で割った余り 番目の末尾に B を追加する
rst = A の B に C の B 番目を加えた値を D で割った余り 番目の末尾に B を追加する <eos>
2323
src = if 0 <= A < B :
trg = 0 が A 以下かどうかが B より小さいとき 、
rst = 0 が A 以下かどうかが B より小さいとき 、 <eos>
2324
src = if A . prev == None :
trg = A の prev が 、 つまり未定値と等しいとき 、
rst = A の prev が 、 つまり未定値と等しいとき 、 <eos>
2325
src = if A >= B [ 1 ] and A < B [ 2 ] :
trg = A が B の 1 番目以上かつ A が B の 2 番目より小さいとき 、
rst = A が B の 1 番目以上かつ A が B の 2 番目より小さいとき 、 <eos>
2326
src = A = [ cross3 ( B [ C - 1 ] , B [ C ] , D ) for C in range ( len ( B ) ) ]
trg = 0 から B の長さ未満までの数列の各要素を C とし 、 cross 3( B [ C -1], B [ C ] , D ) の列を A とする
rst = 0 から B の長さ未満までの数列の各要素を C とし 、 cross 3( B [ C -1], B [ C ] , D ) の列を A とする <eos>
2327
src = if not inside ( A + B [ C ] , D + E [ C ] ) :
trg = inside ( A + B [ C ] , D + E [ C ] ) でないとき 、
rst = compare _ <unk> ( A + B [ C ] , D + E [ C ] ) でないとき 、 <eos>
2328
src = if A . imag < B . imag < C . imag :
trg = A の imag が B の imag より小さいかどうかが C の imag より小さいとき 、
rst = A の imag が B の imag より小さいかどうかが C の imag より小さいとき 、 <eos>
2329
src = A = min ( score ( B + 1 , C , 0 ) , D - E + score ( B , C + 1 , 0 ) )
trg = score ( B +1, C ,0) 、 D から E を引いた値に score ( B , C +1,0) を加えた値の最小値を A とする
rst = score ( B +1, C ,0, D ) から E を引いた値に score ( B , C +1,0) を加えた値の最小値を A とする <eos>
2330
src = if A [ : 2 ] == B and A [ - 1 ] == C :
trg = A の 、 つまり先頭から 2 番目までの部分列が B と等しくかつ A の -1 番目が C と等しいとき 、
rst = A の 、 つまり先頭から 2 番目までの部分列が B と等しくかつ A の 、 つまり末尾 から 、 つまり末尾までの部分列が C と等しいとき 、 <eos>
2331
src = A = ( B [ 0 ] - C [ 0 ] , B [ 1 ] - C [ 1 ] )
trg = ( B の先頭から C の先頭を引いた値 、 B の 1 番目から C の 1 番目を引いた値 ) の組を A とする
rst = ( B の 0 番目から C の先頭を引いた値 、 B の 1 番目から C の 1 番目を引いた値 ) の組を A とする <eos>
2332
src = A = set ( [ B for C , B in D ] )
trg = D の各要素を C 、 B とし 、 B の列の集合を A とする
rst = D の各要素を C 、 B とし 、 B の列の集合を A とする <eos>
2333
src = while A - 1 >= 0 :
trg = A から 1 を引いた値が 0 以上の 間 、 次 を 繰り返 す
rst = A から 1 を引いた値が 0 以上の 間 、 次 を 繰り返 す <eos>
2334
src = if A + B <= C or B + C <= A or C + A <= B :
trg = A に B を加えた値が C 以下または B に C を加えた値が A 以下または C に A を加えた値が B 以下のとき 、
rst = A に B を加えた値が C 以下または B に C を加えた値が A 以下または C に A を加えた値が B 以下のとき 、 <eos>
2335
src = if A . key == B . right :
trg = A の key が B の right と等しいとき 、
rst = A の key が B の right と等しいとき 、 <eos>
2336
src = A = min ( A , min ( B , C ) )
trg = A 、 B 、 C の最小値の最小値 を A とする
rst = A 、 B 、 C の最小値を A とする <eos>
2337
src = A [ B ] [ C ] = D
trg = D を A の B 番目の C 番目に する
rst = D を A の B 番目の C 番目に する <eos>
2338
src = if A [ B : B + 3 ] == [ C , D , E ] :
trg = A の B 番目から B に 3 を加えた値までの部分列が ( C 、 D 、 E ) からなる列と等しいとき 、
rst = A の B 番目から B に 3 を加えた値までの部分列が ( C 、 D 、 E ) からなる列と等しいとき 、 <eos>
2339
src = print ( B if solve ( 0 , A ) else C )
trg = solve (0, A ) のとき B 、 そうでなければ C を出力する
rst = solve (0, A ) のとき B 、 そうでなければ C を出力する <eos>
2340
src = print ( minkowsuki ( A , B , 1 ) )
trg = minkowsuki ( A , B ,1) を出力する
rst = minkowsuki ( A , B ,1) を出力する <eos>
2341
src = A = deque ( [ int ( input ( ) ) for B in range ( C ) ] )
trg = 0 から C 未満までの数列の各要素を B とし 、 、 つまり入力された文字列の整数値 の列 の両端キューを A とする
rst = 0 から C 未満までの数列の各要素を B とし 、 、 つまり入力された文字列の整数値 の列をソートした列を A とする <eos>
2342
src = return A . find ( B , C . left )
trg = A の位置 C の left から B を探して見つかった位置 を返す
rst = A の位置 C の left から B を探して見つかった位置 を返す <eos>
2343
src = if A [ 0 ] + B == A [ B ] :
trg = A の先頭に B を加えた値が A の B 番目と等しいとき 、
rst = A の 0 番目に B を加えた値が A の B 番目と等しいとき 、 <eos>
2344
src = put_queen ( A , B )
trg = put _ queen ( A , B )
rst = put _ queen ( A , B ) <eos>
2345
src = A = drop ( B , C , D + 1 , E )
trg = drop ( B , C , D +1, E ) を A とする
rst = drop ( B , C , D +1, E ) を A とする <eos>
2346
src = A . child_cnt = len ( B )
trg = B の長さを A の child _ cnt に する
rst = B の長さを A の num _ of _ <unk> に する <eos>
2347
src = if A [ B [ 1 ] ] [ B [ 0 ] ] == C :
trg = A の B の 1 番目番目の B の先頭番目が C と等しいとき 、
rst = A の B の 1 番目番目の B の先頭番目が C と等しいとき 、 <eos>
2348
src = 1
trg = 1
rst = 1 <eos>
2349
src = A = float ( B . strip ( ) )
trg = B の両端から 空白改行を取り除いた文字列 の浮動小数点数を A とする
rst = B の両端から 空白改行を取り除いた文字列 の浮動小数点数を A とする <eos>
2350
src = judge ( A , B )
trg = judge ( A , B )
rst = judge ( A , B ) <eos>
2351
src = A = ( A * B - C * D [ E ] [ F ] + D [ E ] [ F + G ] ) & H
trg = A に B を掛けた値から C に D [ E ] の F 番目を掛けた値を引いた値 に D の E 番目の F に G を加えた値番目を加えた値 と H の論理積を A とする
rst = A に B を掛けた値から C に D の E 番目の F 番目を引いた値に D の E 番目の F 番目を加えた値に G を加えた値を A とする <eos>
2352
src = print ( A , B + C , B * 200 + C * 300 )
trg = A 、 B に C を加えた値 、 B に 200 を掛けた値に C に 300 を掛けた値を加えた値 を出力する
rst = A 、 B に C を加えた値 、 B に 200 を掛けた値に C に 300 を掛けた値を加えた値 を出力する <eos>
2353
src = A [ B ] [ C ] [ 1 ] += 1
trg = A の B 番目の C 番目の 1 番目を 1 だけ 増 加 させ る
rst = A の B 番目の C 番目の 1 番目を 1 だけ 増 加 させ る <eos>
2354
src = return [ 4 , A [ B ] ]
trg = ( 4 、 A の B 番目 ) からなる列を返す
rst = ( 4 、 A の B 番目 ) からなる列を返す <eos>
2355
src = global time
trg = time は グ ロー バ ル 変数 とする
rst = time は グ ロー バ ル 変数 とする <eos>
2356
src = while A >= 5 :
trg = A が 5 以上の 間 、 次 を 繰り返 す
rst = A が 5 以上の 間 、 次 を 繰り返 す <eos>
2357
src = print ( ' ' . join ( [ str ( A ) for A in sorted ( [ int ( B ) for B in input ( ) . split ( ) ] , reverse = True ) ] ) )
trg = 空白文字を間に入れて 、 つまり逆順に input (). split () の各要素を B とし 、 int ( B ) の列をソートした列の各要素を A とし 、 A の文字列の列を連結した文字列 を出力する
rst = 空白文字を間に入れて 、 つまり逆順に B とし 、 A の文字列の列を連結した文字列 を出力する <eos>
2358
src = C = [ 0 ] * ( B + 1 )
trg = (0) からなる列の B に 1 を加えた値回分の列を C とする
rst = (0) からなる列の B に 1 を加えた値回分の列を C とする <eos>
2359
src = A = list ( [ 0 ] * 100 )
trg = (0) からなる列の 100 回分の列 のリストを A とする
rst = (0) からなる列の 100 回分の列 のリストを A とする <eos>
2360
src = A [ B ] [ C ] = max ( A [ B ] [ C ] , 0 ) + D [ C + 1 ] - D [ B ]
trg = A の B 番目の C 番目 、0 の最大値に D の C に 1 を加えた値番目を加えた値から D の B 番目を引いた値を A の B 番目の C 番目に する
rst = A の B 番目の C 番目 、0 D に C を加えた値から D の B -1 番目を引いた値番目に D の B 番目 を加えた値の最大値を A の B 番目の C 番目に する <eos>
2361
src = A += min ( B * C , D * C + E )
trg = A を B に C を掛けた値 、 D に C を掛けた値に E を加えた値の最小値 だけ 増 加 させ る
rst = A を B に C を掛けた値 、 D に C を掛けた値に E を加えた値の最小値 だけ 増 加 させ る <eos>
2362
src = A = 2 * 10 ** 6
trg = 2 に 10 の 6 乗を掛けた値を A とする
rst = 2 に 10 の 6 乗を掛けた値を A とする <eos>
2363
src = if 0 == len ( A ) :
trg = 0 が A の長さ と等しいとき 、
rst = 0 が A の長さ と等しいとき 、 <eos>
2364
src = A += B * ( C - 1 ) % D
trg = A を B に C から 1 を引いた値を掛けた値を D で割った余りだけ 増 加 させ る
rst = A を B に C から 1 を引いた値を掛けた値を D で割った余りだけ 増 加 させ る <eos>
2365
src = A . append ( B . sum ( C - 1 , D ) )
trg = A の末尾に B 、 C から 1 を引いた値 、 D の総和 を追加する
rst = A の末尾に B 内の C から 1 を引いた値 、 D の総和 を追加する <eos>
2366
src = A = sorted ( B , key = lambda C : ( C . y , C . x ) ) [ 0 ]
trg = pt をパラメータとして ( C の y 座標 、 C の x 座標 ) の組を返す関数をキーとして B をソートした列の先頭を A とする
rst = x をパラメータとして ( x の y 座標 、 x の x 座標 ) の組を返す関数をキーとして B をソートした列を A とする <eos>
2367
src = A = [ A [ B + C * D ] for B in [ range ( C ) for D in [ 0 , 1 ] ] ]
trg = (0、1) からなる列の各要素を D とし 、0 から C 未満までの数列の列の各要素を B とし 、 A の B に C に D を掛けた値を加えた値 番目の列を A とする
rst = D の各要素を B とし 、 C から D 未満までの数列の各要素を B とし 、 A の B に C を掛けた値に D を加えた値番目の列を A とする <eos>
2368
src = while A < 5 and B [ A ] == C :
trg = A が 5 より小さくかつ B の A 番目が C と等しい 間 、 次 を 繰り返 す
rst = A が 5 より小さくかつ B の A 番目が C と等しい 間 、 次 を 繰り返 す <eos>
2369
src = A = range ( B )
trg = 0 から B 未満までの数列を A とする
rst = 0 から B 未満までの数列を A とする <eos>
2370
src = exec ( A + B + C )
trg = exec ( A + B + C )
rst = put _ S ( A + B + C ) <eos>
2371
src = B [ 1 ] = C [ 1 ]
trg = C の 1 番目を B の 1 番目に する
rst = C の 1 番目を B の 1 番目に する <eos>
2372
src = print ( sum ( [ e == 2 for e in A ] ) )
trg = A の各要素をネイピア数 とし 、 、 つまりネイピア数が 2 と等しいかどうかの列の総和 を出力する
rst = A の各要素をネイピア数 とし 、 、 つまりネイピア数が A に含まれるかどうかの列の総和 を出力する <eos>
2373
src = print ( A , int ( B * C / A ) )
trg = A 、 B に C を掛けた値を A で割った値の整数値 を出力する
rst = A 、 B に C を掛けた値を A で割った値 を出力する <eos>
2374
src = if A [ B - 1 ] == A [ C - 1 ] :
trg = A の B から 1 を引いた値番目が A の C から 1 を引いた値番目と等しいとき 、
rst = A の B から 1 を引いた値番目が A の C から 1 を引いた値番目と等しいとき 、 <eos>
2375
src = e += 1
trg = ネイピア数を 1 だけ 増 加 させ る
rst = ネイピア数を 1 だけ 増 加 させ る <eos>
2376
src = if A - B > 3 :
trg = A から B を引いた値が 3 より大きいとき 、
rst = A から B を引いた値が 3 より大きいとき 、 <eos>
2377
src = A = 1000000000
trg = 1000000000 を A とする
rst = 1000000000 を A とする <eos>
2378
src = A = ( B * ( C - D ) + ( E - D ) * ( F - B ) )
trg = B に C から D を引いた値を掛けた値に E から D を引いた値に F から B を引いた値を掛けた値を加えた値を A とする
rst = B に C から D を引いた値を掛けた値に E から D を引いた値に F から B を引いた値を掛けた値を加えた値を A とする <eos>
2379
src = A = B + C [ D ]
trg = B に C の D 番目を加えた値を A とする
rst = B に C の D 番目を加えた値を A とする <eos>
2380
src = print ( max ( A // B + 1 , 0 ) )
trg = A を B で割った商に 1 を加えた値 、0 の最大値 を出力する
rst = A を B で割った商に 1 を加えた値 、0 の最大値 を出力する <eos>
2381
src = print ( C * A [ B ] if 0 < A [ B ] else D )
trg = 0 が A の B 番目より小さいとき C に A の B 番目を掛けた値 、 そうでなければ D を出力する
rst = A が 0 より小さいとき C に A の B 番目を掛けた値 、 そうでなければ D を出力する <eos>
2382
src = if A > 9 :
trg = A が 9 より大きいとき 、
rst = A が 9 より大きいとき 、 <eos>
2383
src = if A % B in C :
trg = A を B で割った余りが C に含まれるとき 、
rst = A を B で割った余りが C に含まれるとき 、 <eos>
2384
src = if A [ B ] [ C ] == 0 :
trg = A の B 番目の C 番目が 0 と等しいとき 、
rst = A の B 番目の C 番目が 0 と等しいとき 、 <eos>
2385
src = bfs2 ( A , B )
trg = bfs 2( A , B )
rst = <unk> ( A , B ) <eos>
2386
src = A = A * 2 - 1
trg = A に 2 を掛けた値から 1 を引いた値を A とする
rst = A に 2 を掛けた値から 1 を引いた値を A とする <eos>
2387
src = print ( '\n' . join ( map ( A , B ) ) )
trg = 改行文字を間に入れて B の各要素に A を適用した列を連結した文字列 を出力する
rst = 改行文字を間に入れて B の各要素に A を適用した列を連結した文字列 を出力する <eos>
2388
src = for A in range ( min ( B + 1 - C - D - E , 10 ) ) :
trg = 0 から B +1 から C を引いた値から D を引いた値から E を引いた値 、 10 の最小値 未満までの数列を順に A として 、 繰り返 す
rst = 0 から B に 1 を加えた値から C を引いた値から D を引いた値から E を引いた値 、 10 の最小値 未満までの数列を順に A として 、 繰り返 す <eos>
2389
src = A . par = list ( range ( B ) )
trg = 0 から B 未満までの数列のリストを A の par に する
rst = 0 から B 未満までの数列のリストを A の par に する <eos>
2390
src = A = '' . join ( A )
trg = 空文字列を間に入れて A を連結した文字列を A とする
rst = 空文字列を間に入れて A を連結した文字列を A とする <eos>
2391
src = A . left = _add ( A . left )
trg = _ add ( A . left ) を A の left に する
rst = _ add ( A . left ) を A の left に する <eos>
2392
src = return A * B [ C ] - D * ( B [ C ] + E )
trg = A に B の C 番目を掛けた値から D に B の C 番目に E を加えた値 を掛けた値を引いた値を返す
rst = A に B の C 番目から D に B の C 番目を掛けた値に E を加えた値 を掛けた値を引いた値を返す <eos>
2393
src = heappush ( A , ( B , C , D , E , F + 1 ) )
trg = heappush ( A , ( B , C , D , E , F +1))
rst = heappush ( A , ( B , C , D , E , F +1) <eos>
2394
src = A -= 100
trg = A を 100 だけ 減 少 させ る
rst = A を 100 だけ 減 少 させ る <eos>
2395
src = A -= B [ C [ D ] ]
trg = A を B の C の D 番目番目だけ 減 少 させ る
rst = A を B の C の D 番目番目だけ 減 少 させ る <eos>
2396
src = A [ B ] [ C ] = calc ( D * E * F - G * H * I , I * E * F )
trg = calc ( D * E * F - G * H * I , I * E * F ) を A の B 番目の C 番目に する
rst = calc ( D * E * F - G * H * I ) を A の B 番目の C 番目に する <eos>
2397
src = A . add ( Edge ( B , C , D , E ) )
trg = A に Edge ( B , C , D , E ) を追加した集まり
rst = A に Edge ( B , C , D , E ) を追加した集まり <eos>
2398
src = if A == [ ( 0 , 0 ) , ( 1 , 0 ) , ( 2 , 0 ) , ( 3 , 0 ) ] :
trg = A が ((0、0) の組 、(1、0) の組 、(2、0) の組 、(3、0) の組 ) からなる列と等しいとき 、
rst = A が ((0、0) の組 、(0、1) の組 、(0、2) の組 、(0、3) の組 ) からなる列と等しいとき 、 <eos>
2399
src = A = [ 0 for B in range ( len ( C ) + 1 ) ]
trg = 0 から C の長さに 1 を加えた値未満までの数列の各要素 を B とし 、0 の列を A とする
rst = 0 から C の長さに 1 を加えた値未満までの数列の各要素 を B とし 、0 の列を A とする <eos>
2400
src = A [ B + 1 ] [ C ] = A [ B ] [ C ]
trg = A の B 番目の C 番目を A の B に 1 を加えた値番目の C 番目に する
rst = A の B 番目の C 番目を A の B に 1 を加えた値番目の C 番目に する <eos>
2401
src = A += str ( B % 2 )
trg = A を B を 2 で割った余りの文字列 だけ 増 加 させ る
rst = A を B を 2 で割った余りの文字列 番目だけ 増 加 させ る <eos>
2402
src = A . nodes = [ 0 for B in range ( pow ( 2 , A . height + 1 ) - 1 ) ]
trg = 0 から 2 の A . height に 1 を加えた値 乗から 1 を引いた値 未満までの数列の各要素を B とし 、0 の列を A の nodes に する
rst = 0 から 2 の A . height に 1 を加えた値 乗から 1 を引いた値 未満までの数列の各要素を B とし 、0 の列を A の nodes に する <eos>
2403
src = if check ( int ( input ( ) ) ) :
trg = check ( int ( input ())) のとき 、
rst = check ( int ( input ())) のとき 、 <eos>
2404
src = f_dfs ( A )
trg = f _ dfs ( A )
rst = <unk> ( A ) <eos>
2405
src = if A . all ( ) :
trg = A . all () のとき 、
rst = A が全て数字 のとき 、 <eos>
2406
src = return query ( 0 , 0 , A . size )
trg = query (0,0, A . size ) を返す
rst = query (0,0, A . size ) を返す <eos>
2407
src = if ( not 0 < A < B . width - 1 ) or ( not 0 < C < B . height - 1 ) :
trg = 0 が A より小さいかどうかが B の width から 1 を引いた値 より小さくなくまたは 0 が C より小さいかどうかが B の height から 1 を引いた値 より小さくないとき 、
rst = 0 が A より小さいかどうかが B の width から 1 を引いた値より小さい 0 より小さくまたは C が B の height より小さくないとき 、 <eos>
2408
src = while len ( A [ B ] ) == 2 :
trg = A の B 番目の長さが 2 と等しい 間 、 次 を 繰り返 す
rst = A の B 番目の長さが 2 と等しい 間 、 次 を 繰り返 す <eos>
2409
src = print ( 100 + A * 16 + 15 * B + 15 * C + 7 * D + 2 * E + 3 * F - G * 3 )
trg = 100+ A * 16 +15* B +15* C に 7* D を加えた値に 2 に E を掛けた値を加えた値に 3 に F を掛けた値を加えた値から G に 3 を掛けた値を引いた値 を出力する
rst = 100+ 9 5* A に B * 15 + C * 7 に D を掛けた値を加えた値に 2 に E を掛けた値を加えた値に 3 に F を掛けた値を加えた値から 3 に E を掛けた値に G を掛けた値を加えた値 を出力する <eos>
2410
src = A = B . intersect ( C )
trg = B . intersect ( C ) を A とする
rst = B . intersect ( C ) を A とする <eos>
2411
src = A = [ B + 1 for B in range ( C ) ] [ : : - 1 ]
trg = 0 から C 未満までの数列の各要素を B とし 、 B に 1 を加えた値の列 の逆順を A とする
rst = 0 から C 未満までの数列の各要素を B とし 、 B に 1 を加えた値の列を A とする <eos>
2412
src = A = True if len ( B ) == 6 and len ( C ) == 6 else False
trg = B の長さが 6 と等しくかつ C の長さが 6 と等しいとき 、 つまり真 、 そうでなければ 、 つまり偽 を A とする
rst = B の長さが 6 と等しいとき 、 つまり真 、 そうでなければ C の長さが 6 と等しいとき 1400、 を A とする <eos>
2413
src = A , count = erase ( A , count , B [ 1 ] )
trg = erase ( A , count , B [1]) を展開し 、 それぞれ A 、 無限の整数列 とする
rst = erase ( A , count , B [1]) を展開し 、 それぞれ A 、 無限の整数列 とする <eos>
2414
src = A = tuple ( [ int ( B ) for B in input ( ) . split ( ' ' ) ] )
trg = 入力された文字列を空白 文字で分割した字句列の各要素を B とし 、 B の整数値の列の組を A とする
rst = 入力された文字列を空白 文字で分割した字句列の各要素を B とし 、 B の列の組を A とする <eos>
2415
src = return calc ( A )
trg = calc ( A ) を返す
rst = calc ( A ) を返す <eos>
2416
src = for A , B , e in C [ D + E ] [ F + G ] [ H ] [ I - 1 ] :
trg = C の D に E を加えた値番目の F に G を加えた値番目の H 番目の I から 1 を引いた値番目 を順に A 、 B 、 ネイピア数 として 、 繰り返 す
rst = C の D に E を加えた値番目の F 番目に G の H 番目の I 番目を加えた値から I の F 番目のキーと値の集まり を順に A 、 B 、 ネイピア数 として 、 繰り返 す <eos>
2417
src = for A in list ( itertools . permutations ( [ B + 1 for B in range ( C ) ] ) ) :
trg = 0 から C 未満までの数列の各要素を B とし 、 B に 1 を加えた値の列の順列のリストを 順に A として 、 繰り返 す
rst = 0 から C 未満までの数列の各要素を B とし 、 B に 1 <unk> A として 、 繰り返 す <eos>
2418
src = CHECK_NUM ( A , B )
trg = CHECK _ NUM ( A , B )
rst = <unk> ( A , B ) <eos>
2419
src = else = A [ B : ] + A [ : B ]
trg = A の B 番目から 、 つまり末尾までの部分列に A の 、 つまり先頭から B 番目までの部分列を加えた値を そうでなければ 、 とする
rst = A の B 番目から 、 つまり末尾までの部分列に A の 、 つまり先頭から B 番目までの部分列を加えた値を そうでなければ 、 とする <eos>
2420
src = print ( dfs ( 0 , A [ 0 ] ) )
trg = dfs (0, A [0]) を出力する
rst = dfs (0, A [0]) を出力する <eos>
2421
src = A . spin_left ( )
trg = A . spin _ left ()
rst = A . dice _ s () <eos>
2422
src = - manhattan ( A . size , B , C )
trg = - manhattan ( A . size , B , C )
rst = manhattan ( A . size , B , C ) <eos>
2423
src = A . weights [ B ] = - C - A . weights [ D ] + A . weights [ E ]
trg = - C から A の weights の D 番目を引いた値に A の weights の E 番目を加えた値を A の weights の B 番目に する
rst = - C から A の weights の D 番目を引いた値に A の weights の E 番目を加えた値を A の weights の B 番目に する <eos>
2424
src = A [ B + 1 ] [ C ] = max ( A [ B ] [ C ] , A [ B + 1 ] [ C ] )
trg = A の B 番目の C 番目 、 A の B に 1 を加えた値番目の C 番目の最大値を A の B に 1 を加えた値番目の C 番目に する
rst = A の B 番目の C 番目 、 A の B に 1 を加えた値番目の C 番目の最大値を A の B に 1 を加えた値番目の C 番目に する <eos>
2425
src = A = B . split ( )
trg = B を空白で分割した字句列を A とする
rst = B を空白で分割した字句列を A とする <eos>
2426
src = if dict [ A [ B ] ] > 0 :
trg = 辞書の A の B 番目番目が 0 より大きいとき 、
rst = 辞書の A の B 番目番目が 0 より大きいとき 、 <eos>
2427
src = print ( A % ( B , C [ B ] . p , C [ B ] . sib , 2 - C [ B ] . c . count ( - 1 ) ) , end = '' )
trg = 改行せずに A を ( B 、 C の B 番目の p 、 C の B 番目の sib 、 2 から C [ B ] . c 内の -1 の出現回数を引いた値 ) の組で割った余り を出力する
rst = 改行せずに A を ( B 、 C の B 番目の p 、 C の B 番目の p 2 の B 乗から 1 を引いた値 、 - C の B 番目の c ) の組で割った余り を出力する <eos>
2428
src = A += B . get ( ( C [ - 1 ] , C [ 0 ] ) , 0 )
trg = A を B に対応する値 、 もし存在しなければ ( C の末尾 、 C の先頭 ) の組 、0 だけ 増 加 させ る
rst = A を B に対応する値 、 もし存在しなければ C の末尾 、 C の先頭を (0、0) の組 、0 だけ 増 加 させ る <eos>
2429
src = if ( A + B ) % C == D :
trg = A に B を加えた値を C で割った余りが D と等しいとき 、
rst = A に B を加えた値を C で割った余りが D と等しいとき 、 <eos>
2430
src = print ( '' . join ( A [ B ] ) )
trg = 空文字列を間に入れて A の B 番目を連結した文字列を出力する
rst = 空文字列を間に入れて A の B 番目を連結した文字列を出力する <eos>
2431
src = A = slide ( B , C * D )
trg = slide ( B , C * D ) を A とする
rst = slide ( B , C * D ) を A とする <eos>
2432
src = A = B // 100
trg = B を 100 で割った商を A とする
rst = B を 100 で割った商を A とする <eos>
2433
src = A = min ( closest_part2 ( B [ : C ] , C ) , closest_part2 ( B [ C : ] , D - C ) )
trg = closest _ part 2( B [ : C ] , C ) 、 closest _ part 2( B [ C : ] , D - C ) の最小値を A とする
rst = min _ cost _ cost _ distance ( B [ : C ] , ( C , D - C ) 、 segment _ line _ dist ( D - C , D - C ) の最小値を A とする <eos>
2434
src = A = '' . join ( [ readline ( ) . strip ( ) for B in range ( C ) ] )
trg = 空文字列を間に入れて 0 から C 未満までの数列の各要素を B とし 、 readline () の両端から 空白改行を取り除いた文字列 の列を連結した文字列を A とする
rst = 空文字列を間に入れて 0 から C 未満までの数列の各要素を B とし 、 readline () の両端から 空白改行を取り除いた文字列の列 の列を連結した文字列を A とする <eos>
2435
src = return ( A . index ( B ) , B )
trg = ( A の B と等しい要素の最初の位置 、 B ) の組を返す
rst = ( A の B と等しい要素の最初の位置 、 B ) の組を返す <eos>
2436
src = A = min ( A , B [ C ] [ 0 ] , B [ C ] [ - 1 ] )
trg = A 、 B の C 番目の先頭 、 B の C 番目の末尾 の最小値を A とする
rst = A 、 B の C 番目の先頭 、 B の C 番目の 1 番目から 1 を引いた値の最小値を A とする <eos>
2437
src = A = A [ : B + 1 ] + [ C ] + A [ B + 1 : ]
trg = A の 、 つまり先頭から B に 1 を加えた値までの部分列に ( C ) からなる列を加えた値に A の B に 1 を加えた値から 、 つまり末尾までの部分列を加えた値 を A とする
rst = A の 、 つまり先頭から B に 1 を加えた値までの部分列に ( C ) からなる列を加えた値 を加えた値を A とする <eos>
2438
src = A = [ ( A [ B ] + A [ B + 1 ] ) % 10 for B in range ( len ( A ) - 1 ) ]
trg = 0 から A の長さから 1 を引いた値 未満までの数列の各要素を B とし 、 A の B 番目に A の B に 1 を加えた値番目を加えた値を 10 で割った余りの列を A とする
rst = 0 から A の長さから 1 を引いた値 未満までの数列の各要素を B とし 、 A の B 番目に A の B +1 を加えた値を掛けた値を 10 で割った余りの列を A とする <eos>
2439
src = A = [ list ( map ( int , input ( ) . split ( ) ) ) for B in range ( e ) ]
trg = 0 から 、 つまりネイピア数 未満までの数列の各要素を B とし 、 、 つまり入力された文字列 を空白で分割した字句列の各要素に 整数を適用した列のリストの列を A とする
rst = 0 から 、 つまりネイピア数 未満までの数列の各要素を B とし 、 、 つまり入力された文字列 を空白で分割した字句列の各要素に 整数を適用した列のリストの列を A とする <eos>
2440
src = A [ B + C ] , A [ B ] = A [ B ] , A [ B + C ]
trg = A の B に C を加えた値番目と A の B 番目を 入れ 替 え る
rst = A の B 番目 、 A の B に C を加えた値番目を A の B に C を加えた値番目 、 A の B 番目とする <eos>
2441
src = print ( sum ( A ) * sum ( B ) )
trg = A の総和に B の総和 を掛けた値を出力する
rst = A の総和に B の総和 を掛けた値を出力する <eos>
2442
src = while len ( A ) < 10 :
trg = A の長さが 10 より小さい 間 、 次 を 繰り返 す
rst = A の長さが 10 より小さい 間 、 次 を 繰り返 す <eos>
2443
src = A . deg = [ 0 for B in range ( C ) ]
trg = 0 から C 未満までの数列の各要素を B とし 、0 の列を A の deg に する
rst = 0 から C 未満までの数列の各要素を B とし 、0 の列を A の deg に する <eos>
2444
src = A . append ( ( B , D if C [ D + 1 ] [ B ] else D + 1 , E , F if C [ F - 1 ] [ E ] else F - 1 , G ) )
trg = A の末尾に ( B 、 C の D +1 番目の B 番目のとき D 、 そうでなければ D に 1 を加えた値 、 E 、 C の F -1 番目の E 番目のとき F 、 そうでなければ F から 1 を引いた値 、 G ) の組 を追加する
rst = A の末尾に ( C の D に 1 を加えた値番目のとき B 、 D に 1 を加えた値 、 そうでなければ D に 1 を加えた値 、 E 、 F の C 番目の F から 1 を引いた値番目のとき E 、 そうでなければ F から 1 を引いた値 、 G ) の組 を追加する <eos>
2445
src = _remove ( A . left )
trg = _ remove ( A . left )
rst = _ remove ( A . left ) <eos>
2446
src = if ( A [ - 1 ] [ 0 ] if A else 0 ) < B [ C ] [ D ] :
trg = A のとき A の末尾の 0 番目 、 そうでなければ 0 が B の C 番目の D 番目より小さいとき 、
rst = A が 0 より小さいとき A の末尾の先頭 、 そうでなければ B の C 番目の D 番目のとき 、 <eos>
2447
src = print ( A % ( min ( [ abs ( ( B ** 2 + ( C - B ) ** 2 ) ** 0.5 - e ) for B in range ( C // 2 + 1 ) ] ) ) )
trg = A を 0 から C //2+1 未満までの数列の各要素を B とし 、 ( B **2+( C - B )**2)**0.5 - e の絶対値の列の最小値 で割った余りを出力する
rst = A を 0 から C +1 未満までの数列の各要素を B とし 、 ( abs ( B **2+( C - B )**2 <unk> で割った値 を引いた値の絶対値の列の最小値を 出力する <eos>
2448
src = A = dfs ( 0 , B )
trg = dfs (0, B ) を A とする
rst = dfs (0, B ) を A とする <eos>
2449
src = A . append ( ( B , - C , D ) )
trg = A の末尾に ( B 、 - C 、 D ) の組 を追加する
rst = A の末尾に ( B 、 - C 、 D ) の組 を追加する <eos>
2450
src = A = ( 2 * ( B - C ) * D - E ** 2 - B ** 2 + F ** 2 + C ** 2 ) / ( 2 * ( F - E ) )
trg = 2*( B - C )* D から E **2 を引いた値から B の 2 乗を引いた値に F の 2 乗を加えた値に C の 2 乗を加えた値を 2 に F から E を引いた値 を掛けた値で割った値を A とする
rst = 2 に B から C を引いた値を掛けた値に D を掛けた値から E の 2 乗を引いた値に B の 2 乗を加えた値に F から C を引いた値の絶対値を A とする <eos>
2451
src = A = [ inf ] * ( B + 1 )
trg = ( 、 つまり無限大 ) からなる列の B に 1 を加えた値回分の列を A とする
rst = ( 、 つまり無限大 ) からなる列の B に 1 を加えた値回分の列を A とする <eos>
2452
src = A [ B ] . append ( [ C , 0 , - D , len ( A [ C ] ) - 1 ] )
trg = A の B 番目の末尾に ( C 、0、- D 、 A の C 番目の長さから 1 を引いた値 ) からなる列 を追加する
rst = A の B 番目の末尾に ( C 、0、-1) からなる列 、 ( D 、 A の C 番目の長さから 1 を引いた値 ) からなる列 を追加する <eos>
2453
src = reconstruction ( A , B )
trg = reconstruction ( A , B )
rst = <unk> ( A , B ) <eos>
2454
src = A = [ [ int ( B ) for B in input ( ) . split ( ' ' ) ] for C in range ( D ) ]
trg = 0 から D 未満までの数列の各要素を C とし 、 、 つまり入力された文字列を空白 文字で分割した字句列の各要素を B とし 、 B の整数値の列の列を A とする
rst = 0 から D 未満までの数列の各要素を C とし 、 、 つまり入力された文字列を空白 文字で分割した字句列の各要素を B とし 、 B の整数値の列の列を A とする <eos>
2455
src = A = B * C * math . sin ( math . radians ( D ) ) / 2
trg = B に C を掛けた値に D のラジアンの正弦を掛けた値を 2 で割った値を A とする
rst = B に C を掛けた値に D のラジアンの正弦を掛けた値を 2 で割った値を A とする <eos>
2456
src = A = [ 771 , 16843009 , 15 , 66306 , 1539 , 131841 , 774 ]
trg = ( 771 、 16843009 、15、 66306 、 1539 、 131841 、 774 ) からなる列を A とする
rst = ( <unk> 、 <unk> 、 <unk> 、 <unk> 、 <unk> 、 <unk> 、 <unk> 、 <unk> 、 <unk> からなる列を A とする <eos>
2457
src = A = [ list ( map ( int , input ( ) . split ( ) ) ) for B in range ( C * ( C - 1 ) // 2 ) ]
trg = 0 から C に C から 1 を引いた値を掛けた値を 2 で割った商 未満までの数列の各要素を B とし 、 、 つまり入力された文字列 を空白で分割した字句列の各要素に 整数を適用した列のリストの列を A とする
rst = 0 から C に 1 を加えた値を掛けた値を 2 で割った商 未満までの数列の各要素を B とし 、 、 つまり入力された文字列 を空白で分割した字句列の各要素に 整数を適用した列のリストの列を A とする <eos>
2458
src = F = G + C * H / E
trg = G に C に H を掛けた値を E で割った値を加えた値を F とする
rst = G に C に H を掛けた値を E で割った値を加えた値を F とする <eos>
2459
src = A += B [ C . index ( D [ : 4 ] ) ]
trg = A を B の C の D の 、 つまり先頭から 4 番目までの部分列 と等しい要素の最初の位置番目 だけ 増 加 させ る
rst = A を B の C の D の 、 つまり先頭から 4 番目までの部分列 と等しい要素の最初の位置番目 だけ 増 加 させ る <eos>
2460
src = A = [ B [ 0 ] / C , B [ 1 ] / C ]
trg = ( B の 0 番目を C で割った値 、 B の 1 番目を C で割った値 ) からなる列を A とする
rst = ( B の先頭を C で割った値 、 B の 1 番目を C で割った値 ) からなる列を A とする <eos>
2461
src = B = str ( A )
trg = A の文字列を B とする
rst = A の文字列を B とする <eos>
2462
src = A = [ int ( input ( ) . split ( ' ' ) [ 0 ] ) for B in range ( C ) ]
trg = 0 から C 未満までの数列の各要素を B とし 、 、 つまり入力された文字列 を空白文字で分割した字句列 の先頭 の整数値の列を A とする
rst = 0 から C 未満までの数列の各要素を B とし 、 、 つまり入力された文字列を空白 <unk> A とする <eos>
2463
src = A = B // _pow ( 10 , 20 )
trg = B を _ pow (10,2 0 ) で割った商を A とする
rst = B を _ pow (10,2 0 ) で割った商を A とする <eos>
2464
src = A . graph [ e [ 0 ] ] . append ( e [ 1 ] )
trg = A の graph の 、 つまりネイピア数の先頭番目 の末尾にネイピア数の 1 番目を追加する
rst = A の graph の 、 つまりネイピア数の先頭番目 を A の graph の 1 番目 番目の末尾にネイピア数の先頭 を追加する <eos>
2465
src = A , B = solve ( C , D )
trg = solve ( C , D ) を展開し 、 それぞれ A 、 B とする
rst = solve ( C , D ) を展開し 、 それぞれ A 、 B とする <eos>
2466
src = if A [ B ] - C - D >= E :
trg = A の B 番目から C を引いた値から D を引いた値が E 以上のとき 、
rst = A の B 番目から C を引いた値から D を引いた値が E 以上のとき 、 <eos>
2467
src = if A [ 0 : 9 : 4 ] . count ( B ) == 3 or A [ 2 : 7 : 2 ] . count ( B ) == 3 :
trg = A の 、 つまり先頭から 9 番目までの 4 間隔による部分列内の B の出現回数が 3 と等しくまたは A の 2 番目から 7 番目までの 2 間隔による部分列内の B の出現回数が 3 と等しいとき 、
rst = A の 、 つまり先頭から 9 番目までの 4 間隔による部分列が B と等しくまたは A の 2 番目から 7 番目までの 2 間隔による部分列が B と等しいとき 、 <eos>
2468
src = A = int ( '' . join ( sorted ( B , reverse = 1 ) ) ) - int ( '' . join ( sorted ( B ) ) )
trg = 空文字列を間に入れて 1 を reverse として B をソートした列を連結した文字列 の整数値から 、 つまり空文字列を間に入れて B をソートした列を連結した文字列 の整数値を引いた値を A とする
rst = 空文字列を間に入れて 1 から 、 つまり逆順に B をソートした列を連結した文字列 の整数値を引いた値 を返す関数をキーとして逆順に B の値の集まりをソートした列 を加えた値を A とする <eos>
2469
src = if e <= 5 :
trg = ネイピア数が 5 以下のとき 、
rst = ネイピア数が 5 以下のとき 、 <eos>
2470
src = A = Multi_map ( )
trg = Multi _ map () を A とする
rst = <unk> () を A とする <eos>
2471
src = A = B . next ( C )
trg = B . next ( C ) を A とする
rst = B . next ( C ) を A とする <eos>
2472
src = if any ( ( A < B , C < D , E < F , G < H ) ) :
trg = ( A が B より小さいかどうか 、 C が D より小さいかどうか 、 E が F より小さいかどうか 、 G が H より小さいかどうか ) の組が 少 なく と も ひ とつは真 のとき 、
rst = A が B より小さいかどうかが C より小さいかどうかが D , E , F , G が H より小さいとき 、 <eos>
2473
src = for A in map ( int , B . readline ( ) . split ( ) ) :
trg = B から読み込んだ一行を 空白で分割した字句列 の各要素に整数を適用した列を順に A として 、 繰り返 す
rst = B から読み込んだ一行 を空白で分割した字句列 の各要素に整数を適用した列 の各要素に整数を適用した列を順に A として 、 繰り返 す <eos>
2474
src = print ( A + 1 , end = '' )
trg = 改行せずに A に 1 を加えた値を出力する
rst = 改行せずに A に 1 を加えた値を出力する <eos>
2475
src = print ( 1 if A == 0 else 2 // A )
trg = A が 0 と等しいとき 1 、 そうでなければ 2 を A で割った商 を出力する
rst = A が 0 と等しいとき 1 、 そうでなければ A を 2 で割った商 を出力する <eos>
2476
src = A = int ( B [ 2 : - 2 ] )
trg = B の 2 番目から -2 番目までの部分列の整数値を A とする
rst = B の 2 番目から -2 番目までの部分列の整数値を A とする <eos>
2477
src = A = B [ : ]
trg = B のコピーされた列を A とする
rst = B の [ MASK ] から [ MASK ] までの部分列を A とする <eos>
2478
src = A = max ( A , ( B - C ) * D )
trg = A 、 B から C を引いた値に D を掛けた値の最大値を A とする
rst = A 、 B から C を引いた値に D を掛けた値の最大値を A とする <eos>
2479
src = A [ B ] = not A [ B ]
trg = A の B 番目でない を A の B 番目に する
rst = A の B 番目でない A の B 番目に する <eos>
2480
src = A = [ list ( range ( B ) ) for C in range ( B ) ]
trg = 0 から B 未満までの数列の各要素を C とし 、0 から B 未満までの数列のリスト の列を A とする
rst = 0 から B 未満までの数列の各要素を C とし 、0 から B 未満までの数列のリストを A とする <eos>
2481
src = A += str ( 2 ** B ) + ' '
trg = A を 2 の B 乗 の文字列に空白文字を加えた値 だけ 増 加 させ る
rst = A を 2 の B 乗 の平方根 だけ 増 加 させ る <eos>
2482
src = print ( A + str ( count ) + B + str ( C ) )
trg = A に count の文字列を加えた値に B を加えた値に C の文字列を加えた値を出力する
rst = A に <unk> B に C の文字列を加えた値を出力する <eos>
2483
src = if int ( A [ 0 ] ) + int ( A [ 1 ] + A [ 2 ] ) + int ( A [ 3 ] + A [ 4 ] + A [ 5 ] ) == int ( A [ 6 ] + A [ 7 ] + A [ 8 ] ) :
trg = A の先頭の整数値に A [1] に A [2] を加えた値の整数値 を加えた値に A [3] に A [4] を加えた値に A の 5 番目を加えた値の整数値 を加えた値が A の 6 番目に A の 7 番目を加えた値に A の 8 番目を加えた値の整数値 と等しいとき 、
rst = A [0] の整数値に A [1] の整数値に A [2] に 10 を加えた値に A [3] の 4 番目を加えた値に A の 8 番目を加えた値に A の 5 番目を加えた値に A の 7 番目を加えた値 と等しいとき 、 <eos>
2484
src = A . append ( ( B , C . ADD , D ) )
trg = A の末尾に ( B 、 C の ADD 、 D ) の組 を追加する
rst = A の末尾に ( B 、 C の <unk> 、 D ) の組 を追加する <eos>
2485
src = A [ B - 1 ] = max ( A [ B - 1 ] , max ( A [ B ] - 1 , 0 ) )
trg = A の B から 1 を引いた値番目 、 A の B 番目から 1 を引いた値 、0 の最大値の最大値を A の B から 1 を引いた値番目に する
rst = A の B から 1 を引いた値番目 、 A の B 番目から 1 を引いた値 、0 の最大値の最大値を A の B から 1 を引いた値番目に する <eos>
2486
src = else = 1
trg = 1 を そうでなければ 、 とする
rst = 1 を そうでなければ 、 とする <eos>
2487
src = A [ B ] [ C ] = A [ B - 1 ] [ C ] + D [ B ] [ C ]
trg = A の B から 1 を引いた値番目の C 番目に D の B 番目の C 番目を加えた値を A の B 番目の C 番目に する
rst = A の B から 1 を引いた値番目の C 番目に D の B 番目の C 番目を加えた値を A の B 番目の C 番目に する <eos>
2488
src = if A [ B + 1 ] [ C + 1 ] and not D [ B ] :
trg = A の B に 1 を加えた値番目の C に 1 を加えた値番目かつ D の B 番目でないとき 、
rst = A の B に 1 を加えた値番目の C に 1 を加えた値番目かつ D の B 番目でないとき 、 <eos>
2489
src = A , B , C = int ( D [ 0 ] ) , float ( D [ 1 ] ) , int ( D [ 2 ] )
trg = D の先頭の整数値 、 D の 1 番目の浮動小数点数 、 D の 2 番目の整数値を A 、 B 、 C とする
rst = D の先頭の整数値 、 D の 1 番目の浮動小数点数 、 D の 2 番目の浮動小数点数 の要素をそれぞれ組にした列 の 2 番目の整数値を A 、 B 、 C とする <eos>
2490
src = if check ( A , B , C , D , E , F ) :
trg = check ( A , B , C , D , E , F ) のとき 、
rst = check ( A , B , C , D , E , F ) のとき 、 <eos>
2491
src = A . root = A . _insert_main ( A . root , B , C )
trg = A ._ insert _ main ( A . root , B , C ) を A の root に する
rst = A ._ insert _ main ( A . root , B , C ) を A の root に する <eos>
2492
src = A , B , C , D , E , F = map ( float , input ( ) . strip ( ) . split ( ) )
trg = 入力された文字列の両端から 空白改行を取り除いた文字列 を空白で分割した字句列の各要素に 浮動小数点数を適用した列を展開し 、 それぞれ A 、 B 、 C 、 D 、 E 、 F とする
rst = 入力された文字列の両端から 空白改行を取り除いた文字列 を空白で分割した字句列の各要素に 浮動小数点数を適用した列を展開し 、 それぞれ A 、 B 、 C 、 D 、 E 、 F とする <eos>
2493
src = if input ( ) == A :
trg = 入力された文字列 が A と等しいとき 、
rst = 入力された文字列 が A と等しいとき 、 <eos>
2494
src = return ( A - 1 ) % 5
trg = A から 1 を引いた値を 5 で割った余りを返す
rst = A から 1 を引いた値を 5 で割った余りを返す <eos>
2495
src = if A [ B : B + C ] . startswith ( D ) :
trg = A の B 番目から B に C を加えた値までの部分列 の先頭が D で 始 まるとき 、
rst = A の B 番目から B に C を加えた値までの部分列が D で 始 まるとき 、 <eos>
2496
src = heappush ( A , ( B , C , ( 1 , D ) ) )
trg = heappush ( A , ( B , C , (1, D )))
rst = heappush ( A , ( B , C , ( (1, D ))) <eos>
2497
src = if 0 <= A < 30 :
trg = 0 が A 以下かどうかが 30 より小さいとき 、
rst = 0 が A 以下かどうかが 30 より小さいとき 、 <eos>
2498
src = A = 688 * ( B - C )
trg = 688 に B から C を引いた値を掛けた値を A とする
rst = func [ t ] (* B - C ) を A とする <eos>
2499
src = return A . FLAGS & A . ALL_ON != A . ALL_OFF
trg = A の FLAGS と A の ALL _ ON の論理積が A の ALL _ OFF と等しくないかどうかを返す
rst = A の FLAGS と A の ALL _ ON の論理積が A の ALL _ OFF と等しくないかどうかを返す <eos>
2500
src = print ( - A , B )
trg = - A 、 B を出力する
rst = - A 、 B を出力する <eos>
2501
src = while A and not A % 5 :
trg = A かつ A を 5 で割った余り でない 間 、 次 を 繰り返 す
rst = A かつ A を 5 より大きい 間 、 次 を 繰り返 す <eos>
2502
src = A = int ( B // 2 )
trg = B を 2 で割った商の整数値を A とする
rst = B を 2 で割った商の整数値を A とする <eos>
2503
src = if A [ B - C ] [ D ] :
trg = A の B から C を引いた値番目の D 番目のとき 、
rst = A の B から C を引いた値番目の D 番目のとき 、 <eos>
2504
src = for A in range ( 8 ) :
trg = 0 から 8 未満までの数列を順に A として 、 繰り返 す
rst = 0 から 8 未満までの数列を順に A として 、 繰り返 す <eos>
2505
src = A , B , C = D [ E - 1 : E + 2 ]
trg = D の E から 1 を引いた値から E に 2 を加えた値までの部分列を展開し 、 それぞれ A 、 B 、 C とする
rst = D の E から 1 を引いた値から E に 2 を加えた値までの部分列を A 、 B 、 C とする <eos>
2506
src = A , B = C [ D - 3 ] , C [ D - 4 ]
trg = C の D から 3 を引いた値番目 、 C の D から 4 を引いた値番目を A 、 B とする
rst = C の D から 3 を引いた値番目 、 C の D から 4 を引いた値番目を A 、 B とする <eos>
2507
src = A [ B ] = [ None , None , None , 0 , B , 1 , 0 , 0 ]
trg = ( 、 つまり未定値 、 未定値 、 未定値 、0、 B 、 1、0、0) からなる列を A の B 番目に する
rst = ( 、 つまり未定値 、 未定値 、0、 B 、1、0) からなる列を A の B 番目に する <eos>
2508
src = if A . r == 0 :
trg = A の r が 0 と等しいとき 、
rst = A の r が 0 と等しいとき 、 <eos>
2509
src = A = B * 0.05
trg = B に 0.05 を掛けた値を A とする
rst = B に <unk> を掛けた値を A とする <eos>
2510
src = for A , B , C in D [ E - 1 ] :
trg = D の E から 1 を引いた値番目 を順に A 、 B 、 C として 、 繰り返 す
rst = D の E から 1 を引いた値番目 を順に A 、 B 、 C として 、 繰り返 す <eos>
2511
src = A += B . lower ( ) . split ( ) . count ( C )
trg = A を B を英小文字に変換した文字列を 空白で分割した字句列内の C の出現回数 だけ 増 加 させ る
rst = A を B を英小文字に変換した文字列 を空白で分割した字句列 を連結した文字列 内の C の出現回数 だけ 増 加 させ る <eos>
2512
src = print ( dfs ( 0 , [ 0 ] * A ) )
trg = dfs (0,[0]* A ) を出力する
rst = dfs (0,[0]* A ) を出力する <eos>
2513
src = f ( B , C , D )
trg = f ( B , C , D )
rst = f ( B , C , D ) <eos>
2514
src = A = sorted ( set ( range ( 1 , 2 * B + 1 ) ) - set ( C ) )
trg = 1 から 2* B に 1 を加えた値 未満までの数列の集合から C の集合を引いた値をソートした列を A とする
rst = 1 から 2 に B を掛けた値に 1 を加えた値 未満までの数列の集合から C を引いた値を A とする <eos>
2515
src = if not isAvailableAreas ( A ) :
trg = isAvailableAreas ( A ) でないとき 、
rst = _ subset ( len ( A ) でないとき 、 <eos>
2516
src = if A % 7 == 0 :
trg = A を 7 で割った余りが 0 と等しいとき 、
rst = A を 7 で割った余りが 0 と等しいとき 、 <eos>
2517
src = A = B [ - 1 ] + 1
trg = B の -1 番目に 1 を加えた値を A とする
rst = B の -1 番目に 1 を加えた値を A とする <eos>
2518
src = A [ is_right_triangle ( B ) ] += 1
trg = A の is _ right _ triangle ( B ) 番目を 1 だけ 増 加 させ る
rst = A の <unk> ( B ) 番目を 1 だけ 増 加 させ る <eos>
2519
src = for A in B . tree [ C ] [ : : - 1 ] :
trg = B の tree の C 番目 の逆順 を順に A として 、 繰り返 す
rst = B の tree の C 番目から 、 つまり末尾までの部分列 を順に A として 、 繰り返 す <eos>
2520
src = A . append ( extract ( B ) )
trg = A の末尾に extract ( B ) を追加する
rst = A の末尾に <unk> ( B ) を追加する <eos>
2521
src = if check ( A , B ) == 1 :
trg = check ( A , B ) が 1 と等しいとき 、
rst = check ( A , B ) が 1 と等しいとき 、 <eos>
2522
src = A . sink . edge . append ( B )
trg = A の sink の edge の末尾に B を追加する
rst = A の sink の末尾に B を追加する <eos>
2523
src = A . par = [ B for B in range ( C ) ]
trg = 0 から C 未満までの数列の各要素を B とし 、 B の列を A の par に する
rst = 0 から C 未満までの数列の各要素を B とし 、 B の列を A の par に する <eos>
2524
src = if A . is_orthogonal ( B , C ) :
trg = A . is _ orthogonal ( B , C ) のとき 、
rst = A . is _ orthogonal ( B , C ) のとき 、 <eos>
2525
src = write ( A % min ( B [ C - 1 ] ) )
trg = write ( A % min ( B [ C -1]))
rst = write ( A % min ( B [ C -1])) <eos>
2526
src = if A [ B - C ] != - 1 and A [ B - C ] <= D :
trg = A の B から C を引いた値番目が -1 と等しくなくかつ A の B から C を引いた値番目が D 以下のとき 、
rst = A の B から C を引いた値番目が -1 と等しくなくかつ A の B から C を引いた値番目が D 以下のとき 、 <eos>
2527
src = if not A [ B ] [ C ] [ ( D + 1 ) % 4 ] :
trg = A の B 番目の C 番目の D に 1 を加えた値を 4 で割った余り 番目でないとき 、
rst = A の B 番目の C 番目の D に 1 を加えた値を 4 で割った余り番目 でないとき 、 <eos>
2528
src = if not is_triangle ( A ) :
trg = is _ triangle ( A ) でないとき 、
rst = _ subset ( len ( A ) でないとき 、 <eos>
2529
src = return [ 2 , A [ B [ 2 ] ] , A [ B [ 3 ] ] , A [ B [ 4 ] ] ]
trg = ( 2 、 A の B の 2 番目番目 、 A の B の 3 番目番目 、 A の B の 4 番目番目 ) からなる列を返す
rst = ( 2 、 A の B の 2 番目番目 、 A の B の 3 番目番目 、 A の B の 4 番目番目 ) からなる列を返す <eos>
2530
src = if A [ B ] == C and D [ E + 1 ] [ B ] and D [ B + 1 ] [ F - 1 ] :
trg = A の B 番目が C と等しくかつ D の E に 1 を加えた値番目の B 番目かつ D の B に 1 を加えた値番目の F から 1 を引いた値番目のとき 、
rst = A の B 番目が C と等しくかつ D の E に 1 を加えた値番目の B 番目かつ D の B に 1 を加えた値番目の F から 1 を引いた値番目のとき 、 <eos>
2531
src = A = sorted ( [ ( len ( B ) , B ) for B in C . keys ( ) ] )
trg = C のキーの集まりの各要素を B とし 、 ( B の長さ 、 B ) の組の列をソートした列を A とする
rst = C のキーの集まりの各要素を B とし 、 ( B の長さ 、 B の長さ ) の組の列の集合を A とする <eos>
2532
src = E = int ( E )
trg = E の整数値を E とする
rst = E の整数値を E とする <eos>
2533
src = A = B . leader ( C )
trg = B . leader ( C ) を A とする
rst = B . leader ( C ) を A とする <eos>
2534
src = if A - 1 == - 1 :
trg = A から 1 を引いた値が -1 と等しいとき 、
rst = A から 1 を引いた値が -1 と等しいとき 、 <eos>
2535
src = if A . count ( B [ C ] [ 0 ] ) == 1 :
trg = A 内の B の C 番目の先頭の出現回数が 1 と等しいとき 、
rst = A 内の B の C 番目の 0 番目の出現回数が 1 と等しいとき 、 <eos>
2536
src = print ( int ( A + B * 5 + C * 10 + D * 50 + e * 100 + E * 500 >= 1000 ) )
trg = A + B *5 + C *10+ D *50 に e *100 を加えた値に E に 500 を掛けた値を加えた値が 1000 以上かどうかの整数値 を出力する
rst = A + B *5 に C <unk> を加えた値に D に 50 を掛けた値を加えた値に e に 100 を掛けた値を加えた値に E に 500 を掛けた値を加えた値 を出力する <eos>
2537
src = A -= B [ 0 ] * B [ 1 ]
trg = A を B の先頭に B の 1 番目を掛けた値だけ 減 少 させ る
rst = A を B の先頭に B の 1 番目を掛けた値だけ 減 少 させ る <eos>
2538
src = return ( A // B , C // B )
trg = ( A を B で割った商 、 C を B で割った商 ) の組を返す
rst = ( A を B で割った商 、 C を B で割った商 ) の組を返す <eos>
2539
src = A = - 1000
trg = - 1000 を A とする
rst = - 1000 を A とする <eos>
2540
src = A = B . count ( chr ( C ) )
trg = B 内の 、 つまり文字 コ ー ド C の文字の出現回数 を A とする
rst = B 内の 、 つまり文字 コ ー ド C <unk> A とする <eos>
2541
src = A = gcd ( abs ( B ) , C )
trg = B の絶対値と C の最大公約数を A とする
rst = B の絶対値の C の最大公約数を A とする <eos>
2542
src = A . add_edge ( B + C - 1 , D + E , 1 )
trg = A . add _ edge ( B + C -1, D + E ,1)
rst = A . add _ edge ( B + C -1, D + E ,1) <eos>
2543
src = A , now = 1 , 0
trg = 1 、0 を A 、 現在の日時とする
rst = 1 、0 を A 、 現在の日時 とする <eos>
2544
src = A [ 1 ] = B [ 5 ]
trg = B の 5 番目を A の 1 番目に する
rst = B の 5 番目を A の 1 番目に する <eos>
2545
src = while A != B . nodes [ A ] :
trg = A が B の nodes の A 番目と等しくない 間 、 次 を 繰り返 す
rst = A が B の nodes の A 番目と等しくない 間 、 次 を 繰り返 す <eos>
2546
src = if A . count ( B ) >= C and D < A . count ( B ) :
trg = A 内の B の出現回数が C 以上かつ D が A 内の B の出現回数 より小さいとき 、
rst = A 内の B の出現回数が C 以上かつ D が A 内の B の出現回数 より小さいとき 、 <eos>
2547
src = print ( ( 0 - A [ 0 ] ) * A [ 2 ] + A [ 3 ] + A [ 1 ] * A [ 4 ] )
trg = 0 から A [0] を引いた値に A の 2 番目を掛けた値に A の 3 番目を加えた値に A の 1 番目に A の 4 番目を掛けた値を加えた値 を出力する
rst = 0 から A [0] を引いた値に A の 2 番目を掛けた値に A の 3 番目を加えた値に A の 1 番目に A の 4 番目を掛けた値を加えた値 を出力する <eos>
2548
src = A [ B ] [ C ] = [ D , [ E , F , G ] ]
trg = ( D 、 ( E 、 F 、 G ) からなる列 ) からなる列を A の B 番目の C 番目に する
rst = ( D 、 E 、 F 、 G ) からなる列を A の B 番目の C 番目に する <eos>
2549
src = A = ( B % 3600 ) // 60
trg = B を 3600 で割った余りを 60 で割った商を A とする
rst = B を 3600 で割った余りを 60 で割った商を A とする <eos>
2550
src = A = [ [ B , C ] , [ B , C - 1 ] , [ B - 1 , C ] , [ B + 1 , C ] , [ B , C + 1 ] ]
trg = ( ( B 、 C ) からなる列 、 ( B 、 C から 1 を引いた値 ) からなる列 、 ( B から 1 を引いた値 、 C ) からなる列 、 ( B に 1 を加えた値 、 C ) からなる列 、 ( B 、 C に 1 を加えた値 ) からなる列 ) からなる列を A とする
rst = ( B 、 C ) からなる列 、 ( B 、 C から 1 を引いた値 ) からなる列 、 ( B 、 C に 1 を加えた値 、 C ) からなる列 、 ( B 、 C に 1 を加えた値 、 C ) からなる列 、 B に 1 を加えた値 、 C に 1 を加えた値
2551
src = if A [ B ] [ 0 ] [ 0 ] == C :
trg = A の B 番目の先頭の 0 番目が C と等しいとき 、
rst = A の B 番目の先頭の 0 番目が C と等しいとき 、 <eos>
2552
src = A = A . _replace ( left = B )
trg = A ._ replace ( left = B ) を A とする
rst = A ._ replace ( left = B ) を A とする <eos>
2553
src = A = A % _pow ( 10 , 24 )
trg = A を _ pow (10,2 4) で割った余りを A とする
rst = A を _ pow (10,6 4) で割った余りを A とする <eos>
2554
src = A . extend ( B [ C - D ] )
trg = B の C から D を引いた値番目 を追加して A を 拡張 する
rst = B の C から D を引いた値番目 を追加して A を 拡張 する <eos>
2555
src = A . append ( B . count ( 1 ) )
trg = A の末尾に B 内の 1 の出現回数 を追加する
rst = A の末尾に B 内の 1 の出現回数 を追加する <eos>
2556
src = if A + 1 in B and A + 2 in B and A + 3 in B :
trg = A に 1 を加えた値が B に含まれかつ A に 2 を加えた値が B に含まれかつ A に 3 を加えた値が B に含まれるとき 、
rst = A に 1 を加えた値が B に含まれかつ A に 2 を加えた値が B に含まれかつ A に 3 を加えた値が B に含まれるとき 、 <eos>
2557
src = A = min ( B - C , D )
trg = B から C を引いた値 、 D の最小値を A とする
rst = B から C を引いた値 、 D の最小値を A とする <eos>
2558
src = insertion_sort ( A , B , C [ D ] )
trg = insertion _ sort ( A , B , C [ D ] )
rst = insertion _ sort ( A , B , C [ D ] ) <eos>
2559
src = A . append ( 2020 )
trg = A の末尾に 2020 を追加する
rst = A の末尾に 2020 を追加する <eos>
2560
src = return A . p [ B ]
trg = A の p の B 番目を返す
rst = A の p の B 番目を返す <eos>
2561
src = A , B = divmod ( B , 1000 )
trg = B と 1000 を 割った ときの ( 商を展開し 、 それぞれ A 、 B とする
rst = B と 1000 を 割った ときの ( 商を展開し 、 それぞれ A 、 B とする <eos>
2562
src = A = ( A + B - 1 ) % len ( C )
trg = A に B を加えた値から 1 を引いた値を C の長さで割った余りを A とする
rst = A に B を加えた値から 1 を引いた値を C の長さで割った余りを A とする <eos>
2563
src = A = [ sorted ( B ) for C in [ range ( D ) for B in list ( combinations ( list ( map ( str , input ( ) . split ( ) ) ) [ 1 : ] , 2 ) ) ] ]
trg = list ( map ( str , input (). split ())) の先頭を除いた部分列の 2 個までの コン ビ ネ ー シ ョ ンのリスト の各要素を B とし 、0 から D 未満までの数列の列の各要素を C とし 、 B をソートした列の列を A とする
rst = [ MASK ] の各要素に lambdaB : <unk> に番号付した組の列の各要素を B 、 つまり先頭から 、 つまり末尾までの 2 間隔による部分列 の要素をそれぞれ組にした列 の各要素を C とし 、 B の列を A とする <eos>
2564
src = A . append ( B [ ( C [ D ] - 1 ) % 4 + 15 ] )
trg = A の末尾に B の C [ D ] から 1 を引いた値を 4 で割った余りに 15 を加えた値番目 を追加する
rst = A の末尾に B の C [ D ] 番目から 1 を引いた値を 4 で割った余りに 15 を加えた値番目 を追加する <eos>
2565
src = A , B = abs ( C - D ) ** 2 , abs ( E - F ) ** 2
trg = C から D を引いた値の絶対値の 2 乗 、 E から F を引いた値の絶対値の 2 乗を A 、 B とする
rst = C から D を引いた値の絶対値の 2 乗 、 E から F を引いた値の 2 乗を引いた値を A 、 B とする <eos>
2566
src = A . printl ( 3 )
trg = A . printl (3)
rst = A . <unk> () <eos>
2567
src = A [ B - 1 ] = str ( int ( A [ B - 1 ] ) // int ( A [ B + 1 ] ) + 1 )
trg = A の B -1 番目の整数値を A の B +1 番目の整数値 で割った商に 1 を加えた値の文字列を A の B から 1 を引いた値番目に する
rst = A の B から 1 を引いた値番目の整数値を A の B に 1 を加えた値番目の整数値 <unk> A の B から 1 を引いた値番目に する <eos>
2568
src = A [ B ] = ( C [ : - 1 ] , C [ - 1 ] )
trg = ( C の末尾を除いた部分列 、 C の末尾 ) の組を A の B 番目に する
rst = ( C の逆順 、 C の末尾を A の B 番目に する <eos>
2569
src = A . sizes [ B ] += A . sizes [ C ]
trg = A の sizes の B 番目を A の sizes の C 番目だけ 増 加 させ る
rst = A の sizes の B 番目を A の sizes の C 番目だけ 増 加 させ る <eos>
2570
src = A = { (0, 0, 1) : 0 }
trg = ( ( (0、0、1) の組 , 0 )) からなる辞書を A とする
rst = (((0、 B から 1 を引いた値 ) の組 , 0 )) からなる辞書を A とする <eos>
2571
src = A = int ( '' . join ( B [ C : D ] ) )
trg = 空文字列を間に入れて B の C 番目から D 番目までの部分列 を連結した文字列の整数値を A とする
rst = 空文字列を間に入れて B の C 番目から D 番目までの部分列 を連結した文字列の整数値を A とする <eos>
2572
src = A = bin ( B << 1 ) [ 2 : ] . zfill ( 32 )
trg = B を 1 だけ左シフトした値 の 2 進 数文字列の 2 番目から 、 つまり末尾までの部分列を長さ 32 に な るように '0' 左 詰め した文字列を A とする
rst = B を 1 だけ右シフトした値 の 2 進 数文字列の 2 番目から 、 つまり末尾までの部分列を長さ 32 に な るように '0' 左 詰め した文字列を A とする <eos>
2573
src = A . bit2 = BinaryIndexedTree ( B + 1 )
trg = BinaryIndexedTree ( B +1) を A の bit 2 に する
rst = BinaryIndexedTree ( B +1) を A の bit 2 に する <eos>
2574
src = A , B = B , 0
trg = B 、0 を A 、 B とする
rst = B 、0 を A 、 B とする <eos>
2575
src = if A [ - 1 ] > B :
trg = A の -1 番目が B より大きいとき 、
rst = A の -1 番目が B より大きいとき 、 <eos>
2576
src = A [ B ] = len ( C ) - 1
trg = C の長さから 1 を引いた値を A の B 番目に する
rst = C の長さから 1 を引いた値を A の B 番目に する <eos>
2577
src = for A in range ( 2 * B , 110000 , B ) :
trg = 2 に B を掛けた値から 110000 未満までの B 間隔の数列を順に A として 、 繰り返 す
rst = 2 に B を掛けた値から 110000 未満までの B 間隔の数列を順に A として 、 繰り返 す <eos>
2578
src = return set ( )
trg = 集合を 返す
rst = set () を返す <eos>
2579
src = while A . cursor . next is not None :
trg = A の cursor の next が 、 つまり未定値と等しい 間 、 次 を 繰り返 す
rst = A の cursor の next が 、 つまり未定値と等しい 間 、 次 を 繰り返 す <eos>
2580
src = A = ( B - 1 ) % C
trg = B から 1 を引いた値を C で割った余りを A とする
rst = B から 1 を引いた値を C で割った余りを A とする <eos>
2581
src = A [ B ] = 3
trg = 3 を A の B 番目に する
rst = 3 を A の B 番目に する <eos>
2582
src = if trucks ( A , B - 1 ) <= C :
trg = trucks ( A , B -1) が C 以下のとき 、
rst = <unk> ( A , B -1) が C 以下のとき 、 <eos>
2583
src = A = paint ( A , B , C - 3 )
trg = paint ( A , B , C -3) を A とする
rst = paint ( A , B , C -3 ) を A とする <eos>
2584
src = A . insert ( B , C [ D + 1 ] )
trg = A の B に C の D に 1 を加えた値番目 を挿入する
rst = A の B に C の D に 1 を加えた値番目 を挿入する <eos>
2585
src = A [ B ] , A [ C ] = D [ B ] , D [ E ]
trg = D の B 番目 、 D の E 番目を A の B 番目 、 A の C 番目とする
rst = D の B 番目 、 D の E 番目を A の B 番目 、 A の C 番目とする <eos>
2586
src = A = [ 1 for B in range ( C + D + 1 ) ]
trg = 0 から C に D を加えた値に 1 を加えた値未満までの数列の各要素 を B とし 、 1 の列を A とする
rst = 0 から C に D を加えた値に 1 を加えた値未満までの数列の各要素 を B とし 、 1 の列を A とする <eos>
2587
src = print ( A - 1867 )
trg = A から 1867 を引いた値 を出力する
rst = A から 1867 を引いた値 を出力する <eos>
2588
src = A = randrange ( 1 , B )
trg = 1 から B 未満までの 整数 乱 数を A とする
rst = <unk> ( B ) を A とする <eos>
2589
src = print ( ut2jd ( A , B , C ) - ut2jd ( D , E , F ) )
trg = ut 2 jd ( A , B , C ) から ut 2 jd ( D , E , F ) を引いた値 を出力する
rst = <unk> ( A , B , C ) から segment _ line _ dist _ dist 2( D , E , F ) を引いた値 を出力する <eos>
2590
src = if A [ B - C ] :
trg = A の B から C を引いた値番目のとき 、
rst = A の B から C を引いた値番目のとき 、 <eos>
2591
src = A , B , C = D . readline ( ) . split ( )
trg = D から読み込んだ一行を 空白で分割した字句列 を展開し 、 それぞれ A 、 B 、 C とする
rst = D から読み込んだ一行を 空白で分割した字句列 を展開し 、 それぞれ A 、 B 、 C とする <eos>
2592
src = A = { suit : [ { [ D for D in range ( 1 , 14 ) ] } for B in C ] }
trg = ( ( B , C の各要素を B とし 、 ( < __ main __ . Cammaobjectat 0 x 10 a 10 eca 0> ) の集合の列 )) からなる辞書を A とする
rst = ( ( B , C の各要素を B とし 、 ( < __ main __ . Cammaobjectat 0 x 10 a 10 ea 0 0> ) の集合の列 )) からなる辞書を A とする <eos>
2593
src = if A + B <= C and D [ A + B ] == 0 :
trg = A に B を加えた値が C 以下かつ D の A に B を加えた値番目が 0 と等しいとき 、
rst = A に B を加えた値が C 以下かつ D の A に B を加えた値番目が 0 と等しいとき 、 <eos>
2594
src = if A . count ( 0 ) > 1 :
trg = A 内の 0 の出現回数が 1 より大きいとき 、
rst = A 内の 0 の出現回数が 1 より大きいとき 、 <eos>
2595
src = A = B * ( C - D ) - E * ( F - G )
trg = B に C から D を引いた値を掛けた値から E に F から G を引いた値を掛けた値を引いた値を A とする
rst = B に C から D を引いた値を掛けた値から E に F から G を引いた値を掛けた値を引いた値を A とする <eos>
2596
src = write ( A % ( B + C + ( D - E ) ) )
trg = write ( A %( B + C +( D - E )))
rst = write ( A %( B + C + D - E )) <eos>
2597
src = A += ( B == C )
trg = A を B が C と等しいかどうか だけ 増 加 させ る
rst = A を B が C と等しいかどうか だけ 増 加 させ る <eos>
2598
src = print ( A [ ( B , C ) ] [ D ] )
trg = A の ( B 、 C ) の組 番目の D 番目を出力する
rst = A の ( B 、 C ) の組 番目の D 番目を出力する <eos>
2599
src = return '\n' . join ( [ A . format ( B , C . members ( B ) ) for B in C . roots ( ) ] )
trg = 改行文字を間に入れて C . roots () の各要素を B とし 、 A を書式として B 、 C . members ( B ) で整形した文字列の列 を連結した文字列を返す
rst = 改行文字を間に入れて C . split () の各要素を B とし 、 A を書式として B 、 C . <unk> ( B ) の列の最小値 を返す <eos>
2600
src = print ( '' . join ( map ( str , A [ : : - 1 ] ) ) )
trg = 空文字列を間に入れて A の逆順 の各要素に整数を適用した列 を連結した文字列を出力する
rst = 空文字列を間に入れて A の逆順 の各要素に整数を適用した列 を連結した文字列を出力する <eos>
2601
src = print ( A . solve ( B , C , 1 , 1 , 1 , 0 ) )
trg = A . solve ( B , C , 1 , 1,1,0) を出力する
rst = A . solve ( B , C ,1,1,0, 0 ) を出力する <eos>
2602
src = A = B * pow ( 2 , 0.5 )
trg = B に 2 の 0.5 乗を掛けた値を A とする
rst = B に 2 の 0.5 乗を掛けた値を A とする <eos>
2603
src = if A + B + C + D == int ( E ) :
trg = A に B を加えた値に C を加えた値に D を加えた値が E の整数値 と等しいとき 、
rst = A に B を加えた値に C を加えた値に D を加えた値が E の整数値 と等しいとき 、 <eos>
2604
src = return max ( enumerate ( A ) , key = lambda B : B [ 1 ] )
trg = x をパラメータとして x の 1 番目を返す関数を key として A に番号付した組の列 の最大値を返す
rst = w をパラメータとして w の 1 番目を返す関数を key として A の最大値 を返す <eos>
2605
src = print ( A - B - dij ( C , D ) - dij ( D , C ) )
trg = A から B を引いた値から dij ( C , D ) を引いた値から dij ( D , C ) を引いた値 を出力する
rst = A から B を引いた値から <unk> _ segment _ <unk> ( C , D ) を引いた値から ( C ) を引いた値 を出力する <eos>
2606
src = if A [ 0 ] == B [ 0 ] :
trg = A の 0 番目が B の 0 番目と等しいとき 、
rst = A の先頭が B の先頭と等しいとき 、 <eos>
2607
src = if A [ 0 ] != B [ 0 ] :
trg = A の 0 番目が B の先頭と等しくないとき 、
rst = A の先頭が B と等しくないとき 、 <eos>
2608
src = A . low [ B ] = A . cnt
trg = A の cnt を A の low の B 番目に する
rst = A の cnt を A の low の B 番目に する <eos>
2609
src = print ( * [ pow ( 2 * A [ B ] , B ) for B in range ( len ( A ) ) if A [ B ] ] )
trg = 0 から A の長さ未満までの数列の各要素を B とし 、 A の B 番目のときの 2 に A [ B ] を掛けた値 の B 乗の列 を展開してを出力する
rst = 0 から A の長さ未満までの数列の各要素を B とし 、 B の A 番目の B 番目のときの 2 に A の B <unk> 展開してを出力する <eos>
2610
src = A = [ B + 1 ] * 4
trg = ( B に 1 を加えた値 ) からなる列の 4 回分の列を A とする
rst = ( B に 1 を加えた値 ) からなる列の 4 回分の列を A とする <eos>
2611
src = return A . _max ( A . root )
trg = A ._ max ( A . root ) を返す
rst = A ._ delete _ max ( A . root ) を返す <eos>
2612
src = A . heappush ( B , ( C , e ) )
trg = A . heappush ( B , ( C , e ))
rst = A . heappush ( B , ( C , e )) <eos>
2613
src = if A . f [ B ] != B + 1 :
trg = A の f の B 番目が B に 1 を加えた値 と等しくないとき 、
rst = A の f の B 番目が B に 1 を加えた値 と等しくないとき 、 <eos>
2614
src = A , B = get_par ( C ) , get_par ( D )
trg = get _ par ( C ) 、 get _ par ( D ) を A 、 B とする
rst = get _ par ( C ) 、 get _ par ( D ) を A 、 B とする <eos>
2615
src = A [ B ] [ 3 ] = int ( A [ B ] [ 3 ] )
trg = A の B 番目の 3 番目の整数値を A の B 番目の 3 番目に する
rst = A の B 番目の 3 番目の整数値を A の B 番目の 3 番目に する <eos>
2616
src = A = ( B . update , lambda C , D : print ( B . find ( C , D ) ) )
trg = ( [ MASK ] を追加して B を 更新 する 、 x 、 y をパラメータとして B の位置 y から x を探して見つかった位置を出力する を返す関数 ) の組を A とする
rst = find _ <unk> ( B , min ( C , D )) を A とする <eos>
2617
src = A = min ( A , B [ C ] [ 1 ] - 1 )
trg = A 、 B の C 番目の 1 番目から 1 を引いた値の最小値を A とする
rst = A 、 B の C 番目の 1 番目から 1 を引いた値の最小値を A とする <eos>
2618
src = for A in str :
trg = 整数 を順に A として 、 繰り返 す
rst = 整数 を順に A として 、 繰り返 す <eos>
2619
src = print ( len ( ( A - B ) | ( C & A ) ) )
trg = A から B を引いた値と C と A の論理積の論理和 の長さ を出力する
rst = A から B を引いた値と C と A の論理積 の最小公倍数 を出力する <eos>
2620
src = return ( sum ( A ) , B - 1 )
trg = ( A の総和 、 B から 1 を引いた値 ) の組を返す
rst = ( A の総和 、 B から 1 を引いた値 ) の組を返す <eos>
2621
src = if A == B or C [ B ] == D :
trg = A が B と等しくまたは C の B 番目が D と等しいとき 、
rst = A が B と等しくまたは C の B 番目が D と等しいとき 、 <eos>
2622
src = shell_sort ( A , len ( A ) )
trg = shell _ sort ( A , len ( A ))
rst = shell _ sort ( A , len ( A )) <eos>
2623
src = combi ( A + 1 , B , C + D [ E ] [ 2 ] )
trg = combi ( A +1, B , C + D [ E ][2])
rst = combi (2, A +1, B , C + D [ E ] [2])) <eos>
2624
src = A , B = min ( C , D , E ) , max ( C , D , E )
trg = C 、 D 、 E の最小値 、 C 、 D 、 E の最大値を A 、 B とする
rst = C 、 D 、 E の最小値 、 C 、 D 、 E の最大値を A 、 B とする <eos>
2625
src = if A [ B ] != A [ B - 1 ] :
trg = A の B 番目が A の B から 1 を引いた値番目 と等しくないとき 、
rst = A の B 番目が A の B から 1 を引いた値番目 と等しくないとき 、 <eos>
2626
src = heapreplace ( A , B )
trg = heapreplace ( A , B )
rst = <unk> ( A , B ) <eos>
2627
src = if A + B > C and B + C > A and C + A > B :
trg = A に B を加えた値が C より大きくかつ B に C を加えた値が A より大きくかつ C に A を加えた値が B より大きいとき 、
rst = A に B を加えた値が C より大きくかつ B に C を加えた値が A より大きくかつ C に A を加えた値が B より大きいとき 、 <eos>
2628
src = if ord ( A [ B ] ) > ord ( C [ B ] ) :
trg = A の B 番目の順序数が C の B 番目の順序数 より大きいとき 、
rst = A の B 番目の順序数が C の B 番目の順序数 より大きいとき 、 <eos>
2629
src = A = float ( B . pop ( - 2 ) ) * float ( B . pop ( - 1 ) )
trg = B の -2 を取り出した値の浮動小数点数 に B の -1 を取り出した値の浮動小数点数 を掛けた値を A とする
rst = B の -2 を取り出した値の浮動小数点数 に B の -1 を取り出した値の浮動小数点数 を掛けた値を A とする <eos>
2630
src = write ( A % ( B - 1988 , C , D ) )
trg = write ( A %( B -1988 , C , D ))
rst = write ( A %( B - 1988 , C , D )) <eos>
2631
src = A = B // C
trg = B を C で割った商を A とする
rst = B を C で割った商を A とする <eos>
2632
src = if len ( A [ B ] ) == C [ B ] :
trg = A の B 番目の長さが C の B 番目と等しいとき 、
rst = A の B 番目の長さが C の B 番目と等しいとき 、 <eos>
2633
src = A . relations ( B , C )
trg = A . relations ( B , C )
rst = A . <unk> ( B , C ) <eos>
2634
src = A . append ( B - C . count ( D ) )
trg = A の末尾に B から C 内の D の出現回数を引いた値 を追加する
rst = A の末尾に B から C 内の D の出現回数 を追加する <eos>
2635
src = A = read ( B )
trg = read ( B ) を A とする
rst = read ( B ) を A とする <eos>
2636
src = A . append ( [ 0 , B , - C , D ] )
trg = A の末尾に (0、 B 、 - C 、 D ) からなる列 を追加する
rst = A の末尾に (0、 B から C を引いた値 、 D ) からなる列 を追加する <eos>
2637
src = A , B = pi
trg = 円周率 を展開し 、 それぞれ A 、 B とする
rst = 円周率の 各要素に整数を適用した列を展開し 、 それぞれ A 、 B とする <eos>
2638
src = A = B [ C : D ] + [ float ( E ) ]
trg = B の C 番目から D 番目までの部分列に ( E の浮動小数点数 ) からなる列を加えた値を A とする
rst = B の C 番目から D 番目までの部分列に ( float ( E )) を A とする <eos>
2639
src = A = A // 5
trg = A を 5 で割った商を A とする
rst = A を 5 で割った商を A とする <eos>
2640
src = print ( A . format ( count ) )
trg = A を書式として 、 つまり無限の整数列 で整形した文字列を出力する
rst = A を書式として 、 つまり無限の整数列 で整形した文字列を出力する <eos>
2641
src = for A in range ( 12 ) :
trg = 0 から 12 未満までの数列を順に A として 、 繰り返 す
rst = 0 から 12 未満までの数列を順に A として 、 繰り返 す <eos>
2642
src = if A [ B ] [ 1 ] > C :
trg = A の B 番目の 1 番目が C より大きいとき 、
rst = A の B 番目の 1 番目が C より大きいとき 、 <eos>
2643
src = A . top += 1
trg = A の top を 1 だけ 増 加 させ る
rst = A の top を 1 だけ 増 加 させ る <eos>
2644
src = A = sum ( [ B % 10 ** ( C + 1 ) // 10 ** C for C in range ( 1000 ) if B % 10 ** C != B ] )
trg = 0 から 1000 未満までの数列の各要素を C とし 、 B を 10 の C 乗 で割った余りが B と等しくないときの B を 10 の ( C +1) 乗で割った余りを 10 の C 乗で割った商 の列の総和を A とする
rst = 0 から 1000 未満までの数列の各要素を C とし 、 B を C で割った余りが 1 を 10 で割った余り と等しくないときの B を 10 の C に 1 を加えた値までの部分列の総和を A とする <eos>
2645
src = A [ 0 ] [ 0 ] = 1
trg = 1 を A の先頭の 0 番目に する
rst = 1 を A の先頭の 0 番目に する <eos>
2646
src = A . append ( bin ( B ) [ - len ( C ) : ] )
trg = A の末尾に B の 2 進 数文字列の - C の長さから 、 つまり末尾までの部分列 を追加する
rst = A の末尾に B の 2 進 数文字列の 2 番目から 、 つまり末尾までの部分列 を追加する <eos>
2647
src = for A , B in C . primeFactorization . items ( ) :
trg = C の primeFactorization のキーと値の集まり を順に A 、 B として 、 繰り返 す
rst = C の primeFactorization のキーと値の集まり を順に A 、 B として 、 繰り返 す <eos>
2648
src = A . p [ B ] = C . findSet ( A . p [ B ] )
trg = C . findSet ( A . p [ B ] ) を A の p の B 番目に する
rst = C . findSet ( A . p [ B ] ) を A の p の B 番目に する <eos>
2649
src = A = ( round ( ( B [ 0 ] + 2 * C [ 0 ] ) / 3 , 5 ) , round ( ( B [ 1 ] + 2 * C [ 1 ] ) / 3 , 5 ) )
trg = ( B の 0 番目に 2 に C [0] を掛けた値を加えた値を 3 で割った値 、 5 を 四捨五 入した整数値 、 B の 1 番目に 2 に C [1] を掛けた値を加えた値を 3 で割った値 、 5 を 四捨五 入した整数値 ) の組を A とする
rst = ( B の 0 番目に 2 に C の先頭を掛けた値を加えた値を 3 で割った値 、 B の 1 番目に 2 に C の 1 番目を掛けた値を加えた値を 5 で割った値 、 B の 1 番目に C の 5 を掛けた値を加えた値を 5 で割った値 ) の組を A とする <eos>
2650
src = A = 10000
trg = 10000 を A とする
rst = 10000 を A とする <eos>
2651
src = if 0 <= A < B and 0 <= C - 1 < D and E [ A ] [ C - 1 ] == 1 :
trg = 0 が A 以下かどうかが B より小さくかつ 0 が C から 1 を引いた値以下かどうかが D より小さくかつ E の A 番目の C から 1 を引いた値番目が 1 と等しいとき 、
rst = 0 が A 以下かどうかが B より小さくかつ 0 が C から 1 を引いた値以下かどうかが D より小さくかつ E の A 番目の C から 1 を引いた値番目が 1 と等しいとき 、 <eos>
2652
src = A . append ( int ( str ( B ) + str ( C ) ) )
trg = A の末尾に B の文字列に C の文字列を加えた値の整数値 を追加する
rst = A の末尾に B の文字列に C の文字列を加えた値 を追加する <eos>
2653
src = A . check ( )
trg = A . check ()
rst = A . check () <eos>
2654
src = chessboard ( A , B )
trg = chessboard ( A , B )
rst = <unk> ( A , B ) <eos>
2655
src = if len ( A ) < len ( B ) :
trg = A の長さが B の長さより小さいとき 、
rst = A の長さが B の長さより小さいとき 、 <eos>
2656
src = A = rotate ( A )
trg = rotate ( A ) を A とする
rst = rotate ( A ) を A とする <eos>
2657
src = A [ ord ( B [ C ] ) - 97 ] += 1
trg = A の B の C 番目の順序数から 97 を引いた値番目を 1 だけ 増 加 させ る
rst = A の B の C 番目の順序数から 97 を引いた値番目を 1 だけ 増 加 させ る <eos>
2658
src = A = [ 0 ] + [ float ( B ) ] * ( C )
trg = (0) からなる列に ( B の浮動小数点数 ) からなる列の C 回分の列を加えた値を A とする
rst = (0) からなる列に ( B の浮動小数点数 ) からなる列の C 回分の列を加えた値を A とする <eos>
2659
src = A = bisect . bisect_left ( B [ C ] , D )
trg = ソートされた順序を保ったまま D を B の C 番目 に挿入できる位置を A とする
rst = ソートされた順序を保ったまま D を B の C 番目 に挿入できる位置を A とする <eos>
2660
src = A = ( B * B + C * C ) - D * D
trg = B に B を掛けた値に C に C を掛けた値を加えた値から D に D を掛けた値を引いた値を A とする
rst = B に B を掛けた値に C に C を掛けた値を加えた値に C に D を掛けた値を加えた値を A とする <eos>
2661
src = A . sort ( key = B . itemgetter ( 2 ) )
trg = B . itemgetter (2) を key として A をソート する
rst = B . itemgetter (2) を key として A をソート する <eos>
2662
src = A = rot60 ( Point ( ( B . x - C . x ) / 3 , ( B . y - C . y ) / 3 ) )
trg = rot 60 ( Point ( ( B . x - C . x )/3,( B . y - C . y )/3) ) を A とする
rst = <unk> ( Point ( B . x / C . x ) , 1/3) を A とする <eos>
2663
src = A = B + input ( ) + C
trg = B に入力された文字列を加えた値に C を加えた値を A とする
rst = B に入力された文字列を加えた値に C を加えた値を A とする <eos>
2664
src = print ( 1 if A == 0 else A )
trg = A が 0 と等しいとき 1 、 そうでなければ A を出力する
rst = A が 0 と等しいとき 1 、 そうでなければ A を出力する <eos>
2665
src = write ( A % ( B - C , D - 1 ) )
trg = write ( A %( B - C , D -1))
rst = write ( A %( B - C , D -1)) <eos>
2666
src = A = namedtuple ( B , ( C , D , E ) )
trg = namedtuple ( B , ( C , D , E )) を A とする
rst = namedtuple ( B , ( C , D , E )) を A とする <eos>
2667
src = for A in range ( 1 , - ~ B ) :
trg = 1 から - B の 補 数 未満までの数列を順に A として 、 繰り返 す
rst = 1 から -1 の 補 数 から B 未満までの数列を順に A として 、 繰り返 す <eos>
2668
src = A [ B ] = operator ( C , D , E [ F ] )
trg = operator ( C , D , E [ F ] ) を A の B 番目に する
rst = <unk> _ <unk> ( C , D , E [ F ] ) を A の B 番目に する <eos>
2669
src = return A + B * C
trg = A に B に C を掛けた値を加えた値を返す
rst = A に B に C を掛けた値を加えた値を返す <eos>
2670
src = A = lcm_mul ( B )
trg = lcm _ mul ( B ) を A とする
rst = <unk> ( B ) を A とする <eos>
2671
src = if e [ 1 ] == 0 :
trg = ネイピア数の 1 番目が 0 と等しいとき 、
rst = ネイピア数の 1 番目が 0 と等しいとき 、 <eos>
2672
src = while A and len ( B ) :
trg = A かつ B の長さの 間 、 次 を 繰り返 す
rst = A かつ B の長さの 間 、 次 を 繰り返 す <eos>
2673
src = print ( sum ( A [ : 1 - B ] ) )
trg = A の 、 つまり先頭から 1 から B を引いた値までの部分列の総和 を出力する
rst = A の 、 つまり先頭から 1 を引いた値から B 番目までの部分列の総和 を出力する <eos>
2674
src = A = { c : [ Counter ( ) for B in C . ascii_lowercase ] }
trg = ( ( B , C の ascii _ lowercase の各要素を B とし 、 [ MASK ] の 辞書 カ ウ ンタの列 )) からなる辞書を A とする
rst = ( ( B , C の ascii _ lowercase の各要素を B とし 、 、 つまり空辞書の列 )) からなる辞書を A とする <eos>
2675
src = if A * B >= 0 :
trg = A に B を掛けた値が 0 以上のとき 、
rst = A に B を掛けた値が 0 以上のとき 、 <eos>
2676
src = A = max ( A , B * C )
trg = A 、 B に C を掛けた値の最大値を A とする
rst = A 、 B に C を掛けた値の最大値を A とする <eos>
2677
src = A = B / 2 / ( C - D ) * ( C + E - B - F - e )
trg = B を 2 で割った値を C から D を引いた値で割った値に C に E を加えた値から B を引いた値から F を引いた値から 、 つまりネイピア数 を引いた値を掛けた値を A とする
rst = B を 2 で割った値を C から D を引いた値で割った値に C に E を加えた値から B を引いた値から F を引いた値を掛けた値を A とする <eos>
2678
src = A , B = polar_to_cartesian ( 2 * C / 3 , D )
trg = polar _ to _ cartesian (2* C /3, D ) を展開し 、 それぞれ A 、 B とする
rst = <unk> _ gcd ( 2 * C を 3 で割った値 、 D ) を展開し 、 それぞれ A 、 B とする <eos>
2679
src = A . tree [ e [ 1 ] ] . append ( ( e [ 0 ] , e [ 2 ] ) )
trg = A の tree の 、 つまりネイピア数の 1 番目番目の末尾に ( 、 つまりネイピア数の先頭 、 ネイピア数の 2 番目 ) の組 を追加する
rst = A の tree の 、 つまりネイピア数の 1 番目 番目の末尾にネイピア数の先頭 を追加する <eos>
2680
src = A = [ 0 ] * 105
trg = (0) からなる列の 105 回分の列を A とする
rst = (0) からなる列の 105 回分の列を A とする <eos>
2681
src = A = min ( A , B // C )
trg = A 、 B を C で割った商の最小値を A とする
rst = A 、 B を C で割った商の最小値を A とする <eos>
2682
src = for A in map ( B . index , e [ 1 : - 1 ] ) :
trg = ネイピア数の 1 番目から 、 つまり末尾までの部分列の各要素に B の [ MASK ] と等しい要素の最初の位置 を適用した列を順に A として 、 繰り返 す
rst = ネイピア数の 1 番目から 、 つまり末尾までの部分列 の各要素に整数を適用した列を順に A として 、 繰り返 す <eos>
2683
src = A = B . S [ - 1 ]
trg = B の S の末尾を A とする
rst = B の S の末尾を A とする <eos>
2684
src = A . tree [ e [ 0 ] - 1 ] . append ( e [ 1 ] - 1 )
trg = A の tree の 、 つまりネイピア数の先頭 から 1 を 引いた値番目の末尾にネイピア数の 1 番目から 1 を引いた値 を追加する
rst = A の tree の 、 つまりネイピア数の 0 番目から 1 を 引いた値番目の末尾にネイピア数の 1 番目から 1 を引いた値 を追加する <eos>
2685
src = for A in range ( 2 , int ( B ** 0.5 ) + 2 ) :
trg = 2 から B の 0.5 乗の整数値に 2 を加えた値未満までの数列を順に A として 、 繰り返 す
rst = 2 から B の 0.5 乗の整数値に 2 を加えた値未満までの数列を順に A として 、 繰り返 す <eos>
2686
src = A . _cache [ B ] = C
trg = C を A の _ cache の B 番目に する
rst = C を A の _ cache の B 番目に する <eos>
2687
src = if A >= 3 :
trg = A が 3 以上のとき 、
rst = A が 3 以上のとき 、 <eos>
2688
src = A = ( [ map ( int , readline ( ) . split ( ) ) for B in range ( 4 ) ] )
trg = 0 から 4 未満までの数列の各要素を B とし 、 readline () を空白で分割した字句列の各要素に 整数を適用した列の列を A とする
rst = 0 から 4 未満までの数列の各要素を B とし 、 readline () を空白で分割した字句列の各要素に 整数を適用した列の列を A とする <eos>
2689
src = A . head = None
trg = 未定値を A の head に する
rst = 未定値を A の head に する <eos>
2690
src = A . head [ A . next [ B ] ] = A . head [ B ]
trg = A の head の B 番目を A の head の A の next の B 番目番目に する
rst = A の head の B 番目を A の head の A の next の B 番目番目に する <eos>
2691
src = A = int ( pow ( B , 2 ) )
trg = B の 2 乗の整数値を A とする
rst = B の 2 乗の整数値を A とする <eos>
2692
src = A = B . data
trg = B の data を A とする
rst = B の data を A とする <eos>
2693
src = A [ B ] = Dice ( C )
trg = Dice ( C ) を A の B 番目に する
rst = Dice ( C ) を A の B 番目に する <eos>
2694
src = A . weights [ B ] = C - D + E
trg = C から D を引いた値に E を加えた値を A の weights の B 番目に する
rst = C から D を引いた値に E を加えた値を A の weights の B 番目に する <eos>
2695
src = print ( {X:.3f} {Y:.3f} )
trg = "{} {}" を出力する
rst = "{} \ n {} \ n {}" を出力する <eos>
2696
src = A . idx = { }
trg = 空辞書を A の idx に する
rst = 空辞書を A の idx に する <eos>
2697
src = A += ( - B [ C ] [ 0 ] ) * D
trg = A を - B の C 番目の先頭に D を掛けた値だけ 増 加 させ る
rst = A を - B の C 番目の 0 番目に D を掛けた値だけ 増 加 させ る <eos>
2698
src = A , B = get_co ( C - 1 , D )
trg = get _ co ( C -1, D ) を展開し 、 それぞれ A 、 B とする
rst = get _ co ( C -1, D ) を展開し 、 それぞれ A 、 B とする <eos>
2699
src = A = B [ 3 : ]
trg = B の 3 番目から 、 つまり末尾までの部分列を A とする
rst = B の 3 番目から 、 つまり末尾までの部分列を A とする <eos>
2700
src = A += min ( B , C )
trg = A を B 、 C の最小値だけ 増 加 させ る
rst = A を B 、 C の最小値だけ 増 加 させ る <eos>
2701
src = A = ( to_gamma ( B [ 0 ] ) - to_gamma ( B [ 3 ] ) + 26 ) % 26
trg = to _ gamma ( B [0]) から to _ gamma ( B [3]) を引いた値に 26 を加えた値を 26 で割った余りを A とする
rst = to _ gamma ( B [0]- B [3]) に 26 を加えた値を 26 で割った余りを A とする <eos>
2702
src = search ( 0 , A , B )
trg = A 、 B に お いて正規表現 0 が最初にマッチする位置
rst = B 、 A に お いて正規表現 0 が最初にマッチする位置 <eos>
2703
src = A , B = C [ D ] [ 0 ]
trg = C の D 番目の先頭 を展開し 、 それぞれ A 、 B とする
rst = C の D 番目の先頭 を展開し 、 それぞれ A 、 B とする <eos>
2704
src = for A in range ( 65 , 91 ) :
trg = 65 から 9 1 未満までの数列を順に A として 、 繰り返 す
rst = 65 から 9 1 未満までの数列を順に A として 、 繰り返 す <eos>
2705
src = return _find ( A . left )
trg = _ find ( A . left ) を返す
rst = _ find ( A . left ) を返す <eos>
2706
src = A . rp . append ( ( [ A . d [ 0 ] , A . d [ 1 ] ] , A . d [ 2 ] ) )
trg = A の rp の末尾に ( ( A の d の先頭 、 A の d の 1 番目 ) からなる列 、 A の d の 2 番目 ) の組 を追加する
rst = A の rp の末尾に ( A の d の先頭 、 A の d の 1 番目 、 A の d の 2 番目 ) からなる列 を追加する <eos>
2707
src = A [ B + 3 ] [ C + 1 ] = D
trg = D を A の B に 3 を加えた値番目の C に 1 を加えた値番目に する
rst = D を A の B に 3 を加えた値番目の C に 1 を加えた値番目に する <eos>
2708
src = if A > B and C > B :
trg = A が B より大きくかつ C が B より大きいとき 、
rst = A が B より大きくかつ C が B より大きいとき 、 <eos>
2709
src = A . marge_next_wait ( B )
trg = A . marge _ next _ wait ( B )
rst = A . <unk> ( B ) <eos>
2710
src = print ( A [ not ( B < C < D ) : : 2 ] )
trg = A の B が C より小さいかどうかが D より小さく ない から 、 つまり末尾までの 2 間隔による部分列 を出力する
rst = A の B が C より小さいかどうかが D <unk> 、 つまり末尾までの 2 間隔による部分列 を出力する <eos>
2711
src = A = B . INFINITY
trg = B の INFINITY を A とする
rst = B の INFINITY を A とする <eos>
2712
src = if A [ 0 ] == B and C > 0 :
trg = A の先頭が B と等しくかつ C が 0 より大きいとき 、
rst = A の先頭が B と等しくかつ C が 0 より大きいとき 、 <eos>
2713
src = print ( str [ A : B ] )
trg = 整数の A 番目から B 番目までの部分列 を出力する
rst = 整数の A 番目から B 番目までの部分列 を出力する <eos>
2714
src = A , B , C = 1 , 1 , 0
trg = 1 、1、0 を A 、 B 、 C とする
rst = 1 、0、 C を A 、 B 、 C とする <eos>
2715
src = A = int ( B + str ( C ) + B [ : : - 1 ] )
trg = B に C の文字列を加えた値に B の逆順を加えた値 の整数値を A とする
rst = B に C の文字列を加えた値に B の逆順を加えた値 の整数値を A とする <eos>
2716
src = A . append ( [ B + 1 for B in A [ C ] ] )
trg = A の末尾に A の C 番目の各要素を B とし 、 B に 1 を加えた値の列 を追加する
rst = A の末尾に A の C 番目の各要素を B とし 、 B に 1 を加えた値の列 を追加する <eos>
2717
src = A . update ( B [ 0 ] , B [ 1 ] , 1 , 1 , C , B [ 2 ] )
trg = B の先頭 、 B の 1 番目 、 1、1、 C 、 B の 2 番目 を追加して A を 更新 する
rst = B の先頭 、 B の 1 番目 、 C 、 B の 2 番目 、 B の 2 番目 を追加して A を 更新 する <eos>
2718
src = A = set ( B [ C ] )
trg = B の C 番目 の集合を A とする
rst = B の C 番目を A とする <eos>
2719
src = A = prim ( )
trg = prim () を A とする
rst = prim () を A とする <eos>
2720
src = A [ B [ 1 ] ] = A [ B [ 0 ] ]
trg = A の B の先頭番目を A の B の 1 番目番目に する
rst = A の B の先頭番目を A の B の 1 番目番目に する <eos>
2721
src = A = shcd_order ( B )
trg = shcd _ order ( B ) を A とする
rst = <unk> ( B ) を A とする <eos>
2722
src = A = tuple ( 1 if B == C else [ 0 for C in range ( D ) ] )
trg = B が C と等しいとき 1 、 そうでなければ 0 から D 未満までの数列の各要素を C とし 、0 の列の組を A とする
rst = B が C と等しいとき 1 、 そうでなければ 0 から D 未満までの数列の各要素を C とし 、0 の列 ) の組を A とする <eos>
2723
src = print ( A . index ( max ( A ) ) )
trg = A の A の最大値と等しい要素の最初の位置 を出力する
rst = A の A の最大値と等しい要素の最初の位置 を出力する <eos>
2724
src = A = B [ C ] . intersect ( B [ D ] )
trg = B [ C ] . intersect ( B [ D ] ) を A とする
rst = B [ C ] . intersect ( B [ D ] ) を A とする <eos>
2725
src = A = [ 999999999 ] * ( B + 1 )
trg = ( 999999999 ) からなる列の B に 1 を加えた値回分の列を A とする
rst = ( <unk> ) からなる列の B に 1 を加えた値回分の列を A とする <eos>
2726
src = if A == 100 :
trg = A が 100 と等しいとき 、
rst = A が 100 と等しいとき 、 <eos>
2727
src = if cross3 ( A , B , C [ D ] ) <= 0 :
trg = cross 3( A , B , C [ D ] ) が 0 以下のとき 、
rst = cross 3( A , B , C [ D ] ) が 0 以下のとき 、 <eos>
2728
src = A [ 2 ] -= 1
trg = A の 2 番目を 1 だけ 減 少 させ る
rst = A の 2 番目を 1 だけ 減 少 させ る <eos>
2729
src = for A , e in enumerate ( B . E [ C ] ) :
trg = B の E の C 番目 に番号付した組の列を順に A 、 ネイピア数 として 、 繰り返 す
rst = B の E の C 番目 に番号付した組の列を順に A 、 ネイピア数 として 、 繰り返 す <eos>
2730
src = print ( dfs ( A , B , C , D , E ) % ( 10 ** 9 + 7 ) )
trg = dfs ( A , B , C , D , E ) を 10 の 9 乗に 7 を加えた値 で割った余りを出力する
rst = dfs ( A , B , C , D , E ) を ( Decimal 9 乗に 7 を加えた値 の 9 を加えた値を出力する <eos>
2731
src = A -= A // B
trg = A を A を B で割った商だけ 減 少 させ る
rst = A を A を B で割った商だけ 減 少 させ る <eos>
2732
src = A = int ( B * C )
trg = B に C を掛けた値の整数値を A とする
rst = B に C を掛けた値の整数値を A とする <eos>
2733
src = return A . value == B . value
trg = A の value が B の value と等しいかどうかを返す
rst = A の value が B の value と等しいかどうかを返す <eos>
2734
src = if ( A not in B . keys ( ) ) :
trg = A が B のキーの集まり に含まれないとき 、
rst = A が B のキーの集まりに含まれるとき 、 <eos>
2735
src = e [ A [ 0 ] - 1 ] [ A [ B ] - 1 ] = 1
trg = 1 をネイピア数の A の先頭から 1 を引いた値番目の A の B 番目から 1 を引いた値番目に する
rst = 1 をネイピア数の A の先頭から 1 を引いた値番目の A の B 番目から 1 を引いた値番目に する <eos>
2736
src = A . append ( ( B [ C ] , C ) )
trg = A の末尾に ( B の C 番目 、 C ) の組 を追加する
rst = A の末尾に ( B の C 番目 、 C ) の組 を追加する <eos>
2737
src = A = min ( int ( B / 2 ) , C )
trg = B を 2 で割った値の整数値 、 C の最小値を A とする
rst = B を 2 で割った値 、 C の最小値を A とする <eos>
2738
src = dfs ( A [ B ] )
trg = dfs ( A [ B ] )
rst = dfs ( A [ B ] ) <eos>
2739
src = if A [ 0 ] == B [ 2 ] :
trg = A の先頭が B の 2 番目と等しいとき 、
rst = A の先頭が B の 2 番目と等しいとき 、 <eos>
2740
src = if A [ - 1 ] :
trg = A の末尾 のとき 、
rst = A の -1 番目のとき 、 <eos>
2741
src = if A != len ( io ) - 1 :
trg = A が io の長さから 1 を引いた値と等しくないとき 、
rst = A が io の長さから 1 を引いた値と等しくないとき 、 <eos>
2742
src = A = B + C * ( D - E ) // F
trg = B に C に D から E を引いた値を掛けた値を F で割った商を加えた値を A とする
rst = B に C に D から E を引いた値を掛けた値を F で割った商を加えた値を A とする <eos>
2743
src = fill ( A - 1 , B + 1 )
trg = fill ( A -1, B +1)
rst = fill ( A -1, B +1) <eos>
2744
src = A . table = [ B ] * A . offset + C + [ B ] * ( A . offset - len ( C ) )
trg = ( B ) からなる列の A の offset に C を加えた値に ( B ) からなる列の A の offset から C の長さを引いた値 回分の列を加えた値回分の列を A の table に する
rst = ( B ) からなる列の A の offset に C を加えた値に [ B ] を掛けた値に A の offset に C を掛けた値から C を引いた値を掛けた値の 0.5 乗を A の table に する <eos>
2745
src = if ( A % 100 ) // 10 == ( B % 100 ) // 10 :
trg = A を 100 で割った余りを 10 で割った商が B を 100 で割った余りを 10 で割った商 と等しいとき 、
rst = A を 100 で割った余りを 10 で割った商が B を 100 で割った商 と等しいとき 、 <eos>
2746
src = A = MultiSet ( )
trg = MultiSet () を A とする
rst = <unk> () を A とする <eos>
2747
src = A . prev . next = B
trg = B を A の prev の next に する
rst = B を A の prev の next に する <eos>
2748
src = A = ( B [ C ] [ D ] + 2 == B [ C + 1 ] [ D ] )
trg = B の C 番目の D 番目に 2 を加えた値が B の C に 1 を加えた値番目の D 番目と等しいかどうかを A とする
rst = B の C 番目の D 番目に 2 を加えた値が B の C に 1 を加えた値番目の D 番目と等しいとき A とする <eos>
2749
src = print ( A - B [ : : - 1 ] . index ( min ( B ) ) )
trg = A から B の逆順の B の最小値と等しい要素の最初の位置 を引いた値 を出力する
rst = A から B の逆順の B と等しい要素の最初の位置 を引いた値 を出力する <eos>
2750
src = print ( str [ : A ] )
trg = 整数の 、 つまり先頭から A 番目までの部分列 を出力する
rst = 整数の 、 つまり先頭から A 番目までの部分列 を出力する <eos>
2751
src = print_preorder ( A . left )
trg = print _ preorder ( A . left )
rst = print _ preorder ( A . left ) <eos>
2752
src = A += B // C
trg = A を B を C で割った商だけ 増 加 させ る
rst = A を B を C で割った商だけ 増 加 させ る <eos>
2753
src = print ( A . access ( int ( B ) ) )
trg = A . access ( int ( B )) を出力する
rst = A . <unk> ( int ( B )) を出力する <eos>
2754
src = A , B = C . MAX , C . MAX
trg = C の MAX 、 C の MAX を A 、 B とする
rst = C の <unk> を A 、 B とする <eos>
2755
src = A = [ ( 0 , 0 , 0 , 0 ) ]
trg = ((0、0、0、0) の組 ) からなる列を A とする
rst = ( (0、0、0、0、0、0、0 ) からなる列を A とする <eos>
2756
src = A = [ str [ B ] for B in range ( C ) ]
trg = 0 から C 未満までの数列の各要素を B とし 、 、 つまり整数の B 番目の列を A とする
rst = 0 から C 未満までの数列の各要素を B とし 、 B の文字列の列を A とする <eos>
2757
src = if A [ B ] [ C ] == D or E [ B ] [ C ] :
trg = A の B 番目の C 番目が D と等しくまたは E の B 番目の C 番目のとき 、
rst = A の B 番目の C 番目が D と等しくまたは E の B 番目の C 番目のとき 、 <eos>
2758
src = A += 15 * B + ( 15 - 2 ) * 5 * B
trg = A を 15 に B を掛けた値に 15 から 2 を引いた値に 5 を掛けた値に B を掛けた値を加えた値だけ 増 加 させ る
rst = A を 15 に B を掛けた値に 15 から 2 を引いた値に 5 を掛けた値に B を掛けた値を加えた値だけ 増 加 させ る <eos>
2759
src = A . update_depth ( )
trg = A . update _ depth ()
rst = A . dice _ s () <eos>
2760
src = A [ A [ - 1 ] ] . type = B
trg = B を A の A の末尾番目の type に する
rst = B を A の A の末尾の type 番目に する <eos>
2761
src = fill ( A , B )
trg = fill ( A , B )
rst = fill ( A , B ) <eos>
2762
src = if ( A >= B and A <= C ) and ( D >= E and D <= F ) :
trg = A が B 以上かつ A が C 以下かつ D が E 以上かつ D が F 以下のとき 、
rst = A が B 以上かつ A が C 以下かつ D が E 以下かつ D が F 以下のとき 、 <eos>
2763
src = A . append ( ( int ( B ) , int ( C ) , D , int ( E ) , e ) )
trg = A の末尾に ( B の整数値 、 C の整数値 、 D 、 E の整数値 、 ネイピア数 ) の組 を追加する
rst = A の末尾に ( B の整数値 、 C の整数値 、 D 、 E の整数値 、 ネイピア数 ) の組 を追加する <eos>
2764
src = search ( A , B , C , D , E )
trg = B 、 C 、 D 、 E に お いて正規表現 A が最初にマッチする位置
rst = B 、 C 、 D 、 E に お いて正規表現 A が最初にマッチする位置 <eos>
2765
src = if A - B == C - D :
trg = A から B を引いた値が C から D を引いた値と等しいとき 、
rst = A から B を引いた値が C から D を引いた値と等しいとき 、 <eos>
2766
src = A [ B ] = f ( A [ B * 2 ] , A [ B * 2 + 1 ] )
trg = f ( A [ B *2], A [ B *2+1] ) を A の B 番目に する
rst = f ( A [ B <unk> A [ B *2+2 ] ) を A の B 番目に する <eos>
2767
src = A = B [ C . pop ( ) ]
trg = B の C の先頭を取り出した値 番目を A とする
rst = B の C を取り出した値を A とする <eos>
2768
src = A = B . bst . get ( C ) + 1
trg = B の bst に対応する値 、 もし存在しなければ C に 1 を加えた値を A とする
rst = B に対応する値 、 もし存在しなければ C に 1 を加えた値を A とする <eos>
2769
src = if A - B - C < C and A - B - C > 0 :
trg = A から B を引いた値から C を引いた値が C より小さくかつ A から B を引いた値から C を引いた値が 0 より大きいとき 、
rst = A から B を引いた値から C を引いた値が C より小さくかつ A から B を引いた値から C を引いた値が 0 より大きいとき 、 <eos>
2770
src = A += ( B - C ) // D
trg = A を B から C を引いた値を D で割った商だけ 増 加 させ る
rst = A を B から C を引いた値を D で割った商だけ 増 加 させ る <eos>
2771
src = A [ 0 ] [ B - 1 ] = 1
trg = 1 を A の先頭の B から 1 を引いた値番目に する
rst = 1 を A の先頭の B から 1 を引いた値番目に する <eos>
2772
src = A = 1 + B * C [ 1 ] / 100
trg = 1 に B に C の 1 番目を掛けた値を 100 で割った値を加えた値を A とする
rst = 1 に B に C の 1 番目を掛けた値を 100 で割った値を加えた値を A とする <eos>
2773
src = A += B [ : C ]
trg = A を B の 、 つまり先頭から C 番目までの部分列 だけ 増 加 させ る
rst = A を B の 、 つまり先頭から C 番目までの部分列 だけ 増 加 させ る <eos>
2774
src = if A . isupper ( ) :
trg = A の全てが英大文字のとき 、
rst = A 、 無限の整数列 のとき 、 <eos>
2775
src = A += e . c
trg = A をネイピア数の c だけ 増 加 させ る
rst = A をネイピア数の c だけ 増 加 させ る <eos>
2776
src = return A . value
trg = A の value を返す
rst = A の value を返す <eos>
2777
src = time += A [ B ] [ 1 ]
trg = time を A の B 番目の 1 番目だけ 増 加 させ る
rst = time を A の B 番目の 1 番目だけ 増 加 させ る <eos>
2778
src = while A - 1 :
trg = A から 1 を引いた値の 間 、 次 を 繰り返 す
rst = A から 1 を引いた値の 間 、 次 を 繰り返 す <eos>
2779
src = move ( A )
trg = move ( A )
rst = move ( A ) <eos>
2780
src = print ( ' ' + A + str ( B [ C ] ) + D , end = '' )
trg = 改行せずに空白文字に A を加えた値に B の C 番目の文字列を加えた値に D を加えた値を出力する
rst = 改行せずに空白文字に A + B [ C ] の文字列を加えた値に D を加えた値を出力する <eos>
2781
src = A . spin ( )
trg = A . spin ()
rst = A . spin () <eos>
2782
src = A . left = 0
trg = 0 を A の left に する
rst = 0 を A の left に する <eos>
2783
src = A [ B ] [ C ] = sum ( [ A [ B - 1 ] [ C - D ] for D in E [ B - 1 ] if D <= C ] )
trg = E の B から 1 を引いた値番目の各要素を D とし 、 D が C 以下のとき の A の B から 1 を引いた値番目の C から D を引いた値番目の列の総和を A の B 番目の C 番目に する
rst = E の各要素を D とし 、 B -1 が D 以下のとき の A の B から 1 を引いた値番目の C 番目の列の総和を A の B 番目の C 番目に する <eos>
2784
src = for A , B , C in D . log :
trg = D の log を順に A 、 B 、 C として 、 繰り返 す
rst = D の log を順に A 、 B 、 C として 、 繰り返 す <eos>
2785
src = A = [ False , False , False ]
trg = ( 、 つまり偽 、 偽 、 偽 ) からなる列を A とする
rst = ( 、 つまり偽 、 偽 、 偽 ) からなる列を A とする <eos>
2786
src = A = [ [ [ 0 ] * [ ( B + 1 ) for C in range ( 3 ) ] ] for C in range ( B + 1 ) ]
trg = 0 から B に 1 を加えた値未満までの数列の各要素 を C とし 、 ( (0) からなる列の 0 から 3 未満までの数列の各要素を C とし 、 B に 1 を加えた値の列回分の列 ) からなる列の列を A とする
rst = 0 から B に 1 を加えた値未満までの数列の各要素 を C とし 、 ( (0) からなる列の 0 から 3 未満までの数列の各要素を C とし 、 B に 1 を加えた値の列回分の列 ) からなる列の列を A とする <eos>
2787
src = A [ B ] = root ( A , A [ B ] )
trg = root ( A , A [ B ] ) を A の B 番目に する
rst = root ( A , A [ B ] ) を A の B 番目に する <eos>
2788
src = A = ( ( 1 , 4 ) , ( 0 , 2 , 5 ) , ( 1 , 3 , 6 ) , ( 2 , 7 ) , ( 0 , 5 ) , ( 1 , 4 , 6 ) , ( 2 , 5 , 7 ) , ( 3 , 6 ) )
trg = ( (1、4) の組 、 (0、2、5 ) の組 、(1、3、 6) の組 、(2、 7 ) の組 、(0、5 ) の組 、(1、 4、6) の組 、(2、 5、7) の組 、 ( 3、6) の組 ) の組を A とする
rst = ( 1、4、1、4、1、2、1、2) の組 、 ( 4 、0、2、3 の組 、 ( 2、2) の組 ) の組 ) の組 ) からなる列を A とする <eos>
2789
src = A = defaultdict ( int , { a : 1 } )
trg = defaultdict ( int ,{ a : 1 }) を A とする
rst = defaultdict ( int , 97 )) を A とする <eos>
2790
src = if A . cross ( B , C ) > D . epsilon :
trg = A . cross ( B , C ) が D の epsilon より大きいとき 、
rst = A . cross ( B , C ) が D の epsilon より大きいとき 、 <eos>
2791
src = return A . find ( B ) == A . find ( C )
trg = A の先頭から B を探して見つかった位置が A の先頭から C を探して見つかった位置 と等しいかどうかを返す
rst = A の先頭から B を探して見つかった位置が A の先頭から C を探して見つかった位置 と等しいかどうかを返す <eos>
2792
src = A [ B + 1 ] [ C ] = max ( A [ B ] [ C ] , A [ B + 1 ] [ C - D [ B ] ] + E [ B ] )
trg = A の B 番目の C 番目 、 A の B に 1 を加えた値番目の C から D の B 番目を引いた値番目に E の B 番目 を加えた値の最大値を A の B に 1 を加えた値番目の C 番目に する
rst = A の B 番目の C 番目 、 A の B に 1 を加えた値番目の C から D の B 番目を引いた値番目に E の B 番目 を加えた値の最大値を A の B に 1 を加えた値番目の C 番目に する <eos>
2793
src = [ print ( * [ A * B ] ) for C in range ( D ) ]
trg = 0 から D 未満までの数列の各要素を C とし 、 ( A に B を掛けた値 ) からなる列 を展開してを出力するの列
rst = 0 から D 未満までの数列の各要素を C とし 、 A に B を掛けた値 の C 番目を掛けた値の列の総和 を出力する <eos>
2794
src = A [ B : ] [ : : - 1 ] + A [ : B ] [ : : - 1 ]
trg = A の B 番目から 、 つまり末尾までの部分列の逆順 に A の 、 つまり先頭から B 番目までの部分列の逆順を加えた値
rst = A の B 番目から 、 つまり末尾までの -1 間隔による部分列に A の 、 つまり先頭から B 番目までの部分列の 、 つまり末尾までの -1 間隔による部分列 を加えた値を A の B 番目から 、 つまり末尾までの -1 間隔による部分列に する <eos>
2795
src = A . tail = A . Node ( )
trg = A . Node () を A の tail に する
rst = A . Node () を A の tail に する <eos>
2796
src = return [ ( A , B , C ) ] + divide ( [ A , C ] + D )
trg = ( ( A 、 B 、 C ) の組 ) からなる列に divide ([ A , C ] + D ) を加えた値を返す
rst = ( ( A 、 B 、 C ) の組 ) からなる列に divide ( A , C ) を加えた値に ( D ) を加えた値を返す <eos>
2797
src = A = get ( B , C , D , E , E [ 5 ] , 5 ) [ : ]
trg = get ( B , C , D , E , E [5], 5) のコピーされた列を A とする
rst = get ( B , C , D , E , E [ 5 ] , のコピーされた列を A とする <eos>
2798
src = A [ pi ] = A [ pi - B ] + 1
trg = A の 、 つまり円周率から B を引いた値番目に 1 を加えた値を A の 、 つまり円周率 番目に する
rst = A の 、 つまり円周率から B を引いた値番目に 1 を加えた値を A の 、 つまり円周率 番目に する <eos>
2799
src = A [ B ] = 100
trg = 100 を A の B 番目に する
rst = 100 を A の B 番目に する <eos>
2800
src = print ( A . format ( B [ 0 ] , B [ 1 ] ) )
trg = A を書式として B の先頭 、 B の 1 番目で整形した文字列を出力する
rst = A を書式として B の先頭 、 B の 1 番目で整形した文字列を出力する <eos>
2801
src = if A + 1 < B and C [ D ] [ A + 1 ] != E and not F [ D ] [ A + 1 ] :
trg = A に 1 を加えた値が B より小さくかつ C の D 番目の A に 1 を加えた値番目が E と等しくなくかつ F の D 番目の A に 1 を加えた値 番目でないとき 、
rst = A に 1 を加えた値が B より小さくかつ C の D 番目の A に 1 を加えた値番目が E と等しくなくかつ F の D 番目の A に 1 を加えた値番目 番目でないとき 、 <eos>
2802
src = count = swap_count ( A )
trg = swap _ count ( A ) を無限の整数列 とする
rst = count 6174 ( A ) を無限の整数列 とする <eos>
2803
src = if A [ B ] % C > A [ B + 1 ] % C :
trg = A の B 番目を C で割った余りが A の B に 1 を加えた値番目を C で割った余り より大きいとき 、
rst = A の B 番目を C で割った余りが A の B に 1 を加えた値番目を C で割った余り より大きいとき 、 <eos>
2804
src = A . append ( [ B [ C ] ] )
trg = A の末尾に ( B の C 番目 ) からなる列 を追加する
rst = A の末尾に ( B の C 番目 ) からなる列 を追加する <eos>
2805
src = A = B = C = D = 0
trg = 0 を D を C を B とする とするとするを A とする
rst = 0 を D を C を B とするとするとするとする を A とする <eos>
2806
src = A += B [ C - 26 ]
trg = A を B の C から 26 を引いた値番目だけ 増 加 させ る
rst = A を B の C から 26 を引いた値番目だけ 増 加 させ る <eos>
2807
src = print ( B if A >= 4 else C )
trg = A が 4 以上のとき B 、 そうでなければ C を出力する
rst = A が 4 以上のとき B 、 そうでなければ C を出力する <eos>
2808
src = A = any ( [ len ( B ) > 1 and B [ 0 ] == C for B in re . split ( D , E ) ] )
trg = E を正規表現 D で分割した文字列リスト の各要素を B とし 、 B の長さが 1 より大きくかつ B の先頭が C と等しいかどうかの列が 少 なく と も ひ とつは真かどうかを A とする
rst = D を E で分割した字句列の各要素を B とし 、 B の長さが 1 より大きくかつ B の 0 番目が D と等しいかどうか の列の総和を A とする <eos>
2809
src = A = getSum ( B , C , D * 2 + 2 , E + 1 , F )
trg = getSum ( B , C , D *2+2, E +1, F ) を A とする
rst = getSum ( B , C , D *2+1, E , F + 1,1,0) を A とする <eos>
2810
src = A [ B ] [ C ] . remove ( D )
trg = A の B 番目の C 番目内の D と等しい要素を取り除く
rst = A の B 番目の C 番目内の D と等しい要素を取り除く <eos>
2811
src = A = { i : [ False for B in range ( C ) ] }
trg = ( ( B , 0 から C 未満までの数列の各要素を B とし 、 、 つまり偽の列 )) からなる辞書を A とする
rst = ( ( B , 0 から C 未満までの数列の各要素を B とし 、 、 つまり偽の列 を A とする <eos>
2812
src = if calc ( A ) :
trg = calc ( A ) のとき 、
rst = calc ( A ) のとき 、 <eos>
2813
src = search ( A , B , C , D - 1 , E )
trg = B 、 C 、 D から 1 を引いた値 、 E に お いて正規表現 A が最初にマッチする位置
rst = B 、 C 、 D から 1 を引いた値 、 E に お いて正規表現 A が最初にマッチする位置 <eos>
2814
src = print ( A . dinic ( B , C ) )
trg = A . dinic ( B , C ) を出力する
rst = A . dinic ( B , C ) を出力する <eos>
2815
src = print ( A [ 0 ] . p )
trg = A の先頭の p を出力する
rst = A の先頭の p を出力する <eos>
2816
src = print ( A [ B ] [ 1 : ] )
trg = A の B 番目の先頭を除いた部分列 を出力する
rst = A の B 番目の 1 番目から 、 つまり末尾までの部分列 を出力する <eos>
2817
src = A [ B ] [ C ] [ D ] += E
trg = A の B 番目の C 番目の D 番目を E だけ 増 加 させ る
rst = A の B 番目の C 番目の D 番目を E だけ 増 加 させ る <eos>
2818
src = A [ B ] , e = map ( int , readline ( ) . split ( ) )
trg = readline () を空白で分割した字句列の各要素に 整数を適用した列を展開し 、 それぞれ A の B 番目 、 ネイピア数とする
rst = readline () を空白で分割した字句列 の各要素に整数を適用した列を A の B 番目 、 ネイピア数とする <eos>
2819
src = A = set ( [ B , C , D ] )
trg = ( B 、 C 、 D ) からなる列の集合を A とする
rst = ( B 、 C 、 D ) からなる列の集合を A とする <eos>
2820
src = if A [ B - 1 ] + 1 in A or A [ B - 1 ] == 2019 :
trg = A の B から 1 を引いた値番目に 1 を加えた値が A に含まれまたは A の B から 1 を引いた値番目が 2019 と等しいとき 、
rst = A の B から 1 を引いた値番目に 1 を加えた値が A に含まれまたは A の B から 1 を引いた値番目が 2019 と等しいとき 、 <eos>
2821
src = A . level = [ 0 ] * B
trg = (0) からなる列の B 回分の列を A の level に する
rst = (0) からなる列の B 回分の列を A の level に する <eos>
2822
src = for A in range ( B * B , 10001 , B ) :
trg = B に B を掛けた値から 10001 未満までの B 間隔の数列を順に A として 、 繰り返 す
rst = B に B を掛けた値から 10001 未満までの B 間隔の数列を順に A として 、 繰り返 す <eos>
2823
src = A = A * pi / 180.
trg = A に円周率を掛けた値を 180. で割った値を A とする
rst = A に円周率を掛けた値を 180. で割った値を A とする <eos>
2824
src = if ( A * B + C * D + E ) * ( A * B + C * D + E ) <= F * F * ( A * A + C * C ) :
trg = A に B を掛けた値に C に D を掛けた値を加えた値に E を加えた値に A に B を掛けた値に C に D を掛けた値を加えた値に E を加えた値を掛けた値が F に F を掛けた値に A に A を掛けた値に C に C を掛けた値を加えた値を掛けた値 以下のとき 、
rst = A に B を掛けた値に C に D を掛けた値を加えた値に E を加えた値に A に B * C に D を掛けた値を加えた値に E を加えた値を掛けた値が F に C に A に C を掛けた値に C を掛けた値を加えた値 以下のとき 、 <eos>
2825
src = A |= { [ B + C for B in A ] }
trg = A を ( < __ main __ . Cammaobjectat 0 x 109 e 4 1 c 7 0> ) の集合と の 論理和に する
rst = A を ( < __ main __ . Cammaobjectat 0 x 109 e 4 1 b 2 0> ) の集合と の 論理和に する <eos>
2826
src = A [ B ] . left = int ( C [ 0 ] )
trg = C の先頭の整数値を A の B 番目の left に する
rst = C の先頭の整数値を A の B 番目の left に する <eos>
2827
src = A . elements = [ B for B in range ( C ) ]
trg = 0 から C 未満までの数列の各要素を B とし 、 B の列を A の elements に する
rst = 0 から C 未満までの数列の各要素を B とし 、 B の列を A の elements に する <eos>
2828
src = A , B = divmod ( A , 10000 )
trg = A と 10000 を 割った ときの ( 商を展開し 、 それぞれ A 、 B とする
rst = A と 10000 を 割った ときの ( 商を展開し 、 それぞれ A 、 B とする <eos>
2829
src = for A in [ A ** max ( [ B [ A ] for B in C ] ) for A in D ] :
trg = D の各要素を A とし 、 A の C の各要素を B とし 、 B の A 番目 の列の最大値乗 の列を順に A として 、 繰り返 す
rst = A の各要素を D とし 、 A の各要素を B とし 、 A の B 番目 の列の最大値 を順に A として 、 繰り返 す <eos>
2830
src = if not path [ A ] [ B ] :
trg = os . path の A 番目の B 番目でないとき 、
rst = os . path の A 番目の B 番目でないとき 、 <eos>
2831
src = for A , B in ( D if C % 2 else E ) :
trg = C を 2 で割った余りのとき D 、 そうでなければ E を順に A 、 B として 、 繰り返 す
rst = C を 2 で割った余りのとき D 、 そうでなければ E を順に A 、 B として 、 繰り返 す <eos>
2832
src = A = B [ C - 2 ]
trg = B の C から 2 を引いた値番目を A とする
rst = B の C から 2 を引いた値番目を A とする <eos>
2833
src = if A [ B ] [ C - 3 ] :
trg = A の B 番目の C から 3 を引いた値番目のとき 、
rst = A の B 番目の C から 3 を引いた値番目のとき 、 <eos>
2834
src = A -= B [ C % D ]
trg = A を B の C を D で割った余り番目だけ 減 少 させ る
rst = A を B の C を D で割った余り番目だけ 減 少 させ る <eos>
2835
src = return A . index ( 0 ) + 1
trg = A の 0 と等しい要素の最初の位置に 1 を加えた値を返す
rst = A の 0 と等しい要素の最初の位置に 1 を加えた値を返す <eos>
2836
src = A . prev [ B ] = C
trg = C を A の prev の B 番目に する
rst = C を A の prev の B 番目に する <eos>
2837
src = if ( A * ( 100 + B ) // 100 ) + ( C * ( 100 + B ) // 100 ) == D :
trg = A に 100 に B を加えた値を掛けた値を 100 で割った商に C に 100 に B を加えた値を掛けた値を 100 で割った商を加えた値が D と等しいとき 、
rst = A に 100 に B を加えた値を掛けた値を 100 で割った商に C に 100 を掛けた値を加えた値に B を 100 で割った商を加えた値を D で割った商が D と等しいとき 、 <eos>
2838
src = E = ( F + G ) % H
trg = F に G を加えた値を H で割った余りを E とする
rst = F に G を加えた値を H で割った余りを E とする <eos>
2839
src = A [ B [ 0 ] ] . append ( C [ 0 ] )
trg = A の B の先頭番目の末尾に C の先頭 を追加する
rst = A の B の先頭番目の末尾に C の 0 番目を追加する <eos>
2840
src = A = math . sqrt ( sum ( [ ( B - C ) ** 2 for B in D ] ) / E )
trg = D の各要素を B とし 、 ( B - C ) の 2 乗の列の総和を E で割った値の平方根を A とする
rst = D の各要素を B とし 、 ( B - C ) の 2 乗の列の総和を E で割った値の平方根を A とする <eos>
2841
src = A = [ 1 ] + [ 0 ] * ( B - 1 )
trg = (1) からなる列に (0) からなる列の B から 1 を引いた値回分の列を加えた値 を A とする
rst = (1) からなる列に (0) からなる列の B から 1 を引いた値回分の列を加えた値 を A とする <eos>
2842
src = if F ( A , B , C [ 0 ] ) == D and F ( A , B , C [ 1 ] ) == E :
trg = F ( A , B , C [0]) が D と等しくかつ F ( A , B , C [1]) が E と等しいとき 、
rst = F ( A , B , C [0]) が D と等しくかつ F ( A , B , C [1]- E [1]) と等しいとき 、 <eos>
2843
src = D = B [ C [ - 1 ] ]
trg = B の C の末尾番目を D とする
rst = B の C <unk> D とする <eos>
2844
src = A [ 1 ] = [ 3 , 2 ]
trg = (3、2 ) からなる列を A の 1 番目に する
rst = ( 3 、0、2、3 ) からなる列を A の 1 番目に する <eos>
2845
src = A . append ( [ int ( B ) for B in input ( ) . strip ( ) . split ( ) ] )
trg = A の末尾に 入力された文字列の両端から 空白改行を取り除いた文字列 を空白で分割した字句列の各要素を B とし 、 B の整数値の列 を追加する
rst = A の末尾に 入力された文字列の両端から 空白改行を取り除いた文字列 を空白で分割した字句列の各要素を B とし 、 B の整数値の列 を追加する <eos>
2846
src = A , B = 0 , [ int ( input ( ) ) for C in range ( 5 ) ]
trg = 0、0 から 5 未満までの数列の各要素を C とし 、 、 つまり入力された文字列の整数値 の列を A 、 B とする
rst = 0 から 5 未満までの数列の各要素を C とし 、 、 つまり入力された文字列 の整数値の列を展開し 、 それぞれ A 、 B とする <eos>
2847
src = A . nil . prev = A . nil
trg = A の nil を A の nil の prev に する
rst = A の nil を A の nil に する <eos>
2848
src = if type ( A ) == B :
trg = A の 型 が B と等しいとき 、
rst = A の 型 が B と等しいとき 、 <eos>
2849
src = print ( A + B * ( int ( input ( ) ) // 100 + 3 ) )
trg = A に B に int ( input ()) を 100 で割った商に 3 を加えた値を掛けた値を加えた値 を出力する
rst = A に B に input () を 100 で割った商を加えた値 を加えた値を出力する <eos>
2850
src = A = min ( A , dfs ( B , 1 << B ) )
trg = A 、 dfs ( B ,1<< B ) の最小値を A とする
rst = A 、 dfs ( B , 1 ,1) の最小値を A とする <eos>
2851
src = if A in B . elements :
trg = A が B の elements に含まれるとき 、
rst = A が B の elements に含まれるとき 、 <eos>
2852
src = A [ B ] . append ( C + 100 )
trg = A の B 番目の末尾に C に 100 を加えた値 を追加する
rst = A の B 番目の末尾に C に 100 を加えた値 を追加する <eos>
2853
src = if A . d [ B ] < C :
trg = A の d の B 番目が C より小さいとき 、
rst = A の d の B 番目が C より小さいとき 、 <eos>
2854
src = A = int ( 2 ** ( math . log2 ( B . size + 1 ) + 1 ) ) - 1
trg = 2 の 2 を 底 とする B . size +1 の対数 に 1 を加えた値 乗の整数値から 1 を引いた値を A とする
rst = 2 の 2 を 底 とする B の size に 1 を加えた値 乗から 1 を引いた値 の対数の切り 上 げ 整数値乗 を A とする <eos>
2855
src = A = - 10001
trg = - 10001 を A とする
rst = - 10001 を A とする <eos>
2856
src = A = B [ - 2 ] / sum ( B [ - 2 : ] )
trg = B の -2 番目を B の -2 番目から 、 つまり末尾までの部分列の総和 で割った値を A とする
rst = B の -2 番目を B の -2 番目から 、 つまり末尾までの部分列の総和を A とする <eos>
2857
src = A += C [ B ] if B in C else B
trg = A を B が C に含まれるとき C の B 番目 、 そうでなければ B だけ 増 加 させ る
rst = A を B が C に含まれるとき C の B 番目 、 そうでなければ B だけ 増 加 させ る <eos>
2858
src = if A [ B ] [ C ] == A [ B - 1 ] [ C - 1 ] :
trg = A の B 番目の C 番目が A の B から 1 を引いた値番目の C から 1 を引いた値番目と等しいとき 、
rst = A の B 番目の C 番目が A の B から 1 を引いた値番目の C から 1 を引いた値番目と等しいとき 、 <eos>
2859
src = if A [ B ] [ 0 ] < A [ C ] [ 0 ] :
trg = A の B 番目の 0 番目が A の C 番目の先頭 より小さいとき 、
rst = A の B 番目の 0 番目が A の C 番目の先頭 より小さいとき 、 <eos>
2860
src = A = A . delete ( )
trg = A . delete () を A とする
rst = A . delete () を A とする <eos>
2861
src = A [ B ] . append ( ( C , D , E , e ) )
trg = A の B 番目の末尾に ( C 、 D 、 E 、 ネイピア数 ) の組 を追加する
rst = A の B 番目の末尾に ( C 、 D 、 E 、 ネイピア数 ) の組 を追加する <eos>
2862
src = A = ( ( 1 , 0 ) , ( 0 , 1 ) )
trg = ( (1、0) の組 、(0、1) の組 ) の組を A とする
rst = ( (1、0) の組 、(0、1) の組 ) の組を A とする <eos>
2863
src = A = vector_minus ( B , C )
trg = vector _ minus ( B , C ) を A とする
rst = <unk> ( B , C ) を A とする <eos>
2864
src = A [ B ] = C + e
trg = C にネイピア数を加えた値を A の B 番目に する
rst = C にネイピア数を加えた値を A の B 番目に する <eos>
2865
src = A . spin90 ( )
trg = A . spin 90 ()
rst = A . dice _ s () <eos>
2866
src = return ( A . x * A . x + A . y * A . y ) ** ( 1.0 / 2.0 )
trg = A の x 座標に A の x 座標を掛けた値に A の y 座標に A の y 座標を掛けた値を加えた値 の 1.0 を 2.0 で割った値乗 を返す
rst = A の x 座標に A の x 座標を掛けた値に A の y 座標に 1.0 を掛けた値を 3.0 で割った値 の絶対値を返す <eos>
2867
src = A [ 1 ] [ B ] = - C
trg = - C を A の 1 番目の B 番目に する
rst = - C を A の 1 番目の B 番目に する <eos>
2868
src = A = [ [ inf for B in range ( C ) ] for D in range ( C ) ]
trg = 0 から C 未満までの数列の各要素を D とし 、0 から C 未満までの数列の各要素を B とし 、 、 つまり無限大の列 の列を A とする
rst = 0 から C 未満までの数列の各要素を D とし 、0 から C 未満までの数列の各要素を B とし 、 、 つまり無限大の列 を A とする <eos>
2869
src = A = set ( B [ 1 : ] )
trg = B の先頭を除いた部分列の集合 を A とする
rst = B の 1 番目から 、 つまり末尾までの部分列を A とする <eos>
2870
src = if A [ B - 1 ] [ 1 ] == A [ B ] [ 1 ] and A [ B - 1 ] [ 2 ] == A [ B ] [ 2 ] :
trg = A の B から 1 を引いた値番目の 1 番目が A の B 番目の 1 番目と等しくかつ A の B から 1 を引いた値番目の 2 番目が A の B 番目の 2 番目と等しいとき 、
rst = A の B -1 番目の 1 番目が A の B 番目の 1 番目と等しくかつ A の B -1 番目の 2 番目が A の B から 1 を引いた値番目の 2 番目と等しいとき 、 <eos>
2871
src = A = [ [ [ 0 for B in range ( C ) ] for D in range ( E ) ] for F in range ( G ) ]
trg = 0 から G 未満までの数列の各要素を F とし 、0 から E 未満までの数列の各要素を D とし 、0 から C 未満までの数列の各要素を B とし 、0 の列の列の列 を A とする
rst = 0 から G 未満までの数列の各要素を F とし 、0 から E 未満までの数列の各要素を D とし 、0 から C 未満までの数列の各要素を B とし 、0 の列の列の列 を A とする <eos>
2872
src = A = rotate_dice ( B , C )
trg = rotate _ dice ( B , C ) を A とする
rst = rotate _ dice ( B , C ) を A とする <eos>
2873
src = if A - B <= C :
trg = A から B を引いた値が C 以下のとき 、
rst = A から B を引いた値が C 以下のとき 、 <eos>
2874
src = print ( max ( A [ B ] , C [ B ] ) )
trg = A の B 番目 、 C の B 番目の最大値 を出力する
rst = A の B 番目 、 C の B 番目の最大値 を出力する <eos>
2875
src = A . rotate ( - B )
trg = A の要素を右に - B 個 、 回転する
rst = A の要素を右に - B 個 、 回転する <eos>
2876
src = if A . board is None :
trg = A の board が 、 つまり未定値と等しくないとき 、
rst = A の board が 、 つまり未定値と等しくないとき 、 <eos>
2877
src = if A >= 0 and B >= 0 and A <= 9 and B <= 9 :
trg = A が 0 以上かつ B が 0 以上かつ A が 9 以下かつ B が 9 以下のとき 、
rst = A が 0 以上かつ B が 0 以上かつ A が 9 以下かつ B が 9 以下のとき 、 <eos>
2878
src = A [ B ] = chr ( min ( C ) + ord ( D ) )
trg = 文字 コ ー ド C の最小値に D の順序数を加えた値の文字を A の B 番目に する
rst = 文字 コ ー ド C の正弦に D を加えた値の最小値を A の B 番目に する <eos>
2879
src = for A , B in cwr ( C , 2 ) :
trg = cwr ( C ,2) を順に A 、 B として 、 繰り返 す
rst = <unk> _ point ( C ,2) を順に A 、 B として 、 繰り返 す <eos>
2880
src = if ( A > B [ C ] ) :
trg = A が B の C 番目より大きいとき 、
rst = A が B の C 番目より大きいとき 、 <eos>
2881
src = A , B = C . flow_with_limit ( 0 , D - 1 , E )
trg = C . flow _ with _ limit (0, D -1, E ) を展開し 、 それぞれ A 、 B とする
rst = C . cross _ point (0, D -1, E ) を展開し 、 それぞれ A 、 B とする <eos>
2882
src = if A and B > C [ D ] + 1 <= E :
trg = A かつ B が C の D 番目に 1 を加えた値 より大きいかどうかが E 以下のとき 、
rst = A かつ B が C の D 番目に 1 を加えた値が E 以下のとき 、 <eos>
2883
src = add ( A , B [ 0 ] , B [ 2 ] )
trg = add ( A , B [0], B [2])
rst = add ( A , B [0], B [2]) <eos>
2884
src = if [ A [ B ] , A [ B + 1 ] , A [ B + 2 ] ] == C :
trg = ( A の B 番目 、 A の B に 1 を加えた値番目 、 A の B に 2 を加えた値番目 ) からなる列が C と等しいとき 、
rst = ( A の B 番目 、 A の B に 1 を加えた値番目 、 A の B に 2 を加えた値番目が C と等しいとき 、 <eos>
2885
src = A [ len ( B ) - 1 ] . append ( B )
trg = A の B の長さから 1 を引いた値番目の末尾に B を追加する
rst = A の B の長さから 1 を引いた値番目の末尾に B を追加する <eos>
2886
src = print ( 1 if A . issubset ( B ) else 0 )
trg = A が B の部分集合のとき 1 、 そうでなければ 0 を出力する
rst = A が B の部分集合のとき 1 、 そうでなければ 0 を出力する <eos>
2887
src = A = ( B - 1 , C - 1 , D - 1 , E - 1 )
trg = ( B から 1 を引いた値 、 C から 1 を引いた値 、 D から 1 を引いた値 、 E から 1 を引いた値 ) の組を A とする
rst = ( B から 1 を引いた値 、 C から 1 を引いた値 、 D から 1 を引いた値 、 E から 1 を引いた値 ) の組を A とする <eos>
2888
src = return A * B + C * D + ( A // 10 ) * E + ( C // 20 ) * F
trg = A に B を掛けた値に C に D を掛けた値を加えた値に A を 10 で割った商に E を掛けた値を加えた値に C を 20 で割った商に F を掛けた値を加えた値を返す
rst = A に B を掛けた値に C に D を掛けた値を加えた値に A を 10 で割った商に E を掛けた値を加えた値に C を 20 で割った商に F を掛けた値を加えた値に E を掛けた値を加えた値を A を掛けた値を加えた値を掛けた値 を返す <eos>
2889
src = np = next_perm ( A [ : ] )
trg = next _ perm ( A [:]) を np とする
rst = <unk> ( A [:]) を np とする <eos>
2890
src = A [ B ] = A [ B - 1 ] + A [ B ]
trg = A の B から 1 を引いた値番目に A の B 番目を加えた値を A の B 番目に する
rst = A の B から 1 を引いた値番目に A の B 番目を加えた値を A の B 番目に する <eos>
2891
src = if A % 4 == 0 and ( A % 100 != 0 or A % 400 == 0 ) :
trg = A を 4 で割った余りが 0 と等しくかつ A を 100 で割った余りが 0 と等しくなくまたは A を 400 で割った余りが 0 と等しいとき 、
rst = A を 4 で割った余りが 0 と等しくかつ A を 100 で割った余りが 0 と等しくなくまたは A を 400 で割った余りが 0 と等しいとき 、 <eos>
2892
src = A = complex ( B . imag , - B . real )
trg = B の imag を 実 部 、 - B の real を 虚 部 とし た 複 素数を A とする
rst = B の imag を 実 部 、 - B の real を引いた値を 虚 部 とし た 複 素数を A とする <eos>
2893
src = A [ 0 ] = copy [ 4 ]
trg = copy の 4 番目を A の 0 番目に する
rst = copy の 4 番目を A の 0 番目に する <eos>
2894
src = A . add_edge ( B , C , D , 0 )
trg = A . add _ edge ( B , C , D ,0)
rst = A . add _ edge ( B , C , D ,0) <eos>
2895
src = A [ B ] = A [ 2 * B + 2 ]
trg = A の 2 に B を掛けた値に 2 を加えた値番目を A の B 番目に する
rst = A の 2 に B を掛けた値に 2 を加えた値番目を A の B 番目に する <eos>
2896
src = ( B , C ) = ( 0 , 1 ) if A < e else ( 1 , 0 )
trg = A が 、 つまりネイピア数より小さいとき (0、1) の組を ( B 、 C ) の組 とする 、 そうでなければ (1、0) の組
rst = A が 、 つまりネイピア数 より小さいとき (1、0) の組 、 そうでなければ (0、1) の組 を展開し 、 それぞれ A 、 B 、 C とする <eos>
2897
src = e . cap -= A
trg = ネイピア数の cap を A だけ 減 少 させ る
rst = ネイピア数の cap を A だけ 減 少 させ る <eos>
2898
src = push ( A [ 1 ] , A [ 2 ] )
trg = push ( A [1], A [2])
rst = push ( A [1], A [2]) <eos>
2899
src = judge ( A )
trg = judge ( A )
rst = judge ( A ) <eos>
2900
src = A = B + C + 1
trg = B に C を加えた値に 1 を加えた値を A とする
rst = B に C を加えた値に 1 を加えた値を A とする <eos>
2901
src = A . size = [ 1 ] * B
trg = (1) からなる列の B 回分の列を A の size に する
rst = (1) からなる列の B 回分の列を A の size に する <eos>
2902
src = A [ B ] = A [ C ] + 1
trg = A の C 番目に 1 を加えた値を A の B 番目に する
rst = A の C 番目に 1 を加えた値を A の B 番目に する <eos>
2903
src = if A != - 1 != B != A :
trg = A が -1 と等しくないかどうかが B と等しくないかどうかが A と等しくないとき 、
rst = A が -1 と等しくないかどうかが B と等しくないかどうかが A と等しくないとき 、 <eos>
2904
src = A /= 362880
trg = A を 362880 分の 一 に する
rst = A を _ area () 分の 一 に する <eos>
2905
src = bfs ( A , B , C )
trg = bfs ( A , B , C )
rst = bfs ( A , B , C ) <eos>
2906
src = A = ( B ** 2 + C ** 2 ) ** 0.5 // 2
trg = B の 2 乗に C の 2 乗を加えた値の 0.5 乗を 2 で割った商を A とする
rst = B の 2 乗に C の 2 乗を加えた値の 0.5 乗を 2 で割った商を A とする <eos>
2907
src = A [ B + C ] = D [ C ]
trg = D の C 番目を A の B に C を加えた値番目に する
rst = D の C 番目を A の B に C を加えた値番目に する <eos>
2908
src = for A in [ 0 ] * int ( input ( ) ) :
trg = (0) からなる列の 、 つまり入力された文字列の整数値 回分の列 を順に A として 、 繰り返 す
rst = (0) からなる列の 、 つまり入力された文字列の整数値 未満までの数列を順に A として 、 繰り返 す <eos>
2909
src = if A . index ( B ) + 1 < 2020 and A [ A . index ( B ) + 1 ] == 200 :
trg = A の B と等しい要素の最初の位置に 1 を加えた値が 2020 より小さくかつ A の A の B と等しい要素の最初の位置に 1 を加えた値番目が 200 と等しいとき 、
rst = A の B と等しい要素の最初の位置に 1 を加えた値が A より小さくかつ A の A . index ( B ) に 1 を加えた値番目が C と等しいとき 、 <eos>
2910
src = A += max ( abs ( B - C ) , abs ( D - E ) )
trg = A を B から C を引いた値の絶対値 、 D から E を引いた値の絶対値の最大値 だけ 増 加 させ る
rst = A を B から C を引いた値の絶対値 、 D から E を引いた値の絶対値の最大値 だけ 増 加 させ る <eos>
2911
src = A [ ord ( B ) - C ] = int ( D )
trg = D の整数値を A の B の順序数から C を引いた値番目に する
rst = D の整数値を A の B の順序数から C を引いた値番目に する <eos>
2912
src = A . top = A . west
trg = A の west を A の top に する
rst = A の west を A の top に する <eos>
2913
src = A = float ( B [ 0 ] )
trg = B の先頭の浮動小数点数を A とする
rst = B の先頭 の浮動小数点数を A とする <eos>
2914
src = register ( A , B , C , 2 )
trg = register ( A , B , C ,2)
rst = register ( A , B , C ,2) <eos>
2915
src = A , B , C , D = E , F , E + G , F + H
trg = E 、 F 、 E に G を加えた値 、 F に H を加えた値を A 、 B 、 C 、 D とする
rst = E 、 F 、 E に G を加えた値 、 H に F を加えた値を A 、 B 、 C 、 D とする <eos>
2916
src = else = A - B
trg = A から B を引いた値を そうでなければ 、 とする
rst = A から B を引いた値を そうでなければ 、 とする <eos>
2917
src = if ( lt ( A , B ) and lt ( B , pi ) ) or ( lt ( pi , B ) and lt ( B , A ) ) :
trg = lt ( A , B ) かつ lt ( B , pi ) または lt ( pi , B ) かつ lt ( B , A ) のとき 、
rst = lt ( A , B ) かつ lt ( B , pi または lt ( B , B ) かつ lt ( B , A ) のとき 、 <eos>
2918
src = for A in range ( B , C + 1 , B ) :
trg = B から C に 1 を加えた値未満までの B 間隔の数列を順に A として 、 繰り返 す
rst = B から C に 1 を加えた値未満までの B 間隔の数列を順に A として 、 繰り返 す <eos>
2919
src = A . dfs ( B )
trg = A . dfs ( B )
rst = A . dfs ( B ) <eos>
2920
src = A = [ ( - 1 , 0 ) , ( 0 , - 1 ) , ( 0 , 0 ) , ( 0 , 1 ) , ( 1 , 0 ) ]
trg = ((-1、0) の組 、(0、-1) の組 、(0、0) の組 、(0、1) の組 、(1、0) の組 ) からなる列を A とする
rst = ((-1、0) の組 、(0、-1) の組 、(1、0) の組 、(0、1) の組 、(0、0) の組 ) からなる列を A とする <eos>
2921
src = return max ( _max ( A * 2 + 1 , B , C ) , _max ( A * 2 + 2 , C + 1 , D ) )
trg = _ max ( A *2+1, B , C ) 、 _ max ( A *2+2, C +1, D ) の最大値を返す
rst = <unk> ( A *2+1, B , C ) 、 <unk> ( A * max (2, C ) , D +1) の最大値を返す <eos>
2922
src = A = query ( B , C , 2 * D + 1 , E , ( E + F ) // 2 )
trg = query ( B , C ,2* D +1, E , ( E + F )//2) を A とする
rst = query ( B , C ,2* D <unk> E + F )//2, E ) を A とする <eos>
2923
src = A . to , A . cap , A . rev = B , C , D
trg = B 、 C 、 D を A の to 、 A の cap 、 A の rev とする
rst = B 、 C 、 D を A の to 、 A の cap 、 A の rev とする <eos>
2924
src = A [ B ] [ C ] = ( D , E , F )
trg = ( D 、 E 、 F ) の組を A の B 番目の C 番目に する
rst = ( D 、 E 、 F ) の組を A の B 番目の C 番目に する <eos>
2925
src = print ( pow ( A , B ) )
trg = A の B 乗 を出力する
rst = A の B 乗 を出力する <eos>
2926
src = if A [ 0 ] [ 0 ] == B - C :
trg = A の先頭の 0 番目が B から C を引いた値と等しいとき 、
rst = A の先頭の 0 番目が B から C を引いた値と等しいとき 、 <eos>
2927
src = if A . next is not None :
trg = A の next が 、 つまり未定値と等しいとき 、
rst = A の next が 、 つまり未定値と等しいとき 、 <eos>
2928
src = A [ ( B , C , D ) ] = A [ ( B , C , D ) ] + E
trg = A の ( B 、 C 、 D ) の組番目に E を加えた値を A の ( B 、 C 、 D ) の組番目に する
rst = A の ( B 、 C 、 D ) の組番目に E を加えた値を A の ( B 、 C 、 D ) の組番目に する <eos>
2929
src = A = B * C * sin ( D * pi / 180 ) / 2
trg = B に C を掛けた値に D に pi を掛けた値を 180 で割った値の正弦を掛けた値を 2 で割った値を A とする
rst = B に C を掛けた値に D に円周率を掛けた値を 180 で割った値の正弦を掛けた値を 2 で割った値を A とする <eos>
2930
src = A . append ( ( B [ 0 ] - 1 , B [ 1 ] ) )
trg = A の末尾に ( B の先頭から 1 を引いた値 、 B の 1 番目 ) の組 を追加する
rst = A の末尾に ( B の 0 番目から 1 を引いた値 、 B の 1 番目 ) の組 を追加する <eos>
2931
src = A [ B + 1 ] += C // 2 + 1
trg = A の B に 1 を加えた値番目を C を 2 で割った商に 1 を加えた値だけ 増 加 させ る
rst = A の B に 1 を加えた値番目を C を 2 で割った商に 1 を加えた値だけ 増 加 させ る <eos>
2932
src = A = B [ 1 : B [ 0 ] + 1 ]
trg = B の 1 番目から B の先頭に 1 を加えた値までの部分列を A とする
rst = B の 1 番目から B の 0 番目に 1 を加えた値までの部分列を A とする <eos>
2933
src = A = 2001
trg = 2001 を A とする
rst = 2001 を A とする <eos>
2934
src = print ( A [ 7 ] )
trg = A の 7 番目を出力する
rst = A の 7 番目を出力する <eos>
2935
src = print ( left key = {lk}, , end = '' )
trg = 改行せずに " leftkey = {}, " を出力する
rst = 改行せずに " parentkey = {}, " を出力する <eos>
2936
src = A = [ [ 0 ] * [ B for C in range ( 5 ) ] ]
trg = ( (0) からなる列の 0 から 5 未満までの数列の各要素を C とし 、 B の列回分の列 ) からなる列を A とする
rst = ( (0) からなる列の 0 から 5 未満までの数列の各要素を C とし 、 B の列回分の列 ) からなる列を A とする <eos>
2937
src = A = B / C * ( D + E ) - F
trg = B を C で割った値に D に E を加えた値を掛けた値から F を引いた値を A とする
rst = B を C で割った値に D に E を加えた値を掛けた値から F を引いた値を A とする <eos>
2938
src = A = B + ( C - B ) * math . cos ( math . pi / 3 ) - ( D - E ) * math . sin ( math . pi / 3 )
trg = B に C から B を引いた値に math . pi を 3 で割った値の余弦を掛けた値 を加えた値から D から E を引いた値に円周率を 3 で割った値の正弦 を掛けた値を引いた値を A とする
rst = B に C から B を引いた値に math . pi を 3 で割った値の正弦 を掛けた値を加えた値に E から D <unk> 3 で割った値の余弦を掛けた値 を加えた値を A とする <eos>
2939
src = A = '\n'
trg = 改行文字を A とする
rst = ネイピア数を A とする <eos>
2940
src = A [ : 4 ] = [ B + C , D , 0 , E ]
trg = ( B に C を加えた値 、 D 、0、 E ) からなる列を A の 、 つまり先頭から 4 番目までの部分列に する
rst = ( B に C を加えた値 、 D 、0、 E ) からなる列を A の 、 つまり先頭から 4 番目までの部分列に する <eos>
2941
src = A = B [ C ] - D + E
trg = B の C 番目から D を引いた値に E を加えた値を A とする
rst = B の C 番目から D を引いた値に E を加えた値を A とする <eos>
2942
src = A = B . index ( ' ' )
trg = B の 、 つまり空白文字 と等しい要素の最初の位置を A とする
rst = B の 、 つまり空白文字の出現回数 を A とする <eos>
2943
src = A [ B ] [ C ] [ D + 1 ] += 1
trg = A の B 番目の C 番目の D に 1 を加えた値番目を 1 だけ 増 加 させ る
rst = A の B 番目の C 番目の D に 1 を加えた値番目を 1 だけ 増 加 させ る <eos>
2944
src = A = lambda B : ( ( D ( B [ 2 ] ) - D ( B [ 0 ] ) ) * ( D ( B [ 6 ] ) - D ( B [ 4 ] ) ) + ( D ( B [ 3 ] ) - D ( B [ 1 ] ) ) * ( D ( B [ 7 ] ) - D ( B [ 5 ] ) ) )
trg = l をパラメータとして D ( B [2]) から D ( B [0]) を引いた値に D ( B [6] ) から D ( B [4]) を引いた値を掛けた値に D ( B [3]) から D ( B [1]) を引いた値に D ( B [7]) から D ( B [5]) を引いた値を掛けた値を加えた値 を返す関数を A とする
rst = i ( ( B [4]) から 2 を引いた値に D から B [0] を引いた値を掛けた値から B の 1 番目に D から B [1] を引いた値に e 9 0> ) を掛けた値を加えた値に B の 1 番目から D から 6 を引いた値を掛けた値を引いた値に D の 2 乗 を加えた値を返す関数を A とする <eos>
2945
src = A = ( B [ 0 ] [ 1 ] + B [ 2 ] [ 1 ] ) / 2
trg = B の先頭の 1 番目に B の 2 番目の 1 番目を加えた値を 2 で割った値を A とする
rst = B の先頭の 1 番目に B の 2 番目の 1 番目を加えた値を 2 で割った値を A とする <eos>
2946
src = A [ 2 ] += B
trg = A の 2 番目を B だけ 増 加 させ る
rst = A の 2 番目を B だけ 増 加 させ る <eos>
2947
src = if A [ B + C ] == D :
trg = A の B に C を加えた値番目が D と等しいとき 、
rst = A の B に C を加えた値番目が D と等しいとき 、 <eos>
2948
src = if A [ B ] > 4 :
trg = A の B 番目が 4 より大きいとき 、
rst = A の B 番目が 4 より大きいとき 、 <eos>
2949
src = A = int ( ( B + 5 ) // 5 )
trg = B に 5 を加えた値を 5 で割った商の整数値を A とする
rst = B に 5 を加えた値を 5 で割った商の整数値を A とする <eos>
2950
src = for A in range ( B - C ) :
trg = 0 から B から C を引いた値未満までの数列を順に A として 、 繰り返 す
rst = 0 から B から C を引いた値未満までの数列を順に A として 、 繰り返 す <eos>
2951
src = if e . residual_capacity ( A ) > 0 and B [ C ] > B [ A ] + D :
trg = e . residual _ capacity ( A ) が 0 より大きくかつ B の C 番目が B の A 番目に D を加えた値 より大きいとき 、
rst = e . residual _ capacity ( A ) が 0 より大きくかつ B の C 番目が B の A 番目に D を加えた値 より大きいとき 、 <eos>
2952
src = for A in [ 1 , 2 , 3 , 0 ] :
trg = (1、2、3、0) からなる列 を順に A として 、 繰り返 す
rst = (1、2、3、 0 ) からなる列 を順に A として 、 繰り返 す <eos>
2953
src = A . append ( B [ C + 1 ] % D [ C + 1 ] )
trg = A の末尾に B の C に 1 を加えた値番目を D の C に 1 を加えた値番目 で割った余り を追加する
rst = A の末尾に B の C に 1 を加えた値番目を D の C に 1 を加えた値番目 を追加する <eos>
2954
src = e [ inf [ 0 ] ] . append ( [ inf [ 2 + A * 2 ] , inf [ 2 + A * 2 + 1 ] ] )
trg = ネイピア数の 、 つまり無限大 の先頭番目の末尾に ( 、 つまり無限大の 2 に A に 2 を掛けた値を加えた値番目 、 無限大 の 2 に A *2 を加えた値に 1 を加えた値番目 ) からなる列 を追加する
rst = ネイピア数の 、 つまり先頭から 、 つまり無限大 の 2 に A を掛けた値に 2 を加えた値番目 、 A の 2 に 1 を加えた値番目の最大値を A の 、 つまり無限大 番目に する <eos>
2955
src = A = tuple ( map ( int , input ( ) . split ( ) ) ) + ( 10 ** 18 )
trg = 入力された文字列 を空白で分割した字句列の各要素 に整数を適用した列の組に 10 の 18 乗を加えた値を A とする
rst = 入力された文字列 を空白で分割した字句列の各要素に 整数を適用した列のリストに 10 を加えた値を A とする <eos>
2956
src = while A != None and B == A . right :
trg = A が 、 つまり未定値と等しくなくかつ B が A の right と等しい 間 、 次 を 繰り返 す
rst = A が 、 つまり未定値と等しくなくかつ B が A の right と等しい 間 、 次 を 繰り返 す <eos>
2957
src = for A , B , C in ( [ map ( int , D . readline ( ) . split ( ) ) for E in range ( F ) ] ) :
trg = 0 から F 未満までの数列の各要素を E とし 、 D から読み込んだ一行を 空白で分割した字句列 の各要素に整数を適用した列 の列を順に A 、 B 、 C として 、 繰り返 す
rst = 0 から F 未満までの数列の各要素を E とし 、 D から読み込んだ一行 を空白で分割した字句列の各要素 に整数を適用した列の総和 の列を展開し 、 それぞれ A 、 B 、 C として 、 繰り返 す <eos>
2958
src = A = closest_pair_distance ( B )
trg = closest _ pair _ distance ( B ) を A とする
rst = closest _ pair _ distance ( B ) を A とする <eos>
2959
src = A . mincost = 0
trg = 0 を A の mincost に する
rst = 0 を A の <unk> に する <eos>
2960
src = return A . FLAGS & A . ALL_ON == A . ALL_ON
trg = A の FLAGS と A の ALL _ ON の論理積が A の ALL _ ON と等しいかどうかを返す
rst = A の FLAGS と A の <unk> 番目の論理積が A の ALL _ OFF と等しいかどうかを返す <eos>
2961
src = insort ( A , ( e - 2 * pi , 1 ) )
trg = ( 、 つまりネイピア数から 2 に円周率を掛けた値 を引いた値 、1) の組を A にソート順で 最後 に 挿入する
rst = ( 、 つまりネイピア数 から 2 に円周率を掛けた値 未満までの 1 間隔の数列を順に A にソート順で 最後 に 挿入する <eos>
2962
src = A = [ 0 for B in range ( C ) ]
trg = 0 から C 未満までの数列の各要素を B とし 、0 の列を A とする
rst = 0 から C 未満までの数列の各要素を B とし 、0 の列を A とする <eos>
2963
src = A [ B + 1 ] [ C + 1 ] += 1
trg = A の B に 1 を加えた値番目の C に 1 を加えた値番目を 1 だけ 増 加 させ る
rst = A の B に 1 を加えた値番目の C に 1 を加えた値番目を 1 だけ 増 加 させ る <eos>
2964
src = print ( sum ( [ abs ( A [ B ] - C [ B ] ) for B in range ( D ) ] ) )
trg = 0 から D 未満までの数列の各要素を B とし 、 A [ B ] から C [ B ] を引いた値の絶対値 の列の総和を出力する
rst = 0 から D 未満までの数列の各要素を B とし 、 A [ B ] から C [ B ] を引いた値の絶対値の列の最大値を 出力する <eos>
2965
src = print ( A [ ( B + 6 ) % 7 ] )
trg = A の B に 6 を加えた値を 7 で割った余り番目 を出力する
rst = A の B に 6 を加えた値を 7 で割った余り番目 を出力する <eos>
2966
src = print ( I if A < B or C < D or E < F or G < H else J )
trg = A < B または C < D または E が F より小さくまたは G が H より小さいとき I 、 そうでなければ J を出力する
rst = A が B より小さくまたは C が D より小さくまたは E が F より小さくまたは G が H より小さいとき I 、 そうでなければ J を出力する <eos>
2967
src = A . cdused [ B ] = True
trg = 真を A の cdused の B 番目に する
rst = 真を A の cdused の B 番目に する <eos>
2968
src = A = rot60_on_complex_plane ( B , C )
trg = rot 60 _ on _ complex _ plane ( B , C ) を A とする
rst = <unk> ( B , C ) を A とする <eos>
2969
src = A , B = set ( ) , set ( )
trg = 集合 、 集合を A 、 B とする
rst = 集合 、 集合を A 、 B とする <eos>
2970
src = A = B ** 2 + C ** 2 - 2 * B * C * math . cos ( D )
trg = B の 2 乗に C の 2 乗を加えた値から 2 に B を掛けた値に C を掛けた値に D の余弦を掛けた値を引いた値 を A とする
rst = B の 2 乗に C の 2 乗を加えた値から 2 に B を掛けた値に C を掛けた値に D の余弦を掛けた値 を引いた値の平方根を A とする <eos>
2971
src = if A >= 1 and B <= 8 :
trg = A が 1 以上かつ B が 8 以下のとき 、
rst = A が 1 以上かつ B が 8 以下のとき 、 <eos>
2972
src = if len ( A ) == 0 or len ( B ) == 0 :
trg = A の長さが 0 と等しくまたは B の長さが 0 と等しいとき 、
rst = A の長さが 0 と等しくまたは B の長さが 0 と等しいとき 、 <eos>
2973
src = print ( int ( all ( [ A . data & 1 << B for B in A . masks [ C ] ] ) ) )
trg = A . masks の C 番目の各要素を B とし 、 A . data &1 を B だけ左シフトした値の列 が全てが真かどうか の整数値を出力する
rst = A . masks の C 番目の各要素を B とし 、 A . data &1 を B だけ左シフトした値の列 が 少 なく と も ひ とつは真かどうか の整数値を出力する <eos>
2974
src = print ( A * 1000 )
trg = A に 1000 を掛けた値を出力する
rst = A に 1000 を掛けた値を出力する <eos>
2975
src = A = A - B + ( C - B )
trg = A から B を引いた値に C から B を引いた値を加えた値を A とする
rst = A から B を引いた値に C から B を引いた値を加えた値を A とする <eos>
2976
src = A = [ B [ : - C ] for B in A ]
trg = A の各要素を B とし 、 B の 、 つまり先頭から - C 番目までの部分列 の列を A とする
rst = A の各要素を B とし 、 B の 、 つまり先頭から C 番目までの部分列 の列を A とする <eos>
2977
src = if A . is_same ( B ) :
trg = A . is _ same ( B ) のとき 、
rst = A . is _ same ( B ) のとき 、 <eos>
2978
src = A [ B ] [ 0 ] = A [ B ] [ B ] = 1
trg = 1 を A の B 番目の B 番目とするを A の B 番目の 0 番目に する
rst = 1 を A の B 番目の B 番目とするを A の B 番目の 0 番目に する <eos>
2979
src = A . data = [ 0 ] * B
trg = (0) からなる列の B 回分の列を A の data に する
rst = (0) からなる列の B 回分の列を A の data に する <eos>
2980
src = for A in range ( ord ( B ) , ord ( B ) + 26 ) :
trg = B の順序数から B の順序数に 26 を加えた値未満までの数列を順に A として 、 繰り返 す
rst = B の順序数から ord ( B ) に 26 を加えた値未満までの数列を順に A として 、 繰り返 す <eos>
2981
src = time += int ( input ( ) )
trg = time を入力された文字列の整数値だけ 増 加 させ る
rst = time を入力された文字列の整数値だけ 増 加 させ る <eos>
2982
src = A , str = input ( ) . split ( )
trg = 入力された文字列 を空白で分割した字句列 を展開し 、 それぞれ A 、 整数 とする
rst = 入力された文字列 を空白で分割した字句列 を展開し 、 それぞれ A 、 整数 とする <eos>
2983
src = A = B [ 1 ] - C
trg = B の 1 番目から C を引いた値を A とする
rst = B の 1 番目から C を引いた値を A とする <eos>
2984
src = print ( sum ( A [ B ] ) , end = ' ' )
trg = 空白文字を 代わ りの行末として A の B 番目 の総和を出力する
rst = 空白文字を 代わ りの行末として A の B 番目を出力する <eos>
2985
src = if ( 1 == A [ B [ 0 ] ] ) :
trg = 1 が A の B の先頭 番目と等しいとき 、
rst = 1 が A の B の先頭 番目と等しいとき 、 <eos>
2986
src = + calc ( A - 2 , B , C , D )
trg = calc ( A -2, B , C , D ) に [ MASK ] を加えた値
rst = calc ( A -2, B , C , D ) に [ MASK ] を加えた値 <eos>
2987
src = print ( E if abs ( A * B - C * D ) < 1e-10 else F )
trg = A * B から C * D を引いた値の絶対値が 1 e -10 より小さいとき E 、 そうでなければ F を出力する
rst = A * B - C * D を加えた値の絶対値が 1 e -10 より小さいとき E 、 そうでなければ F を出力する <eos>
2988
src = A , B = ( C , D ) , ( E - C , D )
trg = ( C 、 D ) の組 、 ( E から C を引いた値 、 D ) の組を A 、 B とする
rst = ( C 、 D ) の組 、 ( E から C を引いた値 、 D ) の組を A 、 B とする <eos>
2989
src = A [ - 2 ] = int ( B ) if B else 1
trg = B のとき B の整数値 、 そうでなければ 1 を A の -2 番目に する
rst = B のとき B の整数値を A の -2 番目に する <eos>
2990
src = A = B = C >> 1
trg = C を 1 だけ右シフトした値を B とする を A とする
rst = C を 1 だけ右シフトした値を B とする を A とする <eos>
2991
src = A = { 0 : 0 , 1 : 0 , 2 : 0 , 3 : 0 , 4 : 0 , 5 : 0 }
trg = ( (0, 0)、( 1 , 0)、( 2 , 0)、( 3 , 0)、( 4 , 0)、( 5 , 0 )) からなる辞書を A とする
rst = ( (0, 0)、( B , 0)、( C , 0)、( D , 0)、( E , 0 )) からなる辞書を A とする <eos>
2992
src = A = [ [ ( B - C ) ** 2 for B in range ( D ) ] for C in range ( D ) ]
trg = 0 から D 未満までの数列の各要素を C とし 、0 から D 未満までの数列の各要素を B とし 、 B から C を引いた値の 2 乗 の列の列を A とする
rst = 0 から D 未満までの数列の各要素を C とし 、0 から D 未満までの数列の各要素を B とし 、 B から C を引いた値の 2 乗の列を A とする <eos>
2993
src = A = time [ 0 ]
trg = time の先頭を A とする
rst = time の先頭を A とする <eos>
2994
src = return A . format ( _str ( B ) , C , D , _str ( E ) )
trg = A を書式として _ str ( B ) 、 C 、 D 、 _ str ( E ) で整形した文字列を返す
rst = A を書式として sort _ three _ numbers ( B ) 、 C , D , E ) で整形した文字列を返す <eos>
2995
src = return _heights ( A )
trg = _ heights ( A ) を返す
rst = calc _ overlap ( A ) を返す <eos>
2996
src = A [ 3 ] [ B ] += A [ C ] [ B ]
trg = A の 3 番目の B 番目を A の C 番目の B 番目だけ 増 加 させ る
rst = A の 3 番目の B 番目を A の C 番目の B 番目だけ 増 加 させ る <eos>
2997
src = print ( sum ( A ) - B )
trg = A の総和から B を引いた値 を出力する
rst = A の総和から B を引いた値 を出力する <eos>
2998
src = A = [ '' ] * 100
trg = ( 、 つまり空文字列 ) からなる列の 100 回分の列を A とする
rst = ( 、 つまり空文字列 ) からなる列の 100 回分の列を A とする <eos>
2999
src = if A [ B ] > 0 and A [ C ] > 0 :
trg = A の B 番目が 0 より大きくかつ A の C 番目が 0 より大きいとき 、
rst = A の B 番目が 0 より大きくかつ A の C 番目が 0 より大きいとき 、 <eos>
3000
src = A = list ( map ( lambda B , C : ( B + 1 ) * ( C ^ 1 ) , A , D ) )
trg = A 、 D の各要素に pre 、 cur をパラメータとして B に 1 を加えた値に C と 1 の排他論理和 を掛けた値を 返す関数を適用した列のリストを A とする
rst = A の各要素に x をパラメータとして ( B に 1 を加えた値 、 C に 1 を加えた値 ) の組 を返す関数を適用した列の総和を A とする <eos>
3001
src = print ( len ( list ( set ( A ) ) ) )
trg = A の集合のリストの長さ を出力する
rst = A の集合のリストをソートした列を 出力する <eos>
3002
src = print ( A , B * ( C - 2 ) , A , sep = '' )
trg = 区 切りなしで A 、 B に C から 2 を引いた値を掛けた値 、 A を出力する
rst = 区 切りなしで A 、 B に C から 2 を引いた値 を掛けた値を出力する <eos>
3003
src = if A + B > C or D + B > E or A - B < 0 or D - B < 0 :
trg = A に B を加えた値が C より大きくまたは D に B を加えた値が E より大きくまたは A から B を引いた値が 0 より小さくまたは D から B を引いた値が 0 より小さいとき 、
rst = A に B を加えた値が C より大きくまたは D に B を加えた値が E より大きくまたは A から B を引いた値が 0 より小さくまたは D から B を引いた値が 0 より小さいとき 、 <eos>
3004
src = return A . bits != 0
trg = A の bits が 0 と等しくないかどうかを返す
rst = A の bits が 0 と等しくないかどうかを返す <eos>
3005
src = A , B = C [ D ] . split ( )
trg = C の D 番目を空白で分割した字句列 を展開し 、 それぞれ A 、 B とする
rst = C の D 番目 を空白で分割した字句列 を展開し 、 それぞれ A 、 B とする <eos>
3006
src = while A < B [ C ] :
trg = A が B の C 番目より小さい 間 、 次 を 繰り返 す
rst = A が B の C 乗より小さい 間 、 次 を 繰り返 す <eos>
3007
src = A = B [ 1 ] * 4 + B [ 2 ] * 9 + B [ 3 ] * 4
trg = B の 1 番目に 4 を掛けた値に B の 2 番目に 9 を掛けた値を加えた値に B の 3 番目に 4 を掛けた値を加えた値を A とする
rst = B の 1 番目に 4 を掛けた値に B の 2 番目に 9 を掛けた値を加えた値に B の 3 番目に 4 を掛けた値を加えた値を A とする <eos>
3008
src = A [ 3 ] = int ( input ( ) )
trg = 入力された文字列の整数値を A の 3 番目に する
rst = 入力された文字列の整数値を A の 3 番目に する <eos>
3009
src = A = A [ - B : ]
trg = A の - B 番目から 、 つまり末尾までの部分列を A とする
rst = A の - B 番目から 、 つまり末尾までの部分列を A とする <eos>
3010
src = return C if A == B else D
trg = A が B と等しいとき C 、 そうでなければ D を返す
rst = A が B と等しいとき C 、 そうでなければ D を返す <eos>
3011
src = A . graph = B
trg = B を A の graph に する
rst = B を A の graph に する <eos>
3012
src = if A == B * C :
trg = A が B に C を掛けた値と等しいとき 、
rst = A が B に C を掛けた値と等しいとき 、 <eos>
3013
src = return A . bst . get ( B ) > 0
trg = A の bst に対応する値 、 もし存在しなければ B が 0 より大きいかどうかを返す
rst = A の bst に対応する値 、 もし存在しなければ B が 0 より大きいかどうかを返す <eos>
3014
src = A [ B + 1 ] [ C + D ] += A [ B ] [ C ]
trg = A の B に 1 を加えた値番目の C に D を加えた値番目を A の B 番目の C 番目だけ 増 加 させ る
rst = A の B に 1 を加えた値番目の C に D を加えた値番目を A の B 番目の C 番目だけ 増 加 させ る <eos>
3015
src = print ( reverse_polish_calculator ( A ) )
trg = reverse _ polish _ calculator ( A ) を出力する
rst = <unk> ( A ) を出力する <eos>
3016
src = A = max ( A , B [ ( C + D , E + F ) ] )
trg = A 、 B の ( C に D を加えた値 、 E に F を加えた値 ) の組 番目の最大値を A とする
rst = A 、 B の ( C に D を加えた値 、 E に F を加えた値 ) からなる列の最大値を A とする <eos>
3017
src = heappush ( A , ( - ( B + C ) , D , E + 1 ) )
trg = heappush ( A ,(- ( B + C ) , D , E +1))
rst = heappush ( A ,(- ( B + C ) , D , E +1)) <eos>
3018
src = A . remove ( min ( A ) )
trg = A 内の A の最小値 と等しい要素を取り除く
rst = A 内の A の最小値 と等しい要素を取り除く <eos>
3019
src = A = bisect_right ( B , B [ C ] + D , C , A + 1 ) - 1
trg = ソートされた順序を保ったまま B の C 番目に D を加えた値を C から A に 1 を加えた値までの 範囲 で B に挿入できる位置から 1 を引いた値を A とする
rst = ソートされた順序を保ったまま B の C 番目に D を加えた値を C から A に 1 を加えた値までの 範囲 で B に挿入できる位置から 1 を引いた値を A とする <eos>
3020
src = A = [ ( 0 , 0 ) , ( 1 , 0 ) ]
trg = ((0、0) の組 、(1、0) の組 ) からなる列を A とする
rst = ((0、0) の組 、(1、0) の組 、(0、1) の組 ) からなる列を A とする <eos>
3021
src = if 0 <= A <= 7 and 0 <= B <= 7 and C [ B ] [ A ] == D :
trg = 0 が A 以下かどうかが 7 以下かつ 0 が B 以下かどうかが 7 以下かつ C の B 番目の A 番目が D と等しいとき 、
rst = 0 が A 以下かどうかが 7 以下かつ 0 が B 以下かどうかが 7 以下かつ C の B 番目の A 番目が D と等しいとき 、 <eos>
3022
src = if A [ B ] >= 0 :
trg = A の B 番目が 0 以上のとき 、
rst = A の B 番目が 0 以上のとき 、 <eos>
3023
src = A = MinimumSpanningTree ( B , C )
trg = MinimumSpanningTree ( B , C ) を A とする
rst = <unk> ( B , C ) を A とする <eos>
3024
src = A = max ( B ) - min ( B )
trg = B の最大値から B の最小値を引いた値を A とする
rst = B の最大値から B を引いた値の最大値を A とする <eos>
3025
src = if A <= 0 or B <= 0 or C <= 0 :
trg = A が 0 以下または B が 0 以下または C が 0 以下のとき 、
rst = A が 0 以下または B が 0 以下または C が 0 以下のとき 、 <eos>
3026
src = A = list ( B | C )
trg = B と C の論理和のリストを A とする
rst = B と C の論理和のリストを を連結した文字列を A とする <eos>
3027
src = if A [ B ] == C and A [ B + 1 ] == D and A [ B + 2 ] == E and A [ B + 3 ] == F and A [ B + 4 ] == G :
trg = A [ B ] が C と等しくかつ A [ B +1] が D と等しくかつ A の B +2 番目が E と等しくかつ A の B に 3 を加えた値番目が F と等しくかつ A の B に 4 を加えた値番目が G と等しいとき 、
rst = A [ B ] が C と等しくかつ A [ B +1] が D と等しくかつ A の B +2 番目が E と等しくかつ A の B に 3 を加えた値番目が F と等しくかつ A の B に 4 を加えた値番目が G と等しいとき 、 <eos>
3028
src = A = sieve ( )
trg = sieve () を A とする
rst = sieve () を A とする <eos>
3029
src = print ( A + str ( B ) + C + str ( D [ B ] [ 0 ] ) + E + getDepth ( D [ B ] ) + F + G , end = ' ' )
trg = 空白文字を 代わ りの行末として A + str ( B )+ C + str ( D [ B ][0]) に E を加えた値に getDepth ( D [ B ] ) を加えた値に F を加えた値に G を加えた値を出力する
rst = 空白文字を 代わ りの行末として A に str ( B ) を加えた値に C を加えた値に str ( D [ B ] [ E ] の文字列を加えた値に F を加えた値に D を加えた値を出力する <eos>
3030
src = while A < B :
trg = A が B より小さい 間 、 次 を 繰り返 す
rst = A が B より小さい 間 、 次 を 繰り返 す <eos>
3031
src = A += abs ( B - C ) ** D
trg = A を B から C を引いた値の絶対値の D 乗だけ 増 加 させ る
rst = A を B から C を引いた値の絶対値の D 乗だけ 増 加 させ る <eos>
3032
src = A = min ( [ B [ C * D + E ] for C in range ( F + 1 ) ] )
trg = 0 から F に 1 を加えた値未満までの数列の各要素 を C とし 、 B の C に D を掛けた値に E を加えた値 番目の列の最小値を A とする
rst = 0 から F に 1 を加えた値未満までの数列の各要素 を C とし 、 B の C * D に E を掛けた値に D を加えた値番目に する <eos>
3033
src = for A in range ( B - 1 ) :
trg = 0 から B から 1 を引いた値未満までの数列を順に A として 、 繰り返 す
rst = 0 から B から 1 を引いた値未満までの数列を順に A として 、 繰り返 す <eos>
3034
src = A . heappush ( B , Node ( C . dst , D . dist [ C . dst ] ) )
trg = A . heappush ( B , Node ( C . dst , D . dist [ C . dst ]))
rst = A . heappush ( B , Node ( C . dst , D . dist [ C . dst ])) <eos>
3035
src = return ( A , B , C , D , E , F )
trg = ( A 、 B 、 C 、 D 、 E 、 F ) の組を返す
rst = ( A 、 B 、 C 、 D 、 E 、 F ) の組を返す <eos>
3036
src = A , B = C [ 0 ] - D [ 0 ] , C [ 1 ] - D [ 1 ]
trg = C の 0 番目から D の先頭を引いた値 、 C の 1 番目から D の 1 番目を引いた値を A 、 B とする
rst = C の 0 番目から D の先頭を引いた値 、 C の 1 番目から D の 1 番目を引いた値を A 、 B とする <eos>
3037
src = print ( A . format ( B . real , B . imag , C . real , C . imag ) )
trg = A を書式として B の real 、 B の imag 、 C の real 、 C の imag で整形した文字列を出力する
rst = A を書式として B の real 、 B の imag 、 C の real 、 C の imag で整形した文字列を出力する <eos>
3038
src = A [ B ] [ C + 1 ] = D + E
trg = D に E を加えた値を A の B 番目の C に 1 を加えた値番目に する
rst = D に E を加えた値を A の B 番目の C に 1 を加えた値番目に する <eos>
3039
src = Pre_order ( A )
trg = Pre _ order ( A )
rst = Pre _ order ( A ) <eos>
3040
src = while A + B < 12 :
trg = A に B を加えた値が 12 より小さい 間 、 次 を 繰り返 す
rst = A に B を加えた値が 12 より小さい 間 、 次 を 繰り返 す <eos>
3041
src = A = ( B , C , D , E , F , G , H , I )
trg = ( B 、 C 、 D 、 E 、 F 、 G 、 H 、 I ) の組を A とする
rst = ( B 、 C 、 D 、 E 、 F 、 G 、 H 、 I ) の組を A とする <eos>
3042
src = A , B , C = A + D * E , B + E , C + 1
trg = A に D に E を掛けた値を加えた値 、 B に E を加えた値 、 C に 1 を加えた値を A 、 B 、 C とする
rst = A に D に E を掛けた値を加えた値 、 B に E を加えた値 、 C に 1 を加えた値を A 、 B 、 C とする <eos>
3043
src = print ( A . sum ( B ) - A . sum ( C - 1 ) )
trg = A 、 B の総和から A 、 C から 1 を引いた値 の総和を引いた値 を出力する
rst = A 、 B の総和から A 、 C から 1 を引いた値までの部分列の総和 を引いた値 を出力する <eos>
3044
src = A . insert ( 0 , 0 )
trg = A の 0 に 0 を挿入する
rst = A の 0 に 0 を挿入する <eos>
3045
src = A . graph [ e [ 0 ] ] . append ( ( e [ 1 ] , e [ 2 ] ) )
trg = A の graph の 、 つまりネイピア数の先頭番目 の末尾に ( 、 つまりネイピア数の 1 番目 、 ネイピア数の 2 番目 ) の組 を追加する
rst = A の graph の 、 つまりネイピア数の 1 番目 番目の末尾にネイピア数の先頭 を追加する <eos>
3046
src = A = intersection_of_perpendicular ( B , C , D )
trg = intersection _ of _ perpendicular ( B , C , D ) を A とする
rst = <unk> ( B , C , D ) を A とする <eos>
3047
src = A += count ( B , C )
trg = A を B から 始 まり C 間隔 で 続 く無限の整数列 だけ 増 加 させ る
rst = A を ( B 、 C ) の組 だけ 増 加 させ る <eos>
3048
src = print ( A . format ( B . t , B . b , B . n , B . s , B . e , B . w ) )
trg = A を書式として B の t 、 B の b 、 B の n 、 B の s 、 B の e 、 B の w で整形した文字列を出力する
rst = A を書式として B の t 、 B の s 、 B の e 、 B の w 、 B の w で整形した文字列を出力する <eos>
3049
src = print ( E if abs ( cross ( A - B , C - D ) ) < 1e-10 else F )
trg = cross ( A - B , C - D ) の絶対値が 1 e -10 より小さいとき E 、 そうでなければ F を出力する
rst = cross ( A - B , C - D ) の絶対値が 1 e -10 より小さいとき E 、 そうでなければ F を出力する <eos>
3050
src = if e == 0 or A == B :
trg = ネイピア数が 0 と等しくまたは A が B と等しいとき 、
rst = ネイピア数が 0 と等しくまたは A が B と等しいとき 、 <eos>
3051
src = print ( A [ int ( B [ 1 ] ) : int ( B [ 2 ] ) + 1 ] )
trg = A の B の 1 番目の整数値から B の 2 番目の整数値に 1 を加えた値までの部分列 を出力する
rst = A の B の 1 番目の整数値から B の 2 番目の整数値に 1 を加えた値までの部分列 を出力する <eos>
3052
src = A . south = B
trg = B を A の south に する
rst = B を A の south に する <eos>
3053
src = print ( min ( A * B , D if C >= A else D + ( A - C ) * E ) )
trg = A に B を掛けた値 、 C が A 以上のとき D 、 そうでなければ D に ( A - C ) に E を掛けた値を加えた値の最小値 を出力する
rst = A が B 以上のとき A に B を掛けた値 、 D に C を加えた値 、 そうでなければ A から D を引いた値に E を掛けた値の最小値 を出力する <eos>
3054
src = A = B * 10 ** - 5
trg = B に 10 の -5 乗を掛けた値を A とする
rst = B に 10 の -5 乗を掛けた値を A とする <eos>
3055
src = A -= 6 * B
trg = A を 6 に B を掛けた値だけ 減 少 させ る
rst = A を 6 に B を掛けた値だけ 減 少 させ る <eos>
3056
src = A . append ( [ B , C , 0 ] )
trg = A の末尾に ( B 、 C 、0) からなる列 を追加する
rst = A の末尾に ( B 、 C 、0) からなる列 を追加する <eos>
3057
src = A = B [ C + D : C + D + E ]
trg = B の C に D を加えた値から C に D を加えた値に E を加えた値までの部分列を A とする
rst = B の C に D を加えた値から C に D を加えた値に E を加えた値までの部分列を A とする <eos>
3058
src = A = B * 151
trg = B に 151 を掛けた値を A とする
rst = B に <unk> を掛けた値を A とする <eos>
3059
src = while A . next is not None and A . next . key != B :
trg = A の next が 、 つまり未定値と等しくかつ A の next の key が B と等しくない 間 、 次 を 繰り返 す
rst = A の next が 、 つまり未定値と等しくかつ A の next が B と等しくない 間 、 次 を 繰り返 す <eos>
3060
src = return sum ( A ) == B and C == D
trg = A の総和が B と等しくかつ C が D と等しいかどうかを返す
rst = A の総和が B と等しくかつ C が D と等しいかどうかを返す <eos>
3061
src = A = [ B for B in C if sum ( B ) == D ]
trg = C の各要素を B とし 、 B の総和が D と等しいとき の B の列を A とする
rst = C の各要素を B とし 、 B の総和が D と等しいとき の B の列を A とする <eos>
3062
src = A , B = bfs ( 0 )
trg = bfs (0) を展開し 、 それぞれ A 、 B とする
rst = bfs (0) を展開し 、 それぞれ A 、 B とする <eos>
3063
src = return A . _paths . values ( )
trg = A の _ paths の値の集まり を返す
rst = A ._ post _ walk () を返す <eos>
3064
src = return ( A , B [ C ] [ 2 ] , D )
trg = ( A 、 B の C 番目の 2 番目 、 D ) の組を返す
rst = ( A 、 B の C 番目の 2 番目 、 D ) の組を返す <eos>
3065
src = A [ B ] += math . sin ( C * D ) * math . cos ( C * D )
trg = A の B 番目を C に D を掛けた値の正弦に C に D を掛けた値の余弦を掛けた値 だけ 増 加 させ る
rst = A の B 番目を C に D の正弦を掛けた値に C に D <unk> A の D を掛けた値だけ 増 加 させ る <eos>
3066
src = A [ 3 ] . append ( B )
trg = A の 3 番目の末尾に B を追加する
rst = A の 3 番目の末尾に B を追加する <eos>
3067
src = if ( A [ B ] + C ) in D :
trg = A の B 番目に C を加えた値が D に含まれるとき 、
rst = A の B 番目に C を加えた値が D に含まれるとき 、 <eos>
3068
src = if A [ 0 ] [ 0 ] == B and A [ 1 ] [ 1 ] == B and A [ 2 ] [ 2 ] == B :
trg = A の先頭の 0 番目が B と等しくかつ A の 1 番目の 1 番目が B と等しくかつ A の 2 番目の 2 番目が B と等しいとき 、
rst = A の先頭の 0 番目が B と等しくかつ A の 1 番目の 1 番目が B と等しくかつ A の 2 番目の 2 番目が B と等しいとき 、 <eos>
3069
src = dict = [ None for A in range ( B ) ]
trg = 0 から B 未満までの数列の各要素を A とし 、 、 つまり未定値の列を 辞書 とする
rst = 0 から B 未満までの数列の各要素を A とし 、 、 つまり未定値の列を A とする <eos>
3070
src = calc ( A + 1 , B - C , D - E , F - G )
trg = calc ( A +1, B - C , D - E , F - G )
rst = calc ( A +1, B - C , D - E , F - G ) <eos>
3071
src = A . append ( B % int ( C * ( 100 - D ) / E ) )
trg = A の末尾に B を C に (100- D ) を掛けた値を E で割った値の整数値 で割った余り を追加する
rst = A の末尾に B を C に 100 から D を引いた値を掛けた値を E で割った値の整数値 を追加する <eos>
3072
src = calc_hash ( A , B , C )
trg = calc _ hash ( A , B , C )
rst = calc _ hash ( A , B , C ) <eos>
3073
src = A [ 3 ] += B < 0
trg = A の 3 番目を B が 0 より小さいかどうか だけ 増 加 させ る
rst = A の 3 番目を B が 0 より大きいかどうか だけ 増 加 させ る <eos>
3074
src = if A & B [ C + D ] :
trg = A と B の C に D を加えた値番目 の論理積のとき 、
rst = A と B の C に D を加えた値番目のとき 、 <eos>
3075
src = A = [ B ] + sorted ( A )
trg = ( B ) からなる列に A をソートした列 を加えた値を A とする
rst = ( B ) からなる列に A をソートした列 を加えた値を A とする <eos>
3076
src = A [ B ] [ C ] = A [ B ] [ C ] + 1
trg = A の B 番目の C 番目に 1 を加えた値を A の B 番目の C 番目に する
rst = A の B 番目の C 番目に 1 を加えた値を A の B 番目の C 番目に する <eos>
3077
src = A = sum ( [ 1 for B in C [ 1 : ] if not int ( B ) ] )
trg = C の 1 番目から 、 つまり末尾までの部分列の各要素を B とし 、 B の整数値 でないとき の 1 の列の総和を A とする
rst = C の 1 番目から 、 つまり末尾までの部分列の各要素を B とし 、 B の整数値が B の浮動小数点数 と等しいとき の 1 の列の総和を A とする <eos>
3078
src = print ( pwr ( A , B ) )
trg = pwr ( A , B ) を出力する
rst = pwr ( A , B ) を出力する <eos>
3079
src = if A [ B ] != C [ A [ B ] ] :
trg = A の B 番目が C の A の B 番目 番目と等しくないとき 、
rst = A の B 番目が C の A の B 番目と等しくないとき 、 <eos>
3080
src = A = min ( dfs ( B + 1 , C ) - D [ C ] [ B ] , dfs ( B , C + 1 ) + E [ C ] [ B ] )
trg = dfs ( B +1, C ) から D の C 番目の B 番目を引いた値 、 dfs ( B , C +1) に E の C 番目の B 番目を加えた値の最小値を A とする
rst = dfs ( B +1, C ) から D の C 番目の B 番目を引いた値 、 dfs ( B , C +1) に E の C 番目の B 番目を加えた値の最小値を A とする <eos>
3081
src = for A in range ( 27 ) :
trg = 0 から 27 未満までの数列を順に A として 、 繰り返 す
rst = 0 から 27 未満までの数列を順に A として 、 繰り返 す <eos>
3082
src = A = list ( B . items ( ) )
trg = B のキーと値の集まりのリストを A とする
rst = B のキーと値の集まり のリストを A とする <eos>
3083
src = A += ( B - 100 ) // 100
trg = A を B から 100 を引いた値を 100 で割った商だけ 増 加 させ る
rst = A を B から 100 を引いた値を 100 で割った商だけ 増 加 させ る <eos>
3084
src = return fibo ( A - 1 ) + fibo ( A - 2 )
trg = fibo ( A -1) に fibo ( A -2) を加えた値を返す
rst = has _ one _ child ( A -1) に A の末尾を除いた部分列を加えた値を 返す <eos>
3085
src = A . append ( deque ( ) )
trg = A の末尾に [ MASK ] の両端キューを 追加する
rst = A の末尾に [ MASK ] を追加する <eos>
3086
src = if A + B < C [ D + 2 ] :
trg = A に B を加えた値が C の D に 2 を加えた値 番目より小さいとき 、
rst = A に B を加えた値が C の D に 2 を加えた値 番目より小さいとき 、 <eos>
3087
src = return A . _edges [ B ]
trg = A の _ edges の B 番目を返す
rst = A の _ edges の B 番目を返す <eos>
3088
src = heappush ( A , ( B , 0 , C ) )
trg = heappush ( A , ( B ,0, C ))
rst = heappush ( A , ( B ,0, C )) <eos>
3089
src = if A == B or A == C or A == D :
trg = A が B と等しくまたは A が C と等しくまたは A が D と等しいとき 、
rst = A が B と等しくまたは A が C と等しくまたは A が D と等しいとき 、 <eos>
3090
src = A = [ dict ( ) for B in range ( C + 1 ) ]
trg = 0 から C に 1 を加えた値未満までの数列の各要素 を B とし 、 、 つまり辞書の列 を A とする
rst = 0 から C に 1 を加えた値未満までの数列の各要素 を B とし 、 、 <unk> A とする <eos>
3091
src = print ( A . count ( B - 3 ) )
trg = A 内の B から 3 を引いた値 の出現回数 を出力する
rst = A 内の B から 3 を引いた値から B から 3 を引いた値 を探して見つかった位置を出力する <eos>
3092
src = A = [ 0 , B ]
trg = (0、 B ) からなる列を A とする
rst = (0、 B ) からなる列を A とする <eos>
3093
src = if A <= 60 and B <= 2 :
trg = A が 60 以下かつ B が 2 以下のとき 、
rst = A が 60 以下かつ B が 2 以下のとき 、 <eos>
3094
src = A [ ( B + C , D + E ) ] = ( F , ( G + 2 ) % 4 , H [ D + E ] [ B + C ] )
trg = ( F 、 G に 2 を加えた値を 4 で割った余り 、 H の D に E を加えた値番目の B に C を加えた値番目 ) の組を A の ( B に C を加えた値 、 D に E を加えた値 ) の組番目に する
rst = ( F に G を加えた値 、 H に 2 を加えた値を D で割った余り番目 、 E の D 番目に E の D 番目を加えた値 ) の組を A の ( B に C を加えた値 、 D に E を加えた値 ) の組番目に する <eos>
3095
src = A . M = A . _make_matrix ( B , C )
trg = A ._ make _ matrix ( B , C ) を A の M に する
rst = A ._ make _ matrix ( B , C ) を A の M に する <eos>
3096
src = if A + 2 <= B [ C ] :
trg = A に 2 を加えた値が B の C 番目以下のとき 、
rst = A に 2 を加えた値が B の C 番目以下のとき 、 <eos>
3097
src = A = ( B * e - C * D ) / ( E * e - D * F )
trg = B にネイピア数を掛けた値から C に D を掛けた値を引いた値を E にネイピア数を掛けた値から D に F を掛けた値を引いた値で割った値 を A とする
rst = B にネイピア数を掛けた値から C に D を掛けた値を引いた値を E にネイピア数を掛けた値から D に F を掛けた値を引いた値を掛けた値を A とする <eos>
3098
src = A . primes = [ ]
trg = 空列を A の primes に する
rst = 空列を A の primes に する <eos>
3099
src = A += int ( B . readline ( ) )
trg = A を B から読み込んだ一行の整数値 だけ 増 加 させ る
rst = A を B から読み込んだ一行の整数値 だけ 増 加 させ る <eos>
3100
src = A = min ( A , minimum_cost ( B + 1 , C , update_state ( D , B + 1 ) , min ( E + F - 1 , G ) , H , I , J , G ) + K )
trg = A 、 minimum _ cost ( B +1, C , update _ state ( D , B +1) , min ( E + F -1, G ) , H , I , J , G ) に K を加えた値の最小値を A とする
rst = A 、 minimum _ cost ( B +1, C , tuple ( D , B +1) , E , F , G , H , I ) に J を加えた値の最小値を A とする <eos>
3101
src = A = A [ B : B + C ] + A [ : B ] + A [ B + C : ]
trg = A の B 番目から B に C を加えた値までの部分列に A の 、 つまり先頭から B 番目までの部分列を加えた値に A の B に C を加えた値から 、 つまり末尾までの部分列を加えた値 を A とする
rst = A の B 番目から B に C を加えた値までの部分列に A の 、 つまり先頭から B 番目までの部分列に A の B 番目から C 番目までの部分列を加えた値に A の B 番目から B に C を加えた値までの部分列 を加えた値を A とする <eos>
3102
src = if A < B [ C ] [ 1 ] - B [ D ] [ 1 ] :
trg = A が B の C 番目の 1 番目から B の D 番目の 1 番目を引いた値 より小さいとき 、
rst = A が B の C 番目の 1 番目から B の D 番目の 1 番目を引いた値 より小さいとき 、 <eos>
3103
src = while len ( A ) != 0 :
trg = A の長さが 0 と等しくない 間 、 次 を 繰り返 す
rst = A の長さが 0 と等しくない 間 、 次 を 繰り返 す <eos>
3104
src = A = B [ : C + 1 ]
trg = B の 、 つまり先頭から C に 1 を加えた値までの部分列を A とする
rst = B の 、 つまり先頭から C に 1 を加えた値までの部分列を A とする <eos>
3105
src = A = 100000000000001
trg = 100000000000001 を A とする
rst = <unk> を A とする <eos>
3106
src = A . append ( list ( map ( int , input ( ) . split ( ) ) ) )
trg = A の末尾に入力された文字列 を空白で分割した字句列の各要素に 整数を適用した列のリスト を追加する
rst = A の末尾に input () を空白で分割した字句列の各要素 に整数を適用した列のリストの総和 を追加する <eos>
3107
src = A = [ sum ( B [ C ] ) for C in range ( D ) ]
trg = 0 から D 未満までの数列の各要素を C とし 、 B の C 番目の総和 の列を A とする
rst = 0 から D 未満までの数列の各要素を C とし 、 B の C 番目の列の総和を A とする <eos>
3108
src = if A [ B ] [ C ] < 4 :
trg = A の B 番目の C 番目が 4 より小さいとき 、
rst = A の B 番目の C 番目が 4 より小さいとき 、 <eos>
3109
src = A = MST ( B )
trg = MST ( B ) を A とする
rst = <unk> ( B ) を A とする <eos>
3110
src = A = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) [ : : - 1 ]
trg = input () を空白で分割した字句列の各要素に 整数を適用した列のリストを ソートした列の逆順を A とする
rst = input () を空白で分割した字句列 の各要素に整数を適用した列 <unk> A とする <eos>
3111
src = A += sum ( [ B [ C ] * pow ( C , D - 2 , D ) for C in range ( 2 , E + 1 ) if E % C == 0 ] )
trg = A を 2 から E に 1 を加えた値未満までの数列の各要素 を C とし 、 E を C で割った余りが 0 と等しいとき の B の C 番目に C の D から 2 を引いた値乗に対する D の 剰 余 を掛けた値の列の総和 だけ 増 加 させ る
rst = A を 0 から E 未満までの数列の各要素を C とし 、 C 番目に D . <unk> ( C ) が E と等しいとき の B の C 番目に D の C を加えた値 、 そうでなければ 0 番目の列の総和を E で割った余りだけ 増 加 させ る <eos>
3112
src = A [ B ] = time - C
trg = time から C を引いた値を A の B 番目に する
rst = time から C を引いた値を A の B 番目に する <eos>
3113
src = A [ B ] [ C - D ] = copy [ B ] [ C ]
trg = copy の B 番目の C 番目を A の B 番目の C から D を引いた値番目に する
rst = copy の B 番目の C 番目を A の B 番目の C から D を引いた値番目に する <eos>
3114
src = A . answers . append ( B )
trg = A の answers の末尾に B を追加する
rst = A の answers の末尾に B を追加する <eos>
3115
src = A = list ( map ( B . find , readline ( ) . strip ( ) ) )
trg = readline () の両端から 空白改行を取り除いた文字列 の各要素に B の先頭から [ MASK ] を探して見つかった位置 を適用した列のリストを A とする
rst = readline () の両端から 空白改行を取り除いた文字列 の各要素に B を適用した列を連結した文字列 を A とする <eos>
3116
src = A = B . count ( C )
trg = B 内の C の出現回数を A とする
rst = B 内の C の出現回数を A とする <eos>
3117
src = if A <= abs ( B [ C ] - D [ C ] ) :
trg = A が B の C 番目から D の C 番目を引いた値の絶対値 以下のとき 、
rst = A が B の C 番目から D の C 番目を引いた値の絶対値 以下のとき 、 <eos>
3118
src = return [ list ( A ) for A in zip ( * reversed ( B ) ) ]
trg = B を反転した列を展開して の要素をそれぞれ組にした列 の各要素を A とし 、 A のリストの列を 返す
rst = B を展開しての 要素をそれぞれ組にした列の各要素 を A とし 、 A の総和の列 を返す <eos>
3119
src = A += B [ C ] + D - 2 * B [ E [ root ( C ) ] ]
trg = A を B の C 番目に D を加えた値から 2 に B の E の root ( C ) 番目 番目を掛けた値を引いた値 だけ 増 加 させ る
rst = A を B の C 番目に D を加えた値から 2 に B の E 番目を掛けた値だけ 増 加 させ る <eos>
3120
src = A = B [ C - 1 : D ]
trg = B の C から 1 を引いた値から D 番目までの部分列を A とする
rst = B の C から 1 を引いた値から D 番目までの部分列を A とする <eos>
3121
src = A , B = C . readline ( ) . strip ( ) . split ( )
trg = C から読み込んだ一行 の両端から 空白改行を取り除いた文字列 を空白で分割した字句列 を展開し 、 それぞれ A 、 B とする
rst = C から読み込んだ一行 の両端から 空白改行を取り除いた文字列 を展開し 、 それぞれ A 、 B とする <eos>
3122
src = A = [ - 1 for B in range ( C ) ]
trg = 0 から C 未満までの数列の各要素を B とし 、 -1 の列を A とする
rst = 0 から C 未満までの数列の各要素を B とし 、 -1 の列を A とする <eos>
3123
src = if A > 30 and B > 4 :
trg = A が 30 より大きくかつ B が 4 より大きいとき 、
rst = A が 30 より大きくかつ B が 4 より大きいとき 、 <eos>
3124
src = A -= 2 ** 32
trg = A を 2 の 32 乗だけ 減 少 させ る
rst = A を 2 の 32 乗だけ 減 少 させ る <eos>
3125
src = sys . stdout . write ( ' ' . join ( [ A [ 0 ] for A in reversed ( B ) if A [ 1 ] ] ) )
trg = sys の stdout に空白文字を間に入れて B を反転した列の各要素 を A とし 、 A の 1 番目のときの A の 0 番目の列を連結した文字列 を書き込む
rst = sys の stdout に A を英小文字に変換した文字列 の各要素を A とし 、 B の A 番目のときの A の文字列の列を連結した文字列 を書き込む <eos>
3126
src = write ( A % ( min ( B ) , max ( B ) ) )
trg = write ( A %( min ( B ) , max ( B )))
rst = write ( A %( min ( B ))) <eos>
3127
src = A [ B ] . c = [ C , D ]
trg = ( C 、 D ) からなる列を A の B 番目の c に する
rst = ( C 、 D ) からなる列を A の B 番目の c に する <eos>
3128
src = A = Cp ( B , C , D )
trg = Cp ( B , C , D ) を A とする
rst = <unk> ( B , C , D ) を A とする <eos>
3129
src = A = [ 2 + B , 1 , None ]
trg = ( 2 に B を加えた値 、 1 、 未定値 ) からなる列を A とする
rst = ( 2 に B を加えた値 、 1 、 未定値 ) からなる列を A とする <eos>
3130
src = A . append ( ( B , int ( C ) ) )
trg = A の末尾に ( B 、 C の整数値 ) の組 を追加する
rst = A の末尾に ( B 、 C の整数値 ) の組 を追加する <eos>
3131
src = A . append ( [ B ] )
trg = A の末尾に ( B ) からなる列 を追加する
rst = A の末尾に ( B ) からなる列 を追加する <eos>
3132
src = A . steps = 0
trg = 0 を A の steps に する
rst = 0 を A の steps に する <eos>
3133
src = A = A + B + [ ' ' ]
trg = A に B を加えた値に ( 、 つまり空白文字 ) からなる列を加えた値を A とする
rst = A に B を加えた値に ( 、 つまり空白文字 ) からなる列を加えた値を A とする <eos>
3134
src = treewalk_inorder ( A [ B ] [ C ] )
trg = treewalk _ inorder ( A [ B ] [ C ] )
rst = treewalk _ inorder ( A [ B ] [ C ] ) <eos>
3135
src = A [ B ] [ C ] = min ( A [ B - 1 ] [ C - 1 ] , A [ B - 1 ] [ C ] , A [ B ] [ C - 1 ] )
trg = A の B から 1 を引いた値番目の C から 1 を引いた値番目 、 A の B から 1 を引いた値番目の C 番目 、 A の B 番目の C から 1 を引いた値番目の最小値を A の B 番目の C 番目に する
rst = A の B から 1 を引いた値番目の C から 1 を引いた値番目 、 A の B から 1 を引いた値番目の C 番目 、 A の B から 1 を引いた値番目の C から 1 を引いた値番目の最小値を A の B 番目の C 番目に する <eos>
3136
src = A , B , C = map ( lambda D : float ( D ) , input ( ) . split ( ) )
trg = 入力された文字列 を空白で分割した字句列の各要素に x をパラメータとして x の浮動小数点数を 返す関数を適用した列を展開し 、 それぞれ A 、 B 、 C とする
rst = 入力された文字列 を空白で分割した字句列の各要素に x をパラメータとして x の浮動小数点数を 返す関数を適用した列を展開し 、 それぞれ A 、 B 、 C とする <eos>
3137
src = A = B . real * C . imag - B . imag * C . real + D . real * E . imag - D . imag * E . real
trg = B の real に C の imag を掛けた値から B の imag に C の real を掛けた値を引いた値に D の real に E の imag を掛けた値を加えた値から D の imag に E の real を掛けた値を引いた値を A とする
rst = B の real に C の imag を掛けた値から B の imag に C の real を掛けた値に D に E の imag を掛けた値を加えた値に D の imag を加えた値を A とする <eos>
3138
src = A = [ Point ( B , C ) for B , C in sorted ( [ ( D . x , D . y ) for D in A ] ) ]
trg = A の各要素を D とし 、 ( D の x 座標 、 D の y 座標 ) の組 の列をソートした列の各要素を B 、 C とし 、 Point ( B , C ) の列を A とする
rst = A の各要素を D とし 、 ( Point ( B , C ) 、 D . x ) 、 y をパラメータとして math . index ( D . x ) の列を A とする <eos>
3139
src = A , B = C [ 10 ] , C [ 11 ]
trg = C の 10 番目 、 C の 1 1 番目を A 、 B とする
rst = C の 10 番目 、 C の 1 1 1 番目を A 、 B とする <eos>
3140
src = A . E [ B ] . append ( Edge ( C , D ) )
trg = A の E の B 番目の末尾に Edge ( C , D ) を追加する
rst = A の E の B 番目の末尾に Edge ( C , D ) を追加する <eos>
3141
src = A += B . area ( )
trg = A を B . area () だけ 増 加 させ る
rst = A を B . area () だけ 増 加 させ る <eos>
3142
src = A , B = C + D [ E << 1 ] , F + D [ ( E << 1 ) + 1 ]
trg = C に D の E を 1 だけ左シフトした値 番目を加えた値 、 F に D の E を 1 だけ左シフトした値に 1 を加えた値番目を加えた値を A 、 B とする
rst = C に D の E を 1 <unk> 、 F に 1 を加えた値番目を A 、 B とする <eos>
3143
src = for A in range ( 3 , int ( math . sqrt ( B ) ) + 1 , 2 ) :
trg = 3 から B の平方根の整数値に 1 を加えた値未満までの 2 間隔の数列を順に A として 、 繰り返 す
rst = 3 から B の平方根の整数値に 1 を加えた値未満までの数列を順に A として 、 繰り返 す <eos>
3144
src = if ( A <= 50 and B [ A ] == 0 ) or B [ A ] > C :
trg = A が 50 以下かつ B の A 番目が 0 と等しくまたは B の A 番目が C より大きいとき 、
rst = A が 50 以下かつ B の A 番目が 0 と等しくまたは B の A 番目が C より大きいとき 、 <eos>
3145
src = A = sum ( [ B for C , B in D ] )
trg = D の各要素を C 、 B とし 、 B の列の総和を A とする
rst = D の各要素を C 、 B とし 、 B の列の総和を A とする <eos>
3146
src = if A < B and - B < C and D * ( C - A ) - A * ( E - D ) > - B :
trg = A が B より小さくかつ - B が C より小さくかつ D に C から A を引いた値を掛けた値から A に E から D を引いた値を掛けた値を引いた値 が - B より大きいとき 、
rst = A が B より小さくかつ - B が C より小さくかつ D に C から A を引いた値を掛けた値が E から D を引いた値に B を掛けた値 より大きいとき 、 <eos>
3147
src = if math . pow ( A [ 0 ] , 2 ) + math . pow ( A [ 1 ] , 2 ) == math . pow ( A [ 2 ] , 2 ) :
trg = math . pow ( A [0], 2 ) に math . pow ( A [1], 2 ) を加えた値が math . pow ( A [2], 2 ) と等しいとき 、
rst = A の 0 番目を引いた値の 2 乗に A の 1 番目の 2 乗を加えた値が A の 1 番目の 2 乗と等しいとき 、 <eos>
3148
src = count = { char : [ { "left" : 0 , "right" : 0 } for A in [ D , E , F , G ] ] }
trg = ( ( A , ( D 、 E 、 F 、 G ) からなる列の各要素を A とし 、(( B , 0)、( C , 0 )) からなる辞書の列 )) からなる辞書を 無限の整数列 とする
rst = ( ( B , ( C , D , E , F の各要素を A 、 D 、 e とし 、 <unk> )) からなる辞書を 無限の整数列 とする <eos>
3149
src = count [ A ] = max ( 0 , B - C )
trg = 0 、 B から C を引いた値の最大値を 無限の整数列の A 番目に する
rst = 0 、 B から C を引いた値の最大値を A の 、 つまりネイピア数番目に する <eos>
3150
src = A . walk_inorder ( B . left )
trg = A . walk _ inorder ( B . left )
rst = A . walk _ inorder ( B . left ) <eos>
3151
src = if A > 30 :
trg = A が 30 より大きいとき 、
rst = A が 30 より大きいとき 、 <eos>
3152
src = A = [ ( B , C ) , ( B + D , C + E ) , ( B + D + F , C + E + G ) , ( B + G , C + G ) ]
trg = ( ( B 、 C ) の組 、 ( B に D を加えた値 、 C に E を加えた値 ) の組 、 ( B に D を加えた値に F を加えた値 、 C に E を加えた値に G を加えた値 ) の組 、 ( B に G を加えた値 、 C に G を加えた値 ) の組 ) からなる列を A とする
rst = ( ( B 、 C ) の組 、 ( B に D を加えた値 、 C に E を加えた値 ) の組 、 ( B に D を加えた値に F を加えた値 、 C に E を加えた値に G を加えた値 ) の組 、 ( B に G を加えた値 ) からなる列を A とする <eos>
3153
src = C = B [ 3 : ]
trg = B の 3 番目から 、 つまり末尾までの部分列を C とする
rst = B の 3 番目から 、 つまり末尾までの部分列を C とする <eos>
3154
src = print ( time )
trg = time を出力する
rst = time を出力する <eos>
3155
src = A [ 0 ] [ 0 ] = 1
trg = 1 を A の先頭の先頭に する
rst = 1 を A の先頭の 0 番目に する <eos>
3156
src = A [ B ] = C [ : D ] [ : : - 1 ]
trg = C の 、 つまり先頭から D 番目までの部分列の逆順を A の B 番目に する
rst = C の 、 つまり先頭から D 番目までの部分列の逆順を A の B 番目に する <eos>
3157
src = A = calc_max_profit ( B )
trg = calc _ max _ profit ( B ) を A とする
rst = <unk> ( B ) を A とする <eos>
3158
src = A = B / 16
trg = B を 16 で割った値を A とする
rst = B を 16 で割った値を A とする <eos>
3159
src = A = 1.
trg = 1 . を A とする
rst = 1 . を A とする <eos>
3160
src = del A [ B [ 0 ] ]
trg = A の B の先頭番目を 削 除 する
rst = A の B の先頭の先頭番目を 削 除 する <eos>
3161
src = A . append ( rotate ( B , C ) )
trg = A の末尾に rotate ( B , C ) を追加する
rst = A の末尾に rotate ( B , C ) を追加する <eos>
3162
src = pi = partition ( A , 0 , len ( A ) - 1 )
trg = partition ( A ,0, len ( A )-1) を円周率 とする
rst = partition ( A ,0, len ( A )-1) を円周率 とする <eos>
3163
src = B = 13
trg = 13 を B とする
rst = 13 を B とする <eos>
3164
src = A = min ( A , B [ - 1 ] [ C ] + D )
trg = A 、 B の末尾の C 番目に D を加えた値の最小値を A とする
rst = A 、 B の末尾の C 番目に D を加えた値の最小値を A とする <eos>
3165
src = A . append ( ( 1 , 0 , 0 ) )
trg = A の末尾に (1、0、0) の組 を追加する
rst = A の末尾に (1、0) の組 を追加する <eos>
3166
src = A , B , C = shellSort ( D )
trg = shellSort ( D ) を展開し 、 それぞれ A 、 B 、 C とする
rst = shellSort ( D ) を展開し 、 それぞれ A 、 B 、 C とする <eos>
3167
src = A , B , C = D . graph [ D . pos [ E ] [ 0 ] ] [ D . pos [ E ] [ 1 ] ]
trg = D の graph の D の pos の E 番目の先頭番目の D の pos の E 番目の 1 番目番目を展開し 、 それぞれ A 、 B 、 C とする
rst = D の graph の D の pos の E 番目の先頭番目の D の pos の E 番目の 1 番目番目を展開し 、 それぞれ A 、 B 、 C とする <eos>
3168
src = return path
trg = os . path を返す
rst = os . path を返す <eos>
3169
src = A = 1 << ( ( B + C ) * D + E + F )
trg = 1 を B に C を加えた値に D を掛けた値に E を加えた値に F を加えた値 だけ左シフトした値を A とする
rst = 1 を B に C を加えた値に D を掛けた値に E を加えた値に F を加えた値を掛けた値を A とする <eos>
3170
src = A = lambda B , C : B * C
trg = x 、 y をパラメータとして x に y を掛けた値 を返す関数を A とする
rst = x 、 x をパラメータとして x に x を掛けた値を 返す関数を適用した列のリストを A とする <eos>
3171
src = if A == 2001 :
trg = A が 2001 と等しいとき 、
rst = A が 2001 と等しいとき 、 <eos>
3172
src = print ( A [ - B ] )
trg = A の - B 番目を出力する
rst = A の - B 番目を出力する <eos>
3173
src = A . append ( C )
trg = A の末尾に C を追加する
rst = A の末尾に C を追加する <eos>
3174
src = A = [ 0 , 6000 , 4000 , 3000 , 2000 ]
trg = (0、 6000 、4000、3000、2000) からなる列を A とする
rst = (0、 6000 、4000、3000、2000) からなる列を A とする <eos>
3175
src = while A >= B [ C ] :
trg = A が B の C 番目以上の 間 、 次 を 繰り返 す
rst = A が B の C 番目以上の 間 、 次 を 繰り返 す <eos>
3176
src = if A + B <= C and D [ A + B ] [ E ] < F + G :
trg = A に B を加えた値が C 以下かつ D の A に B を加えた値番目の E 番目が F に G を加えた値より小さいとき 、
rst = A に B を加えた値が C 以下かつ D の A に B を加えた値番目の E 番目を加えた値が F に G を加えた値より小さいとき 、 <eos>
3177
src = if A [ : B - C ] != D [ C : B ] :
trg = A の 、 つまり先頭から B から C を引いた値までの部分列が D の C 番目から B 番目までの部分列 と等しくないとき 、
rst = A の 、 つまり先頭から B から C を引いた値番目を引いた値が D の C 番目から B 番目までの部分列 と等しくないとき 、 <eos>
3178
src = A = solve ( B + 1 , C - D [ B ] )
trg = solve ( B +1, C - D [ B ] ) を A とする
rst = solve ( B +1, C - D [ B ] ) を A とする <eos>
3179
src = A = [ B [ 0 ] + C [ D ] [ 0 ] ]
trg = ( B の 0 番目に C の D 番目の先頭を加えた値 ) からなる列を A とする
rst = ( B の 0 番目に C の D 番目の先頭を加えた値を A とする <eos>
3180
src = A . flow -= B
trg = A の flow を B だけ 減 少 させ る
rst = A の flow を B だけ 減 少 させ る <eos>
3181
src = if A [ B [ 0 ] ] [ B [ 1 ] ] [ 1 ] == 0 :
trg = A の B の先頭番目の B の 1 番目番目の 1 番目が 0 と等しいとき 、
rst = A の B の先頭番目の B の 1 番目番目の 1 番目が 0 と等しいとき 、 <eos>
3182
src = True
trg = 真
rst = 真 <eos>
3183
src = if max ( A ) < 0 :
trg = A の最大値が 0 より小さいとき 、
rst = A の最大値が 0 より小さいとき 、 <eos>
3184
src = A = set ( map ( B , C ) )
trg = C の各要素に B を適用した列の集合 を A とする
rst = C の各要素に B を適用した列の総和を A とする <eos>
3185
src = A . pop ( )
trg = A の先頭を取り出した値
rst = A の先頭を取り出した値 <eos>
3186
src = for A in range ( B - 1 , B + 3 ) :
trg = B から 1 を引いた値から B に 3 を加えた値未満までの数列を順に A として 、 繰り返 す
rst = B から 1 を引いた値から B に 3 を加えた値未満までの数列を順に A として 、 繰り返 す <eos>
3187
src = print ( reduce ( A , range ( 1 , B + 1 ) , 1 ) )
trg = 1 から B に 1 を加えた値未満までの数列を 1 を 初 期 値として A で集約した列 を出力する
rst = 1 から B に 1 を加えた値未満までの数列 を A で集約した列を返す <eos>
3188
src = A = B [ C ] [ C + D ]
trg = B の C 番目の C に D を加えた値番目を A とする
rst = B の C 番目の C に D を加えた値番目を A とする <eos>
3189
src = A . items = [ ]
trg = 空列を A のキーと値の集まり に する
rst = 空列を A のキーと値の集まり に する <eos>
3190
src = A . C [ B ] [ C ] = D + A . C [ B - 1 ] [ C - E ]
trg = D に A の C の B から 1 を引いた値番目の C から E を引いた値番目を加えた値を A の C の B 番目の C 番目に する
rst = D に A の C の B から 1 を引いた値番目の C 番目を加えた値から E を引いた値を A の C 番目の B 番目に する <eos>
3191
src = A = [ 1 for B in range ( len ( C ) ) ]
trg = 0 から C の長さ未満までの数列の各要素を B とし 、 1 の列を A とする
rst = 0 から C の長さ未満までの数列の各要素を B とし 、 1 の列を A とする <eos>
3192
src = now += ( A - now )
trg = 現在の日時を A から 、 つまり現在の日時を引いた値 だけ 増 加 させ る
rst = 現在の日時を A から 、 つまり現在の日時 を引いた値の最小値 だけ 増 加 させ る <eos>
3193
src = if A == 200 :
trg = A が 200 と等しいとき 、
rst = A が 200 と等しいとき 、 <eos>
3194
src = A , B = list ( C ) , list ( C )
trg = C のリスト 、 C のリストを A 、 B とする
rst = C のリストを展開し 、 それぞれ A 、 B とする <eos>
3195
src = A = chs ( B + C - 1 , B , D )
trg = chs ( B + C -1, B , D ) を A とする
rst = chs ( B + C -1, B , D ) を A とする <eos>
3196
src = A += [ 3 , 7 ] [ B [ A ] == C ]
trg = A を ( 3 、 7 ) からなる列の B の A 番目が C と等しいかどうか 番目だけ 増 加 させ る
rst = A を ( 7 、 B ) からなる列の A が C と等しいかどうか番目を出力する <eos>
3197
src = E = min ( [ C for B , C in D ] )
trg = D の各要素を B 、 C とし 、 C の列の最小値を E とする
rst = D の各要素を B 、 C とし 、 C の列の最小値を E とする <eos>
3198
src = A . append ( gen ( B , 1 ) )
trg = A の末尾に gen ( B ,1) を追加する
rst = A の末尾に gen ( B ,1) を追加する <eos>
3199
src = if isinstance ( A , str ) :
trg = A は 、 つまり整数 型 のとき 、
rst = A は 、 つまり整数 型 のとき 、 <eos>
3200
src = return A [ B ] + 1
trg = A の B 番目に 1 を加えた値を返す
rst = A の B 番目に 1 を加えた値を返す <eos>
3201
src = A , B = lcs ( C [ : sep ] , C [ sep : ] , A , B )
trg = lcs ( C [ : sep ] , C [ sep : ] , A , B ) を展開し 、 それぞれ A 、 B とする
rst = lcs ( C [ : sep ] , C [ sep : ] , A , B ) を展開し 、 それぞれ A 、 B とする <eos>
3202
src = A [ B ] = commands[q] ( int ( C ) )
trg = commands [ q ] ( int ( C )) を A の B 番目に する
rst = commands [ q ] ( int ( C )) を A の B 番目に する <eos>
3203
src = return max ( A ) + 1
trg = A の最大値に 1 を加えた値を返す
rst = A の最大値に 1 を加えた値を返す <eos>
3204
src = A = A and search ( B + C if B + C < 5 else None , D , C , E , not F )
trg = A かつ D 、 C 、 E 、 F でない に お いて正規表現 B に C を加えた値が 5 より小さいとき B に C を加えた値 、 そうでなければ 、 つまり未定値 が最初にマッチする位置を A とする
rst = A かつ C が B に C を加えた値より小さいとき B に C を加えた値に 5 を加えた値 、 そうでなければ 、 つまり未定値 、 D 、 C 、 E 、 F でない に お いて正規表現 B が最初にマッチする位置を A とする <eos>
3205
src = A = [ B ] + [ 0 ] * len ( C )
trg = ( B ) からなる列に (0) からなる列の C の長さ回分の列 を加えた値を A とする
rst = ( B ) からなる列に (0) からなる列の C の長さ回分の列を A とする <eos>
3206
src = A = line_cross_point ( B [ 2 ] , sub ( B [ 1 ] , B [ 0 ] ) , C [ 2 ] , sub ( C [ 1 ] , C [ 0 ] ) )
trg = line _ cross _ point ( B [2], sub ( B [1], B [0]), C [2], sub ( C [1], C [0])) を A とする
rst = line _ cross _ point ( B [2], B [1], sub ( B [0]), C [1], C [0])) を A とする <eos>
3207
src = A . dice_move ( [ B ] )
trg = A . dice _ move ([ B ] )
rst = A . <unk> ( B ) <eos>
3208
src = A . Max = 100
trg = 100 を A の Max に する
rst = 100 を A の <unk> に する <eos>
3209
src = A . height = max ( B , C )
trg = B 、 C の最大値を A の height に する
rst = B 、 C の最大値を A の height に する <eos>
3210
src = A . loop = True
trg = 真を A の loop に する
rst = 真を A の loop に する <eos>
3211
src = A = A [ 8 : ]
trg = A の 8 番目から 、 つまり末尾までの部分列を A とする
rst = A の 8 番目から 、 つまり末尾までの部分列を A とする <eos>
3212
src = [ print ( e ) for e in A [ 1 : ] ]
trg = A の先頭を除いた部分列の各要素を ネイピア数とし 、 、 つまりネイピア数 を出力するの列
rst = A の先頭を除いた部分列の各要素を ネイピア数とし 、 、 つまりネイピア数 を出力するの列 <eos>
3213
src = A = open ( 0 ) . read ( ) . split ( )
trg = 0 を開いたファイルストリーム から読み込んだ デ ータを空白で分割した字句列を A とする
rst = 0 を開いたファイルストリーム から読み込んだ デ ータを空白で分割した字句列 を A とする <eos>
3214
src = A [ 1 << B ] = 1
trg = 1 を A の 1 を B だけ左シフトした値 番目に する
rst = 1 を A の 1 を B だけ左シフトした値 番目に する <eos>
3215
src = return A - B == 2
trg = A から B を引いた値が 2 と等しいかどうかを返す
rst = A から B を引いた値が 2 と等しいかどうかを返す <eos>
3216
src = A = A * B
trg = A に B を掛けた値を A とする
rst = A に B を掛けた値を A とする <eos>
3217
src = A = ( B // C ) % D
trg = B を C で割った商を D で割った余りを A とする
rst = B を C で割った商を D で割った余りを A とする <eos>
3218
src = A = [ sorted ( ( [ B [ C ] [ D ] for C in [ range ( 3 ) for D in range ( 2 , 4 ) ] ] ) , key = lambda E : float ( E [ 1 ] ) ) [ : 2 ] ]
trg = ( x をパラメータとして E [1] の浮動小数点数 を返す関数をキーとして range ( 2 ,4) の各要素を D とし 、 range (3) の列の各要素を C とし 、 B [ C ] の D 番目 の列をソートした列の 、 つまり先頭から 2 番目までの部分列 ) からなる列を A とする
rst = x をパラメータとして - x の 2 番目を返す関数をキーとして 0 から E 未満までの数列の各要素を D とし 、 B の C 番目の D 番目の列を連結した文字列 の 、 つまり先頭から 4 番目までの部分列を A とする <eos>
3219
src = A . left . flip_color ( )
trg = A . left . flip _ color ()
rst = A . left . print _ tree () <eos>
3220
src = A = ( B * ( C + D - B ) * E + C * ( D + B - C ) * F + D * ( B + C - D ) * G ) / ( 16 * H ** 2 )
trg = B に ( C + D - B ) を掛けた値に E を掛けた値に C に ( D + B - C ) を掛けた値に F を掛けた値を加えた値に D に B + C から D を引いた値を掛けた値に G を掛けた値を加えた値を 16 に H の 2 乗を掛けた値で割った値を A とする
rst = B に C に D を掛けた値を加えた値から B に C を掛けた値に D に sin ( B ) を掛けた値を加えた値に C + D に sin ( B ) を掛けた値を加えた値に D に sin ( C + D を掛けた値に 2 を掛けた値を加えた値を G で割った余り を掛けた値を加えた値の最小値を A とする <eos>
3221
src = return [ A for A , B in enumerate ( C . root ) if B < 0 ]
trg = C の root に番号付した組の列の各要素を A 、 B とし 、 B が 0 より小さいとき の A の列を返す
rst = C の root に番号付した組の列の各要素を A 、 B とし 、 B が 0 より小さいとき の A の列を返す <eos>
3222
src = print ( count [ A + 1 ] + count [ B - A - 1 ] )
trg = 無限の整数列の A に 1 を加えた値番目に 無限の整数列の B から A を引いた値から 1 を引いた値番目 を加えた値を出力する
rst = 無限の整数列の A に 1 を加えた値番目に [ MASK ] を加えた値に 無限の整数列の B から A を引いた値から 1 を引いた値番目 を加えた値を出力する <eos>
3223
src = A = lcm ( B , C )
trg = B と C の最小公倍数を A とする
rst = B と C の最小公倍数を A とする <eos>
3224
src = if A [ 4 ] != B :
trg = A の 4 番目が B と等しくないとき 、
rst = A の 4 番目が B と等しくないとき 、 <eos>
3225
src = A = dijkstra2 ( B , 0 )
trg = dijkstra 2( B ,0) を A とする
rst = PathSum 2( B ,0) を A とする <eos>
3226
src = A = least_multiplication ( B )
trg = least _ multiplication ( B ) を A とする
rst = <unk> ( B ) を A とする <eos>
3227
src = print ( ' ' . join ( [ A . format ( B ) for B in [ C , D , E ] ] ) )
trg = 空白文字を間に入れて ( C 、 D 、 E ) からなる列の各要素を B とし 、 A を書式として B で整形した文字列の列 を連結した文字列を出力する
rst = 空白文字を間に入れて ( C 、 D 、 E ) からなる列の各要素を B とし 、 A を書式として B で整形した文字列の列 を連結した文字列を出力する <eos>
3228
src = A = B [ C - 1 ] [ D - 1 ] [ E ]
trg = B の C から 1 を引いた値番目の D から 1 を引いた値番目の E 番目を A とする
rst = B の C から 1 を引いた値番目の D から 1 を引いた値番目の E 番目を A とする <eos>
3229
src = if A . left != B . NIL :
trg = A の left が B の NIL と等しくないとき 、
rst = A の left が B の NIL と等しくないとき 、 <eos>
3230
src = A [ B - 1 ] = A [ B - 1 ] + 1
trg = A の B から 1 を引いた値番目に 1 を加えた値を A の B から 1 を引いた値番目に する
rst = A の B から 1 を引いた値番目に 1 を加えた値を A の B から 1 を引いた値番目に する <eos>
3231
src = print ( A [ B ] [ 2 ] )
trg = A の B 番目の 2 番目を出力する
rst = A の B 番目の 2 番目を出力する <eos>
3232
src = if ( 1 , 1 ) in A :
trg = (1、1) の組が A に含まれるとき 、
rst = (1、1) の組が A に含まれるとき 、 <eos>
3233
src = for A in range ( 0 , 600 , B ) :
trg = 0 から 600 未満までの B 間隔の数列を順に A として 、 繰り返 す
rst = 0 から 600 未満までの B 間隔の数列を順に A として 、 繰り返 す <eos>
3234
src = if not A [ B ] and dfs ( B ) :
trg = A の B 番目でなくかつ dfs ( B ) のとき 、
rst = A の B 番目でなくかつ dfs ( B ) のとき 、 <eos>
3235
src = A = B [ C . index ( D [ E - 1 ] ) ]
trg = B の C の D の E から 1 を引いた値番目 と等しい要素の最初の位置番目を A とする
rst = B の C の D の E から 1 を引いた値番目 と等しい要素の最初の位置を A とする <eos>
3236
src = return ( A , 7 - B , C )
trg = ( A 、 7 から B を引いた値 、 C ) の組を返す
rst = ( A 、 7 から B を引いた値 、 C ) の組を返す <eos>
3237
src = return math . sqrt ( A . x ** 2 + A . y ** 2 )
trg = A の x 座標の 2 乗に A の y 座標の 2 乗を加えた値の平方根を返す
rst = A の x 座標の 2 乗に A の y 座標の 2 乗を加えた値の平方根を返す <eos>
3238
src = if str . isnumeric ( A [ B ] ) == True :
trg = 整数 、 A の B 番目が全て数字かどうか が 、 つまり真と等しいとき 、
rst = 整数 が A の B 番目の出現回数が 、 つまり真と等しいとき 、 <eos>
3239
src = assert A . right is not None
trg = A の right が 、 つまり未定値と等しく なければ な らな い
rst = A の right が 、 つまり未定値と等しく なければ な らな い <eos>
3240
src = return '\n' . join ( A )
trg = 改行文字を間に入れて A を連結した文字列を返す
rst = 改行文字を間に入れて A を連結した文字列を返す <eos>
3241
src = while A < B and C <= D :
trg = A が B より小さくかつ C が D 以下の 間 、 次 を 繰り返 す
rst = A が B より小さくかつ C が D 以下の 間 、 次 を 繰り返 す <eos>
3242
src = A , B , C , D , e = map ( int , input ( ) . split ( ) )
trg = 入力された文字列 を空白で分割した字句列の各要素に 整数を適用した列を展開し 、 それぞれ A 、 B 、 C 、 D 、 ネイピア数とする
rst = 入力された文字列 を空白で分割した字句列の各要素に 整数を適用した列を展開し 、 それぞれ A 、 B 、 C 、 D 、 ネイピア数とする <eos>
3243
src = return A [ : ]
trg = A のコピーされた列を 返す
rst = A の 、 つまり先頭から 、 つまり末尾までの部分列 を返す <eos>
3244
src = A . d [ 0 ] = 0
trg = 0 を A の d の 0 番目に する
rst = 0 を A の d の 0 番目に する <eos>
3245
src = A [ B + 1 ] [ C ] = max ( A [ B + 1 ] [ C ] , e - 1 )
trg = A の B に 1 を加えた値番目の C 番目 、 ネイピア数から 1 を引いた値の最大値を A の B に 1 を加えた値番目の C 番目に する
rst = A の B に 1 を加えた値番目の C 番目 、 -1 の最大値を A の B に 1 を加えた値番目の C 番目に する <eos>
3246
src = f2 ( A + 1 , B )
trg = f 2( A +1, B )
rst = f 2( A +1, B ) <eos>
3247
src = for A in [ 90 , 180 , 270 ] :
trg = ( 90、 180 、 270 ) からなる列 を順に A として 、 繰り返 す
rst = <unk> 、4) からなる列 を順に A として 、 繰り返 す <eos>
3248
src = if 0 <= A + B [ 1 ] <= C :
trg = 0 が A に B の 1 番目 を加えた値以下かどうかが C 以下のとき 、
rst = 0 が A に B の 1 番目を加えた値が C 以下のとき 、 <eos>
3249
src = A . append ( int ( B + C ) )
trg = A の末尾に B に C を加えた値 の整数値を追加する
rst = A の末尾に B に C の整数値を加えた値 を追加する <eos>
3250
src = A = B . append ( int ( C ) )
trg = B の末尾に C の整数値を追加する を A とする
rst = B の末尾に C の整数値を追加する <eos>
3251
src = A . append ( ( B , C , D ) )
trg = A の末尾に ( B 、 C 、 D ) の組 を追加する
rst = A の末尾に ( B 、 C 、 D ) の組 を追加する <eos>
3252
src = print ( D if A . count ( B ) == C . count ( B ) else E )
trg = A 内の B の出現回数が C 内の B の出現回数と等しいとき D 、 そうでなければ E を出力する
rst = A 内の B の出現回数が C と等しいとき D 、 そうでなければ B 内の E の出現回数 を出力する <eos>
3253
src = A == 1
trg = A が 1 と等しいかどうか
rst = A が 1 と等しいかどうか <eos>
3254
src = A [ B ] = 99999
trg = 99999 を A の B 番目に する
rst = <unk> を A の B 番目に する <eos>
3255
src = A , e = e , B
trg = ネイピア数 、 B を A 、 ネイピア数とする
rst = ネイピア数 、 B を A 、 ネイピア数とする <eos>
3256
src = print ( A if A < B else C )
trg = A が B より小さいとき A 、 そうでなければ C を出力する
rst = A が B より小さいとき A 、 そうでなければ C を出力する <eos>
3257
src = A = [ 500 , 100 , 50 , 10 , 5 , 1 ]
trg = (500、100、50、10 、5、1) からなる列を A とする
rst = ( <unk> からなる列を A とする <eos>
3258
src = if A not in B . queen_pos :
trg = A が B の queen _ pos に含まれないとき 、
rst = A が B の queen _ pos に含まれないとき 、 <eos>
3259
src = A = B . dot ( Vector ( B . pt1 , C ) ) / pow ( B . abs ( ) , 2 )
trg = B . dot ( Vector ( B . pt 1 , C )) を B . abs () の 2 乗で割った値を A とする
rst = B . dot ( Vector ( B . pt 1 , C )) を B . abs ( abs ( abs = B . abs ) の abs ( abs ) で割った値を A とする <eos>
3260
src = A [ B - 1 ] -= C
trg = A の B から 1 を引いた値番目を C だけ 減 少 させ る
rst = A の B から 1 を引いた値番目を C だけ 減 少 させ る <eos>
3261
src = A = B ** C // ( 10 ** D ) % 10000
trg = B の C 乗を 10 の D 乗で割った商を 10000 で割った余りを A とする
rst = B の C を 10 の D 乗で割った商を 10000 で割った余りを A とする <eos>
3262
src = A . append ( ( B , C , D - E [ F ] [ 0 ] ) )
trg = A の末尾に ( B 、 C 、 D から E の F 番目の先頭を引いた値 ) の組 を追加する
rst = A の末尾に ( B 、 C 、 D から E の F 番目の先頭を引いた値 ) の組 を追加する <eos>
3263
src = A = { node : [ False for B in C . GetNodes ( ) ] }
trg = ( ( B , C . GetNodes () の各要素を B とし 、 、 つまり偽の列 )) からなる辞書を A とする
rst = ( ( B , C . GetNodes () の各要素を B とし 、 、 つまり偽の列 )) からなる辞書を A とする <eos>
3264
src = write ( A % max ( greedy ( ) ) )
trg = write ( A % max ( greedy ()))
rst = write ( A % max ( max ( split ())) <eos>
3265
src = H = I * ( J - K * ( D + 1 ) )
trg = I に J から K に D に 1 を加えた値 を掛けた値を引いた値を掛けた値を H とする
rst = I に J から K に D に 1 を加えた値を掛けた値を引いた値を G とする <eos>
3266
src = if A == [ ] :
trg = A が 、 つまり空列 と等しいとき 、
rst = A が 、 つまり空列 と等しいとき 、 <eos>
3267
src = A [ B ] . append ( time )
trg = A の B 番目の末尾に time を追加する
rst = A の B 番目の末尾に time を追加する <eos>
3268
src = while A - B >= 0 and C - B >= 0 :
trg = A から B を引いた値が 0 以上かつ C から B を引いた値が 0 以上の 間 、 次 を 繰り返 す
rst = A から B を引いた値が 0 以上かつ C から B を引いた値が 0 以上の 間 、 次 を 繰り返 す <eos>
3269
src = while len ( A ) > 1 and cross3 ( A [ - 1 ] , A [ - 2 ] , B ) >= 0 :
trg = A の長さが 1 より大きくかつ cross 3( A [-1], A [-2], B ) が 0 以上の 間 、 次 を 繰り返 す
rst = A の長さが 1 より大きくかつ cross 3( A [-1], A [-2], B ) が 0 以上の 間 、 次 を 繰り返 す <eos>
3270
src = for A , B in enumerate ( C . distance ) :
trg = C の distance に番号付した組の列を順に A 、 B として 、 繰り返 す
rst = C の distance に番号付した組の列を順に A 、 B として 、 繰り返 す <eos>
3271
src = if A . startswith ( B ) :
trg = A の先頭が B で 始 まるとき 、
rst = A の先頭が B で 始 まるとき 、 <eos>
3272
src = print ( A [ B ] [ C ] + 1 if A [ B ] [ C ] < D else E )
trg = A の B 番目の C 番目が D より小さいとき A の B 番目の C 番目に 1 を加えた値 、 そうでなければ E を出力する
rst = A の B 番目の C 番目が D より小さいとき A の B 番目の C 番目に 1 を加えた値 、 そうでなければ E を出力する <eos>
3273
src = A = max ( - B [ C ] , D [ C ] )
trg = - B の C 番目 、 D の C 番目の最大値を A とする
rst = - B の C 番目 、 D の C 番目の最大値を A とする <eos>
3274
src = A , B , e = map ( int , readline ( ) . split ( ) )
trg = readline () を空白で分割した字句列の各要素に 整数を適用した列を展開し 、 それぞれ A 、 B 、 ネイピア数とする
rst = readline () を空白で分割した字句列の各要素に 整数を適用した列を展開し 、 それぞれ A 、 B 、 ネイピア数とする <eos>
3275
src = if int ( A ) % 1111 == 0 :
trg = A の整数値を 1111 で割った余りが 0 と等しいとき 、
rst = A の整数値を <unk> で割った余りが 0 と等しいとき 、 <eos>
3276
src = A . append ( ( B + 1 ) * C + D )
trg = A の末尾に B に 1 を加えた値に C を掛けた値に D を加えた値 を追加する
rst = A の末尾に B に 1 を加えた値に C を掛けた値に D を加えた値 を追加する <eos>
3277
src = A , B , C = [ float ( D ) for D in input ( ) . split ( E ) ]
trg = 入力された文字列を E で分割した字句列の各要素を D とし 、 D の浮動小数点数の列 を展開し 、 それぞれ A 、 B 、 C とする
rst = 入力された文字列を E で分割した字句列の各要素を D とし 、 D の浮動小数点数の列 を展開し 、 それぞれ A 、 B 、 C とする <eos>
3278
src = aizu_chicken ( A , B , C , D , E )
trg = aizu _ chicken ( A , B , C , D , E )
rst = <unk> ( A , B , C , D , E ) <eos>
3279
src = A = math . floor ( A / 10 )
trg = A を 10 で割った値の切り 捨 て整数値を A とする
rst = A を 10 で割った値の切り 捨 て整数値を A とする <eos>
3280
src = A . append ( ( B - C ** .5 , D - E ) )
trg = A の末尾に ( B から C の .5 乗を引いた値 、 D から E を引いた値 ) の組 を追加する
rst = A の末尾に ( B から C の .5 乗を引いた値 、 D から E を引いた値 ) の組 を追加する <eos>
3281
src = return sum ( count )
trg = 無限の整数列の総和 を返す
rst = 無限の整数列 を返す <eos>
3282
src = if A == B == 0 :
trg = A が B と等しいかどうかが 0 と等しいとき 、
rst = A が B と等しいかどうかが 0 と等しいとき 、 <eos>
3283
src = A [ B ] = min ( [ C [ D ] for D in range ( E , F + G , G ) ] )
trg = E から F に G を加えた値未満までの G 間隔の数列の各要素を D とし 、 C の D 番目の列の最小値を A の B 番目に する
rst = E から F に G を加えた値未満までの数列の各要素 を D とし 、 C の D 番目 番目の列の最小値を A の B 番目に する <eos>
3284
src = while A [ B - 1 ] [ C - 1 ] == - 1 and len ( D ) > 0 :
trg = A の B から 1 を引いた値番目の C から 1 を引いた値番目が -1 と等しくかつ D の長さが 0 より大きい 間 、 次 を 繰り返 す
rst = A の B から 1 を引いた値番目の C から 1 を引いた値番目が -1 と等しくかつ D の長さが 0 より大きい 間 、 次 を 繰り返 す <eos>
3285
src = paint ( A , B )
trg = paint ( A , B )
rst = paint ( A , B ) <eos>
3286
src = if A > 21 :
trg = A が 2 1 より大きいとき 、
rst = A が 2 1 より大きいとき 、 <eos>
3287
src = A = check_puzzle ( B )
trg = check _ puzzle ( B ) を A とする
rst = <unk> ( B ) を A とする <eos>
3288
src = for A , B in enumerate ( zip ( C , D , D [ 1 : ] ) , start = 1 ) :
trg = 1 を開 始 番号として C 、 D 、 D の先頭を除いた部分列 の要素をそれぞれ組にした列 に番号付した組の列を順に A 、 B として 、 繰り返 す
rst = 1 を開 始 番号として C 、 D 、 D の先頭を除いた部分列 の要素をそれぞれ組にした列 に番号付した組の列を順に A 、 B として 、 繰り返 す <eos>
3289
src = for A in range ( 3 , 0 , - 1 ) :
trg = 3 から 0 未満までの -1 間隔の数列を順に A として 、 繰り返 す
rst = 3 から 0 未満までの -1 間隔の数列を順に A として 、 繰り返 す <eos>
3290
src = if e [ 1 ] > 0 and A . level [ e [ 0 ] ] < 0 :
trg = ネイピア数の 1 番目が 0 より大きくかつ A の level の 、 つまりネイピア数の先頭番目が 0 より小さいとき 、
rst = ネイピア数の 1 番目が 0 より大きくかつ A の level の 、 つまりネイピア数の先頭番目 が 0 より小さいとき 、 <eos>
3291
src = if tuple ( A [ 0 ] ) in B :
trg = A の先頭 の組が B に含まれるとき 、
rst = A の 0 番目が B に含まれるとき 、 <eos>
3292
src = if e [ 2 ] :
trg = ネイピア数の 2 番目のとき 、
rst = ネイピア数の 2 番目のとき 、 <eos>
3293
src = A = num_from_card ( B [ C ] )
trg = num _ from _ card ( B [ C ] ) を A とする
rst = num _ from _ card ( B [ C ] ) を A とする <eos>
3294
src = A = complex ( B [ 4 ] , B [ 5 ] )
trg = B の 4 番目を 実 部 、 B の 5 番目を 虚 部 とし た 複 素数を A とする
rst = B の 4 番目を 実 部 、 B の 5 番目を 虚 部 とし た 複 素数を A とする <eos>
3295
src = A [ B : ] = calc ( B , C )
trg = calc ( B , C ) を A の B 番目から 、 つまり末尾までの部分列に する
rst = calc ( B , C ) を A の B 番目から 、 つまり末尾までの部分列に する <eos>
3296
src = print ( * list ( map ( lambda A : str ( A [ 0 ] ) + B + str ( A [ 1 ] ) . zfill ( 2 ) , C ) ) )
trg = C の各要素に tstr ( A [0]) + B + str ( A [1]) . zfill (2) を返す関数を適用した列のリスト を展開してを出力する
rst = A の 1 番目に B を加えた値に A の 1 番目を加えた値に A の 2 に str ( C ) を加えた値を掛けた値 の各要素に整数を適用した列 ルターした列 を展開してを出力する <eos>
3297
src = writelines ( [ A % ( B , C [ B ] , D [ B ] , E [ B ] , F [ B ] , G [ B ] , H if C [ B ] == - 1 else I if E [ B ] == 0 else J ) for B in range ( K ) ] )
trg = writelines ([ A %( B , C [ B ] , D [ B ] , E [ B ] , F [ B ] , G [ B ] , HifC [ B ] == -1 elseIifE [ B ] == 0 elseJ ) forBinrange ( K )])
rst = ( A を B 、 C の B 番目 、 D の B 番目が E と等しいとき F 、 そうでなければ 0 から G 未満までの数列の各要素を B とし 、 B の列 ) からなる列 、 ( B 、 C の B 番目 、 G の B 番目 、 D 番目 ) からなる列 、 E
3298
src = if A [ B ] == False and ( C == - 1 or D [ B ] < D [ C ] ) :
trg = A の B 番目が 、 つまり偽と等しくかつ C が -1 と等しくまたは D の B 番目が D の C 番目より小さいとき 、
rst = A の B 番目が 、 つまり偽 と等しくかつ C が -1 と等しくまたは D の B 番目が D の C 番目より小さいとき 、 <eos>
3299
src = if A == B or C :
trg = A が B と等しくまたは C のとき 、
rst = A が B と等しくまたは C のとき 、 <eos>
3300
src = A = [ [ min ( B [ 0 ] ) , 0 ] , [ max ( B [ 0 ] ) , 0 ] ]
trg = ( ( B の先頭の最小値 、0) からなる列 、 ( B の先頭の最大値 、0) からなる列 ) からなる列を A とする
rst = ( B の先頭 、 B の先頭 、 B の先頭 の最大値 ) からなる列を A とする <eos>
3301
src = print ( A [ 0 ] [ 0 ] , B + 1 )
trg = A の先頭の先頭 、 B に 1 を加えた値を出力する
rst = A の先頭の先頭 、 B に 1 を加えた値を出力する <eos>
3302
src = if A . get ( B [ 0 ] ) :
trg = A に対応する値 、 もし存在しなければ B の先頭のとき 、
rst = A に対応する値 、 もし存在しなければ B の先頭のとき 、 <eos>
3303
src = if len ( count ) == 0 :
trg = 無限の整数列の長さが 0 と等しいとき 、
rst = <unk> 0 と等しいとき 、 <eos>
3304
src = A += B [ 2 ]
trg = A を B の 2 番目だけ 増 加 させ る
rst = A を B の 2 番目だけ 増 加 させ る <eos>
3305
src = if list ( range ( A , A + 5 ) ) == B :
trg = A から A に 5 を加えた値未満までの数列のリスト が B と等しいとき 、
rst = A から A に 5 を加えた値未満までの数列のリスト が B と等しいとき 、 <eos>
3306
src = if f ( X ( A , B , C ) [ 0 ] ) < f ( X ( A , B , C ) [ 1 ] ) :
trg = f ( X ( A , B , C ) [0]) が f ( X ( A , B , C ) [1]) より小さいとき 、
rst = f ( A , B , C ) の先頭が ( f ( A , B ) , C [1]) より小さいとき 、 <eos>
3307
src = search ( A , B , C , D , A [ C ] [ D ] )
trg = B 、 C 、 D 、 A の C 番目の D 番目に お いて正規表現 A が最初にマッチする位置
rst = B 、 C 、 D 、 A の C 番目の D 番目に お いて正規表現 A が最初にマッチする位置 <eos>
3308
src = inorder ( A , B )
trg = inorder ( A , B )
rst = inorder ( A , B ) <eos>
3309
src = A . insert ( B [ 0 ] )
trg = A の B の先頭に [ MASK ] を挿入する
rst = A の B の先頭の整数値に [ MASK ] を挿入する <eos>
3310
src = A , B = term ( )
trg = term () を展開し 、 それぞれ A 、 B とする
rst = term () を展開し 、 それぞれ A 、 B とする <eos>
3311
src = while A [ B ] != C [ D ] :
trg = A の B 番目が C の D 番目と等しくない 間 、 次 を 繰り返 す
rst = A の B 番目が C の D 番目と等しくない 間 、 次 を 繰り返 す <eos>
3312
src = A [ B [ C + 1 ] - 1 ] += 2
trg = A の B の C に 1 を加えた値番目から 1 を引いた値番目を 2 だけ 増 加 させ る
rst = A の B の C に 1 を加えた値番目から 1 を引いた値番目を 2 だけ 増 加 させ る <eos>
3313
src = if not A and not B and not C and not D and not E :
trg = A でなくかつ B でなくかつ C でなくかつ D でなくかつ E でないとき 、
rst = A でなくかつ B でなくかつ C でなくかつ D でなくかつ E でないとき 、 <eos>
3314
src = print ( ' ' . join ( map ( str , sorted ( A [ B ] ) ) ) )
trg = 空白文字を間に入れて A の B 番目をソートした列 の各要素に整数を適用した列 を連結した文字列を出力する
rst = 空白文字を間に入れて A の B 番目の各要素に整数を適用した列 を連結した文字列を出力する <eos>
3315
src = rdfs ( A , B )
trg = rdfs ( A , B )
rst = rdfs ( A , B ) <eos>
3316
src = if ( A + 1 in B or A == 2019 ) :
trg = A に 1 を加えた値が B に含まれまたは A が 2019 と等しいとき 、
rst = A に 1 を加えた値が B に含まれまたは A が 2019 と等しいとき 、 <eos>
3317
src = if A - B in C . table :
trg = A から B を引いた値が C の table に含まれるとき 、
rst = A から B を引いた値が C の table に含まれるとき 、 <eos>
3318
src = if read ( A ) not in B :
trg = read ( A ) が B に含まれないとき 、
rst = read ( A ) が B に含まれないとき 、 <eos>
3319
src = if not in_the_grid ( A , B ) :
trg = in _ the _ grid ( A , B ) でないとき 、
rst = polygon _ <unk> ( A , B ) でないとき 、 <eos>
3320
src = f1 ( [ list ( input ( ) ) for A in range ( 8 ) ] )
trg = f 1 ([ list ( input ()) forAinrange (8) ] )
rst = 0 から 8 未満までの数列の各要素を A とし 、 f ( input ()) の列 <eos>
3321
src = A [ B [ C ] - 1 ] = C
trg = C を A の B の C 番目から 1 を引いた値番目に する
rst = C を A の B の C 番目から 1 を引いた値番目に する <eos>
3322
src = A . append ( 10e9 + 1 )
trg = A の末尾に 10 e 9 に 1 を加えた値 を追加する
rst = A の末尾に <unk> に 1 を加えた値を 追加する <eos>
3323
src = A = min ( A , minimum_cost ( B , C + 1 , tuple ( ( 1 if D == B else [ 0 for D in range ( E ) ] ) ) , min ( F + G - 1 , H ) , I , J , E , H ) + K )
trg = A 、 minimum _ cost ( B , C +1, tuple ( ( 1 ifD == Belse [ 0 forDinrange ( E )])) , min ( F + G -1, H ) , I , J , E , H ) に K を加えた値の最小値を A とする
rst = A 、 minimum _ cost ([ <unk> ( B , C +1, tuple ( D ) , E , F , G ) , H , I ) に お いて正規表現 B , F -1, D ) を加えた値の最小値を A とする <eos>
3324
src = if not A and B == C :
trg = A でなくかつ B が C と等しいとき 、
rst = A でなくかつ B が C と等しいとき 、 <eos>
3325
src = A = [ 0 , 0 ] + [ 1 ] * 9999
trg = (0、0) からなる列に (1) からなる列の 9999 回分の列を加えた値を A とする
rst = (0、0) からなる列に (1) からなる列の 999999 回分の列を加えた値を A とする <eos>
3326
src = if A == 100 or B == 100 or C == 100 or A + B >= 180 or A + B + C >= 240 :
trg = A が 100 と等しくまたは B が 100 と等しくまたは C が 100 と等しくまたは A に B を加えた値が 180 以上または A に B を加えた値に C を加えた値が 240 以上のとき 、
rst = A が 100 と等しくまたは B が 100 と等しくまたは C が 100 と等しくまたは A に B を加えた値が 240 以上のとき 、 <eos>
3327
src = if A [ 2 * B : 2 * B + 2 ] != C and B % 2 :
trg = A の 2 に B を掛けた値から 2 に B を掛けた値に 2 を加えた値までの部分列が C と等しくなくかつ B を 2 で割った余りのとき 、
rst = A の 2 に B を掛けた値から 2 に B を掛けた値に 2 を加えた値までの部分列が C と等しくなくかつ B を 2 で割った余りのとき 、 <eos>
3328
src = if A == None and B == None :
trg = A が 、 つまり未定値と等しくかつ B が 、 つまり未定値と等しいとき 、
rst = A が 、 つまり未定値と等しくかつ B が 、 つまり未定値と等しいとき 、 <eos>
3329
src = A . size = 2 ** ( ( B - 1 ) . bit_length ( ) )
trg = 2 の B から 1 を引いた値のビット長 乗を A の size に する
rst = 2 の B から 1 を引いた値のビット長 乗を A の size に する <eos>
3330
src = if max ( A . values ( ) ) < 1000000 :
trg = A の値の集まりの最大値が 1000000 より小さいとき 、
rst = A <unk> 999999 より小さいとき 、 <eos>
3331
src = E = F + ( G - H )
trg = F に G から H を引いた値を加えた値を E とする
rst = F に G から H を引いた値を加えた値を E とする <eos>
3332
src = for A in B [ C [ 1 ] : C [ 2 ] ] :
trg = B の C の 1 番目から C の 2 番目までの部分列を順に A として 、 繰り返 す
rst = B の C の 1 番目から C の 2 番目までの部分列 番目を順に A として 、 繰り返 す <eos>
3333
src = A += isOddPrime ( 2 * int ( input ( ) ) + 1 )
trg = A を isOddPrime (2* int ( input ()) +1) だけ 増 加 させ る
rst = A を <unk> に 2 を掛けた値の整数値 だけ 増 加 させ る <eos>
3334
src = A = [ sum ( [ B * C for B , C in zip ( D , A ) ] ) % E for D in F ]
trg = F の各要素を D とし 、 D 、 A の要素をそれぞれ組にした列 の各要素を B 、 C とし 、 B に C を掛けた値の列の総和を E で割った余りの列を A とする
rst = F の各要素を D 、 E とし 、 D 、 A の要素をそれぞれ組にした列 の各要素を B 、 C とし 、 B に C を掛けた値の列の総和の列 の列を A とする <eos>
3335
src = A = A * math . pi / 180.0
trg = A に円周率を掛けた値を 180.0 で割った値を A とする
rst = A に円周率を掛けた値を 180.0 で割った値を A とする <eos>
3336
src = A [ B ] = B * A [ B - 1 ]
trg = B に A の B から 1 を引いた値番目を掛けた値を A の B 番目に する
rst = B に A の B から 1 を引いた値番目を掛けた値を A の B 番目に する <eos>
3337
src = A = B . format ( C , D , E , F , G , H , I )
trg = B を書式として C 、 D 、 E 、 F 、 G 、 H 、 I で整形した文字列を A とする
rst = B を書式として C 、 D 、 E 、 F 、 G 、 H 、 I の日付を A とする <eos>
3338
src = if A < 71 :
trg = A が 7 1 より小さいとき 、
rst = A が 7 より小さいとき 、 <eos>
3339
src = print ( A [ 1 ] + A [ 2 ] + A [ 3 ] + B [ 1 ] )
trg = A の 1 番目に A の 2 番目を加えた値に A の 3 番目を加えた値に B の 1 番目 を加えた値を出力する
rst = A の 1 番目に A の 2 番目を加えた値に A の 3 番目を加えた値に B の 1 番目 を加えた値を出力する <eos>
3340
src = A = math . sqrt ( ( B [ 3 ] - C [ 3 ] ) ** 2 + ( B [ 4 ] - C [ 4 ] ) ** 2 )
trg = B の 3 番目から C の 3 番目を引いた値の 2 乗に B の 4 番目から C の 4 番目を引いた値の 2 乗を加えた値の平方根を A とする
rst = B の 3 番目から C の 3 番目を引いた値の 2 乗に B の 4 番目から C の 2 番目を引いた値の 2 乗を加えた値の平方根を A とする <eos>
3341
src = A . insert ( B , C )
trg = A の B に C を挿入する
rst = A の B に C を挿入する <eos>
3342
src = A += B - C + D
trg = A を B から C を引いた値に D を加えた値だけ 増 加 させ る
rst = A を B から C を引いた値に D を加えた値だけ 増 加 させ る <eos>
3343
src = accel_time_end ( )
trg = accel _ time _ end ()
rst = <unk> () <eos>
3344
src = if A [ B - C - 1 ] > 0 :
trg = A の B から C を引いた値から 1 を引いた値番目が 0 より大きいとき 、
rst = A の B から C を引いた値から 1 を引いた値番目が 0 より大きいとき 、 <eos>
3345
src = e = max ( e , A [ B ] + 1 )
trg = ネイピア数 、 A の B 番目に 1 を加えた値の最大値を ネイピア数とする
rst = ネイピア数 、 A の B 番目に 1 を加えた値の最大値を ネイピア数とする <eos>
3346
src = print ( '\n' . join ( [ A ] * 1000 ) )
trg = 改行文字を間に入れて ( A ) からなる列の 1000 回分の列 を連結した文字列を出力する
rst = 改行文字を間に入れて ( A ) からなる列の 1000 を掛けた値を出力する <eos>
3347
src = print ( A % 360 )
trg = A を 360 で割った余りを出力する
rst = A を 360 で割った余りを出力する <eos>
3348
src = B = B % 2
trg = B を 2 で割った余りを B とする
rst = B を 2 で割った余りを B とする <eos>
3349
src = print ( A if len ( set ( e [ : 4 ] ) ) == len ( set ( e [ 4 : 8 ] ) ) == len ( set ( e [ 8 : ] ) ) == 1 else B )
trg = len ( set ( e [:4] )) が len ( set ( e [ 4 : 8 ])) と等しいかどうかが set ( e [8: ] ) の長さと等しいかどうかが 1 と等しいとき A 、 そうでなければ B を出力する
rst = e の 、 つまり先頭から 4 番目までの部分列の総和 から 、 つまりネイピア数の 4 番目が B と等しいとき 、 <eos>
3350
src = while A < B and C [ A ] != D :
trg = A が B より小さくかつ C の A 番目が D と等しくない 間 、 次 を 繰り返 す
rst = A が B より小さくかつ C の A 番目が D と等しくない 間 、 次 を 繰り返 す <eos>
3351
src = A = 2002
trg = 2002 を A とする
rst = <unk> を A とする <eos>
3352
src = A , B , C , D = C , D , A , B
trg = C 、 D 、 A 、 B を A 、 B 、 C 、 D とする
rst = C 、 D 、 A 、 B を A 、 B 、 C 、 D とする <eos>
3353
src = print ( - A [ B ] [ 0 ] )
trg = - A の B 番目の先頭 を出力する
rst = - A の B 番目の先頭 を出力する <eos>
3354
src = A = parse ( B , C , D + 1 , E )
trg = parse ( B , C , D +1, E ) を A とする
rst = parse ( B , C , D +1, E ) を A とする <eos>
3355
src = for A in [ B [ 0 ] for B in C ] :
trg = C の各要素を B とし 、 B の 0 番目 の列を順に A として 、 繰り返 す
rst = C の各要素を B とし 、 B の 0 番目の列 を順に A として 、 繰り返 す <eos>
3356
src = if A [ 0 ] == A [ 1 ] :
trg = A の 0 番目が A の 1 番目と等しいとき 、
rst = A の先頭が A の 1 番目と等しいとき 、 <eos>
3357
src = A [ 3 ] = B + C + 1
trg = B に C を加えた値に 1 を加えた値を A の 3 番目に する
rst = B に C を加えた値に 1 を加えた値を A の 3 番目に する <eos>
3358
src = A = merge ( B , C , D , E )
trg = merge ( B , C , D , E ) を A とする
rst = merge ( B , C , D , E ) を A とする <eos>
3359
src = for A in range ( B // 2 ) :
trg = 0 から B を 2 で割った商 未満までの数列を順に A として 、 繰り返 す
rst = 0 から B を 2 で割った商 未満までの数列を順に A として 、 繰り返 す <eos>
3360
src = if A < 1e-10 :
trg = A が 1 e -10 より小さいとき 、
rst = A が 1 e -10 より小さいとき 、 <eos>
3361
src = return A . end
trg = A の end を返す
rst = A の end を返す <eos>
3362
src = A [ B ] [ C ] [ D ] [ E ] = ( B + 1 == C )
trg = B に 1 を加えた値が C と等しいかどうかを A の B 番目の C 番目の D 番目の E 番目に する
rst = B に 1 を加えた値を C の D 番目の E 番目に する <eos>
3363
src = A = [ [ ] for B in range ( C ** 2 ) ]
trg = 0 から C の 2 乗未満までの数列の各要素を B とし 、 、 つまり空列の列を A とする
rst = 0 から C の 2 乗未満までの数列の各要素を B とし 、 、 つまり空列の列を A とする <eos>
3364
src = if A and B in C :
trg = A かつ B が C に含まれるとき 、
rst = A かつ B が C に含まれるとき 、 <eos>
3365
src = A = A [ 2 : ]
trg = A の 2 番目から 、 つまり末尾までの部分列を A とする
rst = A の 2 番目から 、 つまり末尾までの部分列を A とする <eos>
3366
src = A . find ( int ( B [ 5 : ] ) )
trg = A の先頭から B の 5 番目から 、 つまり末尾までの部分列の整数値 を探して見つかった位置
rst = A の先頭から B の 5 番目から 、 つまり末尾までの部分列の整数値 を探して見つかった位置 <eos>
3367
src = update ( A [ 0 ] , A [ 1 ] + 1 , A [ 2 ] )
trg = update ( A [0], A [1]+1, A [2])
rst = update ( A [0], A [1], A [2]) <eos>
3368
src = A = B . f_val_to_key [ A ]
trg = B の f _ val _ to _ key の A 番目を A とする
rst = B の MOVE _ <unk> の A 番目を A とする <eos>
3369
src = A [ B [ 1 ] ] . appendleft ( A [ B [ 2 ] ] [ 0 ] )
trg = A の B の 1 番目番目の先頭 に A の B の 2 番目番目の先頭 を追加する
rst = A の B の 1 番目番目の末尾に A の B の 2 番目番目の先頭 を追加する <eos>
3370
src = A = float ( B [ 1 ] )
trg = B の 1 番目の浮動小数点数を A とする
rst = B の 1 番目の浮動小数点数を A とする <eos>
3371
src = A = D if B < C else E
trg = B が C より小さいとき D 、 そうでなければ E を A とする
rst = B が C より小さいとき D 、 そうでなければ E を A とする <eos>
3372
src = dict [ A [ 0 ] ] = A [ 1 ]
trg = A の 1 番目 を辞書の A の先頭番目に する
rst = A の 1 番目の整数値を辞書の A の先頭番目に する <eos>
3373
src = sort ( A , B , C , D )
trg = sort ( A , B , C , D )
rst = sort ( A , B , C , D ) <eos>
3374
src = print ( A . format ( sum ( B ) // len ( B ) ) )
trg = A を書式として B の総和を B の長さで割った商 で整形した文字列を出力する
rst = A を書式として B の総和を B <unk> で整形した文字列を出力する <eos>
3375
src = A [ B ] += C [ 0 ]
trg = A の B 番目を C の先頭だけ 増 加 させ る
rst = A の B 番目を C の先頭だけ 増 加 させ る <eos>
3376
src = A [ B + 1 ] = ( C , B )
trg = ( C 、 B ) の組を A の B に 1 を加えた値番目に する
rst = ( C 、 B ) の組を A の B に 1 を加えた値番目に する <eos>
3377
src = A [ B - C ] [ D ] += A [ B + C + 1 ] [ D ]
trg = A の B から C を引いた値番目の D 番目を A の B に C を加えた値に 1 を加えた値番目の D 番目だけ 増 加 させ る
rst = A の B から C を引いた値番目の D 番目を A の B に C を加えた値に 1 を加えた値番目の D 番目だけ 増 加 させ る <eos>
3378
src = A [ B ] = C = C * 10 % D
trg = C に 10 を掛けた値を D で割った余りを C とする を A の B 番目に する
rst = C に 10 を掛けた値を D で割った余りを C とする を A の B 番目に する <eos>
3379
src = A = e * ( 1 - B ** C ) / ( 1 - B ) + B ** C * A
trg = ネイピア数に 1 から B の C 乗を引いた値を掛けた値を 1 から B を引いた値で割った値に B の C 乗に A を掛けた値を加えた値を A とする
rst = ネイピア数に 1 から B の C 乗を引いた値の 1 に B を掛けた値を加えた値を A とする <eos>
3380
src = A = [ [ 1 ] * [ ( B + 4 ) for C in range ( D + 4 ) ] ]
trg = ( (1) からなる列の 0 から D に 4 を加えた値未満までの数列の各要素 を C とし 、 B に 4 を加えた値の列回分の列 ) からなる列を A とする
rst = ( (1) からなる列の 0 から D に 4 を加えた値未満までの数列の各要素 を C とし 、 B に 4 を加えた値の列回分の列 ) からなる列を A とする <eos>
3381
src = if checkQueen ( A , B ) :
trg = checkQueen ( A , B ) のとき 、
rst = <unk> ( A , B ) のとき 、 <eos>
3382
src = A = B + C * ( ( D + 1 ) - E ) // F
trg = B に C に D に 1 を加えた値から E を引いた値を掛けた値を F で割った商を加えた値を A とする
rst = B に C に ( D +1) から E を引いた値を掛けた値を F で割った商を加えた値を A とする <eos>
3383
src = A = A / 2
trg = A を 2 で割った値を A とする
rst = A を 2 で割った値を A とする <eos>
3384
src = A , B , C , D = [ 0 ] , 4
trg = (0) からなる列の 4 回分の列 を展開し 、 それぞれ A 、 B 、 C 、 D とする
rst = (0) からなる列 、 4 を A 、 B 、 C 、 D とする <eos>
3385
src = print ( ' ' . join ( map ( str , A [ B ] [ C ] ) ) )
trg = 空白文字を間に入れて A の B 番目の C 番目の各要素に整数を適用した列 を連結した文字列を出力する
rst = 空白文字を間に入れて A の B 番目の C 番目の各要素に整数を適用した列 を連結した文字列を出力する <eos>
3386
src = if search ( A , B , 6 , 8 , 0 ) :
trg = B 、 6、8 、0 に お いて正規表現 A が最初にマッチする位置 のとき 、
rst = B 、 6 、 8 、 0 に お いて正規表現 A が最初にマッチする位置 のとき 、 <eos>
3387
src = A = { 2 : 1 }
trg = ( (2, 1 )) からなる辞書を A とする
rst = ( 2 進 数文字列の 2 番目から 、 つまり末尾までの部分列を A とする <eos>
3388
src = e = ( A ** 2 + B ** 2 ) ** .5
trg = A の 2 乗に B の 2 乗を加えた値の .5 乗を ネイピア数とする
rst = A の 2 乗に B の 2 乗を加えた値の .5 乗を ネイピア数とする <eos>
3389
src = A . deletelast ( )
trg = A . deletelast ()
rst = A . dice _ s () <eos>
3390
src = A . w = B
trg = B を A の w に する
rst = B を A の w に する <eos>
3391
src = if A == sys . maxsize :
trg = A が sys の maxsize と等しいとき 、
rst = A が sys の maxsize と等しいとき 、 <eos>
3392
src = A = deque ( [ B ] )
trg = ( B ) からなる列 の両端キューを A とする
rst = ( B ) からなる列 の両端キューを A とする <eos>
3393
src = A . stime = A . stime + A . valuelist [ 0 ] [ 1 ]
trg = A の stime に A の valuelist の先頭の 1 番目を加えた値を A の stime に する
rst = A の stime に A の valuelist の先頭の 1 番目を A の stime に する <eos>
3394
src = A = B < C and D [ E ] < D [ B ]
trg = B が C より小さくかつ D の E 番目が D の B 番目より小さいかどうかを A とする
rst = B が C より小さくかつ D の E 番目が D の B 番目より小さいとき 、 <eos>
3395
src = A = [ int ( input ( ) ) for B in range ( C - D ) ]
trg = 0 から C から D を引いた値 未満までの数列の各要素を B とし 、 、 つまり入力された文字列の整数値 の列を A とする
rst = 0 から C から D を引いた値 未満までの数列の各要素を B とし 、 、 つまり入力された文字列の整数値 の列を A とする <eos>
3396
src = A . data [ B ] = A . root ( A . data [ B ] )
trg = A . root ( A . data [ B ] ) を A の data の B 番目に する
rst = A の root の A の data の B 番目番目を A の data の B 番目に する <eos>
3397
src = A [ B [ 1 ] ] . append ( B [ 2 ] )
trg = A の B の 1 番目番目の末尾に B の 2 番目を追加する
rst = A の B の 1 番目番目の末尾に B の 2 番目を追加する <eos>
3398
src = A = ( ( - 1 , 0 ) , ( 1 , 0 ) , ( 0 , - 1 ) , ( 0 , 1 ) , ( 1 , - 1 ) , ( 1 , 1 ) )
trg = ((-1、0) の組 、(1、0) の組 、(0、-1) の組 、(0、1) の組 、(1、-1) の組 、(1、1) の組 ) の組を A とする
rst = ((-1、0) の組 、(1、0) の組 、(0、-1) の組 、(0、1) の組 ) の組を A とする <eos>
3399
src = A , B = - B , A
trg = - B 、 A を A 、 B とする
rst = - B 、 A を A 、 B とする <eos>
3400
src = e = 65535
trg = 65535 をネイピア数とする
rst = 65535 をネイピア数とする <eos>
