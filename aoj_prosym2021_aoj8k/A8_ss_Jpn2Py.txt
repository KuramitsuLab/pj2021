BLEU score = 82.76
epoch = 25
image = 5

| Train Loss: 0.188 | Train PPL:   1.207 |
| Val. Loss: 0.917 |  Val. PPL:   2.502 |
| Test Loss: 0.917 | Test PPL:   2.502 |

0
src = 無限の整数列を 15 で割った余りが 0 と等しいとき 、
trg = if count % 15 == 0 :
rst = if count % 15 == 0 : <eos>
1
src = dfs ( A [0])
trg = dfs ( A [ 0 ] )
rst = dfs ( A [ 0 ] ) <eos>
2
src = A . has _ left () かつ A . left . has _ left () の 間 、 次 を 繰り返 す
trg = while A . has_left ( ) and A . left . has_left ( ) :
rst = while A . has_left ( ) and A . left . y ) : <eos>
3
src = DFS (0,-1)
trg = DFS ( 0 , - 1 )
rst = ( * - 1 ) <eos>
4
src = C を反転した列 に番号付した組の列を順に A 、 B として 、 繰り返 す
trg = for A , B in enumerate ( reversed ( C ) ) :
rst = for A , B in enumerate ( reversed ( C ) ) : <eos>
5
src = A の B に 3 を掛けた値 番目を返す
trg = return A [ B * 3 ]
rst = return A [ B * 3 ] <eos>
6
src = A 内の B の先頭の出現回数が 2 と等しいとき 、
trg = if A . count ( B [ 0 ] ) == 2 :
rst = if A . count ( B [ 0 ] ) == 2 : <eos>
7
src = 空白文字に A を掛けた値 、 B 、 C の B 番目 、 D の B 番目を出力する
trg = print ( ' ' * A , B , C [ B ] , D [ B ] )
rst = print ( ' ' * A , B , C [ B ] , D [ B ] ) <eos>
8
src = A の _ par _ の B 番目が C と等しくまたは A の cdused の C 番目のとき 、
trg = if A . _par_ [ B ] == C or A . cdused [ C ] :
rst = if A . _par_ [ B ] == C or A . sizes [ C ] : <eos>
9
src = 空辞書を A の f _ val _ to _ key に する
trg = A . f_val_to_key = { }
rst = A . <unk> = { = A . <eos>
10
src = 0 、 ( C ) からなる列 の両端キューを A 、 B とする
trg = A , B = 0 , deque ( [ C ] )
rst = A , B = [ 0 , ( C ) ] <eos>
11
src = A を書式として B の C 番目から 13 を引いた値 で整形した文字列を出力する
trg = print ( A . format ( B [ C ] - 13 ) )
rst = print ( A . format ( B [ C ] - 13 ) ) <eos>
12
src = BinaryIndexedTree ( B +1) を A の bit 1 に する
trg = A . bit1 = BinaryIndexedTree ( B + 1 )
rst = A . bit1 = BinaryIndexedTree ( B + 1 ) <eos>
13
src = A に B に C を加えた値に D を加えた値 を追加した集まり
trg = A . add ( B + C + D )
rst = A . add ( B + C + D ) <eos>
14
src = plot ( A + B , C + D )
trg = plot ( A + B , C + D )
rst = <unk> ( A + B , C + D ) <eos>
15
src = A が B の最大値 より小さいとき 、
trg = if A < max ( B ) :
rst = if A < len ( B ) : <eos>
16
src = B の node の value を A とする
trg = A = B . node . value
rst = A = B . node . value <eos>
17
src = 2 から - B の .5 乗の整数値 の 補 数 未満までの数列を順に A として 、 繰り返 す
trg = for A in range ( 2 , - ~ int ( B ** .5 ) ) :
rst = for A in range ( 2 , ( int ( B ** .5 ) ) : <eos>
18
src = A の B から C を引いた値から 1 を引いた値番目が D と等しくないとき 、
trg = if A [ B - C - 1 ] != D :
rst = if A [ B - C - 1 ] != D : <eos>
19
src = i をパラメータとして B を 2 で割った商から i を引いた値の絶対値を返す関数を key として A をソート する
trg = A . sort ( key = lambda C : abs ( B // 2 - C ) )
rst = A . sort ( key = lambda B : B // 2 - 1 ] ) <eos>
20
src = gen ( B , E ) の最大値を D とする を A の B 番目の C 番目に する
trg = A [ B ] [ C ] = D = max ( gen ( B , E ) )
rst = A [ B ] [ C ] = D = max ( B , E ) <eos>
21
src = (0) からなる列の 62 回分の列 、 (0) からなる列の 62 回分の列を A 、 B とする
trg = A , B = [ 0 ] * 62 , [ 0 ] * 62
rst = A , B = [ 0 ] * 1002 , [ 0 ] * 27 <eos>
22
src = A の E の B 番目の末尾に A . Edge ( C ,0, len ( A . E [ C ] )-1) を追加する
trg = A . E [ B ] . append ( A . Edge ( C , 0 , len ( A . E [ C ] ) - 1 ) )
rst = A . E [ B ] . append ( A . Edge ( C , 0 , len ( A . E [ C ] ) - 1 ) ) <eos>
23
src = A . AddNode ( B )
trg = A . AddNode ( B )
rst = A . <unk> ( B ) <eos>
24
src = ( A 、 B 、 C 、 D 、 E 、 空文字列 、 F 、 空文字列 、 G ) からなる列の H 番目を出力する
trg = print ( [ A , B , C , D , E , '' , F , '' , G ] [ H ] )
rst = print ( [ A , B , C , D , E , E , F , F , [ , [ ] ] ) <eos>
25
src = A の data と A の masks の B 番目の論理積が A の masks の B 番目と等しいかどうかを返す
trg = return A . data & A . masks [ B ] == A . masks [ B ]
rst = return A . data & A . masks [ B ] == A . masks [ B ] <eos>
26
src = C の先頭から 1 を引いた値 、 C の 1 番目から 1 を引いた値を A 、 B とする
trg = A , B = C [ 0 ] - 1 , C [ 1 ] - 1
rst = A , B = C [ 0 ] - 1 , C [ 1 ] - 1 <eos>
27
src = A の末尾に ( ( B 、 C ) の組 ) からなる列 を追加する
trg = A . append ( [ ( B , C ) ] )
rst = A . append ( [ ( B , C ) ] ) <eos>
28
src = time を A の 0 を取り出した値 に 60 を掛けた値に A の 0 を取り出した値 を加えた値だけ 増 加 させ る
trg = time += A . pop ( 0 ) * 60 + A . pop ( 0 )
rst = time += ( A . pop ( ) ) * A + pop ( 0 ) <eos>
29
src = A の B 番目と 2 の論理積のとき 、
trg = if A [ B ] & 2 :
rst = if A [ B ] & 2 : <eos>
30
src = ( 1 、10、11、12、13 ) からなる列が A と等しいとき 、
trg = if [ 1 , 10 , 11 , 12 , 13 ] == A :
rst = if [ 1 , 10 , 11 , 12 , 13 == 13 : <eos>
31
src = A 、 B の 1 番目の整数値 内の全ての要素を取り除く
trg = A . clear ( int ( B [ 1 ] ) )
rst = A . append ( int ( B [ 1 ] ) ) <eos>
32
src = par ( A ) が par ( B ) と等しいとき C 、 そうでなければ D を出力する
trg = print ( C if par ( A ) == par ( B ) else D )
rst = print ( C if if ( A ) == ( B ) else D ) <eos>
33
src = A を B の末尾だけ 増 加 させ る
trg = A += B [ - 1 ]
rst = A += B ( B [ - 1 ] ) <eos>
34
src = C の整数値を A の B 番目の right に する
trg = A [ B ] . right = int ( C )
rst = A [ B ] . right = int ( C ) <eos>
35
src = 0 を A の B 番目の C 番目に する
trg = A [ B ] [ C ] = 0
rst = A [ B ] [ C ] = 0 <eos>
36
src = calc _ gcd ( A , B % A ) を返す
trg = return calc_gcd ( A , B % A )
rst = return calc_gcd ( A , B % A ) <eos>
37
src = 2 、 3 を A の先頭 、 A の 1 番目とする
trg = A [ 0 ] , A [ 1 ] = 2 , 3
rst = A [ 0 ] , A [ 1 ] = 2 , 3 <eos>
38
src = "{} {} {} {}" を出力する
trg = print ( {D_1} {D_2} {D_3} {max} )
rst = print ( <unk> <unk> <unk> <unk> <unk> ) <eos>
39
src = B を C で割った値に B を C で割った余り を加えた値の整数値を A とする
trg = A = int ( B / C + B % C )
rst = A = int ( B / C + ( B % C ) ) <eos>
40
src = A の 4 番目を返す
trg = return A [ 4 ]
rst = return A [ 4 ] <eos>
41
src = C を展開し 、 それぞれ A の B 番目の left 、 A の B 番目の right とする
trg = A [ B ] . left , A [ B ] . right = C
rst = A [ B ] . left , A [ B ] . C = C <eos>
42
src = A の B 番目の末尾 を除いた部分列の総和を A の B 番目の -1 番目に する
trg = A [ B ] [ - 1 ] = sum ( A [ B ] [ : - 1 ] )
rst = A [ B ] [ - 1 ] = - ( A [ B ] [ - 1 ] ) [ : - 1 ] ) <eos>
43
src = A の先頭 、 A の 1 番目 、 A の 2 番目の最小値に A の 3 番目 、 A の 4 番目の最小値 を加えた値から 50 を引いた値 を出力する
trg = print ( min ( A [ 0 ] , A [ 1 ] , A [ 2 ] ) + min ( A [ 3 ] , A [ 4 ] ) - 50 )
rst = print ( min ( A [ 0 ] , A [ 1 ] , A [ 2 ] ) , A [ 2 ] ) - min ( 5 ) ) <eos>
44
src = A を書式として B から 1925 を引いた値 、 C 、 D で整形した文字列を返す
trg = return A . format ( B - 1925 , C , D )
rst = return A . format ( B - 1925 , C , D ) <eos>
45
src = ( (0、0、0、0、0) の組 ) からなる列 の両端キューを A とする
trg = A = deque ( [ ( 0 , 0 , 0 , 0 , 0 ) ] )
rst = A = deque ( [ ( 0 , 4 ) ] ) <eos>
46
src = 0 から 3 未満までの数列の各要素を C とし 、 x をパラメータとして D [1] の浮動小数点数 を返す関数をキーとして B の C 番目をソートした列 の 、 つまり先頭から 4 番目までの部分列 の列を A とする
trg = A = [ sorted ( B [ C ] , key = lambda D : float ( D [ 1 ] ) ) [ : 4 ] for C in range ( 3 ) ]
rst = A = [ sorted ( B [ : : ] , key = lambda D : int [ D [ 1 ] , C [ 1 ] ] ) for C in range ( 3 ) ] <eos>
47
src = A の先頭の B から 1 を引いた値番目に 1 を加えた値を A の先頭の B 番目に する
trg = A [ 0 ] [ B ] = A [ 0 ] [ B - 1 ] + 1
rst = A [ 0 ] [ B ] = A [ 0 ] [ B - 1 ] + 1 <eos>
48
src = A に 1 を加えた値が B の C 番目の D 番目の E 番目より小さいとき 、
trg = if A + 1 < B [ C ] [ D ] [ E ] :
rst = if A + 1 < B [ C ] [ D ] [ E ] : <eos>
49
src = A .__ lower _ bound ( B ) を返す
trg = return A . __lower_bound ( B )
rst = return A . <unk> ( B ) <eos>
50
src = C の末尾から 空白改行を取り除いた文字列 を空白文字で分割した字句列 を展開し 、 それぞれ A 、 B とする
trg = A , B = C . rstrip ( ) . split ( ' ' )
rst = A , B = C . rstrip ( ) . split ( ' ' ) <eos>
51
src = _ put ( A . left ) を A の left に する
trg = A . left = _put ( A . left )
rst = A . left = <unk> ( A . left ) <eos>
52
src = A 、 B から C を引いた値から D の E 番目 を引いた値の最小値を A とする
trg = A = min ( A , B - C - D [ E ] )
rst = A = min ( A , B - C - D [ E ] ) <eos>
53
src = A が 0 と等しくかつ B の C 番目が 0 より小さいとき 、
trg = if A == 0 and B [ C ] < 0 :
rst = if A == 0 and B [ C ] < 0 : <eos>
54
src = 整数の 、 つまり先頭から A 番目までの部分列に 整数の A 番目から B 番目までの部分列の 、 つまり先頭から 、 つまり末尾までの -1 間隔による部分列を加えた値に 整数の B 番目から 、 つまり末尾までの部分列を加えた値 を 整数 とする
trg = str = str [ : A ] + str [ A : B ] [ : : - 1 ] + str [ B : ]
rst = str = str [ : A ] + [ : : B : [ : : - 1 ] + str [ B : ] <eos>
55
src = A の B 番目の C に 2 を加えた値番目のとき 、
trg = if A [ B ] [ C + 2 ] :
rst = if A [ B ] [ C + 2 ] : <eos>
56
src = B の vec の C を 2 で割った余り番目を A とする
trg = A = B . vec [ C % 2 ]
rst = A = B . <unk> [ C % 2 ] <eos>
57
src = 2 に B を掛けた値に C を加えた値を 3 で割った値を A とする
trg = A = ( 2 * B + C ) / 3
rst = A = ( 2 * B + C ) / 3 <eos>
58
src = A の末尾に A の末尾に B を加えた値から C を引いた値 を追加する
trg = A . append ( A [ - 1 ] + B - C )
rst = A . append ( A ) - B - C ) <eos>
59
src = - B の dual の C 番目を A とする
trg = A = - B . dual [ C ]
rst = A = - B . dual [ C ] <eos>
60
src = factor () を展開し 、 それぞれ A 、 B とする
trg = A , B = factor ( )
rst = A , B = factor ( ) <eos>
61
src = A の nums の B 番目が C の nums の B 番目と等しくないとき 、
trg = if A . nums [ B ] != C . nums [ B ] :
rst = if A . nums [ B ] != C . nums [ B ] : <eos>
62
src = A の head を A の tail に する
trg = A . tail = A . head
rst = A . tail = A . head <eos>
63
src = A が B の elements の A 番目と等しくない 間 、 次 を 繰り返 す
trg = while A != B . elements [ A ] :
rst = while A != B . elements [ A ] : <eos>
64
src = A を B に B を掛けた値 分の 一 に する
trg = A /= B * B
rst = A /= B * B <eos>
65
src = A の末尾に ( B に C に D を掛けた値を加えた値 、 E に F に D を掛けた値を加えた値 ) の組 を追加する
trg = A . append ( ( B + C * D , E + F * D ) )
rst = A . append ( ( B + C * D , E + F * D ) ) <eos>
66
src = B . sub ( C ) を追加して A を 拡張 する
trg = A . extend ( B . sub ( C ) )
rst = A . extend ( B . Node ( C ) ) <eos>
67
src = ( (-1) からなる列の 0 から B *2 に 1 を加えた値未満までの数列の各要素 を C とし 、 B に 2 を掛けた値に 1 を加えた値の列回分の列 ) からなる列を A とする
trg = A = [ [ - 1 ] * [ ( B * 2 + 1 ) for C in range ( B * 2 + 1 ) ] ]
rst = A = [ [ - 1 ] * [ ( B * 2 + 1 ) for C in range ( B * 2 + 1 ) ] ] <eos>
68
src = A から B に 3600 を掛けた値を引いた値から C に 60 を掛けた値を引いた値を A とする
trg = A = A - B * 3600 - C * 60
rst = A = A - B * 3600 - C * 60 <eos>
69
src = B を A の qtime に する
trg = A . qtime = B
rst = A . pages = B <eos>
70
src = A の絶対値が 0.00001 より小さいとき 、
trg = if abs ( A ) < 0.00001 :
rst = if abs ( A ) < 0.00001 : <eos>
71
src = A の末尾に B の 3 番目の文字列に B の先頭の文字列を加えた値 の整数値を追加する
trg = A . append ( int ( str ( B [ 3 ] ) + str ( B [ 0 ] ) ) )
rst = A . append ( int ( str ( B [ 3 ] ) + str ( B [ 0 ] ) ) <eos>
72
src = 空文字列を間に入れて A の B 番目から C 番目までの部分列 を連結した文字列を出力する
trg = print ( '' . join ( A [ B : C ] ) )
rst = print ( '' . join ( A [ B : C ] ) ) <eos>
73
src = A から 始 まり 0 、 B 、 C 間隔 で 続 く無限の整数列 を出力する
trg = print ( count ( A , 0 , B , C ) )
rst = print ( count ( A , B , C , <unk> ) ) <eos>
74
src = 空列を A の array に する
trg = A . array = [ ]
rst = A . rects = [ ] <eos>
75
src = 0 から C 未満までの数列の各要素を B とし 、 Lst () の列を A の lst に する
trg = A . lst = [ Lst ( ) for B in range ( C ) ]
rst = A . prt = [ ( ( ) for B in range ( C ) ] <eos>
76
src = A の B に C を加えた値番目の末尾に ( B に D を加えた値 、 E の C から D を引いた値から 1 を引いた値番目 ) の組 を追加する
trg = A [ B + C ] . append ( ( B + D , E [ C - D - 1 ] ) )
rst = A [ B + C ] . append ( ( B + D , E [ C - D - 1 ] ) ) <eos>
77
src = setDepth ( A [ B ] . left , C +1)
trg = setDepth ( A [ B ] . left , C + 1 )
rst = setDepth ( A [ B ] . left , C + 1 ) <eos>
78
src = A の B 、 C の最小値番目を 1 だけ 増 加 させ る
trg = A [ min ( B , C ) ] += 1
rst = A [ min ( B , C ) ] += 1 <eos>
79
src = Node ( B , C , D ) を A とする
trg = A = Node ( B , C , D )
rst = A = Node ( B , C , D ) <eos>
80
src = (1、0、2 ) の組を返す
trg = return ( 1 , 0 , 2 )
rst = return ( 0 , 10 ) <eos>
81
src = A の末尾に bmi ( abs ( calc _ BMI ( B , C ) -2 2 ) , D ) を追加する
trg = A . append ( bmi ( abs ( calc_BMI ( B , C ) - 22 ) , D ) )
rst = A . append ( <unk> ( - ( B , C ) - 2 ) , D ) ) <eos>
82
src = A の B から 1 を引いた値から B に C を加えた値から 1 を引いた値までの部分列が ( 、 つまり空白文字 ) からなる列の C 回分の列 と等しくないとき 、
trg = if A [ B - 1 : B + C - 1 ] != [ ' ' ] * C :
rst = if A [ B - 1 - B + C - 1 ] != [ ' ' * C : <eos>
83
src = 1.0 に B を 100.0 で割った値を加えた値の C 乗を A とする
trg = A = ( 1.0 + ( B / 100.0 ) ) ** C
rst = A = ( 1.0 * B / <unk> ) ** C <eos>
84
src = B に 2 を加えた値から B に 10 を加えた値 、 C に 1 を加えた値の最小値 未満までの数列を順に A として 、 繰り返 す
trg = for A in range ( B + 2 , min ( B + 10 , C + 1 ) ) :
rst = for A in range ( B + 2 , min ( 10 + 10 , C + 1 ) ) : <eos>
85
src = B が C から 1 を引いた値より小さいとき D 、 そうでなければ E を A とする
trg = A = D if B < C - 1 else E
rst = A = D if B < C - 1 else E <eos>
86
src = appx ( A )
trg = appx ( A )
rst = <unk> ( A ) <eos>
87
src = A から B 内の 0 の出現回数を引いた値に 1 を加えた値を出力する
trg = print ( A - B . count ( 0 ) + 1 )
rst = print ( A - B . count ( 0 ) + 1 ) <eos>
88
src = reflect ( A , B ) を出力する
trg = print ( reflect ( A , B ) )
rst = print ( reflect ( A , B ) ) <eos>
89
src = UFT () を A とする
trg = A = UFT ( )
rst = A = <unk> ( ) <eos>
90
src = A が 1 と等しくかつ B の先頭が C と等しいとき 、
trg = if A == 1 and B [ 0 ] == C :
rst = if A == 1 and B [ 0 ] == C : <eos>
91
src = A を 5 に B を掛けた値だけ 減 少 させ る
trg = A -= 5 * B
rst = A -= 5 * B <eos>
92
src = ( ( B , 0)、( C , 0 )) からなる辞書を A とする
trg = A = { start : 0 , goal : 0 }
rst = A = { <unk> : 0 , "B" : 0 } <eos>
93
src = A に Edge ( B , C +1,1) を追加した集まり
trg = A . add ( Edge ( B , C + 1 , 1 ) )
rst = A . add ( Edge ( B , C + 1 , 1 ) <eos>
94
src = A . board . solved () でないとき 、
trg = if not A . board . solved ( ) :
rst = if not A . board . solved ( ) : <eos>
95
src = ( 1 に [ AforAinBifA >0 ] の長さ を加えた値 、 C ) からなる列の B の最大値が 2 より小さいかどうか番目を出力する
trg = print ( [ 1 + len ( [ A for A in B if A > 0 ] ) , C ] [ max ( B ) < 2 ] )
rst = print ( [ 1 , [ [ <unk> : - 1 ] [ [ 1 , [ ] , [ B < [ B < 0 ] ) <eos>
96
src = A の 3 番目を B の 3 番目だけ 減 少 させ る
trg = A [ 3 ] -= B [ 3 ]
rst = A [ 3 ] -= B [ 3 ] <eos>
97
src = update ( A , B -1,2)
trg = update ( A , B - 1 , 2 )
rst = update ( A , B , 1 ) <eos>
98
src = B の先頭の 0 番目に B [0] の 1 番目に 3 を掛けた値を加えた値に B の 1 番目の先頭に 9 を掛けた値を加えた値に B の 1 番目の 1 番目に 27 を掛けた値を加えた値を A とする
trg = A = B [ 0 ] [ 0 ] + B [ 0 ] [ 1 ] * 3 + B [ 1 ] [ 0 ] * 9 + B [ 1 ] [ 1 ] * 27
rst = A = B [ 0 ] [ 0 ] + B [ 0 ] [ 1 ] * 3 + B [ 1 ] [ 0 ] * 9 + B [ 1 ] [ 1 ] * 27 <eos>
99
src = A の B 番目 に対応する値 、 もし存在しなければ C 、0 が D の B 番目 に対応する値 、 もし存在しなければ C 、 100 以下 でないとき 、
trg = if not A [ B ] . get ( C , 0 ) <= D [ B ] . get ( C , 100 ) :
rst = if not A [ B ] . get ( C , 0 ) D D B ] ) . get ( C , B ) : <eos>
100
src = A を 3650 で割った余りが 0 と等しいとき 、
trg = if A % 3650 == 0 :
rst = if A % % == 0 : <eos>
101
src = A を B の文字列 だけ 増 加 させ る
trg = A += str ( B )
rst = A += str ( B ) <eos>
102
src = A の char のとき 、
trg = if A . char :
rst = if A . <unk> : <eos>
103
src = write ( A %( B + C - D ))
trg = write ( A % ( B + C - D ) )
rst = write ( A % ( B + C - D ) ) <eos>
104
src = 0 から C 未満までの数列の各要素を D とし 、(( 、 つまり未定値 ) からなる列の 0 から C 未満までの数列の各要素を B とし 、 4 の列回分の列 ) からなる列の列を A とする
trg = A = [ [ [ None ] * [ 4 for B in range ( C ) ] ] for D in range ( C ) ]
rst = A = [ [ [ None ] * [ 4 for B in range ( C ) ] ] for D in range ( C ) ] <eos>
105
src = A から 1 を引いた値が 0 以上かつ B の A から 1 を引いた値番目が C に含まれるとき 、
trg = if A - 1 >= 0 and B [ A - 1 ] in C :
rst = if A - 1 >= 0 and B [ A - 1 ] in C : <eos>
106
src = 0 から C 未満までの数列の各要素を B とし 、 (0) からなる列に入力された文字列 のリストを加えた値に (0) からなる列を加えた値の列を A とする
trg = A = [ [ 0 ] + list ( input ( ) ) + [ 0 ] for B in range ( C ) ]
rst = A = [ [ [ 0 ] + list ( input ( ) ) + [ 0 for B in range ( C ) ] <eos>
107
src = A . setroot (0)
trg = A . setroot ( 0 )
rst = A . <unk> ( 0 ) <eos>
108
src = convert ( A , B , C ) を A とする
trg = A = convert ( A , B , C )
rst = A = convert ( A , B , C ) <eos>
109
src = A を B の 0 番目から C を引いた値 、0 の最大値 だけ 増 加 させ る
trg = A += max ( B [ 0 ] - C , 0 )
rst = A += max ( B [ 0 ] - C , 0 ) <eos>
110
src = B . operator _ func ( A , B . node [ C -1]) を A とする
trg = A = B . operator_func ( A , B . node [ C - 1 ] )
rst = A = B . distance_with_point ( A , B . node [ C - 1 ] ) <eos>
111
src = 真を A の used の B 番目に する
trg = A . used [ B ] = True
rst = A . used [ B ] = True <eos>
112
src = B を A の top _ left に する
trg = A . top_left = B
rst = A . top = B <eos>
113
src = A の right の value が B と等しいとき 、
trg = if A . right . value == B :
rst = if A . right . value == B : <eos>
114
src = A が B の C 番目以下かどうかが D 以下 でないとき 、
trg = if not A <= B [ C ] <= D :
rst = if not A <= B [ C ] <= D : <eos>
115
src = A から B を引いた値が 0 以下のとき 、
trg = if A - B <= 0 :
rst = if A - B <= 0 : <eos>
116
src = B の 2 に C を加えた値番目を A とする
trg = A = B [ 2 + C ]
rst = A = B [ 2 + C ] <eos>
117
src = intime ( A ) または intime ( B ) かつ C が 40 以下のとき 、
trg = if ( intime ( A ) or intime ( B ) ) and C <= 40 :
rst = if <unk> ( A ) or <unk> ( B ) and C <= <= : <eos>
118
src = A の list の B 番目が C の list の B 番目と等しくないとき 、
trg = if A . list [ B ] != C . list [ B ] :
rst = if A . list [ B ] != C . list [ B ] : <eos>
119
src = G の E 個までの コン ビ ネ ー シ ョ ンの各要素を D とし 、0 から F に 1 を加えた値 未満までの数列の列の各要素を E とし 、 ( D の各要素を C とし 、 1<< C の列の総和 、 空白文字を間に入れて D の各要素に str を適用した列を連結した文字列 ) の組の列をソートした列 を順に A 、 B として 、 繰り返 す
trg = for A , B in sorted ( [ ( ( sum ( [ 1 << C for C in D ] ) ) , ' ' . join ( map ( str , D ) ) ) for E in [ range ( F + 1 ) for D in combinations ( G , E ) ] ] ) :
rst = for A , B in sorted ( [ 1 for C , [ D 1 ) ] ) , [ D for D in [ D + 1 ) for D in [ D + 1 ) for E in [ F + 1 ) for D in range (
120
src = get ( A , B , count , C [1])
trg = get ( A , B , count , C [ 1 ] )
rst = get ( A , B , count , C [ 1 ] ) <eos>
121
src = A が全て ア ル ファ ベ ット かつ A が B に含まれないとき 、
trg = if A . isalpha ( ) and A not in B :
rst = if A . isalpha ( ) not A and not in B : <eos>
122
src = B の F 番目の G 番目を E とする
trg = E = B [ F ] [ G ]
rst = E = B [ F ] [ G ] <eos>
123
src = A を B で割った余りが 0 と等しくない 間 、 次 を 繰り返 す
trg = while A % B != 0 :
rst = while A % B != 0 : <eos>
124
src = A の B 番目の末尾に ( 1 を C だけ左シフトした値 、 B に 1 を加えた値 ) の組 を追加する
trg = A [ B ] . append ( ( 1 << C , B + 1 ) )
rst = A [ B ] . append ( ( 1 << C ) , B + 1 ) ) <eos>
125
src = B の長さを 5 で割った余りを A とする
trg = A = len ( B ) % 5
rst = A = len ( B ) % 5 <eos>
126
src = A を term () だけ 増 加 させ る
trg = A += term ( )
rst = A += term ( ) <eos>
127
src = A の B 番目の C 番目が A の B 番目の C に 1 を加えた値番目 と等しいとき 、
trg = if A [ B ] [ C ] == A [ B ] [ C + 1 ] :
rst = if A [ B ] [ C ] == A [ B ] [ C + 1 ] : <eos>
128
src = B の 0 番目を A とする
trg = A = B [ 0 ]
rst = A = B [ 0 ] <eos>
129
src = B に 1 を加えた値から 150 未満までの数列の各要素を C とし 、 1 から 150 未満までの数列の列の各要素を B とし 、 ( B の 2 乗に C の 2 乗を加えた値 、 B 、 C ) の組の列を A とする
trg = A = [ ( B ** 2 + C ** 2 , B , C ) for B in [ range ( 1 , 150 ) for C in range ( B + 1 , 150 ) ] ]
rst = A = [ ( B ** 2 + C , 2 , B , C ) for B in [ range ( 1 , for B in range ( 1 , B ) for C in range ( B + 1 ) ] ] ) <eos>
130
src = D に E の B 番目を掛けた値を C の B 番目とするを A の B 番目に する
trg = A [ B ] = C [ B ] = D * E [ B ]
rst = A [ B ] = C [ D ] = D * E [ B ] <eos>
131
src = B の C 番目を順にネイピア数 、 A として 、 繰り返 す
trg = for e , A in B [ C ] :
rst = for e , A in B [ C ] : <eos>
132
src = B の pt 1 の y 座標に C を B の abs で割った値に B の vector の y 座標を掛けた値を加えた値を A とする
trg = A = B . pt1 . y + C / B . abs * B . vector . y
rst = A = B . pt1 . y * C / B . abs * B . y <eos>
133
src = B の C 番目から 、 つまりネイピア数番目までの部分列 の最小値を A とする
trg = A = min ( B [ C : e ] )
rst = A = min ( B [ C : e ] ) <eos>
134
src = ( (1, 0)、( 2 , 0)、( 3 , 0)、( 4 , 0)、( 5 , 0)、( 6 , 0 )) からなる辞書を A とする
trg = A = { 1 : 0 , 2 : 0 , 3 : 0 , 4 : 0 , 5 : 0 , 6 : 0 }
rst = A = { 1 : 0 , 2 , 3 , 'E' : 0 , 'E' : 0 , <unk> : 0 , <unk> : 0 , 0 : 0 , 0 : 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0
135
src = 入力された文字列 を空白で分割した字句列の各要素に 整数を適用した列のリストを 追加して A を 拡張 する
trg = A . extend ( list ( map ( int , input ( ) . split ( ) ) ) )
rst = A . extend ( list ( map ( int , input ( ) . split ( ) ) ) ) <eos>
136
src = A の末尾に ( B 、 C の B 番目 、 C の D 番目 、 E 、 F ) からなる列 を追加する
trg = A . append ( [ B , C [ B ] , C [ D ] , E , F ] )
rst = A . append ( [ B , C [ B ] , C [ D ] , E , F ] ) <eos>
137
src = ( B 、 C 、 C 、 D に E を加えた値 ) からなる列を A の 、 つまり先頭から 4 番目までの部分列に する
trg = A [ : 4 ] = [ B , C , C , D + E ]
rst = A [ : 4 ] = [ B , C , C , D + E ] <eos>
138
src = A の B 番目から A の B から 1 を引いた値番目を引いた値が 2 と等しいとき 、
trg = if A [ B ] - A [ B - 1 ] == 2 :
rst = if A [ B ] - A [ B - 1 ] == 2 : <eos>
139
src = B の 1 番目を A の s に する
trg = A . s = B [ 1 ]
rst = A . s = B [ 1 ] <eos>
140
src = A の 0 に B の head の next を挿入する
trg = A . insert ( 0 , B . head . next )
rst = A . insert ( 0 , B . head . bit_length ( ) ) <eos>
141
src = F (* B [ C -1]) を A とする
trg = A = F ( * B [ C - 1 ] )
rst = A = F ( * B [ C - 1 ] ) <eos>
142
src = C 、 D に 1 を加えた値の最小値を A の B 番目に する
trg = A [ B ] = min ( C , D + 1 )
rst = A [ B ] = min ( C , D + 1 ) <eos>
143
src = A が B と等しいとき B 、 そうでなければ reflection ( C , D ) を A とする
trg = A = B if A == B else reflection ( C , D )
rst = A = B if B == B else s ( C , D ) <eos>
144
src = A に B を加えた値に C を加えた値を 整数 とする
trg = str = A + B + C
rst = str = A + B + C <eos>
145
src = A を 10 の B 乗で割った余り に する
trg = A %= 10 ** B
rst = A %= 10 ** B <eos>
146
src = ( 0 、-1、1) からなる列を A とする
trg = A = [ 0 , - 1 , 1 ]
rst = A = [ 0 , 0 , 0 , 0 ] <eos>
147
src = A が 1 と等しいとき 0 、 そうでなければ f ( A ,0) を出力する
trg = print ( 0 if A == 1 else f ( A , 0 ) )
rst = if ( 0 if A == 1 else print ( A ) , A ) <eos>
148
src = B から C を引いた値に D から E を引いた値を掛けた値から F から G を引いた値に H から I を引いた値を掛けた値を引いた値を A とする
trg = A = ( B - C ) * ( D - E ) - ( F - G ) * ( H - I )
rst = A = ( B - C ) * ( D - E ) - ( F - G ) * ( H - H ) <eos>
149
src = ( ( B 、 C に 1 を加えた値 ) からなる列 、 ( B 、 C から 1 を引いた値 ) からなる列 、 ( B に 1 を加えた値 、 C ) からなる列 、 ( B から 1 を引いた値 、 C ) からなる列 ) からなる列を A とする
trg = A = [ [ B , C + 1 ] , [ B , C - 1 ] , [ B + 1 , C ] , [ B - 1 , C ] ]
rst = A = [ [ B , C + 1 ] , [ B , C + 1 ] , [ B B + 1 ] , [ B + 1 ] , [ B - 1 ] ] <eos>
150
src = A の B 番目に C を加えた値に D の E 番目を加えた値が A の 1 番目より小さいとき 、
trg = if A [ B ] + C + D [ E ] < A [ 1 ] :
rst = if A [ B ] + C + D [ E ] < A [ 1 ] : <eos>
151
src = B の to を A とする
trg = A = B . to
rst = A = B . to <eos>
152
src = ( ( B 、 C ) からなる列 、 ( D 、 E ) からなる列 、 ( F 、 G ) からなる列 ) からなる列を A とする
trg = A = [ [ B , C ] , [ D , E ] , [ F , G ] ]
rst = A = [ [ B , C ] , [ D , E ] , [ F , G ] ] <eos>
153
src = A の 、 つまり先頭から B 番目までの部分列に A の C 番目から D 番目までの部分列を加えた値に A の 、 つまりネイピア数番目から C 番目までの部分列を加えた値に A の B 番目から 、 つまりネイピア数番目までの部分列 を加えた値に A の D 番目から 、 つまり末尾までの部分列を加えた値 を A とする
trg = A = A [ : B ] + A [ C : D ] + A [ e : C ] + A [ B : e ] + A [ D : ]
rst = A = A [ : B ] + A [ C : D ] + A [ e : C ] + A [ B : e + A [ + : ] <eos>
154
src = C の各要素を A とし 、 A が B の OUTSIDE と等しいかどうかの列が全てが真 のとき 、
trg = if all ( [ A == B . OUTSIDE for A in C ] ) :
rst = if all ( [ A == B . . for for A in C ] ) : <eos>
155
src = B に B を掛けた値から 32769 未満までの B 間隔の数列を順に A として 、 繰り返 す
trg = for A in range ( B * B , 32769 , B ) :
rst = for A in range ( B * B , <unk> , B ) : <eos>
156
src = B を 1 e 5 で割った値を A とする
trg = A = B / 1e5
rst = A = B // 1 <eos>
157
src = 1 e 5 を A とする
trg = A = 1e5
rst = A = <unk> <eos>
158
src = 2 に C を掛けた値に D を加えた値を 3 で割った値 、 2 に E を掛けた値に F を加えた値を 3 で割った値を A 、 B とする
trg = A , B = ( 2 * C + D ) / 3 , ( 2 * E + F ) / 3
rst = A , B = ( 2 * C + D ) / 3 , ( 2 * E + F ) / 3 <eos>
159
src = A . delete ( B [1])
trg = A . delete ( B [ 1 ] )
rst = A . delete ( B [ 1 ] ) <eos>
160
src = A の masks の末尾に B を追加する
trg = A . masks . append ( B )
rst = A . vs . append ( B ) <eos>
161
src = sum _ of _ digits ( A ) を出力する
trg = print ( sum_of_digits ( A ) )
rst = print ( <unk> ( A ) ) <eos>
162
src = A の B から 1 を引いた値番目の C 番目 、 A の B から 1 を引いた値番目の C から 1 を引いた値番目の最大値に A の B 番目の C 番目を加えた値を A の B 番目の C 番目に する
trg = A [ B ] [ C ] = max ( A [ B - 1 ] [ C ] , A [ B - 1 ] [ C - 1 ] ) + A [ B ] [ C ]
rst = A [ B ] [ C ] = A [ B - 1 ] [ C ] , A [ B - 1 ] [ C - 1 ] + A [ B ] [ C ] <eos>
163
src = 0 が A の先頭と等しいとき 、
trg = if ( 0 == A [ 0 ] ) :
rst = if ( 0 == A [ 0 ] ) : <eos>
164
src = A に 0.01 を掛けた値を A とする
trg = A = A * 0.01
rst = A = A * 1.05 <eos>
165
src = 100 から A を引いた値に B の総和 を掛けた値を B の C 番目で割った値の切り 捨 て整数値 を出力する
trg = print ( math . floor ( ( 100 - A ) * sum ( B ) / B [ C ] ) )
rst = print ( math . floor ( 100 - A ) * B ( B ) C ) ) <eos>
166
src = B の par _ size の A 番目を A とする
trg = A = B . par_size [ A ]
rst = A = B . par_size [ A ] <eos>
167
src = A の B 番目の C 番目を A の B から 1 を引いた値番目の D 番目だけ 増 加 させ る
trg = A [ B ] [ C ] += A [ B - 1 ] [ D ]
rst = A [ B ] [ C ] += A [ B - 1 ] [ D ] <eos>
168
src = ((0、0) の組 、(1、 5) の組 、 (2、3) の組 、(3、0) の組 ) の組 を順に A 、 B として 、 繰り返 す
trg = for A , B in ( ( 0 , 0 ) , ( 1 , 5 ) , ( 2 , 3 ) , ( 3 , 0 ) ) :
rst = for A , B in ( ( 0 , 0 ) , ( 0 , 2 ) , ( 3 , ( 0 , 3 ) ) : <eos>
169
src = A から B を引いた値の 2 乗に C から D を引いた値の 2 乗を加えた値を返す
trg = return ( A - B ) ** 2 + ( C - D ) ** 2
rst = return ( A - B ) ** 2 + ( C - D ) ** 2 <eos>
170
src = A 、 B の C 番目の先頭 の最大値を A とする
trg = A = max ( A , B [ C ] [ 0 ] )
rst = A = max ( A , B [ C ] [ 0 ] ) <eos>
171
src = parse _ tag _ structure ( C ,0) を展開し 、 それぞれ A 、 B とする
trg = A , B = parse_tag_structure ( C , 0 )
rst = A , B = <unk> ( C , 0 ) <eos>
172
src = A を長さ 8 に な るように '0' 左 詰め した文字列に B を加えた値を A とする
trg = A = A . zfill ( 8 ) + B
rst = A = A . zfill ( 8 ) + B <eos>
173
src = B と 1 を C だけ左シフトした値の論理和 を A とする
trg = A = B | ( 1 << C )
rst = A = B ^ ( 1 << C ) <eos>
174
src = A . add _ edge ( outC ( B ) , inM ( C ),1)
trg = A . add_edge ( outC ( B ) , inM ( C ) , 1 )
rst = A . add_edge ( <unk> ( B ) , <unk> ( C ) , 1 ) <eos>
175
src = A から B を引いた値が C より大きい 間 、 次 を 繰り返 す
trg = while A - B > C :
rst = while A - B > C : <eos>
176
src = B の C 番目から C に D の長さを加えた値までの部分列 を A とする
trg = A = B [ C : C + len ( D ) ]
rst = A = B [ C : C + len ( D ) ] <eos>
177
src = A の B に 1 を加えた値番目の C に 1 を加えた値番目 、 A の B に 1 を加えた値番目の C 番目を A の B に 1 を加えた値番目の C 番目 、 A の B に 1 を加えた値番目の C に 1 を加えた値番目とする
trg = A [ B + 1 ] [ C ] , A [ B + 1 ] [ C + 1 ] = A [ B + 1 ] [ C + 1 ] , A [ B + 1 ] [ C ]
rst = A [ B + 1 ] [ C + 1 ] [ A + 1 ] = A [ B + 1 ] [ C + 1 ] , A [ B + 1 ] [ C + 1 ] , A [ B + 1 ] [ C ]
178
src = A を B の tree の C 番目だけ 増 加 させ る
trg = A += B . tree [ C ]
rst = A += B . tree [ C ] <eos>
179
src = 関数 dot を self 、 p をパラメータとして 定 義 する
trg = def dot ( A , B ) : return ( A . x * B . x + A . y * B . y )
rst = def x ( A , B ) : return A . x * B . x * A . x * B . x ) <eos>
180
src = 0 から 99 未満までの数列を順に A として 、 繰り返 す
trg = for A in range ( 99 ) :
rst = for A in range ( 0 ) : <eos>
181
src = B の C 番目に 2 を掛けた値から D の C 番目を引いた値を A とする
trg = A = B [ C ] * 2 - D [ C ]
rst = A = B [ C ] * 2 - D [ C ] <eos>
182
src = 円周率の 1 番目の整数値を 円周率の 1 番目に する
trg = pi [ 1 ] = int ( pi [ 1 ] )
rst = e [ int ( 1 ) * 2 ] = int ( pi ) <eos>
183
src = E の D 番目の B 番目を A の B 番目の C から 1 を引いた値から D を引いた値番目に する
trg = A [ B ] [ C - 1 - D ] = E [ D ] [ B ]
rst = A [ B ] [ C - 1 - D ] = E [ D ] [ B ] <eos>
184
src = B の C 番目の先頭を D とする
trg = D = B [ C ] [ 0 ]
rst = D = B [ C ] [ 0 ] <eos>
185
src = A を B に C を加えた値に D を加えた値に 1 を加えた値だけ 増 加 させ る
trg = A += B + C + D + 1
rst = A += B + C + D + 1 <eos>
186
src = A が ( 2 、 2 、1) からなる列と等しいとき 、
trg = if A == [ 2 , 2 , 1 ] :
rst = if A == [ 2 , 2 , 1 ] : <eos>
187
src = datetime 、 2012 、 12、21 の日付に timedelta ( B ) を加えた値を A とする
trg = A = datetime . date ( 2012 , 12 , 21 ) + timedelta ( B )
rst = A = datetime ( <unk> , B , <unk> , <unk> , <unk> ) <eos>
188
src = A が B に C に D を掛けた値を加えた値 より小さいとき 、
trg = if A < B + C * D :
rst = if A < B + C * D : <eos>
189
src = A の末尾に ( B の先頭 、 B の 1 番目 ) の組 を追加する
trg = A . append ( ( B [ 0 ] , B [ 1 ] ) )
rst = A . append ( ( B [ 0 ] , B [ 1 ] ) ) <eos>
190
src = 入力された文字列を空白 文字で分割した字句列の各要素を B とし 、 B の整数値から 1 を引いた値の列を A とする
trg = A = [ int ( B ) - 1 for B in input ( ) . split ( ' ' ) ]
rst = A = [ int ( B ) - 1 for B in input ( ) . split ( ' ' ) ] <eos>
191
src = B を 60 に 60 を掛けた値で割った商を A とする
trg = A = B // ( 60 * 60 )
rst = A = B // ( 60 * 60 ) <eos>
192
src = Node (1) を A とする
trg = A = Node ( 1 )
rst = A = Node ( 1 ) <eos>
193
src = 0 から 2 未満までの数列の各要素を C とし 、 、 つまり入力された文字列 の整数値の列を展開し 、 それぞれ A 、 B とする
trg = A , B = [ int ( input ( ) ) for C in range ( 2 ) ]
rst = A , B = [ int ( input ( ) ) for C in range ( 2 ) ] <eos>
194
src = A の weight の B 番目を A の weight の A の par の B 番目番目だけ 増 加 させ る
trg = A . weight [ B ] += A . weight [ A . par [ B ] ]
rst = A . weight [ B ] += A . weight [ A . par [ B ] ] <eos>
195
src = bfs () を出力する
trg = print ( bfs ( ) )
rst = print ( bfs ( ) ) <eos>
196
src = A の整数値 、 B の整数値を出力する
trg = print ( int ( A ) , int ( B ) )
rst = print ( int ( A ) , int ( B ) ) <eos>
197
src = B から C を引いた値から B 未満までの数列を順に A として 、 繰り返 す
trg = for A in range ( B - C , B ) :
rst = for A in range ( B - C , B ) : <eos>
198
src = ネイピア数の 0 番目が 、 つまりネイピア数の 1 番目と等しくなくかつ 、 つまりネイピア数の 1 番目が 、 つまりネイピア数の 2 番目と等しくなくかつ 、 つまりネイピア数の 2 番目が 、 つまりネイピア数の先頭 と等しくないとき 、
trg = if e [ 0 ] != e [ 1 ] and e [ 1 ] != e [ 2 ] and e [ 2 ] != e [ 0 ] :
rst = if e [ 0 ] != e [ 1 ] and e != e [ e ] != e [ 2 ] != e [ e ] != e [ : ] != e ] : <eos>
199
src = A が 2 の B から 1 を引いた値から C を引いた値乗 より小さいとき 、
trg = if A < 2 ** ( B - 1 - C ) :
rst = if A < 2 ** ( B - 1 - C ) : <eos>
200
src = B の C 番目の 3 番目を順に A として 、 繰り返 す
trg = for A in B [ C ] [ 3 ] :
rst = for A in B [ C ] [ 3 ] : <eos>
201
src = 空文字列を間に入れて A を連結した文字列を返す
trg = return '' . join ( A )
rst = return '' . join ( A ) <eos>
202
src = D の各値を x をパラメータとして B の 0 番目が C より大きいかどうかを返す 関数で フ ィ ルターした列のリスト を A とする
trg = A = list ( filter ( lambda B : B [ 0 ] > C , D ) )
rst = A = list ( filter ( lambda B : B [ 0 ] > C , D ) ) <eos>
203
src = 入力された文字列 を空白で分割した字句列の各要素に 整数を適用した列のリスト の先頭を除いた部分列 を順に A として 、 繰り返 す
trg = for A in list ( map ( int , input ( ) . split ( ) ) ) [ 1 : ] :
rst = for A in sorted ( map ( int , input ( ) . split ( ) ) ) [ 1 : ] : <eos>
204
src = ( A の先頭 、 A の 1 番目 、 A [0] に 1 を加えた値 、 A の 1 番目 ) の組が B に含まれなくかつ ( A [0] に 1 を加えた値 、 A の 1 番目 、 A の先頭 、 A の 1 番目 ) の組が B に含まれなくかつ A の 0 番目に 1 を加えた値が C 以下のとき 、
trg = if ( A [ 0 ] , A [ 1 ] , A [ 0 ] + 1 , A [ 1 ] ) not in B and ( A [ 0 ] + 1 , A [ 1 ] , A [ 0 ] , A [ 1 ] ) not in B and A [ 0 ] + 1 <= C :
rst = if ( A [ 0 ] , A [ 1 ] , A ) 0 ] , A ) 1 ] ) ) ) not in A [ 0 ] , B [ 0 ] + A [ 0 ] + B [ 0 ] , A [ 0 ]
205
src = 2 進 表 記 、 つまり空文字列を間に入れて A の逆順を連結した文字列の整数値 を出力する
trg = print ( int ( '' . join ( A [ : : - 1 ] ) , 2 ) )
rst = print ( ' . join ( A [ : : - 1 ] ) <eos>
206
src = pp () を展開し 、 それぞれ A 、 B とする
trg = A , B = pp ( )
rst = A , B = <unk> ( ) <eos>
207
src = 無限の整数列の総和 から 、 つまり無限の整数列 の最大値を引いた値 を出力する
trg = print ( sum ( count ) - max ( count ) )
rst = print ( max ( <unk> , count ) ) <eos>
208
src = 偽を A の explored _ dict の B 番目に する
trg = A . explored_dict [ B ] = False
rst = A . explored_dict [ B ] = False <eos>
209
src = A を 2 で割った商を A とする
trg = A = A // 2
rst = A = A // 2 <eos>
210
src = A が B の size に B の size から 1 を引いた値を掛けた値 より小さいとき 、
trg = if A < B . size * ( B . size - 1 ) :
rst = if A < B . size + B . size - 1 ) : <eos>
211
src = A を B で割った商を ネイピア数とする
trg = e = A // B
rst = e = A // B <eos>
212
src = A が 0 と等しくまたは A が B から 1 を引いた値と等しくまたは C が 0 と等しくまたは C が D から 1 を引いた値と等しいとき 、
trg = if A == 0 or A == B - 1 or C == 0 or C == D - 1 :
rst = if A == 0 or A == B - 1 or C == 0 or C == D - 1 : <eos>
213
src = A の 1 番目の B 番目の末尾に ( C 、 D ) の組 を追加する
trg = A [ 1 ] [ B ] . append ( ( C , D ) )
rst = A [ 1 ] [ B ] . append ( ( C , D ) ) <eos>
214
src = A の - B に 1 を加えた値番目が C と等しいとき 、
trg = if A [ - ( B + 1 ) ] == C :
rst = if A [ - B + 1 ] == C : <eos>
215
src = 0 から 2 の D 乗未満までの数列の各要素を E とし 、0 から D 未満までの数列の各要素を C とし 、 B の列の列を A とする
trg = A = [ [ B for C in range ( D ) ] for E in range ( 2 ** D ) ]
rst = A = [ [ B for C in range ( D ) ] for E in range ( 2 ** D ) ] <eos>
216
src = ( A 、 B の先頭を除いた部分列の総和 ) の組を返す
trg = return ( A , sum ( B [ 1 : ] ) )
rst = return ( min ( A , B [ 1 : ] ) ) <eos>
217
src = A に B を加えた値を 1 だけ右シフトした値 を出力する
trg = print ( ( A + B ) >> 1 )
rst = print ( ( A + B ) >> 1 ) <eos>
218
src = A の primeFactorization に対応する値 、 もし存在しなければ 1 、0 が 1 と等しいとき 、
trg = if A . primeFactorization . get ( 1 , 0 ) == 1 :
rst = if A . height . get ( 1 , 0 ) == 1 : <eos>
219
src = A の 1 番目の 0 番目から A の先頭の 0 番目を引いた値に A [1][1] が A [0][1] より大きくまたは A [1][1] == A [0][1] かつ A [1] [2]> A [0] [2] のとき 1 、 そうでなければ 0 を加えた値を出力する
trg = print ( A [ 1 ] [ 0 ] - A [ 0 ] [ 0 ] + ( 1 if A [ 1 ] [ 1 ] > A [ 0 ] [ 1 ] or ( A [ 1 ] [ 1 ] == A [ 0 ] [ 1 ] and A [ 1 ] [ 2 ] > A [ 0 ] [ 2 ] ) else 0 ) )
rst = print ( 1 [ 1 ] [ 0 ] - A [ 0 ] [ 0 ] + A [ 0 ] [ 0 ] ) A [ 0 ] [ 0 ] == A [ 0 ] [ 0 ] == A [ 0 ] [ 0 ] ==
220
src = A から B に C から 10 を引いた値に 125 を掛けた値を加えた値を引いた値 を出力する
trg = print ( A - ( B + ( C - 10 ) * 125 ) )
rst = print ( A - B + ( C - 10 ) * 125 ) <eos>
221
src = A の B 番目の末尾に ( C 、 D の B 番目の C 番目 ) の組 を追加する
trg = A [ B ] . append ( ( C , D [ B ] [ C ] ) )
rst = A [ B ] . append ( ( C , D [ B ] [ C ] ) <eos>
222
src = A の 1 番目に 1 を加えた値を B の 1 番目とするを A の 1 番目に する
trg = A [ 1 ] = B [ 1 ] = A [ 1 ] + 1
rst = A [ 1 ] = B [ 1 ] = A [ 1 ] + 1 <eos>
223
src = Segment ( B , C , D , E ) を A とする
trg = A = Segment ( B , C , D , E )
rst = A = Segment ( B , C , D , E ) <eos>
224
src = 偽を A の 1 番目に する
trg = A [ 1 ] = False
rst = A [ 1 ] = False <eos>
225
src = 入力された文字列 を空白で分割した字句列の各要素に 整数を適用した列を展開し 、 それぞれ A 、 B 、 C とする
trg = A , B , C = map ( int , input ( ) . split ( ) )
rst = A , B , C = map ( int , input ( ) . split ( ) ) <eos>
226
src = time の 3 番目から time の先頭を引いた値を A とする
trg = A = time [ 3 ] - time [ 0 ]
rst = A = time [ 3 ] - time [ 0 ] <eos>
227
src = ネイピア数の整数値を ネイピア数とする
trg = e = int ( e )
rst = e = Counter ( ) <eos>
228
src = andrew ( A )
trg = andrew ( A )
rst = <unk> ( A ) <eos>
229
src = A の 1 番目の整数値が B 以下のとき 、
trg = if int ( A [ 1 ] ) <= B :
rst = if int ( A [ 1 ] ) <= B : <eos>
230
src = C の D から 1 を引いた値番目 の末尾を展開し 、 それぞれ A 、 B とする
trg = A , B = C [ D - 1 ] [ - 1 ]
rst = A , B = map ( int , C [ D - 1 ] ) <eos>
231
src = -10 の 18 乗を B とする を A とする
trg = A = B = - 10 ** 18
rst = A = B = - 10 ** 18 <eos>
232
src = A の B 番目の C 番目かつ D の B 番目の C 番目でないとき 、
trg = if A [ B ] [ C ] and not D [ B ] [ C ] :
rst = if A [ B ] [ C ] and not D [ B ] [ C ] : <eos>
233
src = 1 を B の maxcap のビット長 から 1 を引いた値だけ左シフトした値 を A とする
trg = A = 1 << ( B . maxcap . bit_length ( ) - 1 )
rst = A = 1 << ( B . . . bit_length ( ) - 1 ) <eos>
234
src = 0 から 、 つまり入力された文字列の整数値 未満までの数列の各要素を C とし 、 ch ( B , int ( input ())) の列を A とする
trg = A = [ ch ( B , int ( input ( ) ) ) for C in range ( int ( input ( ) ) ) ]
rst = A = [ <unk> ( B , int ( input ( ) ) ) for C in range ( int ( input ( ) ) ) ] <eos>
235
src = time に番号付した組の列を順に A 、 B として 、 繰り返 す
trg = for A , B in enumerate ( time ) :
rst = for A , B in enumerate ( time ) : <eos>
236
src = A が B の size の C 番目より小さいとき 、
trg = if A < B . size [ C ] :
rst = if A < B . size [ C ] : <eos>
237
src = expr () を返す
trg = return expr ( )
rst = return expr ( ) <eos>
238
src = A の 階 乗を B の 階 乗で割った商を A から B を引いた値の 階 乗で割った商 を返す
trg = return math . factorial ( A ) // math . factorial ( B ) // math . factorial ( A - B )
rst = return factorial ( A ) // factorial ( B ) // factorial ( A - B ) <eos>
239
src = B の 0 番目に C を加えた値を A とする
trg = A = B [ 0 ] + C
rst = A = B [ 0 ] + C <eos>
240
src = ( A 、 B から 1 を引いた値から C を引いた値 ) の組を返す
trg = return ( A , B - 1 - C )
rst = return ( A , B - 1 - C ) <eos>
241
src = A の _ size が 、 つまり未定値と等しいとき 、
trg = if A . _size is not None :
rst = if A . _size == None : <eos>
242
src = A の data を A の masks の B 番目と の排他 的 論理和に する
trg = A . data ^= ( A . masks [ B ] )
rst = A . data |= A . masks [ B ] <eos>
243
src = 空辞書 、 空列を A 、 B とする
trg = A , B = { } , [ ]
rst = A , B = { [ , 1 ] <eos>
244
src = A を 100 で割った余りが 0 と等しいとき 、
trg = if A % 100 == 0 :
rst = if A % 100 == 0 : <eos>
245
src = A の root が 、 つまり未定値と等しく なければ な らな い
trg = assert A . root is not None
rst = assert A . root is not None <eos>
246
src = C の末尾 を順に A 、 B 、 B として 、 繰り返 す
trg = for A , B , B in C [ - 1 ] :
rst = for A , B , B in C [ - 1 ] : <eos>
247
src = _ set _ range (0,0, A . size //2, A . DIVIDED )
trg = _set_range ( 0 , 0 , A . size // 2 , A . DIVIDED )
rst = _set_range ( 0 , 0 , A . size // 2 , A . number ) <eos>
248
src = 0 から C 未満までの数列の各要素を B とし 、 B に 1 を加えた値の列を A とする
trg = A = [ B + 1 for B in range ( C ) ]
rst = A = [ B + 1 for B in range ( C ) ] <eos>
249
src = B 、 C 、 D に 2 を掛けた値 、 E 、 C 、 F を追加して A を 更新 する
trg = A . update ( B , C , D * 2 , E , C , F )
rst = A . update ( B , C , D * 2 , E , C , F ) <eos>
250
src = A 、 B の C 番目の D に 1 を加えた値番目から E の D に 1 を加えた値番目の F に 1 を加えた値番目 を引いた値の最大値を A とする
trg = A = max ( A , B [ C ] [ D + 1 ] - E [ D + 1 ] [ F + 1 ] )
rst = A = max ( A , B [ C ] [ D + 1 ] - E [ D + 1 ] [ F + 1 ] ) <eos>
251
src = 1 を B に 1 を加えた値 だけ左シフトした値を A とする
trg = A = 1 << ( B + 1 )
rst = A = 1 << ( B + 1 ) <eos>
252
src = A に 1 1 を加えた値を返す
trg = return A + 11
rst = return A + 11 <eos>
253
src = A の Node ( int ( B [1]) , None , None ) に [ MASK ] を挿入する
trg = A . insert ( Node ( int ( B [ 1 ] ) , None , None ) )
rst = A . Node ( int ( B [ 1 ] , None , None ) ) <eos>
254
src = pyon ( A ,0, B , C , D ) を出力する
trg = print ( pyon ( A , 0 , B , C , D ) )
rst = print ( <unk> ( A , 0 , B , C , D ) ) <eos>
255
src = quick _ sort ( A ,0, B -1)
trg = quick_sort ( A , 0 , B - 1 )
rst = <unk> ( A , 0 , B - 1 ) <eos>
256
src = (0) からなる列に 0 から C 未満までの数列の各要素を B とし 、 、 つまり入力された文字列の整数値 の列をソートした列 を加えた値を A とする
trg = A = [ 0 ] + sorted ( [ int ( input ( ) ) for B in range ( C ) ] )
rst = A = [ 0 ] + [ int ( input ( ) ) for B in range ( C ) ] <eos>
257
src = A 、 B の C 番目の D 番目の先頭 、 B の C 番目の D 番目の 1 番目 、 B の C 番目の D 番目の 2 番目 、 B の C 番目の D 番目の 3 番目の最大値を A とする
trg = A = max ( A , B [ C ] [ D ] [ 0 ] , B [ C ] [ D ] [ 1 ] , B [ C ] [ D ] [ 2 ] , B [ C ] [ D ] [ 3 ] )
rst = A = max ( A , B [ C ] [ D ] [ 0 ] , B [ C ] [ D ] [ 1 ] , B [ C ] [ D ] [ D ] [ B ] [ 2 ] , B [ C ] [
258
src = E に 1 を加えた値から F 未満までの数列の各要素を B とし 、 A の B 番目の C に 1 を加えた値から D 番目までの部分列の総和の列の総和
trg = sum ( [ sum ( A [ B ] [ C + 1 : D ] ) for B in range ( E + 1 , F ) ] )
rst = [ print ( A [ B ] [ C + 1 ] - D ) for B in range ( E + 1 , F ) ] ) <eos>
259
src = 0 から D 未満までの数列の各要素を C とし 、 B の C 番目の 1 番目から B の C 番目の 0 番目 を引いた値の列の総和を A とする
trg = A = sum ( [ B [ C ] [ 1 ] - B [ C ] [ 0 ] for C in range ( D ) ] )
rst = A = sum ( [ B [ C ] [ 1 ] - B [ C ] [ 0 ] for C in range ( D ) ] ) <eos>
260
src = (0) からなる列の B 回分の列を A の weights に する
trg = A . weights = [ 0 ] * B
rst = A . weights = [ 0 ] * B <eos>
261
src = A が B に 1 を加えた値 と等しくない 間 、 次 を 繰り返 す
trg = while A != B + 1 :
rst = while A != ( B + 1 ) : <eos>
262
src = os . path の B 番目の 1 番目の 、 つまり先頭から path の B 番目の 1 番目の C と等しい要素の最初の位置に 1 を加えた値までの部分列を A とする
trg = A = path [ B ] [ 1 ] [ : path [ B ] [ 1 ] . index ( C ) + 1 ]
rst = A = path [ B ] [ 1 ] [ : : path [ B ] [ 1 ] + index ( C ) + 1 ] <eos>
263
src = A でないとき B 、 そうでなければ A を A とする
trg = A = B if not A else A
rst = A = B if A else A <eos>
264
src = A の末尾に入力された文字列 を空白で分割した字句列の各要素に 整数を適用した列の組 を追加する
trg = A . append ( tuple ( map ( int , input ( ) . split ( ) ) ) )
rst = A . append ( tuple ( map ( int , input ( ) . split ( ) ) ) ) <eos>
265
src = 0 から B に 1 を加えた値未満までの数列を順に A として 、 繰り返 す
trg = for A in range ( B + 1 ) :
rst = for A in range ( B + 1 ) : <eos>
266
src = 0 から 200 未満までの数列の各要素を B とし 、 、 つまり空列の列を A とする
trg = A = [ [ ] for B in range ( 200 ) ]
rst = A = [ [ ] for B in range ( 200 ) ] <eos>
267
src = n をパラメータとして B **2 に B を加えた値に 2 を加えた値を 2 で割った値の整数値 を返す関数を A とする
trg = A = lambda B : int ( ( B ** 2 + B + 2 ) / 2 )
rst = A = lambda B : int ( B ** 2 + ( 2 + 2 ) / 2 ) <eos>
268
src = - B の y 座標を A とする
trg = A = - B . y
rst = A = - B . y <eos>
269
src = ( ( B , D のキーと値の集まりの各要素を B 、 C とし 、 C を 10007 で割った余りの列 )) からなる辞書の 辞書 カ ウ ンタを A とする
trg = A = Counter ( { k : [ C % 10007 for B , C in D . items ( ) ] } )
rst = A = Counter Counter Counter ( [ [ : C , D for B , C in D . items ( ) ] ) ) <eos>
270
src = A . add _ edge ( B + C , D + 1,1,0)
trg = A . add_edge ( B + C , D + 1 , 1 , 0 )
rst = A . add_edge ( B + C , D + 1 , 1 , 0 ) <eos>
271
src = A を B を 2 で割った余りだけ 増 加 させ る
trg = A += B % 2
rst = A += B % 2 <eos>
272
src = ( A / B の切り 上 げ 整数値に C を掛けた値 、 A / D の切り 上 げ 整数値に E を掛けた値 ) からなる列 の最小値 を出力する
trg = print ( min ( [ math . ceil ( A / B ) * C , math . ceil ( A / D ) * E ] ) )
rst = print ( min ( math . ceil ( ( A / B ) * math . ceil ( C / A ) / * math . ceil ( D ) E ) ] ) ) <eos>
273
src = A の末尾に B の hldnxt の C 番目を追加する
trg = A . append ( B . hldnxt [ C ] )
rst = A . append ( B . hldnxt [ C ] ) <eos>
274
src = heappush ( A , ( B +1, C , D , E ))
trg = heappush ( A , ( B + 1 , C , D , E ) )
rst = heappush ( A , ( B + 1 , C , D , E ) ) <eos>
275
src = 0 が A を 2 で割った余り と等しいとき 、
trg = if 0 == A % 2 :
rst = if ( 0 == A % 2 ) : <eos>
276
src = get _ interest 1 ( B , C ) を A とする
trg = A = get_interest1 ( B , C )
rst = A = <unk> ( B , C ) <eos>
277
src = 0 から B の C 番目の先頭 未満までの数列を順に A として 、 繰り返 す
trg = for A in range ( B [ C ] [ 0 ] ) :
rst = for A in range ( B [ C ] [ 0 ] ) : <eos>
278
src = pd を A の整数値に 1 を加えた値 倍 に する
trg = pd *= int ( A ) + 1
rst = A *= int ( A ) + 1 <eos>
279
src = A 、 B の C の D 番目番目の E の D 番目番目の 1 番目の最小値を A とする
trg = A = min ( A , B [ C [ D ] ] [ E [ D ] ] [ 1 ] )
rst = A = min ( A , B [ C [ D ] ] [ E [ D ] ] [ 1 ] ) <eos>
280
src = A の 、 つまりネイピア数番目の B 番目が C より大きいとき 、
trg = if A [ e ] [ B ] > C :
rst = if A [ e ] [ B ] > C : <eos>
281
src = dfs ( A , B +1, C )
trg = dfs ( A , B + 1 , C )
rst = dfs ( A , B + 1 , C ) <eos>
282
src = gengo ( A , B , C ) を出力する
trg = print ( gengo ( A , B , C ) )
rst = print ( <unk> ( A , B , C ) ) <eos>
283
src = A の B から 1 を引いた値番目が C の D から 1 を引いた値番目と等しいとき 、
trg = if A [ B - 1 ] == C [ D - 1 ] :
rst = if A [ B - 1 ] == C [ D - 1 ] : <eos>
284
src = B の 2 番目を A の B の 1 番目番目の B の先頭番目に する
trg = A [ B [ 1 ] ] [ B [ 0 ] ] = B [ 2 ]
rst = A [ B [ 1 ] ] [ B [ 0 ] ] = B [ 2 ] <eos>
285
src = A 、 dfs ( B , C ) に 1 を加えた値の最大値を A とする
trg = A = max ( A , dfs ( B , C ) + 1 )
rst = A = max ( A , dfs ( B , C ) + 1 ) <eos>
286
src = D の 3 番目の各要素を C とし 、 D の 2 番目の列の各要素を B とし 、 B に C を加えた値の列を A とする
trg = A = [ B + C for B in [ D [ 2 ] for C in D [ 3 ] ] ]
rst = A = [ B + C for B in [ D [ 2 ] for C in D [ 3 ] ] ] <eos>
287
src = A の B の C と等しい要素の最初の位置番目 を出力する
trg = print ( A [ B . index ( C ) ] )
rst = print ( A [ B . index ( C ) ] ) <eos>
288
src = D の先頭を A の B 番目の C 番目に する
trg = A [ B ] [ C ] = D [ 0 ]
rst = A [ B ] [ C ] = D [ 0 ] <eos>
289
src = 無限の整数列が 10000 と等しいとき 、
trg = if count == 10000 :
rst = if count == 10000 : <eos>
290
src = 5.0 に A を掛けた値から 5.0 を引いた値を返す
trg = return 5.0 * A - 5.0
rst = return ( * A - ) <eos>
291
src = write ( A %( sum ( dfs ( B ))% C ))
trg = write ( A % ( sum ( dfs ( B ) ) % C ) )
rst = write ( A % ( ( ( B ) // C ) ) <eos>
292
src = A から B を引いた値が 0 以上かつ C から B を引いた値が 0 以上のとき 、
trg = if A - B >= 0 and C - B >= 0 :
rst = if A - B >= 0 and C - B >= 0 : <eos>
293
src = A の B の C に 1 を加えた値番目番目を 1 だけ 増 加 させ る
trg = A [ B [ C + 1 ] ] += 1
rst = A [ B [ C + 1 ] ] += 1 <eos>
294
src = A の B 番目に A の C 番目を加えた値が D 以下のとき 、
trg = if A [ B ] + A [ C ] <= D :
rst = if A [ B ] + A [ C ] <= D : <eos>
295
src = ( A の B 番目 、 A の B から 2 を引いた値番目 ) の組が (1、1) の組と等しいとき 、
trg = if ( A [ B ] , A [ B - 2 ] ) == ( 1 , 1 ) :
rst = if ( A [ B ] , A [ B - 2 ] ) == ( 1 , 1 ) : <eos>
296
src = A の末尾に B の 各要素に整数を適用した列のリスト を追加する
trg = A . append ( list ( map ( int , B ) ) )
rst = A . append ( list ( map ( int , B ) ) ) <eos>
297
src = A 、 B に 1 を加えた値の最大値を A とする
trg = A = max ( A , B + 1 )
rst = A = max ( A , B + 1 ) <eos>
298
src = C の 、 つまり先頭から 、 つまり末尾までの部分列 、 C の 1 番目から 、 つまり末尾までの部分列に ( C の先頭 ) からなる列を加えた値 の要素をそれぞれ組にした列を順に A 、 B として 、 繰り返 す
trg = for A , B in zip ( C [ 0 : ] , C [ 1 : ] + [ C [ 0 ] ] ) :
rst = for A , B in zip ( C [ : : ] , C [ 1 : ] + C [ 0 ] ] ) : <eos>
299
src = A の 、 つまりネイピア数番目が 0 より小さいとき 、
trg = if A [ e ] < 0 :
rst = if A [ e ] < 0 : <eos>
300
src = 1868 に B を加えた値から 1 を引いた値の文字列を A とする
trg = A = str ( 1868 + B - 1 )
rst = A = str ( 1868 + B - 1 ) <eos>
301
src = A の末尾に B に入力された文字列を加えた値に B を加えた値 を追加する
trg = A . append ( B + input ( ) + B )
rst = A . append ( B + input ( ) + B ) <eos>
302
src = A が 25 に B を掛けた値に B を掛けた値から C を引いた値 より大きいとき 、
trg = if A > 25 * B * B - C :
rst = if A > 25 * B * B - C : <eos>
303
src = A の末尾に ( B 、 C にネイピア数の weight を加えた値 ) の組 を追加する
trg = A . append ( ( B , C + e . weight ) )
rst = A . append ( ( B , C + e + ) ) <eos>
304
src = B ._ convert _ left ( A ) を A とする
trg = A = B . _convert_left ( A )
rst = A = B . <unk> ( A ) <eos>
305
src = 入力された文字列を D で分割した字句列の各要素に 整数を適用した列を展開し 、 それぞれ A 、 B 、 C とする
trg = A , B , C = map ( int , input ( ) . split ( D ) )
rst = A , B , C = map ( int , input ( ) . split ( D ) ) <eos>
306
src = A の B 番目の末尾に 3 に C を掛けた値に D を加えた値 を追加する
trg = A [ B ] . append ( 3 * C + D )
rst = A [ B ] . append ( 3 * C + D ) <eos>
307
src = 2 を 3 で割った値に B の 0 番目を掛けた値に 1 を 3 で割った値に C の先頭を掛けた値を加えた値を A とする
trg = A = 2 / 3 * B [ 0 ] + 1 / 3 * C [ 0 ]
rst = A = 2 / 3 * B [ 0 ] + 1 / 3 * C [ 0 ] <eos>
308
src = A . set ( B )
trg = A . set ( B )
rst = A . set ( B ) <eos>
309
src = A が 18680908 より小さいとき 、
trg = if A < 18680908 :
rst = if A < <unk> : <eos>
310
src = A の B 番目を ( A の B 番目の総和 ) からなる列 だけ 増 加 させ る
trg = A [ B ] += [ sum ( A [ B ] ) ]
rst = A [ B ] += [ sum ( A [ B ] ) ] <eos>
311
src = ネイピア数を展開し 、 それぞれ A 、 B 、 C 、 D とする
trg = A , B , C , D = e
rst = A , B , C , D = e <eos>
312
src = (0) からなる列の 5 から A の長さを引いた値に A を加えた値回分の列を A とする
trg = A = [ 0 ] * ( 5 - len ( A ) ) + A
rst = A = [ 0 ] * ( 5 - len ( A ) ) + A <eos>
313
src = sys の stdin の各要素を A とし 、 A の整数値の列の総和 を出力する
trg = print ( sum ( [ int ( A ) for A in sys . stdin ] ) )
rst = print ( sum ( [ int ( A ) for A in sys . stdin ] ) ) <eos>
314
src = spin ( A ) を A とする
trg = A = spin ( A )
rst = A = spin ( A ) <eos>
315
src = D の各要素を B とし 、 decode ( B , C ) の列を A とする
trg = A = [ decode ( B , C ) for B in D ]
rst = A = [ affine ( B , C ) for B in D ] <eos>
316
src = A に B を掛けた値に C を掛けた値が 0 と等しいとき 、
trg = if A * B * C == 0 :
rst = if A * B * C == 0 : <eos>
317
src = 0 から B から C を引いた値から 1 を引いた値未満までの数列を順に A として 、 繰り返 す
trg = for A in range ( B - C - 1 ) :
rst = for A in range ( B - C - 1 ) : <eos>
318
src = B を A の right _ node _ no に する
trg = A . right_node_no = B
rst = A . <unk> = B <eos>
319
src = B から C から 1 を引いた値に 1 を加えた値未満までの数列を順に A として 、 繰り返 す
trg = for A in range ( B , C - 1 + 1 ) :
rst = for A in range ( B , C - 1 ) + 1 ) : <eos>
320
src = A の B 番目かつ A の B から 2 を引いた値番目のとき 、
trg = if A [ B ] and A [ B - 2 ] :
rst = if A [ B ] and A [ B - 2 ] : <eos>
321
src = A の 2 番目が A の 0 番目に A の 1 番目を加えた値 より小さいとき 、
trg = if A [ 2 ] < A [ 0 ] + A [ 1 ] :
rst = if A [ 2 ] < A [ 0 ] + A [ 1 ] : <eos>
322
src = A に 1 を加えた値 の 階 乗に 2 を加えた値を出力する
trg = print ( math . factorial ( A + 1 ) + 2 )
rst = print ( math ( A + 1 ) ** 2 + 2 ) <eos>
323
src = 3 から B に 1 を加えた値 の平方根の切り 上 げ 整数値未満までの 2 間隔の数列を順に A として 、 繰り返 す
trg = for A in range ( 3 , math . ceil ( math . sqrt ( B + 1 ) ) , 2 ) :
rst = for A in range ( 3 , math . ceil ( B + 1 ) ) 2 ) : <eos>
324
src = A を B から 2 を引いた値で割った商 を出力する
trg = print ( A // ( B - 2 ) )
rst = print ( A // ( B - 2 ) ) <eos>
325
src = A を ( B の C 番目の先頭 、 B の C 番目の 1 番目 ) の組 の D が C と等しいかどうか番目 倍 に する
trg = A *= ( B [ C ] [ 0 ] , B [ C ] [ 1 ] ) [ D == C ]
rst = A *= ( B [ C ] [ 0 ] , B [ C ] [ 1 ] ) <eos>
326
src = A . flip ( int ( B [1]))
trg = A . flip ( int ( B [ 1 ] ) )
rst = A . flip ( int ( B [ 1 ] ) ) <eos>
327
src = cross 3( A [-2], A [-1], e ) の絶対値が B より小さいとき 、
trg = if abs ( cross3 ( A [ - 2 ] , A [ - 1 ] , e ) ) < B :
rst = if abs ( cross2 ( A [ - 2 ] , A [ - 1 ] , e ) < B : <eos>
328
src = A の children の長さ のとき 、
trg = if len ( A . children ) :
rst = if len ( A . children ) : <eos>
329
src = B に 150 を掛けた値を A とする
trg = A = B * 150
rst = A = B * * <eos>
330
src = A の e の B 番目の末尾に A . Edge ( C ,0, len ( A . e [ C ] ) -1,- D ) を追加する
trg = A . e [ B ] . append ( A . Edge ( C , 0 , len ( A . e [ C ] ) - 1 , - D ) )
rst = A . e [ B ] . append ( A . Edge ( C , 0 , len ( A . e [ C ] ) . append ( D ) ) <eos>
331
src = A の B に 1 を加えた値番目を C だけ 増 加 させ る
trg = A [ B + 1 ] += C
rst = A [ B + 1 ] += C <eos>
332
src = ( (1、0) の組 、(-1、0) の組 、(0、1) の組 、(0、-1) の組 ) からなる列を A とする
trg = A = [ ( 1 , 0 ) , ( - 1 , 0 ) , ( 0 , 1 ) , ( 0 , - 1 ) ]
rst = A = [ ( 1 , 0 ) , ( - , 0 ) , ( 0 , 0 ) , ( 0 , 0 ) ] <eos>
333
src = C の各要素を A とし 、 ( A - B )**2 の列の総和を D で割った値の平方根 を出力する
trg = print ( math . sqrt ( sum ( [ ( A - B ) ** 2 for A in C ] ) / D ) )
rst = print ( math . sqrt ( [ ( A - B ) ** 2 for A in C ] ) / D ) <eos>
334
src = A を ( 、 つまり文字列 B に C を加えた値に D を加えた値を 評価 した値の浮動小数点数 ) からなる列 だけ 増 加 させ る
trg = A += [ float ( eval ( B + C + D ) ) ]
rst = A += [ str ( eval ( B + C + D ) ) ] <eos>
335
src = D の E 番目の各要素を B 、 C とし 、 ( A に B を加えた値 、 A に C を加えた値 ) の組の列の集合を 返す
trg = return set ( [ ( A + B , A + C ) for B , C in D [ E ] ] )
rst = return [ tuple ( [ A + B , A + C ) for B , C in D [ E ] ] ) <eos>
336
src = B の文字列を長さ 4 に な るように '0' 左 詰め した文字列 のリストを A とする
trg = A = list ( str ( B ) . zfill ( 4 ) )
rst = A = list ( str ( B ) . zfill ( 4 ) ) <eos>
337
src = 0 、 C の D 番目の先頭を A 、 B とする
trg = A , B = 0 , C [ D ] [ 0 ]
rst = A , B = 0 , C [ D ] [ 0 ] <eos>
338
src = put _ dif ()
trg = put_dif ( )
rst = <unk> ( ) <eos>
339
src = 空列を A の order に する
trg = A . order = [ ]
rst = A . order = [ ] <eos>
340
src = 入力された文字列 を空白で分割した字句列の各要素に 浮動小数点数を適用した列を展開し 、 それぞれ A 、 B 、 C 、 D 、 E 、 F 、 G 、 H とする
trg = A , B , C , D , E , F , G , H = map ( float , input ( ) . split ( ) )
rst = A , B , C , D , E , F , G , H = map ( float , input ( ) . split ( ) ) <eos>
341
src = 現在の日時が A から 1 を引いた値より小さいとき 、
trg = if now < A - 1 :
rst = if now < A - 1 : <eos>
342
src = B から C に D の余弦を掛けた値を引いた値 を A とする
trg = A = B - C * math . cos ( D )
rst = A = B - ( math . cos ( C * D ) ) <eos>
343
src = B と C の論理和から B と C の論理積 を引いた値をソートした列を A とする
trg = A = sorted ( ( B | C ) - ( B & C ) )
rst = A = ( B & C ) . ( B , C ) <eos>
344
src = dfs (0, A , deque ( range (6) )) のとき 、
trg = if dfs ( 0 , A , deque ( range ( 6 ) ) ) :
rst = if dfs ( 0 , A , <unk> ( ) , <unk> ( A ) ) : <eos>
345
src = 60* A + B + 60* C に D を加えた値に 60 に E を掛けた値を加えた値に F を加えた値に 60 に G を掛けた値を加えた値に H を加えた値を time とする
trg = time = 60 * A + B + 60 * C + D + 60 * E + F + 60 * G + H
rst = time = lambda A + B + + C + D + 60 * E + F + 60 * 60 + H <eos>
346
src = ( A の B 番目 ) からなる列を A の B 番目に する
trg = A [ B ] = [ A [ B ] ]
rst = A [ B ] = [ A [ B ] ] <eos>
347
src = B に 20000 を加えた値を A とする
trg = A = B + 20000
rst = A = B + 1912 <eos>
348
src = setHeapUp _ max ( A ,0)
trg = setHeapUp_max ( A , 0 )
rst = <unk> ( A , 0 ) <eos>
349
src = A の wait を出力する
trg = print ( A . wait )
rst = print ( A . pop ) <eos>
350
src = C を A の rm の B 番目に する
trg = A . rm [ B ] = C
rst = A . rm [ B ] = C <eos>
351
src = A . heappush ( B , - int ( C [1]))
trg = A . heappush ( B , - int ( C [ 1 ] ) )
rst = A . heappush ( B , - int ( C [ 1 ] ) ) <eos>
352
src = A . add _ edge ( B -1, C ,1,- D )
trg = A . add_edge ( B - 1 , C , 1 , - D )
rst = A . add_edge ( B - 1 , C , 1 , - D ) <eos>
353
src = 16 進 表 記 、 つまり入力された文字列の整数値 の 2 進 数文字列の 文字列の 2 番目から 、 つまり末尾までの部分列を A とする
trg = A = str ( bin ( int ( input ( ) , 16 ) ) ) [ 2 : ]
rst = A = int ( input ( ) ) , 2 ) , 2 : : [ 2 : ] <eos>
354
src = B の MAXV を A とする
trg = A = B . MAXV
rst = A = B . <unk> <eos>
355
src = write ( A *5 )
trg = write ( A * 5 )
rst = write ( A * 5 ) <eos>
356
src = C の B 番目を A の B 番目の 1 番目に する
trg = A [ B ] [ 1 ] = C [ B ]
rst = A [ B ] [ 1 ] = C [ B ] <eos>
357
src = A の 1 を 3 で割った値乗 を出力する
trg = print ( A ** ( 1 / 3 ) )
rst = print ( A ** ( 1 / 3 ) ) <eos>
358
src = 0 から 101 未満までの数列の各要素を B とし 、 、 つまり空列の列を A とする
trg = A = [ [ ] for B in range ( 101 ) ]
rst = A = [ [ ] for B in range ( 101 ) ] <eos>
359
src = C の末尾を除いた部分列 を空白で分割した字句列の各要素に 整数を適用した列のリストを展開し 、 それぞれ A 、 B とする
trg = A , B = list ( map ( int , C [ : - 1 ] . split ( ) ) )
rst = A , B = list ( map ( int , C [ : - 1 ] . split ( ) ) ) <eos>
360
src = B の逆順を A とする
trg = A = B [ : : - 1 ]
rst = A = B [ : : - 1 ] <eos>
361
src = i をパラメータとして i の 1 番目を返す関数をキーとして A のキーと値の集まりをソートした列 を A とする
trg = A = sorted ( A . items ( ) , key = lambda B : B [ 1 ] )
rst = A = sorted ( A . items ( ) , key = lambda B : B [ 1 ] ) <eos>
362
src = 0 から C 未満までの数列の各要素を B とし 、 、 つまり偽の列 を A とする
trg = A = [ False for B in range ( C ) ]
rst = A = [ False for B in range ( C ) ] <eos>
363
src = A が 、 つまり未定値と等しくなくまたは A が 0 より小さいとき 、
trg = if A is None or A < 0 :
rst = if A is None or A < 0 : <eos>
364
src = A の各要素を B 、 C とし 、 B の列を A とする
trg = A = [ B for B , C in A ]
rst = A = [ B for B , C in A ] <eos>
365
src = C 、 D 、 E 、 F の要素をそれぞれ組にした列 に番号付した組の列を順に A 、 B として 、 繰り返 す
trg = for A , B in enumerate ( zip ( C , D , E , F ) ) :
rst = for A , B in enumerate ( zip ( C , D , E , F ) ) : <eos>
366
src = A が 、 つまりネイピア数 と等しいかどうかが 0 と等しいとき 、
trg = if A == e == 0 :
rst = if A == e == 0 : <eos>
367
src = B を 3.0 で割った値を A とする
trg = A = B / 3.0
rst = A = B / 4.9 <eos>
368
src = A の末尾に D の各要素を C とし 、 ( B [ C ] の先頭 、 B [ C ] の 1 番目 ) の組 の列のリストを 追加する
trg = A . append ( list ( [ ( B [ C ] [ 0 ] , B [ C ] [ 1 ] ) for C in D ] ) )
rst = A . append ( list ( [ B [ C ] [ , B [ C ] [ 1 ] ] ) for C in D ] ) <eos>
369
src = B に C を掛けた値から D に E を掛けた値を引いた値を C にネイピア数を掛けた値から F に E を掛けた値を引いた値で割った値 を A とする
trg = A = ( B * C - D * E ) / ( C * e - F * E )
rst = A = ( B * C - D * E ) / ( C * e - F * E ) <eos>
370
src = ( B 、 C ) の組を A の end _ points に する
trg = A . end_points = ( B , C )
rst = A . <unk> = ( B , C ) <eos>
371
src = B の _ parent の C 番目を A とする
trg = A = B . _parent [ C ]
rst = A = B . _parent [ C ] <eos>
372
src = A を B の C 番目の長さ だけ 増 加 させ る
trg = A += len ( B [ C ] )
rst = A += len ( B [ C ] ) <eos>
373
src = B . Decimal ( C ) を A とする
trg = A = B . Decimal ( C )
rst = A = B . Decimal ( C ) <eos>
374
src = A を 2 に 入力された文字列 が B と等しいかどうかを掛けた値 から 1 を引いた値だけ 増 加 させ る
trg = A += 2 * ( input ( ) == B ) - 1
rst = A += 2 * int ( B ) * ( - 1 - - 1 <eos>
375
src = ( - 3、-2、-1 、1、2、3) からなる列を A とする
trg = A = [ - 3 , - 2 , - 1 , 1 , 2 , 3 ]
rst = A = [ - 1 , - 2 , - 1 , 0 , - 1 , - 1 ] <eos>
376
src = Point (0,0) を A とする
trg = A = Point ( 0 , 0 )
rst = A = Point ( 100 , 0 ) <eos>
377
src = B の C 番目の長さ 、 B の D 番目の長さの最小値 から 1 を引いた値から 0 未満までの -1 間隔の数列を順に A として 、 繰り返 す
trg = for A in range ( min ( len ( B [ C ] ) , len ( B [ D ] ) ) - 1 , 0 , - 1 ) :
rst = for A in range ( len ( B [ C ] , , ( B [ D ) ) - 1 ] , - 1 , - 1 ) : <eos>
378
src = B の 2 番目を A の B の先頭番目の B の 1 番目番目に する
trg = A [ B [ 0 ] ] [ B [ 1 ] ] = B [ 2 ]
rst = A [ B [ 0 ] ] [ B [ 1 ] ] = B [ 2 ] <eos>
379
src = B 、 C 、 D から 1 を引いた値に お いて正規表現 A が最初にマッチする位置
trg = search ( A , B , C , D - 1 )
rst = search ( A , B , C , D - 1 ) <eos>
380
src = ( B のリスト ) からなる列を A とする
trg = A = [ list ( B ) ]
rst = A = [ list ( B ) ] <eos>
381
src = A の B と等しい要素の最初の位置 、 B 、 A の長さから A の B と等しい要素の最初の位置 を引いた値 を出力する
trg = print ( A . index ( B ) , B , len ( A ) - A . index ( B ) )
rst = print ( A . index ( B ) , B , len ( A ) - len ( A ) ) <eos>
382
src = B の ascii _ lowercase の C 番目を A とする
trg = A = B . ascii_lowercase [ C ]
rst = A = B . ascii_lowercase [ C ] <eos>
383
src = item ( B , C ) を A とする
trg = A = item ( B , C )
rst = A = namedtuple ( B , C ) <eos>
384
src = B の C から 1 を引いた値番目の D に 1 を加えた値番目を A とする
trg = A = B [ C - 1 ] [ D + 1 ]
rst = A = B [ C - 1 ] [ D + 1 ] <eos>
385
src = ( B が C と等しいとき 0 、 そうでなければ 0 から E 未満までの数列の各要素を B とし 、 D の浮動小数点数の列 ) からなる列を A とする
trg = A = [ 0 if B == C else [ float ( D ) for B in range ( E ) ] ]
rst = A = [ 0 if B == C else [ D float ( D ) for B in range ( E ) ] ] <eos>
386
src = 0 から 5 未満までの数列の各要素を B とし 、 、 つまり空列の列を A とする
trg = A = [ [ ] for B in range ( 5 ) ]
rst = A = [ [ ] for B in range ( 5 ) ] <eos>
387
src = A が B から 1 を引いた値以上かつ C が D より小さいとき 、
trg = if A >= B - 1 and C < D :
rst = if A == ( B - 1 ) + C < D : <eos>
388
src = print _ data ( A ,0)
trg = print_data ( A , 0 )
rst = print_data ( A , 0 ) <eos>
389
src = 0 から C 未満までの数列の各要素を B とし 、 Node () の列を A とする
trg = A = [ Node ( ) for B in range ( C ) ]
rst = A = [ Node ( ) for B in range ( C ) ] <eos>
390
src = ネイピア数の cost 、 ネイピア数の num を追加して A を 更新 する
trg = A . update ( e . cost , e . num )
rst = A . e |= e . e , e ) <eos>
391
src = cut ( A , B , C , D ) を A とする
trg = A = cut ( A , B , C , D )
rst = A = cut ( A , B , C , D ) <eos>
392
src = F から G に D を掛けた値を引いた値を E とする
trg = E = F - G * D
rst = E = F - G * D <eos>
393
src = A の B の長さ番目に C を追加した集まり
trg = A [ len ( B ) ] . add ( C )
rst = A [ int ( B ) ] . add ( C ) <eos>
394
src = 0 から B に 1 を加えた値 、 C の最小値 未満までの数列を順に A として 、 繰り返 す
trg = for A in range ( min ( B + 1 , C ) ) :
rst = for A in range ( min ( B + 1 , C ) ) : <eos>
395
src = C の 、 つまり先頭から 、 つまり末尾までの 2 間隔による部分列 、 C の 1 番目から 、 つまり末尾までの 2 間隔による部分列の 要素をそれぞれ組にした列の各要素 を A 、 B とし 、 A が B と等しいかどうかの列が全てが真 のとき 、
trg = if all ( [ A == B for A , B in zip ( C [ : : 2 ] , C [ 1 : : 2 ] ) ] ) :
rst = if all ( [ A == B for A , B in zip ( C [ : : 2 ] , C [ 1 : : 2 ] ) ) : <eos>
396
src = A の child が 、 つまり未定値と等しくないとき 、
trg = if A . child is None :
rst = if A . child is None : <eos>
397
src = B の位置 D の E 番目から C を探して見つかった位置 に 1 を加えた値を A とする
trg = A = B . find ( C , D [ E ] ) + 1
rst = A = B . find ( C , D [ E ] - 1 ) <eos>
398
src = A が B と等しいとき 、
trg = if A == B :
rst = if A == B : <eos>
399
src = B の先頭を A の 25 番目に する
trg = A [ 25 ] = B [ 0 ]
rst = A [ 25 ] = B [ 0 ] <eos>
400
src = it () から B を引いた値を A とする
trg = A = it ( ) - B
rst = A = UnionFindTree ( ) - B <eos>
401
src = A の B 番目の C 番目を D で割った余りに する
trg = A [ B ] [ C ] %= D
rst = A [ B ] [ C ] %= D <eos>
402
src = A の B 番目が 、 つまり空白文字 と等しくないとき 、
trg = if A [ B ] != ' ' :
rst = if A [ B ] != ' ' : <eos>
403
src = A の B の C と等しい要素の最初の位置番目を 1 だけ 減 少 させ る
trg = A [ B . index ( C ) ] -= 1
rst = A [ B . index ( C ) ] -= 1 <eos>
404
src = A の B の 1 番目 番目を出力する
trg = print ( A [ B [ 1 ] ] )
rst = print ( A [ B [ 1 ] ] ) <eos>
405
src = B の edge の C に B の n を掛けた値に D を加えた値番目を A とする
trg = A = B . edge [ C * B . n + D ]
rst = A = B . edge [ C * B . n + D ] <eos>
406
src = 0 から 26 未満までの数列の各要素を B とし 、 、 つまり空列の列を A とする
trg = A = [ [ ] for B in range ( 26 ) ]
rst = A = [ [ ] for B in range ( 26 ) ] <eos>
407
src = list ( map ( int , input (). split ())) をソートした列 に番号付した組の列の各要素を B 、 C とし 、 A から B を引いた値に C を掛けた値の列の総和を出力する
trg = print ( sum ( [ ( A - B ) * C for B , C in enumerate ( sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) ) ] ) )
rst = print ( sum ( [ A - B * C for C , C in enumerate ( sorted ( list ( input ( ) . split ( ) ) ) ) ) ) ) ) ) ) <eos>
408
src = A が B の末尾 と等しいとき 、
trg = if A == B [ - 1 ] :
rst = if A == B [ - 1 ] : <eos>
409
src = ( B を 2 で割った余り ) からなる列の C に 1 を加えた値回分の列を A とする
trg = A = [ B % 2 ] * ( C + 1 )
rst = A = [ B % 2 ] * ( C + 1 ) <eos>
410
src = A 、0 から E 未満までの数列の各要素を C とし 、 B の C 番目の D 番目の列の総和 の最大値を A とする
trg = A = max ( A , sum ( [ B [ C ] [ D ] for C in range ( E ) ] ) )
rst = A = max ( A , sum ( [ B [ C ] [ D ] for C in range ( E ) ] ) ) <eos>
411
src = bl ( B , C ) から 1 を引いた値を A とする
trg = A = bl ( B , C ) - 1
rst = A = bl ( B , C ) - 1 <eos>
412
src = A . heappush ( B , ( C , e , D , E ))
trg = A . heappush ( B , ( C , e , D , E ) )
rst = A . heappush ( B , ( C , e , D , E ) ) <eos>
413
src = ソートされた順序を保ったまま B を A に挿入できる位置 、 ソートされた順序を保ったまま B を A に挿入できる最後の位置 を出力する
trg = print ( bisect_left ( A , B ) , bisect_right ( A , B ) )
rst = print ( bisect . bisect ( A , B ) , bisect ( A , B ) , bisect ( B ) ) <eos>
414
src = 1 から B に 1 を加えた値 、 3 に 1 を加えた値の最小値 未満までの数列を順に A として 、 繰り返 す
trg = for A in range ( 1 , min ( B + 1 , 3 + 1 ) ) :
rst = for A in range ( 1 , min ( B + 1 , 3 + 1 ) ) : <eos>
415
src = primes 2 (10**7) を A とする
trg = A = primes2 ( 10 ** 7 )
rst = A = primes2 ( <unk> <eos>
416
src = B のリストを順に A として 、 繰り返 す
trg = for A in list ( B ) :
rst = for A in list ( B ) : <eos>
417
src = dfs (0,0, A [0][0], -1)
trg = dfs ( 0 , 0 , A [ 0 ] [ 0 ] , - 1 )
rst = dfs ( 0 , 0 , A [ 0 ] [ - 1 ] ) <eos>
418
src = 0 から D 未満までの数列の各要素を C とし 、 、 つまり入力された文字列 の各要素を B とし 、 B の列の列を A とする
trg = A = [ [ B for B in input ( ) ] for C in range ( D ) ]
rst = A = [ [ B for B in input ( ) ] for C in range ( D ) ] <eos>
419
src = A の B 番目が C の B に 1 を加えた値番目の 1 番目と等しい 間 、 次 を 繰り返 す
trg = while A [ B ] == C [ B + 1 ] [ 1 ] :
rst = while A [ B ] == C [ B + 1 ] [ 1 ] : <eos>
420
src = A の parent の value が B より小さいとき 、
trg = if A . parent . value < B :
rst = if A . parent . value < B : <eos>
421
src = E 、 F の要素をそれぞれ組にした列 の各要素を B 、 D とし 、 B に C 、 D の最小値 を掛けた値の列の総和を A とする
trg = A = sum ( [ B * min ( C , D ) for B , D in zip ( E , F ) ] )
rst = A = [ min ( [ B + ( C , D ) for B , D in zip ( E , F ) ] ) <eos>
422
src = 0 から B の N から 1 を引いた値未満までの数列を順に A として 、 繰り返 す
trg = for A in range ( B . N - 1 ) :
rst = for A in range ( B . N - 1 ) : <eos>
423
src = 2 50 を A とする
trg = A = 250
rst = A = 22 <eos>
424
src = A の q の C 番目 、 A の q の B 番目を A の q の B 番目 、 A の q の C 番目とする
trg = A . q [ B ] , A . q [ C ] = A . q [ C ] , A . q [ B ]
rst = A . q [ B ] , A . q [ C ] = A . q [ C ] , A . q [ B ] <eos>
425
src = B 、 C を A の v 、 A の cost とする
trg = A . v , A . cost = B , C
rst = A . v , A . cost = B , C <eos>
426
src = inside _ convex _ polygon ( B [0], C ) でない を A とする
trg = A = not inside_convex_polygon ( B [ 0 ] , C )
rst = A = not <unk> ( B [ 0 ] , C ) <eos>
427
src = B に E を加えた値を D とする
trg = D = B + E
rst = D = B + E <eos>
428
src = B の集合と C の集合の論理和 のリストを A とする
trg = A = list ( set ( B ) | set ( C ) )
rst = A = list ( set ( B ) | set ( C ) ) <eos>
429
src = A の rp の B 番目の 1 番目を返す
trg = return A . rp [ B ] [ 1 ]
rst = return A . one [ B ] [ 1 ] <eos>
430
src = A が B と等しくなくかつ C の A 番目の D 番目が C の B 番目の D 番目と等しいとき 、
trg = if A != B and C [ A ] [ D ] == C [ B ] [ D ] :
rst = if A != B and C [ A ] [ D ] == C [ B ] [ D ] : <eos>
431
src = 入力された文字列 を空白で分割した字句列 の各要素に整数を適用した列 、 入力された文字列 を空白で分割した字句列を A 、 B とする
trg = A , B = map ( int , input ( ) . split ( ) ) , input ( ) . split ( )
rst = A , B = map ( int , input ( ) . split ( ) ) <eos>
432
src = B 内の C を展開してを [ MASK ] で置き換えた文字列の整数値を A とする
trg = A = int ( B . replace ( * C ) )
rst = A = list ( B . count ( C ) ) <eos>
433
src = A の B から 1 を引いた値番目が C と等しい 間 、 次 を 繰り返 す
trg = while A [ B - 1 ] == C :
rst = while A [ B - 1 ] == C : <eos>
434
src = B を 1000 で割った商に C を掛けた値を A とする
trg = A = B // 1000 * C
rst = A = ( B // 1000 ) * C <eos>
435
src = A の B 番目のコピーされた列を A の B に 1 を加えた値番目に する
trg = A [ B + 1 ] = A [ B ] [ : ]
rst = A [ B + 1 ] = A [ B ] [ : ] <eos>
436
src = str ( A ) に B を加えた値に C の文字列を加えた値に D を加えた値に A に C を掛けた値 の文字列を加えた値を出力する
trg = print ( str ( A ) + B + str ( C ) + D + str ( A * C ) )
rst = print ( str ( A ) + B + str ( C ) + D + str ( A * C ) ) <eos>
437
src = sgn ( A . dot ( B )) が 0 と等しいとき 、
trg = if sgn ( A . dot ( B ) ) == 0 :
rst = if sgn ( A . dot ( B ) ) == 0 : <eos>
438
src = input (). split () の各要素に int を適用した列のリスト の集合の長さ を出力する
trg = print ( len ( set ( list ( map ( int , input ( ) . split ( ) ) ) ) ) )
rst = print ( max ( list ( list ( map ( int , input ( ) . split ( ) ) ) ) ) ) <eos>
439
src = write ( A % B [0][ C ] )
trg = write ( A % B [ 0 ] [ C ] )
rst = write ( A % B [ 0 : - C ] ) <eos>
440
src = A を B の C に 1 を加えた値番目 で割った余りを出力する
trg = print ( A % B [ C + 1 ] )
rst = print ( A % B [ C + 1 ] ) <eos>
441
src = A の B 番目が 、 つまり未定値と等しくなくまたは A の B 番目が C 以下かつ A の D 番目が 、 つまり未定値と等しくなくまたは C が A の D 番目以下のとき 、
trg = if ( A [ B ] is None or A [ B ] <= C ) and ( A [ D ] is None or C <= A [ D ] ) :
rst = if A [ B ] is None or A [ B ] <= C and A [ D ] != None and A <= D ] : <eos>
442
src = get _ cross _ time ( B - C , D - E ) を A とする
trg = A = get_cross_time ( B - C , D - E )
rst = A = <unk> ( B - C , D - E ) <eos>
443
src = A [ B ] . expand ( C )
trg = A [ B ] . expand ( C )
rst = A [ B ] . <unk> ( C ) <eos>
444
src = defaultdict ( lambda : defaultdict ( int )) を A とする
trg = A = defaultdict ( lambda : defaultdict ( int ) )
rst = A = defaultdict ( bool ( int ) ) <eos>
445
src = ( 1、1、1、1、1、2、2、2、 3 ) からなる列を A とする
trg = A = [ 1 , 1 , 1 , 1 , 1 , 2 , 2 , 2 , 3 ]
rst = A = [ [ 3 , 3 , 3 ] <eos>
446
src = B の先頭を取り出した値を C とする
trg = C = B . pop
rst = C = B . pop ( ) <eos>
447
src = A の各要素を B とし 、 、 つまり空白文字を間に入れて B の各要素に整数を適用した列 を連結した文字列の列を A とする
trg = A = ( [ ' ' . join ( map ( str , B ) ) for B in A ] )
rst = A = [ ' ' . join ( map ( str , B ) ) for B in A ] <eos>
448
src = A の B 番目を C 倍 に する
trg = A [ B ] *= C
rst = A [ B ] *= C <eos>
449
src = A に B の C 番目に D を掛けた値を加えた値が 1000 以下のとき 、
trg = if A + B [ C ] * D <= 1000 :
rst = if A + B [ C ] * D <= 1000 : <eos>
450
src = B の先頭から 1 を引いた値を A とする
trg = A = B [ 0 ] - 1
rst = A = B [ 0 ] - 1 <eos>
451
src = 0 、 3 を出力する
trg = print ( 0 , 3 )
rst = print ( 0 , 3 ) <eos>
452
src = 偽を A の D 番目を A の C 番目とするとするを A の B 番目に する
trg = A [ B ] = A [ C ] = A [ D ] = False
rst = A [ B ] = A [ C ] = False [ D ] = False <eos>
453
src = A かつ A の末尾の 0 番目が B から 1 を引いた値と等しくかつ B が C 以下の 間 、 次 を 繰り返 す
trg = while A and A [ - 1 ] [ 0 ] == B - 1 and B <= C :
rst = while A and A [ - 1 ] [ 0 ] == B - 1 and B <= C : <eos>
454
src = ( ( B の INFINITY ) からなる列の 0 から C 未満までの数列の各要素を D とし 、 C の列回分の列 ) からなる列を A とする
trg = A = [ [ B . INFINITY ] * [ C for D in range ( C ) ] ]
rst = A = [ [ B . INFINITY ] * [ C for D in range ( C ) ] ] <eos>
455
src = A の pip の 2 番目 、 A の pip の 5 番目 、 A の pip の先頭 、 A の pip の 3 番目を A の pip の先頭 、 A の pip の 2 番目 、 A の pip の 3 番目 、 A の pip の 5 番目とする
trg = A . pip [ 0 ] , A . pip [ 2 ] , A . pip [ 3 ] , A . pip [ 5 ] = A . pip [ 2 ] , A . pip [ 5 ] , A . pip [ 0 ] , A . pip [ 3 ]
rst = A . pip [ 0 ] , A . pip [ 2 ] , A . pip [ 3 ] , A . pip [ 5 ] , A . pip [ 5 ] , A . pip [ 5 ] , A . pip [ 5 ] , A
456
src = B の p 1 の x 座標から B の p 2 の x 座標を引いた値に C の p 1 の y 座標から B の p 1 の y 座標を引いた値を掛けた値 に B の p 1 の y 座標から B の p 2 の y 座標を引いた値に B の p 1 の x 座標から C の p 1 の x 座標を引いた値を掛けた値 を加えた値を A とする
trg = A = ( B . p1 . x - B . p2 . x ) * ( C . p1 . y - B . p1 . y ) + ( B . p1 . y - B . p2 . y ) * ( B . p1 . x - C . p1 . x )
rst = A = B . p1 . x - ( B . p2 . x ) * ( C . p1 . y ) * ( B . p1 . y - B . p1 . y ) * ( B . p1 . y - B . p1 . x
457
src = update ( 2 ,[(- 1,-1),( 1,-1),( -1,1) , (1, 1)])
trg = update ( 2 , [ ( - 1 , - 1 ) , ( 1 , - 1 ) , ( - 1 , 1 ) , ( 1 , 1 ) ] )
rst = update ( 2 , [ 2 , - 1 , 2 ) , ( 1 , 0 ) , ( 1 , 1 , 0 , 1 , 0 ) ] <eos>
458
src = ( B ) からなる列に C のリスト の末尾を除いた部分列を加えた値 の組を A とする
trg = A = tuple ( [ B ] + list ( C ) [ : - 1 ] )
rst = A = [ B ] + list ( list ( C ) ) <eos>
459
src = A を B の bit の C 番目だけ 増 加 させ る
trg = A += B . bit [ C ]
rst = A += B . bit [ C ] <eos>
460
src = A を A から 20 を引いた値だけ 減 少 させ る
trg = A -= A - 20
rst = A -= A - 20 <eos>
461
src = SSSP ( B ) を A とする
trg = A = SSSP ( B )
rst = A = <unk> ( B ) <eos>
462
src = A を書式として B から 1911 を引いた値 で整形した文字列を出力する
trg = print ( A . format ( B - 1911 ) )
rst = print ( A . format ( B - 1911 ) ) <eos>
463
src = A . print ()
trg = A . print ( )
rst = A . erase ( ) <eos>
464
src = 0 から C 未満までの数列の各要素を B とし 、 LinkList () の列を A とする
trg = A = [ LinkList ( ) for B in range ( C ) ]
rst = A = [ <unk> ( ) for B in range ( C ) ] <eos>
465
src = A が 2 より小さいとき 、
trg = if A < 2 :
rst = if A < 2 : <eos>
466
src = A の status の末尾に ( B ) からなる列の 8 回分の列を 追加する
trg = A . status . append ( [ B ] * 8 )
rst = A . status . append ( [ B ] * 8 ) <eos>
467
src = D ( B ) を A とする
trg = A = D ( B )
rst = A = 2000000000 ( B ) <eos>
468
src = A が 100 以上の 間 、 次 を 繰り返 す
trg = while A >= 100 :
rst = while A >= 100 : <eos>
469
src = 3 が A に含まれかつ 2 が A に含まれるとき 、
trg = if 3 in A and 2 in A :
rst = if 3 in A and 2 in A : <eos>
470
src = roundup 1000 ( A * 1.05 ) を A とする
trg = A = roundup1000 ( A * 1.05 )
rst = A = <unk> ( 1000 * A ) <eos>
471
src = D を C の 、 つまり先頭から 、 つまり末尾までの部分列に する
trg = C [ : ] = D
rst = C [ : : ] = D <eos>
472
src = 2 を A の B から 1 を引いた値番目に する
trg = A [ B - 1 ] = 2
rst = A [ B - 1 ] = 2 <eos>
473
src = A を B で割った値が 、 つまり円周率 より小さいとき 、
trg = if A / B < pi :
rst = if A / B < pi : <eos>
474
src = B から 7 に C を掛けた値に D を加えた値に E を掛けた値を引いた値を A とする
trg = A = B - ( 7 * C + D ) * E
rst = A = B - 7 * C + D * E <eos>
475
src = 改行せずに空白文字に A の B に 1 を加えた値番目 の文字列を加えた値を出力する
trg = print ( ' ' + str ( A [ B + 1 ] ) , end = '' )
rst = print ( ' ' + str ( A [ B + 1 ] ) , end = '' ) <eos>
476
src = propagates (* gindex ( A , B ))
trg = propagates ( * gindex ( A , B ) )
rst = propagates ( * gindex ( A , B ) ) <eos>
477
src = seki ( B , C , A ) を A とする
trg = A = seki ( B , C , A )
rst = A = <unk> ( B , C , A ) <eos>
478
src = 改行せずに A [0] の先頭の文字列に B を加えた値に C を書式として A の先頭の 1 番目で整形した文字列 を加えた値を出力する
trg = print ( str ( A [ 0 ] [ 0 ] ) + B + C . format ( A [ 0 ] [ 1 ] ) , end = '' )
rst = print ( str ( A [ 0 ] [ 0 ] ) + B + C . format ( A [ 0 ] [ 1 ] ) , end = '' ) <eos>
479
src = (0) からなる列の 31 回分の列 、 空列を A 、 B とする
trg = A , B = [ 0 ] * 31 , [ ]
rst = A , B = [ 0 ] * 31 , [ ] <eos>
480
src = C が D 以下のとき ( E 、 F ) の組 、 そうでなければ ( D 、 G ) の組 を展開し 、 それぞれ A 、 B とする
trg = A , B = ( E , F ) if C <= D else ( D , G )
rst = A , B = ( E , F ) if C <= D else ( D , G ) , ( D , G ) ) <eos>
481
src = A の list の 1 番目が B と等しいとき 、
trg = if A . list [ 1 ] == B :
rst = if A . list [ 1 ] == B : <eos>
482
src = A に B を掛けた値を A と B の最大公約数で割った商を A と B の最大公約数で割った商に C を掛けた値を出力する
trg = print ( A * B // gcd ( A , B ) // gcd ( A , B ) * C )
rst = print ( A * B // gcd ( A , B ) gcd ( A , B ) * C ) * C ) <eos>
483
src = D の B 番目から D の C 番目を引いた値の絶対値が 1 以下かどうかを A の B 番目の C 番目に する
trg = A [ B ] [ C ] = abs ( D [ B ] - D [ C ] ) <= 1
rst = A [ B ] [ C ] = abs ( D [ B ] - D [ C ] ) - 1 <eos>
484
src = A が 0 と等しくかつ B の C 番目の D 番目が 1 と等しいとき 、
trg = if A == 0 and B [ C ] [ D ] == 1 :
rst = if A == 0 and B [ C ] [ D ] == 1 : <eos>
485
src = G . popleft () を F とする を展開し 、 それぞれ A 、 B 、 C 、 D 、 E とする
trg = A , B , C , D , E = F = G . popleft ( )
rst = A , B , C , D , E = G . G , F ( G ) <eos>
486
src = A を B だけ右シフトした値と 1 の論理積でないとき 、
trg = if not ( ( A >> B ) & 1 ) :
rst = if not ( A >> B & 1 ) : <eos>
487
src = A の B に C を加えた値から 1 を引いた値番目の末尾に D を追加する
trg = A [ B + C - 1 ] . append ( D )
rst = A [ B + C - 1 ] . append ( D ) <eos>
488
src = 0 から C 未満までの数列の各要素を B とし 、 、 つまり空列の列を A の REdge に する
trg = A . REdge = [ [ ] for B in range ( C ) ]
rst = A . <unk> = [ [ ] for B in range ( C ) ] <eos>
489
src = A に B から C を引いた値を加えた値が D 以下のとき 、
trg = if A + ( B - C ) <= D :
rst = if A + ( B - C ) <= D : <eos>
490
src = 無限の整数列を 2 で割った値を 四捨五 入した整数値 を出力する
trg = print ( round ( count / 2 ) )
rst = print ( round ( count / 2 ) ) <eos>
491
src = ( B 、 C ) の組 から 始 まり D 間隔 で 続 く無限の整数列 を A とする
trg = A = count ( ( B , C ) , D )
rst = A = <unk> ( B , C ) , <unk> ( D , <unk> ) <eos>
492
src = A に B を B に C を加えた値で割った値に D から A を引いた値を掛けた値を加えた値 を返す
trg = return A + B / ( B + C ) * ( D - A )
rst = return A + B / ( B + C ) * ( D - A ) <eos>
493
src = A が (1、1、 3 ) からなる列と等しいとき 、
trg = if A == [ 1 , 1 , 3 ] :
rst = if A == [ 1 , 1 , 3 ] : <eos>
494
src = A を書式として B のとき C を 2 で割った値 、 そうでなければ 0 で整形した文字列を出力する
trg = print ( A . format ( C / 2 if B else 0 ) )
rst = print ( A . format ( B / 2 if B / 2 ) else 0 ) <eos>
495
src = B を書式として C 、 D 、 C に D を掛けた値で整形した文字列を A とする
trg = A = B . format ( C , D , C * D )
rst = A = B . format ( C , D , C * D ) <eos>
496
src = B と C 、 D の ユ ー ク リ ッ ド距離 を A とする
trg = A = dist ( B , C , D )
rst = A = dist ( B , C , D ) <eos>
497
src = A の 99 番目が 0 と等しい 間 、 次 を 繰り返 す
trg = while A [ 99 ] == 0 :
rst = while A . [ ] == 0 : <eos>
498
src = A が 7 以上のとき 、
trg = if A >= 7 :
rst = if A >= 7 : <eos>
499
src = A に B の C 番目 、 1 を追加した集まり
trg = A . add ( B [ C ] , 1 )
rst = A . add ( B [ C ] , 1 ) <eos>
500
src = A . process _ ink ( B , C +1)
trg = A . process_ink ( B , C + 1 )
rst = A . process_ink ( B , C + 1 ) <eos>
501
src = Node ( None , None , None ) を A とする
trg = A = Node ( None , None , None )
rst = A = Node ( None , None , None ) <eos>
502
src = A の末尾に ( B に C を加えた値に 1 を加えた値 、 D に E を加えた値に 1 を加えた値 ) の組 を追加する
trg = A . append ( ( B + C + 1 , D + E + 1 ) )
rst = A . append ( ( B + C + 1 , D + E + 1 ) ) <eos>
503
src = cls ( A ) を返す
trg = return cls ( A )
rst = return compress ( A ) <eos>
504
src = A が B より小さくかつ C の A 番目が C の D 番目より大きいとき 、
trg = if A < B and C [ A ] > C [ D ] :
rst = if A < B and C [ A ] > C [ D ] : <eos>
505
src = 0 から B を 10000 で割った商 未満までの数列を順に A として 、 繰り返 す
trg = for A in range ( B // 10000 ) :
rst = for A in range ( B // 10000 ) : <eos>
506
src = 偽を A の end に する
trg = A . end = False
rst = A . end = False <eos>
507
src = B の A 番目を A とする
trg = A = B [ A ]
rst = A = B [ A ] <eos>
508
src = E の各要素を D 、 A 、 C とし 、 A が B と等しくなくかつ C が B と等しくないかどうかの列 が全てが真のとき 、
trg = if all ( [ A != B and C != B for D , A , C in E ] ) :
rst = if all ( [ A != B and C in B for A , D , C in E ] ) : <eos>
509
src = A を B の C から 1 を引いた値番目の先頭 で割った余りを出力する
trg = print ( A % B [ C - 1 ] [ 0 ] )
rst = print ( A % B [ C - 1 ] [ 0 ] ) <eos>
510
src = A が B から C から D を引いた値の絶対値を引いた値 より小さいとき 、
trg = if A < B - abs ( C - D ) :
rst = if A < B - ( C - D ) < <eos>
511
src = solve 3 () を A とする
trg = A = solve3 ( )
rst = A = solve2 ( ) <eos>
512
src = A 、 B 、 C 、 D から C を引いた値 、 E の最小値の最大値 を A とする
trg = A = max ( A , min ( B , C , D - C , E ) )
rst = A = min ( A , min ( B , C , D - C , E ) ) <eos>
513
src = A の先頭を A の 1 番目に する
trg = A [ 1 ] = A [ 0 ]
rst = A [ 1 ] = A [ 0 ] <eos>
514
src = (0、3) の組を返す
trg = return ( 0 , 3 )
rst = return ( 0 , 3 ) <eos>
515
src = 0 から 8 未満までの数列の各要素を B とし 、 、 つまり未定値の列を A とする
trg = A = [ None for B in range ( 8 ) ]
rst = A = [ None for B in range ( 8 ) ] <eos>
516
src = 0 から C の v 未満までの数列の各要素を B とし 、 ( (0、 B ) の組 ) からなる列の列を A とする
trg = A = [ [ ( 0 , B ) ] for B in range ( C . v ) ]
rst = A = [ [ ( 0 , B ) ] for B in range ( C . v ) ] <eos>
517
src = ( C 、 D 、 E 、 F ) からなる列 、 G の要素をそれぞれ組にした列 の各要素を A 、 B とし 、 A が B 以下かどうかの列が全てが真 のとき 、
trg = if all ( [ A <= B for A , B in zip ( [ C , D , E , F ] , G ) ] ) :
rst = if all ( [ A <= B for A , B in zip ( [ C , D , E , F ) ] ) : <eos>
518
src = 1 から 1 1 未満までの数列の各要素を B とし 、 B の列を A とする
trg = A = [ B for B in range ( 1 , 11 ) ]
rst = A = [ B for B in range ( 1 , 11 ) ] <eos>
519
src = A 、 B 、 C の最小値に D 、 ネイピア数 の最小値 を加えた値から 50 を引いた値 を出力する
trg = print ( min ( A , B , C ) + min ( D , e ) - 50 )
rst = print ( min ( A , B , C ) + min ( D ) e - 50 ) <eos>
520
src = A を 2 の 7 乗で割った値を A とする
trg = A = A / ( 2 ** 7 )
rst = A = A / 2 ** 7 <eos>
521
src = A の末尾に B の C 番目を追加する
trg = A . append ( B [ C ] )
rst = A . append ( B [ C ] ) <eos>
522
src = B に 2 を掛けた値に 1 を加えた値が C 以下のとき D の B に 2 を掛けた値番目 、 そうでなければ 、 つまり未定値 を A とする
trg = A = D [ B * 2 ] if B * 2 + 1 <= C else None
rst = A = D [ B * 2 ] if B * 2 + 1 <= C else None <eos>
523
src = A の nodes を返す
trg = return A . nodes
rst = return A . nodes <eos>
524
src = A を 1 と の排他 的 論理和に する
trg = A ^= 1
rst = A ^= 1 <eos>
525
src = A の nil を A の cur に する
trg = A . cur = A . nil
rst = A . cur = A . nil <eos>
526
src = Vector ( B . p 2- B . p 1 ) を A とする
trg = A = Vector ( B . p2 - B . p1 )
rst = A = Vector ( B . p2 - B . p1 ) <eos>
527
src = A の末尾 を出力する
trg = print ( A [ - 1 ] )
rst = print ( A [ - 1 ] ) <eos>
528
src = B . delete _ node ( B . find ( int ( C [1])) ) を A とする
trg = A = B . delete_node ( B . find ( int ( C [ 1 ] ) ) )
rst = A = B . dice_fix ( B . find ( int ( C [ 1 ] ) ) <eos>
529
src = A の B から 1 を引いた値番目が 0 より小さいとき 、
trg = if A [ B - 1 ] < 0 :
rst = if A [ B - 1 ] < 0 : <eos>
530
src = closest _ pair ( sorted ( B )) を A とする
trg = A = closest_pair ( sorted ( B ) )
rst = A = closest_pair_distance ( sorted ( B ) ) <eos>
531
src = B の浮動小数点数を A の slope に する
trg = A . slope = float ( B )
rst = A . slope = float ( B ) <eos>
532
src = height ( B [ C [ D . LEFT ] ] ) を A とする
trg = A = height ( B [ C [ D . LEFT ] ] )
rst = A = height ( B [ C . D . LEFT ] ) <eos>
533
src = A の 2 番目が B の 2 番目 と等しくまたは A の 3 番目が B の 3 番目と等しいとき 、
trg = if A [ 2 ] == B [ 2 ] or A [ 3 ] == B [ 3 ] :
rst = if A [ 2 ] == B [ 2 ] or A [ 3 ] == B [ 3 ] : <eos>
534
src = A の 0 番目が B の先頭の 0 番目 と等しくまたは A の -1 番目が C から 1 を引いた値と等しくまたは 0 から 3 未満までの数列の各要素を D とし 、 A の D 番目が A の D +1 番目と等しいかどうかの列が 少 なく と も ひ とつは真 のとき 、
trg = if A [ 0 ] == B [ 0 ] [ 0 ] or A [ - 1 ] == C - 1 or any ( [ A [ D ] == A [ D + 1 ] for D in range ( 3 ) ] ) :
rst = if A [ ( 0 == B [ 0 ] == 0 ) or A [ ( ( B [ 1 ] == C ) [ D [ 1 ] == A [ D ] == ( C [ 1 : ] == ) : : <eos>
535
src = (0、0、0) からなる列を追加して A を 拡張 する
trg = A . extend ( [ 0 , 0 , 0 ] )
rst = A . extend ( [ 0 , 0 , 0 ] ) <eos>
536
src = paint ( A , is _ right = True , is _ up = True )
trg = paint ( A , is_right = True , is_up = True )
rst = paint ( A , is_right = True , is_up = True ) <eos>
537
src = A を B の C の先頭 番目だけ 増 加 させ る
trg = A += B [ C [ 0 ] ]
rst = A += B [ C [ 0 ] ] <eos>
538
src = A に対応する値 、 もし存在しなければ B 、 C 、 D の最小値を A の B 番目に する
trg = A [ B ] = min ( A . get ( B , C ) , D )
rst = A [ B ] = min ( A . get ( B , C , D ) <eos>
539
src = A を B に 100 を掛けた値だけ 増 加 させ る
trg = A += B * 100
rst = A += B * 100 <eos>
540
src = A が B 以下または C の B 番目が D と等しくないとき 、
trg = if A <= B or C [ B ] != D :
rst = if A <= B or C [ B ] != D : <eos>
541
src = A に B を加えた値から C を引いた値に 1 を加えた値を出力する
trg = print ( A + B - C + 1 )
rst = print ( A + B - C + 1 ) <eos>
542
src = check (0) を展開し 、 それぞれ A 、 B とする
trg = A , B = check ( 0 )
rst = A , B = check ( 0 ) <eos>
543
src = B の NIL を A の parent の left に する
trg = A . parent . left = B . NIL
rst = A . parent . left = B . NIL <eos>
544
src = A を B の C に D を加えた値番目だけ 増 加 させ る
trg = A += B [ C + D ]
rst = A += B [ C + D ] <eos>
545
src = A の par の B 番目が C と等しいとき 、
trg = if A . par [ B ] == C :
rst = if A . par [ B ] == C : <eos>
546
src = ( B ) からなる列の C に 2 を掛けた値回分の列を A とする
trg = A = [ B ] * ( C * 2 )
rst = A = [ B ] * ( C * 2 ) <eos>
547
src = B の C 番目の総和を A とする
trg = A = sum ( B [ C ] )
rst = A = sum ( B [ C ] ) <eos>
548
src = 1989 に B を加えた値から 1 を引いた値を A とする
trg = A = 1989 + B - 1
rst = A = 1989 + B - 1 <eos>
549
src = A の mp の B に C を加えた値番目の D に E を加えた値番目が A の mp の B 番目の D 番目と等しいとき 、
trg = if A . mp [ B + C ] [ D + E ] == A . mp [ B ] [ D ] :
rst = if A . mp [ B + C ] [ D + E ] == A . mp [ B ] [ D ] : <eos>
550
src = E に F を加えた値を 2 で割った値を D とする
trg = D = ( E + F ) / 2
rst = D = ( E + F ) / 2 <eos>
551
src = A の B 番目かつ C が D より小さいとき 、
trg = if A [ B ] and C < D :
rst = if A [ B ] and C < D : <eos>
552
src = A が 0 より大きくかつ B の C 番目から B の A -1 番目を引いた値に C から A を引いた値に 1 を加えた値を加えた値が D 以下の 間 、 次 を 繰り返 す
trg = while A > 0 and B [ C ] - B [ A - 1 ] + ( C - A + 1 ) <= D :
rst = while A > 0 and B [ C ] - B [ A - 1 ] + ( C - A + 1 ) <= D : <eos>
553
src = check ( A , B , C +[ ( D , E ),( F , G )]) のとき 、
trg = if check ( A , B , C + [ ( D , E ) , ( F , G ) ] ) :
rst = if check ( A , B , C + [ ( D , E ) , ( F , G ) ] ) : <eos>
554
src = B の C 番目が D と等しいとき E から F の C 番目を引いた値 、 そうでなければ E に G の C 番目を加えた値を A とする
trg = A = ( E - F [ C ] if B [ C ] == D else E + G [ C ] )
rst = A = E - C ] if B [ C ] == D else F [ C ] + E [ G ] <eos>
555
src = A が 3 と等しくかつ B から C を引いた値の絶対値が D より小さいとき 、
trg = if A == 3 and abs ( B - C ) < D :
rst = if A == 3 and abs ( B - C ) < D : <eos>
556
src = A が -1 と等しくなく なければ な らな い
trg = assert A != - 1
rst = assert A != - 1 <eos>
557
src = datetime . date (2012,12,21) に datetime . timedelta ( days = B ) を加えた値の文字列を C で分割した字句列の各要素に 整数を適用した列のリストを A とする
trg = A = list ( map ( str , str ( datetime . date ( 2012 , 12 , 21 ) + datetime . timedelta ( days = B ) ) . split ( C ) ) )
rst = A = list ( map ( int , map ( int , C , C , C , C . y , C . y , C . y ) ) , int ( map ( C , ) ) ) <eos>
558
src = A . push ( B * C )
trg = A . push ( B * C )
rst = A . push ( B * C ) <eos>
559
src = A が B と等しくなくまたは C が B と等しくないとき 、
trg = if A != B or C != B :
rst = if A != B or C != B : <eos>
560
src = 1 を A の ( B 、 C ) の組番目に する
trg = A [ ( B , C ) ] = 1
rst = A [ ( B , C ) ] = 1 <eos>
561
src = A の d の C 番目に D を加えた値を A の d の B 番目に する
trg = A . d [ B ] = A . d [ C ] + D
rst = A . d [ B ] = A . d [ C ] + D <eos>
562
src = 期 末 試験 の 成績
trg = 期末試験の成績
rst = <unk> ( A , 4 , 4 , 4 ) <eos>
563
src = E を A の B 番目の C 番目の D 番目に する
trg = A [ B ] [ C ] [ D ] = E
rst = A [ B ] [ C ] [ D ] = E <eos>
564
src = B の 2 乗に C の 2 乗を加えた値から D の 2 乗を引いた値を 2 に C を掛けた値で割った値を A とする
trg = A = ( B ** 2 + C ** 2 - D ** 2 ) / ( 2 * C )
rst = A = ( B ** 2 + ( C ** 2 - D ** 2 ) / ( 2 * C ) <eos>
565
src = A の B 番目の C 番目のとき 、
trg = if A [ B ] [ C ] :
rst = if A [ B ] [ C ] : <eos>
566
src = B の C の 1 番目番目の C の先頭番目を A とする
trg = A = B [ C [ 1 ] ] [ C [ 0 ] ]
rst = A = B [ C [ 1 ] ] [ C [ 0 ] <eos>
567
src = 空辞書を A の f _ key _ to _ val に する
trg = A . f_key_to_val = { }
rst = A . <unk> = = = { <eos>
568
src = ( B の 1 番目の整数値 、0、1) からなる列を A とする
trg = A = [ int ( B [ 1 ] ) , 0 , 1 ]
rst = A = [ int ( B [ 1 ] ) , , 0 ] <eos>
569
src = topological _ sort ( B , C ) を順に A として 、 繰り返 す
trg = for A in topological_sort ( B , C ) :
rst = for A in pm ( B , C ) : <eos>
570
src = A 、 B を ラ ン ダ ムに シ ャ ッ フ ル する を A とする
trg = A = shuffle ( A , B )
rst = A = A , <unk> ( B , <unk> ) <eos>
571
src = A . flip _ color ()
trg = A . flip_color ( )
rst = A . <unk> ( ) <eos>
572
src = RKSearch ( B , C ) を A とする
trg = A = RKSearch ( B , C )
rst = A = <unk> ( B , C ) <eos>
573
src = 0 から G に 1 を加えた値未満までの数列の各要素 を F とし 、0 から D に 1 を加えた値未満までの数列の各要素 を E とし 、0 から D に 1 を加えた値未満までの数列の各要素 を C とし 、 B の列の列の列 を A とする
trg = A = [ [ [ B for C in range ( D + 1 ) ] for E in range ( D + 1 ) ] for F in range ( G + 1 ) ]
rst = A = [ [ [ B for C in range ( D + 1 ) ] for E in range ( D + 1 ) ] for F in range ( G + 1 ) ] <eos>
574
src = A の長さが B の長さ より大きくまたは A の長さが B の長さと等しくかつ A が B より大きいとき 、
trg = if len ( A ) > len ( B ) or ( len ( A ) == len ( B ) and A > B ) :
rst = if len ( A ) > len ( B ) > len ( A ) ) or len ( B ) > A : <eos>
575
src = A を B を 100 で割った商から 1 を引いた値だけ 増 加 させ る
trg = A += ( B // 100 ) - 1
rst = A += B // 100 - 1 <eos>
576
src = A の 、 つまり先頭から B に 1 を加えた値までの部分列に A の B に 1 を加えた値から 、 つまり末尾までの部分列 を反転した列のリストを加えた値を 返す
trg = return A [ : B + 1 ] + list ( reversed ( A [ B + 1 : ] ) )
rst = return A [ : B + 1 ] + A [ ( B + 1 : ] ) <eos>
577
src = A 、 heappop ( B ) の 1 番目の最大値を A とする
trg = A = max ( A , heappop ( B ) [ 1 ] )
rst = A = max ( A , ( B ) [ 1 ] ) <eos>
578
src = gindex ( B , C ) を順に A として 、 繰り返 す
trg = for A in gindex ( B , C ) :
rst = for A in pm ( B , C ) : <eos>
579
src = A を B で割った値の切り 上 げ 整数値に C を掛けた値 、 A を D で割った値の切り 上 げ 整数値に E を掛けた値の最小値 を出力する
trg = print ( min ( ceil ( A / B ) * C , ceil ( A / D ) * E ) )
rst = print ( math . ceil ( A / B ) ceil ceil ( C / math . ceil ( A / D ) * E ) ) <eos>
580
src = ( B の浮動小数点数 ) からなる列の A の num _ of _ nodes 回分の列を A の d に する
trg = A . d = [ float ( B ) ] * A . num_of_nodes
rst = A . d = [ float ( B ) ] * A . num_of_nodes <eos>
581
src = 1 から 5 未満までの数列を順に A として 、 繰り返 す
trg = for A in range ( 1 , 5 ) :
rst = for A in range ( 1 , 5 ) : <eos>
582
src = C に 1 を加えた値を B とする
trg = B = C + 1
rst = B = C + 1 <eos>
583
src = 1000000007 を 無限大 とする
trg = inf = 1000000007
rst = inf = 1000000007 <eos>
584
src = team をパラメータとして (- B の score 、 team の time 、 - B の num ) の組を返す関数を key として A をソート する
trg = A . sort ( key = lambda B : ( - B . score , B . time , - B . num ) )
rst = A . sort ( key = lambda B : - B . range , B . count , B . count ) ) <eos>
585
src = matrics _ vector _ multiply ( B , C ) を順に A として 、 繰り返 す
trg = for A in matrics_vector_multiply ( B , C ) :
rst = for A in <unk> ( B , C ) : <eos>
586
src = B の bit 2 、 C の総和に C を掛けた値に B の bit 1 、 C の総和を加えた値を A とする
trg = A = B . bit2 . sum ( C ) * C + B . bit1 . sum ( C )
rst = A = B . bit2 . sum ( C ) * C + B . bit1 . sum ( C ) <eos>
587
src = ( 0 . 0000000000000000 、0.0 0000000000000000 ) からなる列を A とする
trg = A = [ 0.0000000000000000 , 0.00000000000000000 ]
rst = A = [ 0 , <unk> <eos>
588
src = A に B を掛けた値に C を加えた値を返す
trg = return A * B + C
rst = return A * B + C <eos>
589
src = A . same ( B , C ) のとき 、
trg = if A . same ( B , C ) :
rst = if A . same ( B , C ) : <eos>
590
src = f ( A -1) に f ( A -2) を加えた値に f ( A -3) を加えた値を返す
trg = return f ( A - 1 ) + f ( A - 2 ) + f ( A - 3 )
rst = return f ( A - 1 ) + f ( A - 2 ) + f ( A - 3 ) ) <eos>
591
src = B の 1 番目から C の 1 番目を引いた値を B の 0 番目から C の先頭を引いた値 で割った値を A とする
trg = A = ( B [ 1 ] - C [ 1 ] ) / ( B [ 0 ] - C [ 0 ] )
rst = A = ( B [ 1 ] - C [ 1 ] ) / ( B [ 0 ] - C [ 0 ] ) <eos>
592
src = B に C を加えた値を D の size で割った余りを A とする
trg = A = ( B + C ) % D . size
rst = A = ( B + C ) % D . size <eos>
593
src = A を 2 で割った商に 1 を加えた値を出力する
trg = print ( A // 2 + 1 )
rst = print ( A // 2 + 1 ) <eos>
594
src = B に C を加えた値の整数値に 1 を加えた値の文字列 の先頭を除いた部分列を A とする
trg = A = str ( int ( B + C ) + 1 ) [ 1 : ]
rst = A = B + str ( C ) + 1 1 + 1 <eos>
595
src = C の 2 に B を掛けた値に 2 を加えた値番目を A の B 番目に する
trg = A [ B ] = C [ 2 * B + 2 ]
rst = A [ B ] = C [ 2 * B + 2 ] <eos>
596
src = A の D に C を加えた値番目を A の B に C を加えた値番目に する
trg = A [ B + C ] = A [ D + C ]
rst = A [ B + C ] = A [ D + C ] <eos>
597
src = A の B から 1 を引いた値番目の 2 乗に 1 を加えた値の平方根を A の B 番目に する
trg = A [ B ] = math . sqrt ( A [ B - 1 ] ** 2 + 1 )
rst = A [ B ] = str ( A [ B - 1 ] ** 2 + 1 ) <eos>
598
src = A を 10 で割った余りが B を 1000 で割った商 と等しくまたは A を 10 で割った余りが B を 1000 で割った余りを 100 で割った商 と等しくまたは A を 10 で割った余りが B を 100 で割った余りを 10 で割った商 と等しいとき 、
trg = if A % 10 == B // 1000 or A % 10 == ( B % 1000 ) // 100 or A % 10 == ( B % 100 ) // 10 :
rst = if A % 10 == B // 1000 or ( A % 1000 == B % 1000 == 100 or ( A % 1000 ) // 100 or ( B % 100 == 100 ) : <eos>
599
src = A から B を引いた値から A を引いた値
trg = A - B - A
rst = A - B - A <eos>
600
src = doChain ( D , B , C ) を展開し 、 それぞれ A 、 B 、 C とする
trg = A , B , C = doChain ( D , B , C )
rst = A , B , C = <unk> ( D , B , C ) <eos>
601
src = stl 1 ( B ) を A とする
trg = A = stl1 ( B )
rst = A = <unk> ( B ) <eos>
602
src = bomb ( A , B , C - D )
trg = bomb ( A , B , C - D )
rst = bomb ( A , B , C - D ) <eos>
603
src = ( 、 つまりネイピア数 、 A ) の組を返す
trg = return ( e , A )
rst = return ( e , A ) <eos>
604
src = A の末尾に (-2、1 に [ MASK ] を加えた値 ) の組 を追加する
trg = A . append ( ( - 2 , + 1 ) )
rst = A . append ( ( - 2 ) ) <eos>
605
src = A の 0 に (-1) からなる列の B に 2 を加えた値回分の列を 挿入する
trg = A . insert ( 0 , [ - 1 ] * ( B + 2 ) )
rst = A . insert ( 0 , [ - 1 ] * ( B + 2 ) ) <eos>
606
src = 0 から 8 未満までの数列の各要素を D とし 、0 から C 未満までの数列の各要素を B とし 、0 の列の列を A とする
trg = A = [ [ 0 for B in range ( C ) ] for D in range ( 8 ) ]
rst = A = [ [ 0 for B in range ( C ) ] for D in range ( 8 ) ] <eos>
607
src = A . get _ size ( B ) を A の iter _ size に する
trg = A . iter_size = A . get_size ( B )
rst = A . root_id = A . <unk> ( B ) <eos>
608
src = A . add _ edge ( B + C ,2* B + 1,1,0)
trg = A . add_edge ( B + C , 2 * B + 1 , 1 , 0 )
rst = A . add_edge ( B + C , 2 , B + 1 , 1 , 0 ) <eos>
609
src = create _ cache ( A , B )
trg = create_cache ( A , B )
rst = <unk> ( A , B ) <eos>
610
src = A の B 番目が 0 より大きくかつ C と B の論理積が 0 と等しくかつ D の長さが E より小さいとき 、
trg = if A [ B ] > 0 and C & B == 0 and len ( D ) < E :
rst = if A [ B ] > 0 and C & B == 0 and len ( D ) < E : <eos>
611
src = A の B 番目から 、 つまり末尾までの部分列に A の 、 つまり先頭から B 番目までの部分列を加えた値 のコピー を A とする
trg = A = ( A [ B : ] + A [ : B ] ) . copy ( )
rst = A = A [ B : ] + A [ : B ] ] . lower ( ) <eos>
612
src = A 、 B から C を引いた値の絶対値の最大値を A とする
trg = A = max ( A , abs ( B - C ) )
rst = A = A , A ( B - C ) <eos>
613
src = A が -1 と等しくなくかつ B が -1 と等しくないとき 、
trg = if A != - 1 and B != - 1 :
rst = if A != - 1 and B != - 1 : <eos>
614
src = A の B に C を加えた値番目を 1 だけ 増 加 させ る
trg = A [ B + C ] += 1
rst = A [ B + C ] += 1 <eos>
615
src = add ( A +1,1)
trg = add ( A + 1 , 1 )
rst = add ( A + 1 , 1 ) <eos>
616
src = 0 から E 未満までの数列の各要素を B とし 、 ( B 、 C 、 D ) の組の列 を追加して A を 更新 する
trg = A . update ( [ ( B , C , D ) for B in range ( E ) ] )
rst = A . update ( [ ( B , C , D ) for B in range ( E ) ] ) <eos>
617
src = A の seconds を 3600 で割った商 、 A の seconds を 3600 で割った余りを 60 で割った商 、 A の seconds を 60 で割った余りを出力する
trg = print ( A . seconds // 3600 , A . seconds % 3600 // 60 , A . seconds % 60 )
rst = print ( A . seconds // 3600 , A . seconds % 3600 // 60 , A . % 60 ) <eos>
618
src = A が 6 に B を掛けた値 より大きいとき 、
trg = if A > 6 * B :
rst = if A > 6 * B : <eos>
619
src = C の D の E 番目の順序数から F を引いた値番目 、 G の D の E 番目の順序数から F を引いた値番目を A 、 B とする
trg = A , B = C [ ord ( D [ E ] ) - F ] , G [ ord ( D [ E ] ) - F ]
rst = A , B = C [ D [ E ] ) - F ] , G [ G ] - F ] <eos>
620
src = ( B 、 C 、 B に C を加えた値 、 B から C を引いた値 ) からなる列を A とする
trg = A = [ B , C , B + C , B - C ]
rst = A = [ B , C , B + C , B - C ] <eos>
621
src = B の WHITE を A の color に する
trg = A . color = B . WHITE
rst = A . color = B . Node ( B ) <eos>
622
src = (2、3) からなる列を A の 0 番目に する
trg = A [ 0 ] = [ 2 , 3 ]
rst = A [ 0 ] = [ 2 , 3 ] <eos>
623
src = A . heappush ( B ,((- C << D )| E , E , C ))
trg = A . heappush ( B , ( ( - C << D ) | E , E , C ) )
rst = A . heappush ( B , ( B , C C D , D ) , E , E , E , C ) ) <eos>
624
src = A の ( B 、 C ) の組番目を A の ( B 、 C から 1 を引いた値 ) の組番目の各要素を D とし 、 D に E を加えた値の列 だけ 増 加 させ る
trg = A [ ( B , C ) ] += [ D + E for D in A [ ( B , C - 1 ) ] ]
rst = A [ ( B , C ) ] += [ D [ E ] ] for D in A [ ( B , C - 1 ) ] <eos>
625
src = A の B に 1 を加えた値番目の C に 1 を加えた値番目 、 D に 1 を加えた値の最小値を A の B に 1 を加えた値番目の C に 1 を加えた値番目に する
trg = A [ B + 1 ] [ C + 1 ] = min ( A [ B + 1 ] [ C + 1 ] , D + 1 )
rst = A [ B + 1 ] [ C + 1 ] = min ( A [ B + 1 ] [ C + 1 ] , D + 1 ) <eos>
626
src = syou ( B , C , A ) を A とする
trg = A = syou ( B , C , A )
rst = A = <unk> ( B , C , A ) <eos>
627
src = next ( C ) を空白で分割した字句列の各要素に 整数を適用した列を展開し 、 それぞれ A 、 B とする
trg = A , B = map ( int , next ( C ) . split ( ) )
rst = A , B = map ( int , C ( ) . split ( ) ) <eos>
628
src = sys の stdin の各要素を B とし 、 B の整数値の列 の各要素を A とし 、 sum _ n ( A ) を出力するの列
trg = [ print ( sum_n ( A ) ) for A in [ int ( B ) for B in sys . stdin ] ]
rst = [ print ( A ) for A in [ int ( B ) for B in sys . stdin ] ] <eos>
629
src = A の nums の B 番目の C 番目が D と等しいとき 、
trg = if A . nums [ B ] [ C ] == D :
rst = if A . nums [ B ] [ C ] == D : <eos>
630
src = propagates (* A )
trg = propagates ( * A )
rst = propagates ( * A ) <eos>
631
src = C に D の E 番目を加えた値を A の B 番目に する
trg = A [ B ] = C + D [ E ]
rst = A [ B ] = C + D [ E ] <eos>
632
src = B の C の D 番目番目を順に A として 、 繰り返 す
trg = for A in B [ C [ D ] ] :
rst = for A in B [ C [ D ] ] : <eos>
633
src = A の 0 番目が B と等しくかつ A の 1 番目が C と等しいとき 、
trg = if A [ 0 ] == B and A [ 1 ] == C :
rst = if A [ 0 ] == B and A [ 1 ] == C : <eos>
634
src = (0) からなる列の I () の整数値回分の列 を順に A として 、 繰り返 す
trg = for A in [ 0 ] * int ( I ( ) ) :
rst = for A in [ 0 ] * int ( I ) ) : <eos>
635
src = B から 30 を引いた値を 2 で割った商を A とする
trg = A = ( B - 30 ) // 2
rst = A = ( B - 30 ) // 2 <eos>
636
src = B から 30 を引いた値を 2 で割った値を A とする
trg = A = ( B - 30 ) / 2
rst = A = ( B - 30 ) / 2 <eos>
637
src = (0) からなる列の B 回分の列を A とする
trg = A = [ 0 ] * B
rst = A = [ 0 ] * B <eos>
638
src = 0 から 9 未満までの数列の各要素を B とし 、 C の B 番目が D と等しいとき の B の列を順に A として 、 繰り返 す
trg = for A in [ B for B in range ( 9 ) if C [ B ] == D ] :
rst = for A in [ B for B in range ( 9 ) if C [ B ] == D ] : <eos>
639
src = B の 、 つまりネイピア数 と等しい要素の最初の位置を A とする
trg = A = B . index ( e )
rst = A = B . index ( e ) <eos>
640
src = A の name を出力する
trg = print ( A . name )
rst = print ( A . name ) <eos>
641
src = B に timedelta ( days = A ) を加えた値を A とする
trg = A = B + timedelta ( days = A )
rst = A = B + <unk> ( A ) <eos>
642
src = 無限の整数列を 1 だけ 増 加 させ る
trg = count += 1
rst = count += 1 <eos>
643
src = A の先頭から A の parent の B 番目を探して見つかった位置を A の parent の B 番目に する
trg = A . parent [ B ] = A . find ( A . parent [ B ] )
rst = A . parent [ B ] = A . find ( A . parent [ B ] ) <eos>
644
src = D の B 番目の E に C を加えた値番目を A の B 番目の C 番目に する
trg = A [ B ] [ C ] = D [ B ] [ E + C ]
rst = A [ B ] [ C ] = D [ B ] [ E + C ] <eos>
645
src = 0 が A 以下かどうかが 8 より小さくかつ 0 が B 以下かどうかが 8 より小さくかつ C の B 番目の A 番目が D と等しいとき 、
trg = if 0 <= A < 8 and 0 <= B < 8 and C [ B ] [ A ] == D :
rst = if 0 <= A < 8 and 0 <= B < 8 and C [ B ] [ A ] == D : <eos>
646
src = write ( A * B )
trg = write ( A * B )
rst = write ( A * B ) <eos>
647
src = A から 3 を引いた値を A とする
trg = A = A - 3
rst = A = A - 3 <eos>
648
src = B に C の D 番目の E 番目に F に 2 を掛けた値に 1 を加えた値を掛けた値を加えた値を A とする
trg = A = B + C [ D ] [ E ] * ( F * 2 + 1 )
rst = A = B + C [ D ] [ E ] + F * 2 + 1 <eos>
649
src = 空文字列を間に入れて A の各要素に str を適用した列を連結した文字列 の整数値から 、 つまり空文字列を間に入れて B の各要素に str を適用した列を連結した文字列 の整数値を引いた値 を出力する
trg = print ( int ( '' . join ( map ( str , A ) ) ) - int ( '' . join ( map ( str , B ) ) ) )
rst = print ( int ( '' . join ( map ( int , A ) ) ) ) , int ( map ( int , B ) ) ) <eos>
650
src = 1000000009 を A とする
trg = A = 1000000009
rst = A = <unk> <eos>
651
src = ( 8 、 A の B 番目 ) からなる列を返す
trg = return [ 8 , A [ B ] ]
rst = return [ 8 , A [ B ] ] <eos>
652
src = A . is _ intersected _ with ( B ) の整数値を出力する
trg = print ( int ( A . is_intersected_with ( B ) ) )
rst = print ( int ( A . <unk> ( B ) ) ) <eos>
653
src = play ()
trg = play ( )
rst = <unk> ( ) <eos>
654
src = 0 から B の先頭 未満までの数列の各要素を C とし 、 A に ( B の 2* C に 1 を加えた値番目 、 B の 2* C に 2 を加えた値番目 ) の組を追加した集まり の列
trg = [ A . add ( ( B [ 2 * C + 1 ] , B [ 2 * C + 2 ] ) ) for C in range ( B [ 0 ] ) ]
rst = [ print ( A + [ B [ 2 * C + 1 ] , B [ 2 2 + 2 ] ) ) for C in range ( B ) ] ] <eos>
655
src = A を ( B 、 C の先頭 ) の組で割った余り を出力する
trg = print ( A % ( B , C [ 0 ] ) )
rst = print ( A % ( B , C [ 0 ] ) ) <eos>
656
src = A の末尾に B から C を引いた値の絶対値 を追加する
trg = A . append ( abs ( B - C ) )
rst = A . append ( abs ( B - C ) ) <eos>
657
src = A の B を書式として C 、 D で整形した文字列 番目を返す
trg = return A [ B . format ( C , D ) ]
rst = return A [ B . format ( C , D ) ] <eos>
658
src = B から C を引いた値の 2 乗に D から C を引いた値の 2 乗を加えた値に E の 2 乗を加えた値の平方根を A とする
trg = A = math . sqrt ( ( B - C ) ** 2 + ( D - C ) ** 2 + E ** 2 )
rst = A = math . sqrt ( ( B - C ) ** 2 + ( D - C ) ** 2 + E ** 2 ) <eos>
659
src = A を B に C を掛けた値が D に含まれるかどうか だけ 増 加 させ る
trg = A += B * C in D
rst = A += B * C <= D <eos>
660
src = A を B の C 番目から B の D 番目を引いた値だけ 増 加 させ る
trg = A += B [ C ] - B [ D ]
rst = A += B [ C ] - B [ D ] <eos>
661
src = B に C を加えた値に D から E を引いた値の絶対値を掛けた値を A とする
trg = A = ( B + C ) * abs ( D - E )
rst = A = B + C + ( D - E ) <eos>
662
src = on _ polygon _ line ( A , B ) のとき 1 、 そうでなければ in _ polygon ( A , B ) のとき 2 、 そうでなければ 0 を出力する
trg = print ( 1 if on_polygon_line ( A , B ) else 2 if in_polygon ( A , B ) else 0 )
rst = print ( 1 if <unk> ( A , B ) else <unk> if <unk> ( A , B ) else else ) else 0 ) <eos>
663
src = distant ( A , B ,2)
trg = distant ( A , B , 2 )
rst = distant ( A , B , 2 ) <eos>
664
src = A が B と等しくまたは C が B と等しくまたは B が D と等しくかつ A が E と等しくまたは B が F と等しくかつ C が E と等しいとき 、
trg = if A == B or C == B or ( B == D and A == E ) or ( B == F and C == E ) :
rst = if A == B or C == B or B == D and A == E or B == F and C == E : <eos>
665
src = (0) からなる列の B から 1 を引いた値回分の列 を順に A として 、 繰り返 す
trg = for A in [ 0 ] * ( B - 1 ) :
rst = for A in [ 0 ] * ( B - 1 ) : <eos>
666
src = A に B を加えた値が C から D を引いた値 より小さくまたは A に C を加えた値が B から D を引いた値より小さいとき 、
trg = if A + B < C - D or A + C < B - D :
rst = if A + B < C - D or A + C < B - D : <eos>
667
src = 0.00000000001 を A とする
trg = A = 0.00000000001
rst = A = <unk> <eos>
668
src = (0、0、0、1、 1、1、 2 、 2、2) からなる列を A とする
trg = A = [ 0 , 0 , 0 , 1 , 1 , 1 , 2 , 2 , 2 ]
rst = A = [ 0 , 0 , 2 , 2 , 2 , 2 , 2 ] <eos>
669
src = bubblesort ( A , B )
trg = bubblesort ( A , B )
rst = <unk> ( A , B ) <eos>
670
src = calc ( A , B ) を出力する
trg = print ( calc ( A , B ) )
rst = print ( calc ( A , B ) ) <eos>
671
src = 0 、 31 を A 、 B とする
trg = A , B = 0 , 31
rst = A , B = 0 , 1000 <eos>
672
src = A の文字列を A とする
trg = A = str ( A )
rst = A = str ( A ) <eos>
673
src = B 内の B の C 番目の出現回数を A とする
trg = A = B . count ( B [ C ] )
rst = A = B . count ( B [ C ] ) <eos>
674
src = sort _ middle _ face ( A ) を A とする
trg = A = sort_middle_face ( A )
rst = A = <unk> ( A ) <eos>
675
src = A の 2 乗が B の 2 乗に C の 2 乗を加えた値と等しいとき 、
trg = if A ** 2 == B ** 2 + C ** 2 :
rst = if A ** 2 == B ** 2 + C ** 2 : <eos>
676
src = countingSort ( A , B )
trg = countingSort ( A , B )
rst = <unk> ( A , B ) <eos>
677
src = 2 に B を加えた値に 2 に C に D を加えた値を掛けた値を加えた値に 2 に E に F を加えた値を掛けた値を加えた値を A とする
trg = A = 2 + B + 2 * ( C + D ) + 2 * ( E + F )
rst = A = 2 + B + 2 * ( C + D ) + 2 * ( E + F ) <eos>
678
src = 改行せずに A を英大文字に変換した文字列 を出力する
trg = print ( A . upper ( ) , end = '' )
rst = print ( A . upper ( ) , end = '' ) <eos>
679
src = 0 から D に 1 を加えた値未満までの数列の各要素 を C とし 、 B に C を掛けた値の列を A とする
trg = A = [ B * C for C in range ( D + 1 ) ]
rst = A = [ B * C for C in range ( D + 1 ) ] <eos>
680
src = ( B 、0) の組を A の B 番目に する
trg = A [ B ] = ( B , 0 )
rst = A [ B ] = ( B , 0 ) <eos>
681
src = D 、 E 、 F の最大値を A の B 番目の C 番目に する
trg = A [ B ] [ C ] = max ( D , E , F )
rst = A [ B ] [ C ] = max ( D , E , F ) <eos>
682
src = sys の stdin の各要素に 整数を適用した列のリストを A とする
trg = A = list ( map ( int , sys . stdin ) )
rst = A = list ( map ( int , sys . stdin ) ) <eos>
683
src = B の 7 番目から 、 つまり末尾までの部分列を A とする
trg = A = B [ 7 : - 1 ]
rst = A = B [ 7 : ] <eos>
684
src = B の C 番目の F 番目を E とする
trg = E = B [ C ] [ F ]
rst = E = B [ C ] [ F ] <eos>
685
src = A . print _ all ()
trg = A . print_all ( )
rst = A . <unk> ( ) <eos>
686
src = D [ d ] () が A と等しくないとき 、
trg = if D[d] ( ) != A :
rst = if D . d ( ) != A : <eos>
687
src = delete ( A , int ( B [0]))
trg = delete ( A , int ( B [ 0 ] ) )
rst = delete ( A , int ( B [ 0 ] ) ) <eos>
688
src = buildMaxHeap ( A , B )
trg = buildMaxHeap ( A , B )
rst = <unk> ( A , B ) <eos>
689
src = heappush ( A , ( B +2, C +1, D ))
trg = heappush ( A , ( B + 2 , C + 1 , D ) )
rst = heappush ( A , ( B + 2 , C + 1 , D ) ) <eos>
690
src = A 、 B の E の C の D 番目番目の E の D 番目番目の cap の最小値を A とする
trg = A = min ( A , B . E [ C [ D ] ] [ E [ D ] ] . cap )
rst = A = min ( A , B . E [ C [ D ] ] [ E [ D ] ] . cap ) <eos>
691
src = A の deg の 、 つまりネイピア数の 1 番目番目を 1 だけ 増 加 させ る
trg = A . deg [ e [ 1 ] ] += 1
rst = A . deg [ e [ 1 ] ] += 1 <eos>
692
src = - A を返す
trg = return - A
rst = return - A <eos>
693
src = A を書式として intersection ((0,0, B ) , C ) で整形した文字列を出力する
trg = print ( A . format ( intersection ( ( 0 , 0 , B ) , C ) ) )
rst = print ( A . format ( max ( 0 ( 0 , B ) , C ) ) ) <eos>
694
src = A 、 B 、 C を出力する
trg = print ( A , B , C )
rst = print ( A , B , C ) <eos>
695
src = 2 が A の B 番目 の先頭の長さより小さくかつ A の B 番目の先頭 の長さが 7 より小さいとき 、
trg = if 2 < len ( A [ B ] [ 0 ] ) and len ( A [ B ] [ 0 ] ) < 7 :
rst = if 2 < A [ B ] ] . count ( A [ B ] [ 0 ] ) < 7 : <eos>
696
src = 0 が cross ( A - B , C - D ) と等しいとき 、
trg = if 0 == cross ( A - B , C - D ) :
rst = if 0 == cross ( A - B , C - D ) : <eos>
697
src = B から C を引いた値を A の d に する
trg = A . d = B - C
rst = A . d = B - C <eos>
698
src = A の整数値から B の整数値を引いた値 が 0 と等しくないとき 、
trg = if int ( A ) - int ( B ) != 0 :
rst = if int ( A ) - int ( B ) != 0 : <eos>
699
src = 入力された文字列 を空白で分割した字句列の各要素を C とし 、 C の整数値の列を展開し 、 それぞれ A 、 B 、 C 、 D 、 E とする
trg = A , B , C , D , E = [ int ( C ) for C in input ( ) . split ( ) ]
rst = A , B , C , D , E = [ int ( C ) for C in input ( ) . split ( ) ] <eos>
700
src = A を B から 1 を引いた値から C を引いた値に D の C 番目を掛けた値を B から 1 を引いた値に E を掛けた値で割った値だけ 増 加 させ る
trg = A += ( ( B - 1 - C ) * D [ C ] ) / ( ( B - 1 ) * E )
rst = A += ( B - 1 - C ) * D [ C ] ) ( ( B - 1 ) * E ) <eos>
701
src = 空文字列を間に入れて B を連結した文字列の整数値を A とする
trg = A = int ( '' . join ( B ) )
rst = A = int ( '' . join ( B ) ) <eos>
702
src = A が B の C 番目以下のとき 、
trg = if A <= B [ C ] :
rst = if A <= B [ C ] : <eos>
703
src = rotate _ cw ( A ) を A とする
trg = A = rotate_cw ( A )
rst = A = <unk> ( A ) <eos>
704
src = 2 から B に 1 を加えた値 の 0.5 乗を 四捨五 入した整数値の整数値 未満までの数列を順に A として 、 繰り返 す
trg = for A in range ( 2 , int ( round ( pow ( B + 1 , 0.5 ) ) ) ) :
rst = for A in range ( 2 , int ( range ( 1 , B + 1 ) ** 0.5 ) ) : <eos>
705
src = 空辞書を B とする
trg = B = { }
rst = B = { } <eos>
706
src = B の C 番目に D の E 番目を加えた値 、 B の E 番目に D の C 番目を加えた値の最小値を A とする
trg = A = min ( B [ C ] + D [ E ] , B [ E ] + D [ C ] )
rst = A = min ( B [ C ] + D [ E ] , B [ E ] + D [ C ] ) <eos>
707
src = "{} x {} = {}" を出力する
trg = print ( {i}x{j}={i*j} )
rst = print ( <unk> <unk> <unk> <unk> <unk> ) <eos>
708
src = ( B ) からなる列の C から 1 を引いた値回分の列を D とする
trg = D = [ B ] * ( C - 1 )
rst = D = [ B ] * ( C - 1 ) <eos>
709
src = A の 0 番目が B と等しくかつ A の 2 番目が B と等しくかつ A の 4 番目が C と等しいとき 、
trg = if A [ 0 ] == B and A [ 2 ] == B and A [ 4 ] == C :
rst = if A [ 0 ] == B and A [ 2 ] == B and A [ 4 ] == C : <eos>
710
src = A 、 dfs ( B , C +1,0, D ,1,0) の最小値を A とする
trg = A = min ( A , dfs ( B , C + 1 , 0 , D , 1 , 0 ) )
rst = A = min ( A , dfs ( B , C + 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ) <eos>
711
src = A の先頭の末尾に ( B 、0) の組 を追加する
trg = A [ 0 ] . append ( ( B , 0 ) )
rst = A [ 0 ] . append ( ( B , 0 ) ) <eos>
712
src = A の最大値から A の最小値を引いた値 を出力する
trg = print ( max ( A ) - min ( A ) )
rst = print ( max ( A ) - min ( A ) ) <eos>
713
src = A . cross ( B ) が 0.0 と等しいかどうかを返す
trg = return A . cross ( B ) == 0.0
rst = return A . cross ( B ) == 0.0 <eos>
714
src = A の B 番目の C 番目から D を引いた値の絶対値が 1 より大きいとき 、
trg = if abs ( A [ B ] [ C ] - D ) > 1 :
rst = if abs ( A [ B ] [ C ] - D ) > 1 : <eos>
715
src = A を str ( B ) . rjust (4) だけ 増 加 させ る
trg = A += str ( B ) . rjust ( 4 )
rst = A += str ( B ) . rjust ( 4 ) <eos>
716
src = B を B と - B の論理積で割った商 を 1 だけ右シフトした値を A とする
trg = A = ( B // ( B & - B ) ) >> 1
rst = A = B // ( B & - B ) ) >> 1 <eos>
717
src = A を B の C から D に E を掛けた値 を引いた値番目だけ 増 加 させ る
trg = A += B [ C - D * E ]
rst = A += B [ C - D * E ] <eos>
718
src = A を B に C を掛けた値 の 2 乗に C を掛けた値だけ 増 加 させ る
trg = A += ( B * C ) ** 2 * C
rst = A += ( B * C ) ** 2 * C <eos>
719
src = A の B 番目の C 番目 、 A の B 番目の D 番目に A の D 番目の C 番目を加えた値に E に F を掛けた値に G を掛けた値を加えた値の最小値を A の B 番目の C 番目に する
trg = A [ B ] [ C ] = min ( A [ B ] [ C ] , A [ B ] [ D ] + A [ D ] [ C ] + E * F * G )
rst = A [ B ] [ C ] = min ( A [ B ] [ C ] , A [ B ] [ D ] + A [ D ] [ C ] + E * F ) * G ) <eos>
720
src = B の x 座標に C の正弦を掛けた値に B の y 座標に C の余弦を掛けた値を加えた値 を A とする
trg = A = B . x * sin ( C ) + B . y * cos ( C )
rst = A = B . x * cos ( C ) * B . y * sin ( C ) <eos>
721
src = C を A の B 番目に する
trg = A [ B ] = C
rst = A [ B ] = C <eos>
722
src = A の tail を 1 だけ 減 少 させ る
trg = A . tail -= 1
rst = A . tail -= 1 <eos>
723
src = (0) からなる列に accumulate ( B ) のリストを加えた値を A とする
trg = A = [ 0 ] + list ( accumulate ( B ) )
rst = A = [ 0 ] + list ( accumulate ( B ) ) ) <eos>
724
src = A から B の総和を引いた値 を出力する
trg = print ( A - sum ( B ) )
rst = print ( A - sum ( B ) ) <eos>
725
src = A が 9 より小さいとき 、
trg = if A < 9 :
rst = if A < 9 : <eos>
726
src = A の末尾に B を 1000000007 で割った余り を追加する
trg = A . append ( B % 1000000007 )
rst = A . append ( B % 1000000007 ) <eos>
727
src = A の B に 1 を加えた値から 2 に B を掛けた値に 1 を加えた値までの部分列の総和 を出力する
trg = print ( sum ( A [ B + 1 : 2 * B + 1 ] ) )
rst = print ( sum ( A [ B + 1 : 2 * B + 1 ] ) ) <eos>
728
src = B の先頭を取り出した値 を展開し 、 それぞれ A 、 ネイピア数とする
trg = A , e = B . pop ( )
rst = A , e = B . pop ( ) <eos>
729
src = cross _ point ( C , D ) を展開し 、 それぞれ A 、 B とする
trg = A , B = cross_point ( C , D )
rst = A , B = cross_point ( C , D ) <eos>
730
src = A の 1 番目を A の 0 番目 で割った余りが 0 と等しいとき 、
trg = if A [ 1 ] % A [ 0 ] == 0 :
rst = if A [ 1 ] % A [ 0 ] == 0 : <eos>
731
src = chi _ liu _ edmonds ( A , B , C ) を出力する
trg = print ( chi_liu_edmonds ( A , B , C ) )
rst = print ( <unk> ( A , B , C ) ) <eos>
732
src = B を A の cur の prev の next に する
trg = A . cur . prev . next = B
rst = A . cur . prev . next = B <eos>
733
src = In _ order ( A [ B ][0])
trg = In_order ( A [ B ] [ 0 ] )
rst = In_order ( A [ B ] [ 0 ] ) <eos>
734
src = A の先頭の 1 番目の浮動小数点数を B で割った値が 0.5 より大きいとき 、
trg = if float ( A [ 0 ] [ 1 ] ) / B > 0.5 :
rst = if float ( A [ 0 ] [ 1 ] ) > B > 0.5 : <eos>
735
src = A の B 番目が A の C 番目と等しいとき 1 、 そうでなければ 0 を出力する
trg = print ( 1 if A [ B ] == A [ C ] else 0 )
rst = print ( 1 if A [ B ] == A [ C ] else 0 ) <eos>
736
src = (0、 9 、 2 6、5 0、80、1 15 、 154 、196、2 40 、 28 5、33 0 ) からなる列を A とする
trg = A = [ 0 , 9 , 26 , 50 , 80 , 115 , 154 , 196 , 240 , 285 , 330 ]
rst = A = [ 0 , 3 , 2 , <unk> , <unk> , <unk> , <unk> , <unk> , <unk> , <unk> , <unk> , <unk> , <unk> , <unk> , <unk> , <unk> , <unk> , <unk> , <unk> , <unk> , <unk> , <unk> ] <eos>
737
src = 0 を出力する
trg = print ( 0 )
rst = print ( 0 ) <eos>
738
src = C の D 番目を A の B の C の D 番目番目 番目に する
trg = A [ B [ C [ D ] ] ] = C [ D ]
rst = A [ B [ C [ D ] ] = C [ D ] <eos>
739
src = 入力された文字列 を空白で分割した字句列の各要素を D とし 、 D の整数値の列を ソートした列を展開し 、 それぞれ A 、 B 、 C とする
trg = A , B , C = sorted ( [ int ( D ) for D in input ( ) . split ( ) ] )
rst = A , B , C = sorted ( [ int ( D ) for D in input ( ) . split ( ) ] ) <eos>
740
src = B が C 以下のとき D 、 そうでなければ 0 を A とする
trg = A = D if B <= C else 0
rst = A = D if B <= C else 0 <eos>
741
src = A を B から読み込んだ一行 の 1 番目から C に 1 を加えた値までの部分列 だけ 増 加 させ る
trg = A += B . readline ( ) [ 1 : C + 1 ]
rst = A += B . cos ( B ) [ 1 : C + 1 ] <eos>
742
src = A を (0) からなる列 だけ 増 加 させ る
trg = A += [ 0 ]
rst = A += [ 0 ] <eos>
743
src = 0 が A 以下かどうかが B の長さより小さいとき 、
trg = if 0 <= A < len ( B ) :
rst = if 0 <= A < len ( B ) : <eos>
744
src = ( 1 、 A の B の 2 番目番目 、 A の B の 3 番目番目 、 B の 4 番目の整数値 ) からなる列を返す
trg = return [ 1 , A [ B [ 2 ] ] , A [ B [ 3 ] ] , int ( B [ 4 ] ) ]
rst = return [ 1 , A [ B [ 2 ] ] , A [ B [ 3 ] ] , int ( B [ 4 ] ) ] <eos>
745
src = A が 20 より大きいとき 、
trg = if A > 20 :
rst = if A > 20 : <eos>
746
src = get ( A [1]) を出力する
trg = print ( get ( A [ 1 ] ) )
rst = print ( get ( A [ 1 ] ) ) <eos>
747
src = A が B と等しいかどうかの整数値 を出力する
trg = print ( int ( A == B ) )
rst = print ( int ( A == B ) ) <eos>
748
src = A . enqueue ([ B , int ( C )])
trg = A . enqueue ( [ B , int ( C ) ] )
rst = A . enqueue ( [ B , int ( C ) ] ) <eos>
749
src = B に B から C を引いた値を掛けた値に B から D を引いた値を掛けた値に B から E を引いた値を掛けた値の平方根を A とする
trg = A = math . sqrt ( B * ( B - C ) * ( B - D ) * ( B - E ) )
rst = A = B * ( B - C ) * ( B - D ) * ( B - E ) <eos>
750
src = プ ログラムを 正 常終了 する
trg = sys . exit ( )
rst = import 1600 <eos>
751
src = B の e の C 番目の B の iter の C 番目番目を A とする
trg = A = B . e [ C ] [ B . iter [ C ] ]
rst = A = B . e [ C ] [ B . iter [ C ] ] <eos>
752
src = C の 、 つまり先頭から D 番目までの部分列に E を加えた値に C の D に 5 を加えた値から 、 つまり末尾までの部分列を加えた値 を A の B 番目に する
trg = A [ B ] = C [ : D ] + E + C [ D + 5 : ]
rst = A [ B ] = C [ : D ] + E + C [ D + 5 : ] <eos>
753
src = B の 17 番目 、 B の 12 番目を A の 12 番目 、 A の 17 番目とする
trg = A [ 12 ] , A [ 17 ] = B [ 17 ] , B [ 12 ]
rst = A [ 12 ] , A [ 17 ] = B [ 17 ] , B [ 12 ] <eos>
754
src = 2 から A を引いた値を A とする
trg = A = 2 - A
rst = A = 2 - A <eos>
755
src = tangent _ point ( B , ( C , D )) を A とする
trg = A = tangent_point ( B , ( C , D ) )
rst = A = <unk> ( B , ( C , D ) ) <eos>
756
src = B から C を引いた値の絶対値から 0.5 を引いた値 の整数値 、 D から C を引いた値の絶対値から 0.5 を引いた値の 整数値の最大値を A とする
trg = A = max ( int ( abs ( B - C ) - 0.5 ) , int ( abs ( D - C ) - 0.5 ) )
rst = A = max ( ( B - C ) ** 0.5 ) + ( ( D - C ) ) ** 0.5 ) <eos>
757
src = A の B 番目から C 番目までの部分列を 削 除 する
trg = del A [ B : C ]
rst = del A [ B : C ] <eos>
758
src = A 、 B に 1 を加えた値を出力する
trg = print ( A , B + 1 )
rst = print ( A , B + 1 ) <eos>
759
src = A に B * 15 を加えた値に C に 15 を掛けた値を加えた値に D に 15 を掛けた値を加えた値に E に 7 を掛けた値を加えた値に F に 2 を掛けた値を加えた値を A とする
trg = A = A + B * 15 + C * 15 + D * 15 + E * 7 + F * 2
rst = A = A + B B + 15 + C * 1870 + D * 1870 + E * 7 + F * 2 <eos>
760
src = B を 3600 で割った商 の文字列を長さ 2 に な るように '0' 左 詰め した文字列を A とする
trg = A = str ( B // 3600 ) . zfill ( 2 )
rst = A = str ( B // 3600 ) . zfill ( 2 ) <eos>
761
src = B を _ pow (10,4 ) で割った商を A とする
trg = A = B // _pow ( 10 , 4 )
rst = A = B // _pow ( 10 , <eos>
762
src = C から B を引いた値を A の B 番目に する
trg = A [ B ] = C - B
rst = A [ B ] = C - B <eos>
763
src = copy の先頭を A の 3 番目に する
trg = A [ 3 ] = copy [ 0 ]
rst = A [ 3 ] = copy [ 0 ] <eos>
764
src = is _ contain _ cycle ( A , B ) のとき 1 、 そうでなければ 0 を出力する
trg = print ( 1 if is_contain_cycle ( A , B ) else 0 )
rst = print ( 1 if <unk> ( A , B ) else 0 ) <eos>
765
src = 2 2 が B より大きいとき 2 2 から B を引いた値 、 そうでなければ B から 2 2 を引いた値を A とする
trg = A = 22 - B if 22 > B else B - 22
rst = A = 2 2 2 * 2 if B > 2 else B - 2 if B - 2 <eos>
766
src = A の B の C 番目番目を 2 だけ 増 加 させ る
trg = A [ B [ C ] ] += 2
rst = A [ B [ C ] ] += 2 <eos>
767
src = A の末尾に B の先頭の整数値 を追加する
trg = A . append ( int ( B [ 0 ] ) )
rst = A . append ( int ( B [ 0 ] ) ) <eos>
768
src = B を A の 3 番目に する
trg = A [ 3 ] = B
rst = A [ 3 ] = B <eos>
769
src = A の末尾に 3 に A の B 番目を掛けた値に 1 を加えた値 を追加する
trg = A . append ( 3 * A [ B ] + 1 )
rst = A . append ( 3 * A [ B ] + 1 ) <eos>
770
src = A の 5 に B を掛けた値番目の C 番目を出力する
trg = print ( A [ 5 * B ] [ C ] )
rst = print ( A [ 5 * B ] [ C ] ) <eos>
771
src = ( ( B , 未定値 )) からなる辞書を A とする
trg = A = { start : None }
rst = A = { <unk> : None } <eos>
772
src = C に D を掛けた値を B とする
trg = B = C * D
rst = B = C * D <eos>
773
src = A 、 B を書式として C を 100 で割った商 、 C を 100 で割った余り で整形した文字列を出力する
trg = print ( A , B . format ( C // 100 , C % 100 ) )
rst = print ( A , B . format ( C // 100 , C % 100 ) ) <eos>
774
src = write ( A % B [ ( convert (2004, C , D ) - convert (2004, 1 ,1) +3) % 7 ] )
trg = write ( A % B [ ( convert ( 2004 , C , D ) - convert ( 2004 , 1 , 1 ) + 3 ) % 7 ] )
rst = write ( A % B [ min ( [ C , D , - ( 1868 , 9 , 1 ) ] ) <eos>
775
src = B に C を加えた値に D を加えた値を 2 で割った値を A とする
trg = A = ( B + C + D ) / 2
rst = A = ( B + C + D ) / 2 <eos>
776
src = ( A の 4 番目 、 A の先頭 、 A の 2 番目 、 A の 3 番目 、 A の 5 番目 、 A の 1 番目 ) からなる列を返す
trg = return [ A [ 4 ] , A [ 0 ] , A [ 2 ] , A [ 3 ] , A [ 5 ] , A [ 1 ] ]
rst = return [ A [ 4 ] , A [ 0 ] , A [ 2 ] , A [ 5 ] , A [ 1 ] , A [ 1 ] ] <eos>
777
src = 区 切りなしで改行せずに A の B 番目の C 番目を出力する
trg = print ( A [ B ] [ C ] , sep = '' , end = '' )
rst = print ( A [ B ] [ C ] , sep = '' , end = '' ) <eos>
778
src = A の B 番目の C を 2 で割った商に 1 を加えた値番目を 4 と の 論理和に する
trg = A [ B ] [ C // 2 + 1 ] |= 4
rst = A [ B ] [ C // 2 + 1 ] |= 4 <eos>
779
src = B の 2 乗に B を加えた値に 2 を加えた値を 2 で割った商を A とする
trg = A = ( B ** 2 + B + 2 ) // 2
rst = A = ( B ** 2 + B + 2 ) // 2 <eos>
780
src = B 、 C 、 D 、0 に お いて正規表現 A が最初にマッチする位置 を返す
trg = return search ( A , B , C , D , 0 )
rst = return search ( A , B , C , D , 0 ) <eos>
781
src = A を B に C を掛けた値から B に D を掛けた値を引いた値 だけ 増 加 させ る
trg = A += B * C - B * D
rst = A += B * C - B * D <eos>
782
src = A の B 番目が全て数字 かつ A の B に 1 を加えた値 番目が全て数字 のとき 、
trg = if A [ B ] . isdigit ( ) and A [ B + 1 ] . isdigit ( ) :
rst = if A . B [ B ] . and A [ B + 1 ] . isdigit ( ) : <eos>
783
src = B の 1 番目を B の 2 番目で割った余りを A とする
trg = A = B [ 1 ] % B [ 2 ]
rst = A = B [ 1 ] % B [ 2 ] <eos>
784
src = A から B を引いた値 、0 の最大値を A とする
trg = A = max ( A - B , 0 )
rst = A = max ( A - B , 0 ) <eos>
785
src = 2 と A 、 B の ユ ー ク リ ッ ド距離 を出力する
trg = print ( dist ( 2 , A , B ) )
rst = print ( dist ( 2 , A , B ) ) <eos>
786
src = A を prod ( B ) だけ 増 加 させ る
trg = A += prod ( B )
rst = A += area ( B ) <eos>
787
src = B . flow (2* C ,2* C +1, C ) を A とする
trg = A = B . flow ( 2 * C , 2 * C + 1 , C )
rst = A = B . flow ( 2 * C , 2 * C + 1 , C ) <eos>
788
src = inner _ product ( B , C ) を A とする
trg = A = inner_product ( B , C )
rst = A = bst_find ( B , C ) <eos>
789
src = C の D から E を引いた値番目を展開し 、 それぞれ A 、 B とする
trg = A , B = C [ D - E ]
rst = A , B = C [ D - E ] <eos>
790
src = A が 0 以上かつ A が 12 より小さくかつ B が 0 以上かつ B が 12 より小さいとき 、
trg = if A >= 0 and A < 12 and B >= 0 and B < 12 :
rst = if A >= 0 and A < 12 and B >= 0 and B < 12 : <eos>
791
src = 0 から C 未満までの数列の各要素を B とし 、 A の B 番目を出力するの列
trg = [ print ( A [ B ] ) for B in range ( C ) ]
rst = [ print ( A [ B ] ) for B in range ( C ) ] <eos>
792
src = A が 、 つまり偽 と等しいとき 、
trg = if A == False :
rst = if A == False : <eos>
793
src = ( B の C 番目から D を引いた値に E を加えた値 、 D のとき F の C 番目の 、 つまり先頭から - D 番目までの部分列 、 そうでなければ F の C 番目に G を加えた値 ) の組を A とする
trg = A = ( B [ C ] - D + E , ( F [ C ] [ : - D ] if D else F [ C ] ) + G )
rst = A = ( ( B [ C ] - D + E ) if D [ F ] - D D if D [ C ] + D if D [ + C ] + D ) + G ) <eos>
794
src = 0 を A の score に する
trg = A . score = 0
rst = A . score = 0 <eos>
795
src = Node (2) を A とする
trg = A = Node ( 2 )
rst = A = Node ( 2 ) <eos>
796
src = 0 から 25000 未満までの数列を順に A として 、 繰り返 す
trg = for A in range ( 25000 ) :
rst = for A in range ( <unk> ) : <eos>
797
src = A が B 以上または C が B 以上または D が B 以上のとき 、
trg = if A >= B or C >= B or D >= B :
rst = if A >= B or C >= B >= D : <eos>
798
src = 1 を A の先頭の B を 3 で割った商番目の B を 3 で割った余り番目に する
trg = A [ 0 ] [ B // 3 ] [ B % 3 ] = 1
rst = A [ 0 ] [ B // 3 ] [ B % 3 ] = 1 <eos>
799
src = r ( B +1, l ( C )) の逆順 を順に A として 、 繰り返 す
trg = for A in r ( B + 1 , l ( C ) ) [ : : - 1 ] :
rst = for A in r ( B + 1 , l ( C ) [ : : - 1 ] : <eos>
800
src = A の末尾に query ( B [0], B [1]+1) を追加する
trg = A . append ( query ( B [ 0 ] , B [ 1 ] + 1 ) )
rst = A . append ( str ( query ( B [ 0 ] , B [ 0 ] ) ) ) <eos>
801
src = A の値の集まりの B から 1 を引いた値番目の C から 1 を引いた値番目を返す
trg = return A . values [ B - 1 ] [ C - 1 ]
rst = return A . values [ B - 1 ] [ C - 1 ] <eos>
802
src = 0 から C から 1 を引いた値 未満までの数列の各要素を B とし 、 read () の列を A とする
trg = A = [ read ( ) for B in range ( C - 1 ) ]
rst = A = [ read ( ) for B in range ( C - 1 ) ] <eos>
803
src = A の C に D を加えた値番目 、 A の B 番目を A の B 番目 、 A の C に D を加えた値番目とする
trg = A [ B ] , A [ C + D ] = A [ C + D ] , A [ B ]
rst = A [ B ] , A [ C + D ] = A [ C + D ] , A [ B ] <eos>
804
src = B に C を加えた値から 1 を引いた値を A とする
trg = A = B + C - 1
rst = A = B + C - 1 <eos>
805
src = A の B から C を引いた値番目を 2 だけ 増 加 させ る
trg = A [ B - C ] += 2
rst = A [ B - C ] += 2 <eos>
806
src = 0 から 101 未満までの数列の各要素を C とし 、0 から 3 未満までの数列の各要素を B とし 、0 の列の列を A とする
trg = A = [ [ 0 for B in range ( 3 ) ] for C in range ( 101 ) ]
rst = A = [ [ 0 for B in range ( 3 ) ] for C in range ( 101 ) ] <eos>
807
src = A の B に C に D を掛けた値を加えた値番目の末尾に ( E に C に D を掛けた値を加えた値 、 F ) の組 を追加する
trg = A [ B + C * D ] . append ( ( E + C * D , F ) )
rst = A [ B + C * D ] . append ( ( E + C * D , F ) ) <eos>
808
src = A ._ find ( B ) が A ._ find ( C ) と等しくないとき 、
trg = if A . _find ( B ) != A . _find ( C ) :
rst = if A . _find ( B ) != A . _find ( C ) : <eos>
809
src = A の B に C を加えた値番目の D に E を加えた値番目が 3 と等しいとき 、
trg = if A [ B + C ] [ D + E ] == 3 :
rst = if A [ B + C ] [ D + E ] == 3 : <eos>
810
src = A の B 乗を 10 の 9 乗に 7 を加えた値 で割った余りを出力する
trg = print ( ( A ** B ) % ( pow ( 10 , 9 ) + 7 ) )
rst = print ( A ** B % ( 10 ** 9 + 7 ) ) <eos>
811
src = calc _ a ( B [ C ] ) を A とする
trg = A = calc_a ( B [ C ] )
rst = A = <unk> ( B [ C ] ) <eos>
812
src = (1) からなる列の B から A を引いた値回分の列を time の A 番目から B 番目までの部分列に する
trg = time [ A : B ] = [ 1 ] * ( B - A )
rst = time [ A : B ] = [ 1 ] * ( B - A ) <eos>
813
src = B [ C ] の D 番目の 1 番目から B [ E -1 ] の D 番目の 1 番目を引いた値から B の C 番目の F から 1 を引いた値番目の 1 番目を引いた値に B の E から 1 を引いた値番目の F から 1 を引いた値番目の 1 番目を加えた値を A の 1 番目に する
trg = A [ 1 ] = B [ C ] [ D ] [ 1 ] - B [ E - 1 ] [ D ] [ 1 ] - B [ C ] [ F - 1 ] [ 1 ] + B [ E - 1 ] [ F - 1 ] [ 1 ]
rst = A [ 1 ] = B [ C ] [ D ] [ B [ 1 ] - B [ E - 1 ] ] [ B ] - 1 ] [ B [ E - 1 ] [ D ] - 1 ] - B [ C - 1
814
src = C の逆順 を順に A 、 B として 、 繰り返 す
trg = for A , B in C [ : : - 1 ] :
rst = for A , B in C [ : : - 1 ] : <eos>
815
src = ソートされた順序を保ったまま C の先頭を B に挿入できる位置を A とする
trg = A = bisect . bisect_left ( B , C [ 0 ] )
rst = A = bisect . bisect_left ( B , C [ 0 ] ) <eos>
816
src = A の B 番目の C 番目に A [ B -1 ] の C 番目に C を掛けた値を加えた値に A の B から 1 を引いた値番目の C から 1 を引いた値番目を加えた値を D で割った余りを A の B 番目の C 番目に する
trg = A [ B ] [ C ] = ( A [ B ] [ C ] + A [ B - 1 ] [ C ] * C + A [ B - 1 ] [ C - 1 ] ) % D
rst = A [ B ] [ C ] = ( A [ B ] [ C ] + A [ B - 1 ] [ C ] * C + A [ B - 1 ] [ C - 1 ] ) % D <eos>
817
src = B の C の先頭番目を A とする
trg = A = B [ C [ 0 ] ]
rst = A = B [ C [ 0 ] ] <eos>
818
src = add ( A . x * B . x , A . y * B . y ) を返す
trg = return add ( A . x * B . x , A . y * B . y )
rst = return add ( A . x * B . x , A . y * B . y ) <eos>
819
src = A の末尾に B の先頭の C 番目を追加する
trg = A . append ( B [ 0 ] [ C ] )
rst = A . append ( B [ 0 ] [ C ] ) <eos>
820
src = A を書式として B の x 座標 、 B の y 座標で整形した文字列 を返す
trg = return A . format ( B . x , B . y )
rst = return A . format ( B . x , B . y ) <eos>
821
src = 空文字列を間に入れて B を連結した文字列を C で分割した字句列を A とする
trg = A = '' . join ( B ) . split ( C )
rst = A = '' . join ( B ) . split ( C ) <eos>
822
src = A の末尾に入力された文字列を C で分割した字句列の各要素を B とし 、 B の整数値の列 を追加する
trg = A . append ( [ int ( B ) for B in input ( ) . split ( C ) ] )
rst = A . append ( [ int ( B ) for B in input ( ) . split ( C ) ] ) <eos>
823
src = dist 2( B , C ) の .5 乗を A とする
trg = A = dist2 ( B , C ) ** .5
rst = A = pow ( B , C ) ** .5 <eos>
824
src = C の B 番目が -1 と等しくないとき D の C の B 番目番目 、 そうでなければ -1 を A の B 番目に する
trg = A [ B ] = D [ C [ B ] ] if C [ B ] != - 1 else - 1
rst = A [ B ] = D [ C [ B ] ] if C [ B ] != - 1 else - 1 <eos>
825
src = check ( A [ B ] ) が 、 つまり真 と等しくまたは check ( rev ( A [ B ])) が 、 つまり真と等しいとき 、
trg = if ( check ( A [ B ] ) == True ) or ( check ( rev ( A [ B ] ) ) == True ) :
rst = if check ( ( A [ B ] ) == True or judge ( merge ( A [ B ] ) == True : <eos>
826
src = 0 を A の B 番目の C 番目の D 番目の E に 1 を加えた値番目に する
trg = A [ B ] [ C ] [ D ] [ E + 1 ] = 0
rst = A [ B ] [ C ] [ D ] [ E + 1 ] = 0 <eos>
827
src = A の match の B 番目が 、 つまり未定値と等しいとき 、
trg = if A . match [ B ] is not None :
rst = if A . match [ B ] is not None : <eos>
828
src = C を 2 で割った余りを D とする
trg = D = C % 2
rst = D = C % 2 <eos>
829
src = A の先頭に B を追加した集まり
trg = A [ 0 ] . add ( B )
rst = A . appendleft ( B ) <eos>
830
src = B の C 番目にネイピア数の C 番目の D 番目の 1 番目を加えた値を A とする
trg = A = B [ C ] + e [ C ] [ D ] [ 1 ]
rst = A = B [ C ] [ C ] [ D ] [ 1 ] <eos>
831
src = C の 2 番目に C の 4 番目を加えた値に C の 6 番目を加えた値に C の 8 番目を加えた値と 60 を 割った ときの ( 商を展開し 、 それぞれ A 、 B とする
trg = A , B = divmod ( ( C [ 2 ] + C [ 4 ] + C [ 6 ] + C [ 8 ] ) , 60 )
rst = A , B = divmod ( C [ 2 ] + C [ 4 ] + C [ 6 ] + C [ 8 ] ) / 60 ) <eos>
832
src = A を書式として B 、 C 、 D 、 E で整形した文字列を出力する
trg = print ( A . format ( B , C , D , E ) )
rst = print ( A . format ( B , C , D , E ) ) <eos>
833
src = A を 500 で割った余りを A とする
trg = A = A % 500
rst = A = A % 500 <eos>
834
src = A を 25 で割った余りに する
trg = A %= 25
rst = A %= 25 <eos>
835
src = A と B の論理積が B と等しいかどうかの整数値 を出力する
trg = print ( int ( A & B == B ) )
rst = print ( int ( A & B == B ) ) <eos>
836
src = expose ( B ) を A とする
trg = A = expose ( B )
rst = A = <unk> ( B ) <eos>
837
src = 1 から B 未満までの数列の逆順 を順に A として 、 繰り返 す
trg = for A in range ( 1 , B ) [ : : - 1 ] :
rst = for A in range ( 1 , B ) [ : : - 1 ] : <eos>
838
src = Point ( B . y / C , - B . x / C ) に D を掛けた値を A とする
trg = A = Point ( B . y / C , - B . x / C ) * D
rst = A = Point ( B . y / C , - B . x / C ) <eos>
839
src = A の B 番目が A の A の長さから B を引いた値から 1 を引いた値番目 と等しくないとき 、
trg = if A [ B ] != A [ len ( A ) - B - 1 ] :
rst = if A [ B ] != A [ len ( A ) - B - 1 ] : <eos>
840
src = 空文字列を間に入れて B の各要素に整数を適用した列 を連結した文字列を A とする
trg = A = '' . join ( map ( str , B ) )
rst = A = '' . join ( map ( str , B ) ) <eos>
841
src = time の A 番目から B 番目までの部分列の総和が 0 と等しいとき 、
trg = if sum ( time [ A : B ] ) == 0 :
rst = if sum ( time [ A : B ] ) == 0 : <eos>
842
src = A の value が B と等しいとき 、
trg = if A . value == B :
rst = if A . value == B : <eos>
843
src = bubble _ sort ( C ) を ( A 、 B ) の組 とする
trg = ( A , B ) = bubble_sort ( C )
rst = ( A , B ) = shell_sort ( C ) <eos>
844
src = 入力された文字列 を空白で分割した字句列の各要素に C を適用した列のリストを展開し 、 それぞれ A 、 B とする
trg = A , B = list ( map ( C , input ( ) . split ( ) ) )
rst = A , B = sorted ( map ( C , input ( ) . split ( ) ) ) <eos>
845
src = figure _ in _ board ( A , B ) のとき 、
trg = if figure_in_board ( A , B ) :
rst = if <unk> ( A , B ) : <eos>
846
src = A の 3 番目のとき 、
trg = if A [ 3 ] :
rst = if A [ 3 ] : <eos>
847
src = fib ( B -1) を A とする
trg = A = fib ( B - 1 )
rst = A = fib ( B - 1 ) <eos>
848
src = B に 1 を加えた値を A の B 番目の 0 番目に する
trg = A [ B ] [ 0 ] = B + 1
rst = A [ B ] [ 0 ] = B + 1 <eos>
849
src = koch ( A , ( B , C ),( D , E ))
trg = koch ( A , ( B , C ) , ( D , E ) )
rst = koch ( A , ( B , C ) , ( D , E ) ) <eos>
850
src = A を B の C 番目の整数値に C に 1 を加えた値を掛けた値だけ 増 加 させ る
trg = A += int ( B [ C ] ) * ( C + 1 )
rst = A += int ( B [ C ] ) * ( C + 1 ) <eos>
851
src = A から B を引いた値の 2 乗に C から D を引いた値の 2 乗を加えた値が E に F を加えた値 の 2 乗 以下かどうかを返す
trg = return ( A - B ) ** 2 + ( C - D ) ** 2 <= ( E + F ) ** 2
rst = return ( A - B ) ** 2 + ( C - D ) ** 2 <= ( E + F ) ** .5 <eos>
852
src = A が B より大きいとき C を出力する 、 そうでなければ D を出力する
trg = print ( C ) if A > B else print ( D )
rst = print ( C if A > B else D ) <eos>
853
src = ( A から 1 を引いた値 、 B 、 C ) の組が D に含まれるとき 、
trg = if ( A - 1 , B , C ) in D :
rst = if ( A - 1 , B , C ) in D : <eos>
854
src = A を ( < __ main __ . Cammaobjectat 0 x 10 a 10 ed 9 0> ) の集合と の 論理和に する
trg = A |= { B }
rst = A |= { B } <eos>
855
src = A を B の value の C 番目だけ 増 加 させ る
trg = A += B . value [ C ]
rst = A += B . value [ C ] <eos>
856
src = A に 1 を加えた値が B より小さくかつ C の D *2 番目の A 番目が 0 と等しくかつ E の D 番目の A に 1 を加えた値番目が F に 1 を加えた値 より大きいとき 、
trg = if A + 1 < B and C [ D * 2 ] [ A ] == 0 and E [ D ] [ A + 1 ] > F + 1 :
rst = if A + 1 < B and C [ D * 2 ] [ A ] == 0 and E [ D ] [ A + 1 ] > F + 1 : <eos>
857
src = A を B の C 番目に D の E 番目を掛けた値に F の E 番目を掛けた値を G で割った余りだけ 増 加 させ る
trg = A += B [ C ] * D [ E ] * F [ E ] % G
rst = A += B [ C ] * D [ E ] * F [ E ] % G <eos>
858
src = levenshtein _ distance ( A , B ) を出力する
trg = print ( levenshtein_distance ( A , B ) )
rst = print ( <unk> ( A , B ) ) <eos>
859
src = A の B から 1 を引いた値番目の C 番目 、 A の B 番目の C から D [ B ] の 1 番目を引いた値番目に D の B 番目の先頭 を加えた値の最大値を A の B 番目の C 番目に する
trg = A [ B ] [ C ] = max ( A [ B - 1 ] [ C ] , A [ B ] [ C - D [ B ] [ 1 ] ] + D [ B ] [ 0 ] )
rst = A [ B ] [ C ] = max ( A [ B - 1 ] [ C ] , A [ B ] [ C - D [ B ] [ 1 ] + D [ B ] [ 0 ] ) <eos>
860
src = A の size を 2 倍 に する
trg = A . size *= 2
rst = A . size *= 2 <eos>
861
src = A の末尾に B の C の D 番目 番目を追加する
trg = A . append ( B [ C [ D ] ] )
rst = A . append ( B [ C [ D ] ] ) <eos>
862
src = copy の 1 番目を A の 5 番目に する
trg = A [ 5 ] = copy [ 1 ]
rst = A [ 5 ] = copy [ 1 ] <eos>
863
src = B の末尾を除いた部分列 を順に A として 、 繰り返 す
trg = for A in B [ : - 1 ] :
rst = for A in B [ : - 1 ] : <eos>
864
src = 改行せずに A の B 番目の C 番目を出力する
trg = print ( A [ B ] [ C ] , end = '' )
rst = print ( A [ B ] [ C ] , end = '' ) <eos>
865
src = C の D 番目の E から 1 を引いた値番目を展開し 、 それぞれ A 、 B とする
trg = A , B = C [ D ] [ E - 1 ]
rst = A , B = C [ D ] [ E - 1 ] <eos>
866
src = time を A の先頭だけ 増 加 させ る
trg = time += A [ 0 ]
rst = time += A [ 0 ] <eos>
867
src = C の B から 1 を引いた値番目に 1 を加えた値を A の B 番目に する
trg = A [ B ] = C [ B - 1 ] + 1
rst = A [ B ] = C [ B - 1 ] + 1 <eos>
868
src = A が B より小さくかつ C の A 番目が D と等しいとき 、
trg = if A < B and C [ A ] == D :
rst = if A < B and C [ A ] == D : <eos>
869
src = A の contents の末尾に A の pages の B 番目を追加する
trg = A . contents . append ( A . pages [ B ] )
rst = A . contents . append ( A . index [ B ] ) <eos>
870
src = 0 から C 未満までの数列の各要素を B とし 、 input () を空白で分割した字句列の各要素に 整数を適用した列のリストの列 のリストを A とする
trg = A = list ( [ list ( map ( int , input ( ) . split ( ) ) ) for B in range ( C ) ] )
rst = A = list ( [ list ( map ( int , input ( ) . split ( ) ) ) for B in range ( C ) ] <eos>
871
src = C の bottomright を展開し 、 それぞれ A 、 B とする
trg = A , B = C . bottomright
rst = A , B = C . <unk> <eos>
872
src = A の B に 1 を加えた値番目が 1 と等しくかつ B が 999999 より小さい 間 、 次 を 繰り返 す
trg = while A [ B + 1 ] == 1 and B < 999999 :
rst = while A [ B + 1 ] == 1 and B < < : <eos>
873
src = 0 から B の長さ 、 C の長さの最小値 未満までの数列を順に A として 、 繰り返 す
trg = for A in range ( min ( len ( B ) , len ( C ) ) ) :
rst = for A in range ( len ( B ) , len ( C ) ) ) : <eos>
874
src = A を ( B [ C ] == D -1) に ( E [ C ] == F -1) を加えた値に G [ C ] が H -1 と等しいかどうかを加えた値に B の C 番目が 0 と等しいかどうかを加えた値に E の C 番目が 0 と等しいかどうかを加えた値に G の C 番目が 0 と等しいかどうか を加えた値だけ 増 加 させ る
trg = A += ( B [ C ] == D - 1 ) + ( E [ C ] == F - 1 ) + ( G [ C ] == H - 1 ) + ( B [ C ] == 0 ) + ( E [ C ] == 0 ) + ( G [ C ] == 0 )
rst = A += ( [ B ] [ D ] - 1 ) + ( E [ C ] [ F - F - F ] ) + ( G [ C ] [ H - - G ] ) + ( G [ C ] == 0 ) + (
875
src = A かつ A の -1 番目が B と等しい 間 、 次 を 繰り返 す
trg = while A and A [ - 1 ] == B :
rst = while A and A [ - 1 ] == B : <eos>
876
src = A の B 番目が A の - B から 1 を引いた値番目 と等しくないとき 、
trg = if A [ B ] != A [ - B - 1 ] :
rst = if A [ B ] != A [ - B - 1 ] : <eos>
877
src = B の先頭から A を探して見つかった位置を A とする
trg = A = B . find ( A )
rst = A = B . find ( A ) <eos>
878
src = A に B を掛けた値 、 A に B を加えた値を 1 だけ左シフトした値 を出力する
trg = print ( A * B , ( A + B ) << 1 )
rst = print ( ( A * B , ( A + B ) << 1 ) <eos>
879
src = A の B 番目が 1 と等しいとき 、
trg = if A [ B ] == 1 :
rst = if A [ B ] == 1 : <eos>
880
src = A . Node ( B ) を A の root に する
trg = A . root = A . Node ( B )
rst = A . root = A . Node ( B ) <eos>
881
src = 2 に A を掛けた値に 2 に B を掛けた値を加えた値から C を引いた値を返す
trg = return 2 * A + 2 * B - C
rst = return 2 * A + 2 * B - C <eos>
882
src = A の文字列の長さが 80 以下のとき A 、 そうでなければ B を出力する
trg = print ( A if len ( str ( A ) ) <= 80 else B )
rst = print ( A if len ( A ) ) <= 80 else B ) <eos>
883
src = A に B を加えた値を 2 で割った余りが 0 と等しいとき 、
trg = if ( A + B ) % 2 == 0 :
rst = if ( A + B ) % 2 == 0 : <eos>
884
src = B の color を A の color に する
trg = A . color = B . color
rst = A . color = B . color <eos>
885
src = A を B に C の末尾から 空白改行を取り除いた文字列 を加えた値に B を加えた値だけ 増 加 させ る
trg = A += B + C . rstrip ( ) + B
rst = A += ( B + C ) . bit_length ( ) + B <eos>
886
src = 0 から D から 1 を引いた値 未満までの数列の各要素を C とし 、 B から読み込んだ一行の整数値の列を A とする
trg = A = [ int ( B . readline ( ) ) for C in range ( D - 1 ) ]
rst = A = [ int ( B . readline ( ) ) for C in range ( D - 1 ) ] <eos>
887
src = B の C 番目の 0 番目から D の - E から 1 を引いた値番目の先頭 を引いた値を A とする
trg = A = B [ C ] [ 0 ] - D [ - E - 1 ] [ 0 ]
rst = A = B [ C ] [ 0 ] - D [ - E - 1 ] [ 0 ] <eos>
888
src = A の B の先頭の先頭 番目の 1 番目を出力する
trg = print ( A [ B [ 0 ] [ 0 ] ] [ 1 ] )
rst = print ( A [ B [ 0 ] [ 0 ] [ 1 ] ) <eos>
889
src = cross 3( A , B , C ) が 0 より小さいとき 、
trg = if cross3 ( A , B , C ) < 0 :
rst = if cross3 ( A , B , C ) < 0 : <eos>
890
src = A が B と等しくない 間 、 次 を 繰り返 す
trg = while A != B :
rst = while A != B : <eos>
891
src = 空白文字を 代わ りの行末として A の - B に 1 を加えた値番目 を出力する
trg = print ( A [ - ( B + 1 ) ] , end = ' ' )
rst = print ( A [ - B + 1 ] , end = ' ' ) <eos>
892
src = A の B 番目の C 番目が 0 より大きいとき 、
trg = if A [ B ] [ C ] > 0 :
rst = if A [ B ] [ C ] > 0 : <eos>
893
src = A の総和を 60 で割った商 を出力する
trg = print ( sum ( A ) // 60 )
rst = print ( sum ( A ) // 60 ) <eos>
894
src = B を 18 で割った余りを A とする
trg = A = B % 18
rst = A = B % 18 <eos>
895
src = ccw ( A [-1], A [-2], B ) の 間 、 次 を 繰り返 す
trg = while ccw ( A [ - 1 ] , A [ - 2 ] , B ) :
rst = while ccw ( A [ - 1 ] , A [ - 2 ] , B ) : <eos>
896
src = 0 から B 未満までの数列の各要素を D とし 、 ( (-1) からなる列の 0 から B 未満までの数列の各要素を C とし 、 1 を B だけ左シフトした値 の列回分の列 ) からなる列の列を A とする
trg = A = [ [ [ - 1 ] * [ ( 1 << B ) for C in range ( B ) ] ] for D in range ( B ) ]
rst = A = [ [ [ - 1 ] * [ ( 1 << B ) for C in range ( B ) ] ] for D in range ( B ) ] <eos>
897
src = A の B 番目の長さが 0 と等しくないとき 、
trg = if len ( A [ B ] ) != 0 :
rst = if len ( A [ B ] ) != 0 : <eos>
898
src = 入力された文字列 を空白で分割した字句列の各要素に 整数を適用した列のリストの総和を A とする
trg = A = sum ( list ( map ( int , input ( ) . split ( ) ) ) )
rst = A = list ( map ( int , input ( ) . split ( ) ) ) <eos>
899
src = A に A を掛けた値が B 以下の 間 、 次 を 繰り返 す
trg = while A * A <= B :
rst = while A * A <= B : <eos>
900
src = 2 に B を加えた値に C に D を加えた値を加えた値を A とする
trg = A = 2 + B + ( C + D )
rst = A = ( 2 + B ) ( ( C + D ) <eos>
901
src = ( ( B ) からなる列の集合 、 ( C ) からなる列の集合 、 ( D ) からなる列の集合 、 ( B 、 C ) からなる列の集合 、 ( B 、 D ) からなる列の集合 、 ( C 、 D ) からなる列の集合 、 ( B 、 C 、 D ) からなる列の集合 ) からなる列を A とする
trg = A = [ set ( [ B ] ) , set ( [ C ] ) , set ( [ D ] ) , set ( [ B , C ] ) , set ( [ B , D ] ) , set ( [ C , D ] ) , set ( [ B , C , D ] ) ]
rst = A = [ [ set ( [ B , C ] ) [ [ ] , [ D , ] ] [ [ B ] for B , C ] for B , C ] for B , C in enumerate ( [ C , D ) ] ] [
902
src = A が 、 つまり未定値と等しくなくまたは A の長さが 6 と等しくないとき 、
trg = if A is None or len ( A ) != 6 :
rst = if A is None or len ( A ) != 6 : <eos>
903
src = x をパラメータとして x の 1 番目を返す関数をキーとして A のキーと値の集まりをソートした列 を A とする
trg = A = sorted ( A . items ( ) , key = lambda A : A [ 1 ] )
rst = A = sorted ( A . items ( ) , key = lambda B : B [ 1 ] ) <eos>
904
src = 120 に 60 を掛けた値から B に 3600 を掛けた値に C に 60 を掛けた値を加えた値に D を加えた値を引いた値を A とする
trg = A = 120 * 60 - ( B * 3600 + C * 60 + D )
rst = A = ( * * 60 - B * 3600 + C * 60 + D ) <eos>
905
src = kesu ( ( A [0], A [1]-1) , B , C , D +1)
trg = kesu ( ( A [ 0 ] , A [ 1 ] - 1 ) , B , C , D + 1 )
rst = kesu ( ( A [ 0 ] , A [ 1 ] + 1 , B ) , , B , C , D + 1 ) <eos>
906
src = write ( A % dfs (0, B ,0,0) )
trg = write ( A % dfs ( 0 , B , 0 , 0 ) )
rst = write ( A % dfs ( 0 , B , 0 , 0 ) ) <eos>
907
src = C の両端から 空白改行を取り除いた文字列 を空白で分割した字句列の各要素を B とし 、 B の整数値の列を A とする
trg = A = [ int ( B ) for B in C . strip ( ) . split ( ) ]
rst = A = [ int ( B ) for B in C . strip ( ) . split ( ) ] <eos>
908
src = A が B より小さいとき 、
trg = if A < B :
rst = if A < B : <eos>
909
src = sys の stdin から読み込んだ デ ータを空白で分割した字句列を A とする
trg = A = sys . stdin . read ( ) . split ( )
rst = A = sys . stdin . read ( ) . split ( ) <eos>
910
src = A の B 番目の C 番目の D 番目を返す
trg = return A [ B ] [ C ] [ D ]
rst = return A [ B ] [ C ] [ D ] <eos>
911
src = write ( A %( sum ([ B * CforB , Cinzip ( D , E )])% 10 ))
trg = write ( A % ( sum ( [ B * C for B , C in zip ( D , E ) ] ) % 10 ) )
rst = write ( A % ( sum ( B * B ) , <unk> ( ( D , E ) , 10 ) ) <eos>
912
src = E の F 番目 、 G の F 番目 、 E の H 番目 、 G の H 番目を A 、 B 、 C 、 D とする
trg = A , B , C , D = E [ F ] , G [ F ] , E [ H ] , G [ H ]
rst = A , B , C , D = E [ F ] , G [ F ] , G [ H ] , G [ H ] , G [ H ] <eos>
913
src = 入力された文字列の両端から 空白改行を取り除いた文字列 の各要素を B とし 、 B の整数値の列を A とする
trg = A = [ int ( B ) for B in input ( ) . strip ( ) ]
rst = A = [ int ( B ) for B in input ( ) . strip ( ) ] <eos>
914
src = DiGraph ( B ) を A とする
trg = A = DiGraph ( B )
rst = A = <unk> ( B ) <eos>
915
src = E の各要素を D とし 、 ( D の各要素を C 、 B 、 C とし 、 B の列 、 D ) の組の列を A の coordinates _ に する
trg = A . coordinates_ = [ ( [ B for C , B , C in D ] , D ) for D in E ]
rst = A . <unk> = [ ( B , [ B , C , D for B , C in E ] ) for D in E ] <eos>
916
src = B から 2 を引いた値を A とする
trg = A = B - 2
rst = A = B - 2 <eos>
917
src = 改行せずに A の B 番目の name を出力する
trg = print ( A [ B ] . name , end = '' )
rst = print ( A [ B ] . name , end = '' ) <eos>
918
src = 135 に円周率を掛けた値を 180 で割った値を A とする
trg = A = 135 * math . pi / 180
rst = A = <unk> * math . pi / 180 <eos>
919
src = 1 を A の 、 つまり入力された文字列の整数値 から 1 を引いた値番目に する
trg = A [ int ( input ( ) ) - 1 ] = 1
rst = A [ int ( input ( ) ) - 1 ] = 1 <eos>
920
src = A の長さが 6 より小さくかつ 2 進 表 記 A の整数値が 0 と等しいとき 、
trg = if len ( A ) < 6 and int ( A , 2 ) == 0 :
rst = if len ( A ) == 6 and int ( A ) == 0 : <eos>
921
src = A が B を 2 で割った商 と等しくないとき 、
trg = if A != B // 2 :
rst = if A != B // 2 : <eos>
922
src = A のリスト が B と等しいとき 、
trg = if list ( A ) == B :
rst = if list ( set ( A ) == B : <eos>
923
src = collision ( A , B , C , D ) のとき 、
trg = if collision ( A , B , C , D ) :
rst = if <unk> ( A , B , C , D ) : <eos>
924
src = 0 から B を 2 で割った商から 1 を引いた値未満までの数列を順に A として 、 繰り返 す
trg = for A in range ( B // 2 - 1 ) :
rst = for A in range ( B // 2 - 1 ) : <eos>
925
src = A の B の 1 番目の整数値番目 を出力する
trg = print ( A [ int ( B [ 1 ] ) ] )
rst = print ( A [ int ( B [ 1 ] ) ] ) <eos>
926
src = A の 、 つまり先頭から B の 1 番目の整数値までの部分列に 空文字列を間に入れて A [ int ( B [1]) : int ( B [2]) +1] を反転した列のリスト を連結した文字列を加えた値 に A の B の 2 番目の整数値に 1 を加えた値から 、 つまり末尾までの部分列を加えた値 を A とする
trg = A = A [ : int ( B [ 1 ] ) ] + '' . join ( list ( reversed ( A [ int ( B [ 1 ] ) : int ( B [ 2 ] ) + 1 ] ) ) ) + A [ int ( B [ 2 ] ) + 1 : ]
rst = A = A [ : int ( B [ 1 ] ) ] + str ( B [ [ 1 ] ) [ 1 : int ( ( int ( B [ 2 ] ) + 1 ] ) + 1 ] + 1 : ] + 1 <eos>
927
src = f ( A , B ) を A とする
trg = A = f ( A , B )
rst = A = f ( A , B ) <eos>
928
src = A の triangle ( B , C , D ) 番目を 1 だけ 増 加 させ る
trg = A [ triangle ( B , C , D ) ] += 1
rst = A . init [ B , C , D ) ] += 1 <eos>
929
src = HeavyLightDecomposition ( B ) を A とする
trg = A = HeavyLightDecomposition ( B )
rst = A = <unk> ( B ) <eos>
930
src = A の末尾に ( B 、 C 、 C のとき D 、 そうでなければ 0 ) の組 を追加する
trg = A . append ( ( B , C , D if C else 0 ) )
rst = A . append ( ( B , ( C , C ) else 0 ) ) <eos>
931
src = A 、 B 、 C の最小値に D 、 E の最小値 を加えた値から 50 を引いた値 を出力する
trg = print ( min ( A , B , C ) + min ( D , E ) - 50 )
rst = print ( min ( A , B , C ) + min ( D , E ) - 50 ) <eos>
932
src = B から C を引いた値に D から 、 つまりネイピア数 を引いた値を掛けた値を E から 、 つまりネイピア数 を引いた値で割った値に C を加えた値を A とする
trg = A = ( B - C ) * ( D - e ) / ( E - e ) + C
rst = A = ( B - C ) * ( D - e ) ** ( E - e ) + C <eos>
933
src = PuzzleState ( B . state , depth = B . depth +1) を A とする
trg = A = PuzzleState ( B . state , depth = B . depth + 1 )
rst = A = <unk> ( B . Node , 1 ) B . depth + 1 ) <eos>
934
src = A の 、 つまり先頭から B に C を加えた値までの部分列を 削 除 する
trg = del A [ : B + C ]
rst = del A [ : B + C ] <eos>
935
src = 0 から B の __ leng 未満までの数列を順に A として 、 繰り返 す
trg = for A in range ( B . __leng ) :
rst = for A in range ( B . <unk> ) : <eos>
936
src = reconstruct ( A [1: B +1], C [ : B ] , D )
trg = reconstruct ( A [ 1 : B + 1 ] , C [ : B ] , D )
rst = reconstruct ( A [ 1 : B + 1 ] , C [ : B ] , D ) <eos>
937
src = A . suffix ()
trg = A . suffix ( )
rst = A . <unk> ( ) <eos>
938
src = A の B 番目が 1 より大きいとき 、
trg = if A [ B ] > 1 :
rst = if A [ B ] > 1 : <eos>
939
src = 改行せずに A を ( B の C 番目 、 D ) の組で割った余り を出力する
trg = print ( A % ( B [ C ] , D ) , end = '' )
rst = print ( A % ( B [ C ] , D ) , end = '' ) <eos>
940
src = B に C に D を掛けた値を加えた値を A とする
trg = A = B + C * D
rst = A = B + C * D <eos>
941
src = 1 から B に 2 を掛けた値 未満までの数列を順に A として 、 繰り返 す
trg = for A in range ( 1 , B * 2 ) :
rst = for A in range ( 1 , B * 2 ) : <eos>
942
src = dfs ( B , C ) を A とする
trg = A = dfs ( B , C )
rst = A = dfs ( B , C ) <eos>
943
src = 1 を A の B に 1 を加えた値番目に する
trg = A [ B + 1 ] = 1
rst = A [ B + 1 ] = 1 <eos>
944
src = 5 から 0 未満までの -1 間隔の数列を順に A として 、 繰り返 す
trg = for A in range ( 5 , 0 , - 1 ) :
rst = for A in range ( 5 , 0 , - 1 ) : <eos>
945
src = B に 60 を掛けた値に C を加えた値を A の t に する
trg = A . t = B * 60 + C
rst = A . t = B * 60 + C <eos>
946
src = A の minSpanningTree の末尾に ( B 、 C 、 D ) の組 を追加する
trg = A . minSpanningTree . append ( ( B , C , D ) )
rst = A . valuelist . append ( ( B , C , D ) ) <eos>
947
src = B から C を引いた値に D から E を引いた値を掛けた値を F から E を引いた値で割った値に C を加えた値を A とする
trg = A = ( B - C ) * ( D - E ) / ( F - E ) + C
rst = A = ( B - C ) * ( D - E ) / ( F - E ) + C <eos>
948
src = x をパラメータとして x の先頭を返す関数を key として逆順に A をソート する
trg = A . sort ( key = lambda B : B [ 0 ] , reverse = True )
rst = A . sort ( key = lambda B : B [ 0 ] , reverse = True ) <eos>
949
src = A を書式として B . get _ east _ value () で整形した文字列を出力する
trg = print ( A . format ( B . get_east_value ( ) ) )
rst = print ( A . format ( B . get_top_value ( ) ) ) <eos>
950
src = counting _ sort ( A , B , max ( A ))
trg = counting_sort ( A , B , max ( A ) )
rst = counting_sort ( A , B , max ( A ) ) <eos>
951
src = C に B を掛けた値を D で割った余りを C とする を A の B 番目に する
trg = A [ B ] = C = C * B % D
rst = A [ B ] = C = C * B % D <eos>
952
src = A を 60 分の 一 に する
trg = A //= 60
rst = A /= 60 <eos>
953
src = 1 をネイピア数の 1 番目に する
trg = e [ 1 ] = 1
rst = e [ 1 ] = 1 <eos>
954
src = B に C を掛けた値から D に E を掛けた値を引いた値の 2 乗に D に F を掛けた値から G に C を掛けた値を引いた値の 2 乗を加えた値に G に E を掛けた値から B に F を掛けた値を引いた値の 2 乗を加えた値を A とする
trg = A = ( B * C - D * E ) ** 2 + ( D * F - G * C ) ** 2 + ( G * E - B * F ) ** 2
rst = A = ( B * C - D * E ) ** 2 + ( * F - G * C ) ** 2 + G * E - F * F <eos>
955
src = B を 12 で割った余りを A とする
trg = A = B % 12
rst = A = B % 12 <eos>
956
src = A の集合 を返す
trg = return set ( A )
rst = return len ( A ) <eos>
957
src = rec (0,0) が A 以下のとき B 、 そうでなければ C を出力する
trg = print ( B if rec ( 0 , 0 ) <= A else C )
rst = print ( B if rec ( 0 , 0 ) <= A else C ) <eos>
958
src = calc ( B ,0) を A とする
trg = A = calc ( B , 0 )
rst = A = calc ( B , 0 ) <eos>
959
src = A の先頭が A の 2 番目より大きいとき 、
trg = if A [ 0 ] > A [ 2 ] :
rst = if A [ 0 ] > A [ 2 ] : <eos>
960
src = A の末尾 の浮動小数点数を A とする
trg = A = float ( A [ - 1 ] )
rst = A = float ( A [ - 1 ] ) <eos>
961
src = ( 0 から E 未満までの数列の各要素を C とし 、 B の C 番目に D [ C ] に D [ C +1] を加えた値に 2 を掛けた値を加えた値の列 ) からなる列を A とする
trg = A = [ [ B [ C ] + ( D [ C ] + D [ C + 1 ] ) * 2 for C in range ( E ) ] ]
rst = A = [ [ B [ C ] + D [ C ] * ( D [ C + 1 ) + 2 ] for C in range ( E ) ] ] <eos>
962
src = A の B 番目の長さが 2 と等しくないとき 、
trg = if len ( A [ B ] ) != 2 :
rst = if len ( A [ B ] ) != 2 : <eos>
963
src = 0 から B の長さを 3 で割った値の整数値 未満までの数列を順に A として 、 繰り返 す
trg = for A in range ( int ( len ( B ) / 3 ) ) :
rst = for A in range ( int ( len ( B ) / 3 ) ) : <eos>
964
src = B にネイピア数を掛けた値から C に D を掛けた値を引いた値を A とする
trg = A = B * e - C * D
rst = A = B * e - C * D <eos>
965
src = ((10 の 18 乗 、 -1) の組 ) からなる列の B 回分の列を A とする
trg = A = [ ( 10 ** 18 , - 1 ) ] * B
rst = A = [ ( 10 ** 18 , - 1 ) ] * B <eos>
966
src = open (1, A ) . writelines ([ B . format ( C [ D ] ) forDinmap ( int , open (0) . read (). split ())])
trg = open ( 1 , A ) . writelines ( [ B . format ( C [ D ] ) for D in map ( int , open ( 0 ) . read ( ) . split ( ) ) ] )
rst = open ( 1 , A ) . writelines ( [ B . . writelines ( ) , C ) . count ( ) ) . zfill ( ) ) ) ) ) ) ) ) ) <eos>
967
src = Vector ( A . x + B . x , A . y + B . y ) を返す
trg = return Vector ( A . x + B . x , A . y + B . y )
rst = return Vector ( A . x + B . x , A . y + B . y ) <eos>
968
src = 整数の B の整数値に 1 を加えた値から 、 つまり末尾までの部分列を A とする
trg = A = str [ int ( B ) + 1 : ]
rst = A = str [ int ( B ) + 1 : ] <eos>
969
src = A の末尾に tanri ( B , C , D , E ) を追加する
trg = A . append ( tanri ( B , C , D , E ) )
rst = A . append ( <unk> ( B , C , D , E ) ) <eos>
970
src = heappush ( A ,(0,0, B , C ,0))
trg = heappush ( A , ( 0 , 0 , B , C , 0 ) )
rst = heappush ( A , ( 0 , 0 , B , C , 0 ) ) <eos>
971
src = B に 5 を掛けた値を A とする
trg = A = B * 5
rst = A = B * 5 <eos>
972
src = A と B の論理積の長さが C と等しいかどうかに [ MASK ] を加えた値を出力する
trg = print ( + ( len ( A & B ) == C ) )
rst = print ( + ( ( A & B ) + C ) + C ) <eos>
973
src = A の末尾に B の 2 番目から 、 つまり末尾までの部分列 を追加する
trg = A . append ( B [ 2 : ] )
rst = A . append ( B [ 2 : ] ) <eos>
974
src = 0、0、0、0 を A 、 B 、 C 、 D とする
trg = A , B , C , D = 0 , 0 , 0 , 0
rst = A , B , C , D = 0 , A , 2 <eos>
975
src = ( 、 つまり空白文字を間に入れて A を連結した文字列 、 空白文字を間に入れて B を連結した文字列 ) の組を返す
trg = return ( ' ' . join ( A ) , ' ' . join ( B ) )
rst = return ( ' ' . join ( A ) ) , ' ' . join ( B ) ) <eos>
976
src = C の D 番目を A の B 番目に する
trg = A [ B ] = C [ D ]
rst = A [ B ] = C [ D ] <eos>
977
src = make _ dice ( B ) を A とする
trg = A = make_dice ( B )
rst = A = <unk> ( B ) <eos>
978
src = 0 から 8 未満までの数列の各要素を B とし 、 B の列を A とする
trg = A = [ B for B in range ( 8 ) ]
rst = A = [ B for B in range ( 8 ) ] <eos>
979
src = B に B に 1 を加えた値を掛けた値を 2 で割った値を A とする
trg = A = ( B * ( B + 1 ) ) / 2
rst = A = B * ( B + 1 ) / 2 <eos>
980
src = A が B から C から D を引いた値から E を引いた値の絶対値を引いた値 より小さいとき 、
trg = if A < B - abs ( ( C - D ) - E ) :
rst = if A < B - ( C - D - E ) < <eos>
981
src = A の末尾に ( B の C と 1 の排他論理和番目 の D に 2 を加えた値番目 、 C と 1 の排他論理和 、 E ) の組 を追加する
trg = A . append ( ( B [ C ^ 1 ] [ D + 2 ] , C ^ 1 , E ) )
rst = A . append ( ( B [ C ^ 1 ] [ D + 2 ] , C ^ 1 , E ) ) <eos>
982
src = B の 2 乗から C の 2 乗を引いた値の平方根を A とする
trg = A = math . sqrt ( B ** 2 - C ** 2 )
rst = A = math . sqrt ( B ** 2 - C ** 2 ) <eos>
983
src = 空白文字を間に入れて A が無限大のとき B 、 そうでなければ C の各要素を A とし 、 A の文字列の列を連結した文字列 を出力する
trg = print ( ' ' . join ( ( B if math . isinf ( A ) else [ str ( A ) for A in C ] ) ) )
rst = print ( ' ' . join ( B if A ) isinf ( A ) . lower ( [ str ( A ) for A in C ] ] ) ) <eos>
984
src = A . pre _ order _ search ()
trg = A . pre_order_search ( )
rst = A . pre_order_search ( ) <eos>
985
src = -1 、0 を A 、 B とする
trg = A , B = - 1 , 0
rst = A , B = - 1 , 0 <eos>
986
src = A の長さが B より大きくかつ cross ( C [ A [-2]], C [ A [-1]], C [ D ] ) が 0 以上の 間 、 次 を 繰り返 す
trg = while len ( A ) > B and cross ( C [ A [ - 2 ] ] , C [ A [ - 1 ] ] , C [ D ] ) >= 0 :
rst = while len ( A ) > B and cross ( C [ A ] , C [ A ] ) , C [ A ] ) C C [ D ] ) >= 0 : <eos>
987
src = 1 を A の C 番目とするを A の B 番目に する
trg = A [ B ] = A [ C ] = 1
rst = A [ B ] = A [ C ] = 1 <eos>
988
src = ( ( -1000) からなる列の 0 から D 未満までの数列の各要素を C とし 、 B の列回分の列 ) からなる列を A とする
trg = A = [ [ - 1000 ] * [ B for C in range ( D ) ] ]
rst = A = [ [ [ ] * [ B for C in range ( D ) ] ] <eos>
989
src = A の contains と B の論理積 を返す
trg = return A . contains & B
rst = return A . contains ( B ) <eos>
990
src = A の 、 つまり入力された文字列の整数値 を 7 で割った余り番目 を出力する
trg = print ( A [ int ( input ( ) ) % 7 ] )
rst = print ( A [ ( int ( input ( ) ) % 7 ] ) <eos>
991
src = 入力された文字列 を空白で分割した字句列のリストを A とする
trg = A = list ( input ( ) . split ( ) )
rst = A = list ( input ( ) . split ( ) ) <eos>
992
src = _ put ( A . right ) を A の right に する
trg = A . right = _put ( A . right )
rst = A . right = <unk> ( A . right ) <eos>
993
src = A の総和から A の B から 1 を引いた値から 、 つまり末尾までの B 間隔による部分列の総和 を引いた値 を出力する
trg = print ( sum ( A ) - sum ( A [ B - 1 : : B ] ) )
rst = print ( sum ( A ) - A [ min ( B - 1 : : B ] ) ) <eos>
994
src = D の 、 つまり先頭から 、 つまり末尾までの 2 間隔による部分列 を展開し 、 それぞれ A 、 B 、 C とする
trg = A , B , C = D [ : : 2 ]
rst = A , B , C = D [ : : 2 ] <eos>
995
src = B の nodes の C 番目を A とする
trg = A = B . nodes [ C ]
rst = A = B . nodes [ C ] <eos>
996
src = 1 、 2 の math . log 2( B . size +1) から 1 を引いた値 乗の整数値から 1 を引いた値の最大値を A とする
trg = A = max ( 1 , int ( 2 ** ( math . log2 ( B . size + 1 ) - 1 ) ) - 1 )
rst = A = max ( 1 , 2 . math . math . y ( B . size + 1 ) - 1 ) - 1 ) <eos>
997
src = B に C を掛けた値に D に E を掛けた値を加えた値を B に B を掛けた値に D に D を掛けた値を加えた値で割った値 を A とする
trg = A = ( B * C + D * E ) / ( B * B + D * D )
rst = A = ( B * C + D * E ) / ( B * B + D * D ) <eos>
998
src = A または E 、 F 、 D に 1 を加えた値 、 1 に お いて正規表現 C の各要素を B とし 、 B が D と等しくないときの B の列 が最初にマッチする位置を A とする
trg = A = A or search ( [ B for B in C if B != D ] , E , F , D + 1 , 1 )
rst = A = A or search ( [ B for B in C if D , E , D + 1 , D , D + 1 ) ] <eos>
999
src = A の B 番目から 、 つまり末尾までの部分列 の先頭が C で 始 まるとき 、
trg = if A [ B : ] . startswith ( C ) :
rst = if A [ B : ] . startswith ( C ) : <eos>
1000
src = 区 切りなしで改行せずに A 、 B に C から 2 を引いた値を掛けた値 、 A を出力する
trg = print ( A , B * ( C - 2 ) , A , sep = '' , end = '' )
rst = print ( A , B * ( C - 2 ) , sep = '' , end = '' ) <eos>
1001
src = C の D 番目 、 E の D 番目を A 、 B とする
trg = A , B = C [ D ] , E [ D ]
rst = A , B = C [ D ] , E [ D ] <eos>
1002
src = is _ rect ( A ) のとき 、
trg = if is_rect ( A ) :
rst = if <unk> ( A ) : <eos>
1003
src = A の 0 番目が 100000 に 100000 を掛けた値 より大きいとき 、
trg = if A [ 0 ] > 100000 * 100000 :
rst = if A [ 0 ] > 1912 * 100000 : <eos>
1004
src = _ range ( A . right ) を返す
trg = return _range ( A . right )
rst = return _range ( A . right ) <eos>
1005
src = A に 2 を掛けた値 、 B の最小値を A とする
trg = A = min ( A * 2 , B )
rst = A = min ( A * 2 , B ) <eos>
1006
src = B の C に D を加えた値番目から B の C 番目に E の D 番目を掛けた値を引いた値を F で割った余りを A とする
trg = A = ( B [ C + D ] - B [ C ] * E [ D ] ) % F
rst = A = ( B [ C + D ] - B [ C ] * E [ D ] ) % F <eos>
1007
src = 2 から 1001 未満までの数列を順に A として 、 繰り返 す
trg = for A in range ( 2 , 1001 ) :
rst = for A in range ( 2 , 1001 ) : <eos>
1008
src = 0 を開いたファイルストリームを A とする
trg = A = open ( 0 )
rst = A = <unk> <eos>
1009
src = 0 から F 未満までの数列の各要素を E とし 、 D の B 番目の E 番目に D の E 番目の C 番目を掛けた値の列の総和を A の B 番目の C 番目に する
trg = A [ B ] [ C ] = sum ( [ D [ B ] [ E ] * D [ E ] [ C ] for E in range ( F ) ] )
rst = A [ B ] [ C ] = sum ( [ D [ B ] [ E ] * D [ E ] * E ] for E in range ( F ) ] ) <eos>
1010
src = A に B に C を加えた値 の文字列を加えた値を出力する
trg = print ( A + str ( B + C ) )
rst = print ( A + str ( B + C ) ) <eos>
1011
src = C を A の _ id の B 番目に する
trg = A . _id [ B ] = C
rst = A . _id [ B ] = C <eos>
1012
src = ( A の長さ 、 B の長さ ) の組を返す
trg = return ( len ( A ) , len ( B ) )
rst = return len ( len ( A ) , len ( B ) ) <eos>
1013
src = A の 0 番目が B と等しくなくかつ A の 0 番目が A の 4 番目と等しくかつ A の 4 番目が A の 8 番目と等しいとき 、
trg = if A [ 0 ] != B and A [ 0 ] == A [ 4 ] and A [ 4 ] == A [ 8 ] :
rst = if A [ 0 ] != B and A [ 0 ] == A [ 4 ] and A [ 4 ] == A [ 4 ] : <eos>
1014
src = A の bel の B 番目の C 番目を返す
trg = return A . bel [ B ] [ C ]
rst = return A . weights [ B ] [ C ] <eos>
1015
src = judge ( A ) の整数値を返す
trg = return int ( judge ( A ) )
rst = return int ( judge ( A ) ) <eos>
1016
src = A の B 番目を ( < __ main __ . Cammaobjectat 0 x 10 a 10 ed 0 0> ) の集合と の 論理和に する
trg = A [ B ] |= { C }
rst = A [ B ] |= { B } <eos>
1017
src = 0 から 2 の 、 つまりネイピア数乗 未満までの数列を順に A として 、 繰り返 す
trg = for A in range ( 2 ** e ) :
rst = for A in range ( 2 ** e ) : <eos>
1018
src = " M {}" を出力する
trg = print ( M{y-1867} )
rst = print ( <unk> ) <eos>
1019
src = B を 1 だけ左シフトした値と 1 の論理和を A とする
trg = A = ( B << 1 ) | 1
rst = A = ( B << 1 ) | 1 <eos>
1020
src = str ( oct ( A ) [2:]) . translate ( str . maketrans ( B , C )) を出力する
trg = print ( str ( oct ( A ) [ 2 : ] ) . translate ( str . maketrans ( B , C ) ) )
rst = print ( str ( <unk> ( A ) , A [ 2 ] . translate ( A . maketrans ( B , C ) ) ) <eos>
1021
src = ( ( C から 1 を引いた値 、 D ) の組 、 ( C に 1 を加えた値 、 D ) の組 、 ( C 、 D から 1 を引いた値 ) の組 、 ( C 、 D に 1 を加えた値 ) の組 ) からなる列の各要素を B とし 、0 が B [0] 以下かつ B [0] が E より小さくかつ 0 が B の 1 番目以下かつ B の 1 番目が F より小さいとき の B の列を A とする
trg = A = [ B for B in [ ( C - 1 , D ) , ( C + 1 , D ) , ( C , D - 1 ) , ( C , D + 1 ) ] if ( 0 <= B [ 0 ] and B [ 0 ] < E and 0 <= B [ 1 ] and B [ 1 ] < F ) ]
rst = A = [ B for B in range ( C - 1 ) if ( D , 1 ) if ( C + 1 ) if B + 1 ) if ( C [ 1 ) if E if B + 1 ) if E if B + 1 )
1022
src = A の総和を A の長さで割った値 が 0.5 以上のとき B 、 そうでなければ C を出力する
trg = print ( B if sum ( A ) / len ( A ) >= 0.5 else C )
rst = print ( B if sum ( A ) / len ( A ) <= 80 else C ) <eos>
1023
src = ( 100000 に 100 を掛けた値に 1 を加えた値 ) からなる列の B 回分の列を A とする
trg = A = [ 100000 * 100 + 1 ] * B
rst = A = [ 100000 * 100 + 1 ] * B <eos>
1024
src = A を B の C 番目に D を掛けた値だけ 増 加 させ る
trg = A += B [ C ] * D
rst = A += B [ C ] * D <eos>
1025
src = 無限の整数列の末尾に ( A の B 番目 、1) からなる列 を追加する
trg = count . append ( [ A [ B ] , 1 ] )
rst = count . append ( [ A [ B ] , 1 ] ) <eos>
1026
src = 空列を A の vs に する
trg = A . vs = [ ]
rst = A . mm = [ ] <eos>
1027
src = A に B の C 番目の D 番目に E の D 番目を掛けた値を加えた値を A とする
trg = A = A + B [ C ] [ D ] * E [ D ]
rst = A = A + B [ C ] [ D ] * E [ D ] <eos>
1028
src = 0 が A 以下かどうかが B より小さくなくまたは 0 が C 以下かどうかが D より小さくなくまたは E の C 番目の A 番目が 、 つまり未定値と等しくないとき 、
trg = if not 0 <= A < B or not 0 <= C < D or E [ C ] [ A ] is None :
rst = if not 0 <= A < B or not 0 <= C < D or E [ C ] [ A ] != None : <eos>
1029
src = pos ( A )
trg = pos ( A )
rst = pos ( A ) <eos>
1030
src = A の末尾に 0 から 14 未満までの数列の各要素を B とし 、0 の列 を追加する
trg = A . append ( [ 0 for B in range ( 14 ) ] )
rst = A . append ( [ 0 for B in range ( 14 ) ] ) <eos>
1031
src = (2) からなる列を A とする
trg = A = [ 2 ]
rst = A = [ 2 , 3 ] <eos>
1032
src = 4 が B に含まれるとき 7 、 そうでなければ 3 が B に含まれかつ 2 が B に含まれるとき 6 、 そうでなければ 3 が B に含まれるとき 4 、 そうでなければ B . count (2) が 2 と等しいとき 3 、 そうでなければ 2 を A とする
trg = A = 7 if 4 in B else ( 6 if 3 in B and 2 in B else ( 4 if 3 in B else ( 3 if B . count ( 2 ) == 2 else 2 ) ) )
rst = A = B if B if B < 2 else B if B else 2 if B else 2 if B else 2 if B else 2 if B >= 2 else 2 else 2 else 2 if 2 else 2 else 2 else 2 <eos>
1033
src = B の C から 1 を引いた値番目に 1 を加えた値から C に 2 を加えた値未満までの数列を順に A として 、 繰り返 す
trg = for A in range ( B [ C - 1 ] + 1 , C + 2 ) :
rst = for A in range ( B [ C - 1 ] + 1 , C + 2 ) : <eos>
1034
src = C が D より大きいとき ( C 、 D ) からなる列 、 そうでなければ ( D 、 C ) からなる列を展開し 、 それぞれ A 、 B とする
trg = A , B = [ C , D ] if C > D else [ D , C ]
rst = A , B = [ C , D D if D ) if C != D else ( D , D ) , D <eos>
1035
src = segmentTree ( B , C , sentinel =0) を A とする
trg = A = segmentTree ( B , C , sentinel = 0 )
rst = A = <unk> ( B , C , <unk> ( 0 , 0 ) <eos>
1036
src = 0 から os . path の長さ未満までの数列を順に A として 、 繰り返 す
trg = for A in range ( len ( path ) ) :
rst = for A in range ( len ( path ) ) : <eos>
1037
src = A の B 番目の A の B 番目の長さから 1 を引いた値番目 を出力する
trg = print ( A [ B ] [ len ( A [ B ] ) - 1 ] )
rst = print ( A [ B ] [ len ( A [ B ] ) - 1 ] ) <eos>
1038
src = range (3) の各要素を C とし 、 range (3) の列の各要素を B とし 、 A [ B ] の C 番目の列の総和を 10000 で割った余りを出力する
trg = print ( sum ( [ A [ B ] [ C ] for B in [ range ( 3 ) for C in range ( 3 ) ] ] ) % 10000 )
rst = print ( sum ( [ A [ B ] [ C ] for C in [ range ( ) ) ] ] ) for C in range ( 3 ) ] ] ) <eos>
1039
src = mirror ( A ) を A とする
trg = A = mirror ( A )
rst = A = UnionFindTree ( A ) <eos>
1040
src = A の B 番目 を無限の整数列 とする
trg = count = A [ B ]
rst = count = A [ B ] <eos>
1041
src = A と B の C 番目の論理和を A とする
trg = A = A | B [ C ]
rst = A = A | B [ C ] <eos>
1042
src = rotate _ and _ print ( A )
trg = rotate_and_print ( A )
rst = <unk> ( A ) <eos>
1043
src = A を B の C 番目の 2 番目だけ 減 少 させ る
trg = A -= B [ C ] [ 2 ]
rst = A -= B [ C ] [ 2 ] <eos>
1044
src = A の末尾に ( B に 1 を加えた値 、 ( C 、 D ) の組 、 E 、 F ) の組 を追加する
trg = A . append ( ( B + 1 , ( C , D ) , E , F ) )
rst = A . append ( ( B + 1 , ( C , D ) , E , F ) ) <eos>
1045
src = "{} {} {}" を出力する
trg = print ( {x:.03f} {y:.03f} {r:.03f} )
rst = print ( <unk> <unk> <unk> ) <eos>
1046
src = A の B 番目を C から C に D を加えた値未満までの数列のリスト だけ 増 加 させ る
trg = A [ B ] += list ( range ( C , C + D ) )
rst = A [ B ] += list ( range ( C , C + D ) ) <eos>
1047
src = B を 代わ りの行末として A の 2 番目を出力する
trg = print ( A [ 2 ] , end = B )
rst = print ( A [ 2 ] , end = B ) <eos>
1048
src = A の B から 1 を引いた値番目の末尾に ( C から 1 を引いた値 、 ネイピア数 ) の組 を追加する
trg = A [ B - 1 ] . append ( ( C - 1 , e ) )
rst = A [ B - 1 ] . append ( ( C - 1 , e ) ) <eos>
1049
src = A を B - C の 2 乗に D - E の 2 乗を加えた値の平方根 で割った余りを出力する
trg = print ( A % math . sqrt ( pow ( B - C , 2 ) + pow ( D - E , 2 ) ) )
rst = print ( A % ( ( pow ( B - C ** 2 ) * ( D - E ** 2 ) ) <eos>
1050
src = B の C 番目の 2 番目に D を掛けた値を E で割った値に B の C 番目の先頭を加えた値を A とする
trg = A = B [ C ] [ 2 ] * D / E + B [ C ] [ 0 ]
rst = A = B [ C ] [ 2 ] * D / E + B [ C ] [ 0 ] <eos>
1051
src = A の B 番目が C と等しくまたは A の B 番目が D と等しくまたは A の B 番目が E と等しいとき 、
trg = if A [ B ] == C or A [ B ] == D or A [ B ] == E :
rst = if A [ B ] == C or A [ B ] == D or A [ B ] == E : <eos>
1052
src = 0 から B から読み込んだ一行の整数値 未満までの数列の各要素を C とし 、 B から読み込んだ一行の整数値の列を A とする
trg = A = [ int ( B . readline ( ) ) for C in range ( int ( B . readline ( ) ) ) ]
rst = A = [ int ( B . readline ( ) ) for C in range ( int ( B . readline ( ) ) ) ] <eos>
1053
src = C の各要素を B とし 、 A に B を掛けた値 の列を返す
trg = return [ A * B for B in C ]
rst = return [ A * B for B in C ] <eos>
1054
src = is _ zero ( A - B ) のとき 、
trg = if is_zero ( A - B ) :
rst = if <unk> ( A - B ) : <eos>
1055
src = A を B が C より小さいとき D 、 そうでなければ B が C より大きいとき E 、 そうでなければ F で割った余りを出力する
trg = print ( A % ( D if B < C else E if B > C else F ) )
rst = print ( D if B if B < C else E if F > C else F ) <eos>
1056
src = B から -1 未満までの - C 間隔の数列を順に A として 、 繰り返 す
trg = for A in range ( B , - 1 , - C ) :
rst = for A in range ( B , - 1 , - C ) : <eos>
1057
src = paint ( A , is _ right = False , is _ up = True )
trg = paint ( A , is_right = False , is_up = True )
rst = paint ( A , is_right = False , is_up = True ) <eos>
1058
src = B から C を引いた値に D から E を引いた値を掛けた値から F から G を引いた値に H から I を引いた値 を掛けた値を引いた値の絶対値を A とする
trg = A = abs ( ( B - C ) * ( D - E ) - ( F - G ) * ( H - I ) )
rst = A = abs ( ( B - C ) * ( D - E ) - ( F - G ) * ( H - H ) ) <eos>
1059
src = A の B に C を掛けた値に D を加えた値に 4 を掛けた値に E を加えた値番目のとき 、
trg = if A [ ( B * C + D ) * 4 + E ] :
rst = if A [ ( B * C + D ) * 4 + E ] : <eos>
1060
src = C を B 分の 一 に する
trg = C //= B
rst = C //= B <eos>
1061
src = C を A の B 番目の 1 番目に する
trg = A [ B ] [ 1 ] = C
rst = A [ B ] [ 1 ] = C <eos>
1062
src = A を 0 、 B から C を引いた値の最大値 だけ 増 加 させ る
trg = A += max ( 0 , B - C )
rst = A += max ( 0 , B - C ) <eos>
1063
src = 1 から 16 未満までの数列の各要素を B とし 、 B の列に (0) からなる列を加えた値を A とする
trg = A = [ B for B in range ( 1 , 16 ) ] + [ 0 ]
rst = A = [ B for B in range ( 1 , 16 ) ] + [ 0 ] <eos>
1064
src = A の B 番目の C から 1 を引いた値番目の D から 1 を引いた値番目を E だけ 増 加 させ る
trg = A [ B ] [ C - 1 ] [ D - 1 ] += E
rst = A [ B ] [ C - 1 ] [ D - 1 ] += E <eos>
1065
src = 0 から E 未満までの数列の各要素を F とし 、0 から E 未満までの数列の各要素を D とし 、0 から 31 未満までの数列の各要素を C とし 、 B の列の列の列 を A とする
trg = A = [ [ [ B for C in range ( 31 ) ] for D in range ( E ) ] for F in range ( E ) ]
rst = A = [ [ [ B for C in range ( range ( 31 ) ] for D in range ( E ) ] for F in range ( E ) ] <eos>
1066
src = A の 7 番目を 1 だけ 増 加 させ る
trg = A [ 7 ] += 1
rst = A [ 7 ] += 1 <eos>
1067
src = B の末尾に 2 を加えた値から 2 に C を掛けた値に 2 を加えた値未満までの 2 間隔の数列を順に A として 、 繰り返 す
trg = for A in range ( B [ - 1 ] + 2 , 2 * C + 2 , 2 ) :
rst = for A in range ( B [ 2 2 2 * C + 2 , 2 ) : <eos>
1068
src = A を ( A の先頭 ) からなる列 だけ 増 加 させ る
trg = A += [ A [ 0 ] ]
rst = A += [ A [ 0 ] ] <eos>
1069
src = B が 0 より大きいとき 0 、 B から C を引いた値の最大値 、 そうでなければ 0 、 B に C を加えた値の最小値を A とする
trg = A = max ( 0 , B - C ) if B > 0 else min ( 0 , B + C )
rst = A = min ( [ B - C ) if B > 0 else 0 ( B , 0 ) if B + C ) <eos>
1070
src = B の C 番目から D 番目までの部分列に ( 1 e 10 ) からなる列を加えた値を A とする
trg = A = B [ C : D ] + [ 1e10 ]
rst = A = B [ C : D ] + [ e ] <eos>
1071
src = B のとき 7200 から C を引いた値 、 そうでなければ 7200 から C を引いた値に 3 を掛けた値を A とする
trg = A = 7200 - C if B else ( 7200 - C ) * 3
rst = A = ( - C ) if B - C ) * ( - C * * 3 <eos>
1072
src = A に B から C に A を掛けた値を引いた値 を加えた値を出力する
trg = print ( A + ( B - C * A ) )
rst = print ( A + ( B - C * A ) ) <eos>
1073
src = D を順に A 、 B 、 C 、 ネイピア数 として 、 繰り返 す
trg = for A , B , C , e in D :
rst = for A , B , C , e in D : <eos>
1074
src = A の parent の B 番目が C と等しいとき 、
trg = if A . parent [ B ] == C :
rst = if A . parent [ B ] == C : <eos>
1075
src = TypeVar ( B , int , float ) を A とする
trg = A = TypeVar ( B , int , float )
rst = A = <unk> ( B , int , input ( ) ) <eos>
1076
src = ((-1、0) からなる列 、(1、0) からなる列 、(0、-1) からなる列 、(0、1) からなる列 ) からなる列 を順に A 、 B として 、 繰り返 す
trg = for A , B in [ [ - 1 , 0 ] , [ 1 , 0 ] , [ 0 , - 1 ] , [ 0 , 1 ] ] :
rst = for A , B in [ [ - 1 , 0 ] , [ 0 , 0 ] , [ 0 , - 1 ] , [ 0 , 1 ] ] : <eos>
1077
src = A を B の C の D 番目から 、 つまり末尾までの部分列に E に 5 から F を引いた値に D を加えた値を掛けた値を加えた値 番目だけ 増 加 させ る
trg = A += B [ C [ D : ] + E * ( 5 - F + D ) ]
rst = A += B [ C [ D : ] + E * ( 5 - F ) <eos>
1078
src = 無限の整数列を A とする
trg = A = count
rst = A = count <eos>
1079
src = 0 から C に 1 を加えた値 、 F の長さの最小値 未満までの数列の各要素を E とし 、 D の C から E を引いた値番目に F の E 番目を加えた値の列の最大値を A の B 番目の C 番目に する
trg = A [ B ] [ C ] = max ( [ D [ C - E ] + F [ E ] for E in range ( min ( C + 1 , len ( F ) ) ) ] )
rst = A [ B ] [ C ] = max ( [ D [ C - E ] + E [ E ] for E in range ( C + 1 ) + ) ] ) <eos>
1080
src = 入力された文字列 を空白で分割した字句列の各要素に 整数を適用した列の集合 を A とする
trg = A = set ( map ( int , input ( ) . split ( ) ) )
rst = A = set ( map ( int , input ( ) . split ( ) ) ) <eos>
1081
src = A の各要素を B とし 、 B が C と等しくないときの B の列を A とする
trg = A = [ B for B in A if B != C ]
rst = A = [ B for B in A if B != C ] <eos>
1082
src = B の出現 頻 度順の列の先頭の先頭 を A とする
trg = A = B . most_common ( ) [ 0 ] [ 0 ]
rst = A = B . most_common [ 0 ] [ 0 ] <eos>
1083
src = 1989 年 1 月 8 日の日時を A とする
trg = A = datetime . datetime ( 1989 , 1 , 8 )
rst = A = datetime . datetime ( 1 , 9 , 8 ) <eos>
1084
src = D の 3 番目 、 D の 4 番目 、 D の 5 番目を A 、 B 、 C とする
trg = A , B , C = D [ 3 ] , D [ 4 ] , D [ 5 ]
rst = A , B , C = D [ 3 ] , D [ 4 ] , D [ 5 ] <eos>
1085
src = cut ( A , B ) を A とする
trg = A = cut ( A , B )
rst = A = cut ( A , B ) <eos>
1086
src = bowling _ score ( C ) を展開し 、 それぞれ A 、 B とする
trg = A , B = bowling_score ( C )
rst = A , B = <unk> ( C ) <eos>
1087
src = A の総和を B とする
trg = B = sum ( A )
rst = B = sum ( A ) <eos>
1088
src = (-1、-1、 B 、-1、-1) からなる列を A とする
trg = A = [ - 1 , - 1 , B , - 1 , - 1 ]
rst = A = [ 0 , - 1 , - , - 1 , - 1 ] <eos>
1089
src = A が 、 つまりネイピア数の cap より大きいとき 、
trg = if A > e . cap :
rst = if A > e . cap : <eos>
1090
src = 120 に 60 を掛けた値に 1 を掛けた値から B を引いた値を A とする
trg = A = 120 * 60 * 1 - B
rst = A = ( * 60 * 1 - B <eos>
1091
src = A の B 番目の right が -1 と等しくない 間 、 次 を 繰り返 す
trg = while A [ B ] . right != - 1 :
rst = while A [ B ] . right != - 1 : <eos>
1092
src = E の B 番目の各要素を D とし 、 A の B から 1 を引いた値番目の C から D を引いた値番目の列の総和を A の B 番目の C 番目に する
trg = A [ B ] [ C ] = sum ( [ A [ B - 1 ] [ C - D ] for D in E [ B ] ] )
rst = A [ B ] [ C ] = sum ( [ A [ B - 1 ] [ C - D ] for D in E [ B ] ] ) <eos>
1093
src = C に 2 を加えた値を A の B 番目に する
trg = A [ B ] = C + 2
rst = A [ B ] = C + 2 <eos>
1094
src = ( 、 つまり未定値 ) からなる列の 30 回分の列を C とする を A の B 番目に する
trg = A [ B ] = C = [ None ] * 30
rst = A [ B ] = C = [ None ] * 30 <eos>
1095
src = A . dfs (0,1) の 間 、 次 を 繰り返 す
trg = while A . dfs ( 0 , 1 ) :
rst = while A . dfs ( 0 , 0 ) : <eos>
1096
src = " Case {}:" を出力する
trg = print ( Case {i+1}: )
rst = print ( <unk> {i+1}: ) <eos>
1097
src = 入力された文字列の両端から 空白改行を取り除いた文字列 を英小文字に変換した文字列を A とする
trg = A = input ( ) . strip ( ) . lower ( )
rst = A = input ( ) . strip ( ) . strip ( ) <eos>
1098
src = 0 から D 未満までの数列の各要素を B とし 、0 から C 未満までの数列の各要素を B とし 、0 の列の列を A とする
trg = A = [ [ 0 for B in range ( C ) ] for B in range ( D ) ]
rst = A = [ [ 0 for B in range ( C ) ] for B in range ( D ) ] <eos>
1099
src = A を ( A の 1 番目 ) からなる列 だけ 増 加 させ る
trg = A += [ A [ 1 ] ]
rst = A += [ A [ 1 ] ] <eos>
1100
src = 入力された文字列 を空白で分割した字句列の各要素に 浮動小数点数を適用した列のリスト を展開し 、 それぞれ A 、 B 、 C 、 D 、 E 、 F とする
trg = A , B , C , D , E , F = list ( map ( float , input ( ) . split ( ) ) )
rst = A , B , C , D , E , F = list ( map ( float , input ( ) . split ( ) ) ) <eos>
1101
src = B の 辞書 カ ウ ンタ の出現 頻 度順の列を A とする
trg = A = Counter ( B ) . most_common ( )
rst = A = Counter ( B ) . most_common ( ) <eos>
1102
src = A の B 番目の C 番目 、 D の最小値を A の B 番目の C 番目に する
trg = A [ B ] [ C ] = min ( A [ B ] [ C ] , D )
rst = A [ B ] [ C ] = min ( A [ B ] [ C ] , D ) <eos>
1103
src = convex _ cut ( A ,((- B / C , D ),(- B / C , E ))) を A とする
trg = A = convex_cut ( A , ( ( - B / C , D ) , ( - B / C , E ) ) )
rst = A = convex_cut ( A ) [ B B , C / D , D ( D , ( B , E , E ) ) <eos>
1104
src = B の先頭 、 B の 1 番目 、1、0 、 C から 1 を引いた値 、 B の 2 番目 を追加して A を 更新 する
trg = A . update ( B [ 0 ] , B [ 1 ] , 1 , 0 , C - 1 , B [ 2 ] )
rst = A . update ( B [ 0 ] , B [ 1 ] ) , ( C - 1 , B [ 2 ] ) <eos>
1105
src = A の先頭の先頭 、 C を key として B の最大値 を出力する
trg = print ( A [ 0 ] [ 0 ] , max ( B , key = C ) )
rst = print ( max ( A [ 0 ] [ 0 ] , C . key = B ) ) <eos>
1106
src = get ( B , C , D , E , E [1], 1 ) のコピーされた列を A とする
trg = A = get ( B , C , D , E , E [ 1 ] , 1 ) [ : ]
rst = A = get ( B , C , D , E , E [ 1 ] , 1 ) [ : ] <eos>
1107
src = 1 を B に C を掛けた値から D に E を掛けた値を引いた値で割った値に - E にネイピア数を掛けた値 に B に F を掛けた値を加えた値を掛けた値を A とする
trg = A = 1 / ( B * C - D * E ) * ( - E * e + B * F )
rst = A = 1 / ( B * C - D * E ) - ( E * * e + B * F ) <eos>
1108
src = A の B から 1 を引いた値番目の末尾に ( C 、 D から 1 を引いた値 ) の組 を追加する
trg = A [ B - 1 ] . append ( ( C , D - 1 ) )
rst = A [ B - 1 ] . append ( ( C , D - 1 ) ) <eos>
1109
src = C の D に 2 を加えた値を E で割った余り 番目を展開し 、 それぞれ A 、 B とする
trg = A , B = C [ ( D + 2 ) % E ]
rst = A , B = C [ ( D + 2 ) % E ] <eos>
1110
src = A が 10 より大きいとき 、
trg = if A > 10 :
rst = if A > 10 : <eos>
1111
src = A の末尾に ( B の 2 乗に C の 2 乗を加えた値 、 B 、 C ) の組 を追加する
trg = A . append ( ( B ** 2 + C ** 2 , B , C ) )
rst = A . append ( ( B ** 2 + C ** 2 , B , C ) ) <eos>
1112
src = 1 から B の先頭に 1 を加えた値未満までの数列を順に A として 、 繰り返 す
trg = for A in range ( 1 , B [ 0 ] + 1 ) :
rst = for A in range ( 1 , B [ 0 ] + 1 ) : <eos>
1113
src = A を ( ( 、 つまり現在の日時の 1 番目 、 B ) からなる列 ) からなる列 だけ 増 加 させ る
trg = A += [ [ now [ 1 ] , B ] ]
rst = A += [ [ [ 1 ] , [ B ] ] <eos>
1114
src = A の浮動小数点数 、 B の浮動小数点数を A 、 B とする
trg = A , B = float ( A ) , float ( B )
rst = A , B = float ( A ) , float ( B ) <eos>
1115
src = B が C より大きいとき 2 、 そうでなければ -2 を A とする
trg = A = 2 if B > C else - 2
rst = A = 2 if B > C else - 2 <eos>
1116
src = A の B から 1 を引いた値番目の 、 つまり入力された文字列の整数値 番目を C の B から 1 を引いた値番目で割った値 を出力する
trg = print ( A [ B - 1 ] [ int ( input ( ) ) ] / C [ B - 1 ] )
rst = print ( A [ B - 1 ] [ int ( input ( ) ) ] C [ B - 1 ] ) ) <eos>
1117
src = 1 e -9 を abs _ tol として A と 0.0 が 近 いとき 、
trg = if isclose ( A , 0.0 , abs_tol = 1e-9 ) :
rst = if isclose ( A , B ) < <unk> : <eos>
1118
src = A の末尾に (-1、 未定値 ) の組 を追加する
trg = A . append ( ( - 1 , None ) )
rst = A . append ( ( - 1 , None ) ) <eos>
1119
src = 16 から 18 未満までの数列を順に A として 、 繰り返 す
trg = for A in range ( 16 , 18 ) :
rst = for A in range ( 16 , 18 ) : <eos>
1120
src = A に 1911 を加えた値を出力する
trg = print ( A + 1911 )
rst = print ( A + 1911 ) <eos>
1121
src = A [0][1] の長さが A [1][1] の長さと等しいかどうかが A [2] の 1 番目の長さ と等しいかどうかが 2 と等しくかつ A の 2 番目の 1 番目と A [0] の 1 番目と A [1] の 1 番目 の論理和 の論理積が A の 2 番目の 1 番目と等しいとき 、
trg = if len ( A [ 0 ] [ 1 ] ) == len ( A [ 1 ] [ 1 ] ) == len ( A [ 2 ] [ 1 ] ) == 2 and ( A [ 2 ] [ 1 ] & ( A [ 0 ] [ 1 ] | A [ 1 ] [ 1 ] ) == A [ 2 ] [ 1 ] ) :
rst = if ( A [ 0 ] [ len ( A [ 1 ] ) == 2 ) and len ( A [ 2 ] [ 1 ] ) == ( 1 [ 1 ] [ 1 ] ) == ( A [ 1 ] [ 1 ] 1 ] [
1122
src = A の B から C を引いた値から 1 を引いた値番目の D に C を加えた値 番目でないとき 、
trg = if not A [ B - C - 1 ] [ D + C ] :
rst = if not A [ B - C - 1 ] [ D + C ] : <eos>
1123
src = A の B から 1 を引いた値番目が A の B 番目以下のとき 、
trg = if A [ B - 1 ] <= A [ B ] :
rst = if A [ B - 1 ] <= A [ B ] : <eos>
1124
src = A を 8 分の 一 に する
trg = A //= 8
rst = A /= 8 <eos>
1125
src = A が 、 つまり未定値と等しくなくまたは phase ( A / B ) が 0 以下のとき 、
trg = if A is None or phase ( A / B ) <= 0 :
rst = if A is None or phase ( A / B ) <= 0 : <eos>
1126
src = A の位置 C 、 D 、 E から B に 2 を掛けた値 を探して見つかった位置 を返す
trg = return A . find ( B * 2 , C , D , E )
rst = return A . find ( B , C , D , E - B * 2 ) <eos>
1127
src = A に B を加えた値を 2 で割った商 を出力する
trg = print ( ( A + B ) // 2 )
rst = print ( ( A + B ) // 2 ) <eos>
1128
src = A の 0 番目が B に含まれるとき 、
trg = if A [ 0 ] in B :
rst = if A [ 0 ] in B : <eos>
1129
src = binary _ search ( A , B ) のとき 、
trg = if binary_search ( A , B ) :
rst = if binary_search ( A , B ) : <eos>
1130
src = 改行文字を間に入れて C の各要素を B とし 、 A を書式として B を展開してで整形した文字列 の列を連結した文字列を出力する
trg = print ( '\n' . join ( [ A . format ( * B ) for B in C ] ) )
rst = print ( '\n' . join ( [ A . format ( * B ) ) for B in C ] ) ) <eos>
1131
src = A の 8 番目を出力する
trg = print ( A [ 8 ] )
rst = print ( A [ 8 ] ) <eos>
1132
src = C を 100 で割った商 、 C を 100 で割った余りを A 、 B とする
trg = A , B = C // 100 , C % 100
rst = A , B = C // 100 , C % 100 <eos>
1133
src = write ('' . join ( A ))
trg = write ( '' . join ( A ) )
rst = write ( '' . join ( A ) ) <eos>
1134
src = 0 から readline () の整数値未満までの数列の各要素を B とし 、 readline () を空白で分割した字句列の各要素 に整数を適用した列の組に B を加えた値の列を A とする
trg = A = [ tuple ( map ( int , readline ( ) . split ( ) ) ) + ( B ) for B in range ( int ( readline ( ) ) ) ]
rst = A = [ tuple ( map ( int , readline ( ) . split ( ) ) ) + B for B in range ( int ( readline ( ) ) ) ] <eos>
1135
src = A に ( B 、 C の最小値に 1 を加えた値 、 D に 1 を加えた値 ) の組を追加した集まり
trg = A . add ( ( min ( B , C ) + 1 , D + 1 ) )
rst = A . add ( ( B , C ) + min ( 1 , D + 1 ) ) <eos>
1136
src = A が B と等しくなくかつ A が C と等しくないとき 、
trg = if A != B and A != C :
rst = if A != B and A != C : <eos>
1137
src = 0 を A の 3 番目に する
trg = A [ 3 ] = 0
rst = A [ 3 ] = 0 <eos>
1138
src = A を 4 で割った余りの文字列 を返す
trg = return str ( A % 4 )
rst = return str ( A % 4 ) <eos>
1139
src = A を入力された文字列 の末尾から 空白改行を取り除いた文字列 だけ 増 加 させ る
trg = A += input ( ) . rstrip ( )
rst = A += input ( ) . strip ( ) <eos>
1140
src = A の長さが 0 より大きくまたは 0 が B の先頭を除いた部分列 に含まれる 間 、 次 を 繰り返 す
trg = while len ( A ) > 0 or 0 in B [ 1 : ] :
rst = while len ( A ) > 0 or 0 in B [ 1 : ] : <eos>
1141
src = B と C の論理積 をソートした列を順に A として 、 繰り返 す
trg = for A in sorted ( B & C ) :
rst = for A in sorted ( B & C ) : <eos>
1142
src = A を B の C に 1 を加えた値番目だけ 減 少 させ る
trg = A -= B [ C + 1 ]
rst = A -= B [ C + 1 ] <eos>
1143
src = Koch ( A -1, B , C )
trg = Koch ( A - 1 , B , C )
rst = Koch ( A - 1 , B , C ) <eos>
1144
src = A を 2 で割った商と B の排他論理和を A とする
trg = A = ( A // 2 ) ^ B
rst = A = ( A // 2 ) + B <eos>
1145
src = A 、 B の C と等しい要素の最初の位置の最小値 を A とする
trg = A = min ( A , B . index ( C ) )
rst = A = max ( A , B [ C [ 0 ] ) <eos>
1146
src = Point ( e , B ) を A とする
trg = A = Point ( e , B )
rst = A = Point ( e , B ) <eos>
1147
src = A に B を加えた値から C を引いた値を A とする
trg = A = A + B - C
rst = A = A + B - C <eos>
1148
src = A 内の 1 の出現回数 を出力する
trg = print ( A . count ( 1 ) )
rst = print ( A . count ( 1 ) ) <eos>
1149
src = A の stack の長さが A の tail と等しいかどうかを返す
trg = return len ( A . stack ) == A . tail
rst = return len ( A . stack ) <eos>
1150
src = A 内の A の B 番目の出現回数が 1 と等しいとき 、
trg = if A . count ( A [ B ] ) == 1 :
rst = if A . count ( A [ B ] ) == 1 : <eos>
1151
src = dump ( A , B [1])
trg = dump ( A , B [ 1 ] )
rst = dump ( A , B [ 1 ] ) <eos>
1152
src = B . makeBoard () を順に A として 、 繰り返 す
trg = for A in B . makeBoard ( ) :
rst = for A in B . <unk> ( ) : <eos>
1153
src = 2 に A を掛けた値が B 、 C の最小値から D を引いた値 より大きいとき 、
trg = if 2 * A > min ( B , C ) - D :
rst = if 2 * A > sum ( B , C ) - D : <eos>
1154
src = A に 39 を加えた値を A とする
trg = A = A + 39
rst = A = A + 39 <eos>
1155
src = A が -1 と等しくかつ B が -1 と等しいとき 、
trg = if A == - 1 and B == - 1 :
rst = if A == - 1 and B == - 1 : <eos>
1156
src = A 、 B の C 番目の先頭 の最小値 を返す
trg = return min ( A , B [ C ] [ 0 ] )
rst = return min ( A , B [ C ] [ 0 ] ) <eos>
1157
src = symdiff ( B , C , D , E ) を順に A として 、 繰り返 す
trg = for A in symdiff ( B , C , D , E ) :
rst = for A in <unk> ( B , C , D , E ) : <eos>
1158
src = A の B 番目が - C と等しくないとき 、
trg = if A [ B ] != - C :
rst = if A [ B ] != - C : <eos>
1159
src = B を hour として C を minute として D を second として datetime を A とする
trg = A = datetime ( 2000 , 1 , 1 , hour = B , minute = C , second = D )
rst = A = B , format ( C , <unk> = D , <unk> , D ) <eos>
1160
src = manhattan ( A . size , B , C ) に [ MASK ] を加えた値
trg = + manhattan ( A . size , B , C )
rst = + ( A . size , B , C ) <eos>
1161
src = B の 3 乗を A とする
trg = A = B ** 3
rst = A = B ** 3 <eos>
1162
src = A の B 番目 、 A の C 番目の最小値を A の B 番目に する
trg = A [ B ] = min ( A [ B ] , A [ C ] )
rst = A [ B ] = min ( A [ B ] , A [ C ] ) <eos>
1163
src = C 、 D の要素をそれぞれ組にした列 の各要素を A 、 B とし 、 A に B を掛けた値 の列を返す
trg = return [ A * B for A , B in zip ( C , D ) ]
rst = return [ A * B for A , B in zip ( C , D ) ] <eos>
1164
src = adj _ height ( A , B ) を A とする
trg = A = adj_height ( A , B )
rst = A = adj_height ( A , B ) <eos>
1165
src = B . number _ of _ trailing _ zeros ( C ) を A とする
trg = A = B . number_of_trailing_zeros ( C )
rst = A = B . <unk> ( C ) <eos>
1166
src = yaku ( A )
trg = yaku ( A )
rst = <unk> ( A ) <eos>
1167
src = A が B と等しいかどうかが C と等しいかどうかが -1 と等しいとき 、
trg = if A == B == C == - 1 :
rst = if A == B == C == - 1 : <eos>
1168
src = B に お いて正規表現 A が最初にマッチする位置 のとき 、
trg = if search ( A , B ) :
rst = if search ( A , B ) : <eos>
1169
src = A が B 以上のとき 、
trg = if A >= B :
rst = if A >= B : <eos>
1170
src = B の 1 番目の整数値から C を引いた値を A とする
trg = A = int ( B [ 1 ] ) - C
rst = A = int ( B [ 1 ] ) - C <eos>
1171
src = 0 から B 未満までの数列の各要素を D とし 、 C と 1 を D だけ左シフトした値の論理積 が 0 と等しいとき の D の列を A の B 番目の C 番目に する
trg = A [ B ] [ C ] = [ D for D in range ( B ) if ( C & ( 1 << D ) ) == 0 ]
rst = A [ B ] [ C ] = [ D for D in range ( B ) if D & ( 1 << D ) == 0 ] <eos>
1172
src = inside ( A , B ) でないとき 、
trg = if not inside ( A , B ) :
rst = if not accumulate ( A , B ) : <eos>
1173
src = B の C の D 番目と等しい要素の最初の位置 から E の D を F で割った余り番目を引いた値 を A とする
trg = A = B . index ( C [ D ] ) - E [ D % F ]
rst = A = B [ C . index ( D ) ] - E [ D % F ] <eos>
1174
src = D を E で割った値 、 F の real に G の real を加えた値を 2 で割った値 、 F の imag に G の imag を加えた値を 2 で割った値を A 、 B 、 C とする
trg = A , B , C = D / E , ( F . real + G . real ) / 2 , ( F . imag + G . imag ) / 2
rst = A , B , C = D / E , F . y + G . real + G . y + 2 , ( F . imag + / 2 ) / 2 <eos>
1175
src = A の B に C を加えた値番目を A の B 番目だけ 増 加 させ る
trg = A [ B + C ] += A [ B ]
rst = A [ B + C ] += A [ B ] <eos>
1176
src = A の B から 1 を引いた値から B 番目までの部分列 のとき 、
trg = if A [ B - 1 : B ] :
rst = if A [ B - 1 : B ] : <eos>
1177
src = A が B の 1 番目と等しいとき 、
trg = if A == B [ 1 ] :
rst = if A == B [ 1 ] : <eos>
1178
src = A を B の C の D 番目番目の C の D に 1 を加えた値番目 番目だけ 増 加 させ る
trg = A += B [ C [ D ] ] [ C [ D + 1 ] ]
rst = A += B [ C [ D ] ] [ C [ D + 1 ] ] <eos>
1179
src = ( ( A , B の各要素を A とし 、0 の列 )) からなる辞書を 無限の整数列 とする
trg = count = { char : [ 0 for A in B ] }
rst = count = { <unk> : [ 0 for A in B ] } <eos>
1180
src = 1000 から 、 つまりネイピア数を引いた値を 500 で割った余りを 100 で割った商を A とする
trg = A = ( 1000 - e ) % 500 // 100
rst = A = ( 1000 - e ) % 500 // 100 <eos>
1181
src = dfs ( B -1, C ) に D の B から 1 を引いた値番目を加えた値 、 dfs ( B , C +1) に D の C に 1 を加えた値番目 を加えた値の最大値を A の B 番目の C 番目に する
trg = A [ B ] [ C ] = max ( dfs ( B - 1 , C ) + D [ B - 1 ] , dfs ( B , C + 1 ) + D [ C + 1 ] )
rst = A [ B ] [ C ] = max ( dfs ( B - 1 , C ) + D [ B - 1 ] , dfs ( B [ B - 1 ] , C [ + 1 + 1 ) + D [ C + 1 ] )
1182
src = B の C 番目の right を A とする
trg = A = B [ C ] . right
rst = A = B [ C ] . right <eos>
1183
src = A が B 以上かつ C が D 以下または A が B 以下かつ C が D 以上のとき 、
trg = if ( A >= B and C <= D ) or ( A <= B and C >= D ) :
rst = if A >= B and C <= D or A <= B and C >= D : <eos>
1184
src = can _ construct _ q ( A , B +1, C ) のとき 、
trg = if can_construct_q ( A , B + 1 , C ) :
rst = if <unk> ( A , B + 1 , C ) : <eos>
1185
src = 5 を r として B の コン ビ ネ ー シ ョ ン を順に A として 、 繰り返 す
trg = for A in combinations ( B , r = 5 ) :
rst = for A in combinations ( 5 , B ) : <eos>
1186
src = A の d の 4 番目 、 A の d の 1 番目 、 A の d の 3 番目 、 A の d の 6 番目を A の d の 1 番目 、 A の d の 3 番目 、 A の d の 6 番目 、 A の d の 4 番目とする
trg = A . d [ 1 ] , A . d [ 3 ] , A . d [ 6 ] , A . d [ 4 ] = A . d [ 4 ] , A . d [ 1 ] , A . d [ 3 ] , A . d [ 6 ]
rst = A . d [ 1 ] , A . d [ 3 ] , A . d [ 4 ] , A . d [ 1 ] , A . d [ 1 ] , A . d [ 1 ] , A . d [ 3 ] , A
1187
src = 0 から C の長さから 1 を引いた値 未満までの数列の各要素を B とし 、 C [ B ] が D と等しくかつ C [ B +1] が E と等しくかつ C の B +2 番目が D と等しいとき の 1 の列の総和を A とする
trg = A = sum ( [ 1 for B in range ( len ( C ) - 1 ) if C [ B ] == D and C [ B + 1 ] == E and C [ B + 2 ] == D ] )
rst = A = sum ( [ 1 for B in range ( len ( C ) - 1 ) if C [ B ] == D and C [ B + 1 ] == E and C [ B + 1 ] == D ] ) <eos>
1188
src = A が B と等しくまたは A が 、 つまり空文字列 と等しいとき 、
trg = if A == B or A == '' :
rst = if A == B or A == '' : <eos>
1189
src = ( (-1) からなる列の 3 に input () を空白で分割した字句列 を加えた値に (-1) からなる列の range ( C ) の各要素を B とし 、 3 の列回分の列 を加えた値回分の列 ) からなる列を A とする
trg = A = [ [ - 1 ] * 3 + input ( ) . split ( ) + [ - 1 ] * [ 3 for B in range ( C ) ] ]
rst = A = [ [ - 1 ] * ( + [ ( ( B ) + [ 2 for C in range ( ) ) ] + ( ( C ) ] ] + [ ( C ) ] ] <eos>
1190
src = B の 2 乗から C から D を引いた値の 2 乗を引いた値を A とする
trg = A = B ** 2 - ( C - D ) ** 2
rst = A = B ** 2 - ( C - D ) ** 2 <eos>
1191
src = check ( A - B ) のとき 、
trg = if check ( A - B ) :
rst = if check ( A - B ) : <eos>
1192
src = - A . flow (0, B + C +1, min ( B , C )) を出力する
trg = print ( - A . flow ( 0 , B + C + 1 , min ( B , C ) ) )
rst = print ( - A . flow ( 0 , B + C + 1 , min ( B , C ) ) ) <eos>
1193
src = ネイピア数の 3 番目が 、 つまりネイピア数の 4 番目と等しいかどうかが 、 つまりネイピア数の 5 番目と等しいかどうかが A と等しいとき 、
trg = if e [ 3 ] == e [ 4 ] == e [ 5 ] == A :
rst = if e [ 3 ] == e [ 4 4 ] == e == 5 : <eos>
1194
src = B から 1 を引いた値に C から 1 を引いた値を加えた値に 2 を加えた値から D から 1 を引いた値を引いた値を A とする
trg = A = ( B - 1 ) + ( C - 1 ) + 2 - ( D - 1 )
rst = A = B - 1 + ( C - 1 ) - 2 - ( D - 1 ) <eos>
1195
src = write ( A %( B +1- sum ( C )))
trg = write ( A % ( B + 1 - sum ( C ) ) )
rst = write ( A % ( B - 1 ) ** ( C ) ) ) <eos>
1196
src = dij ( A [1]-1, A [2] -1, B )
trg = dij ( A [ 1 ] - 1 , A [ 2 ] - 1 , B )
rst = <unk> ( A [ 2 ] - A [ 2 ] , 1 , B ) <eos>
1197
src = 0 を A の B 番目の C から D を引いた値番目に する
trg = A [ B ] [ C - D ] = 0
rst = A [ B ] [ C - D ] = 0 <eos>
1198
src = ( 3、0) の組を返す
trg = return ( 3 , 0 )
rst = return ( 0 , 3 ) <eos>
1199
src = 2 から 10000 未満までの数列のリストを A とする
trg = A = list ( range ( 2 , 10000 ) )
rst = A = list ( range ( 2 , <unk> ) ) <eos>
1200
src = B の 2 個までの コン ビ ネ ー シ ョ ンを A とする
trg = A = combinations ( B , 2 )
rst = A = combinations_with_replacement ( B , 2 ) <eos>
1201
src = D の各要素を A とし 、 A 内の B を C で置き換えた文字列を出力する の列
trg = [ print ( A . replace ( B , C ) ) for A in D ]
rst = [ print ( A . replace ( B , C ) for C in D ] <eos>
1202
src = A が ((0、0) の組 、(1、-1) の組 、(1、0) の組 、(2、-1 ) の組 ) からなる列と等しいとき 、
trg = if A == [ ( 0 , 0 ) , ( 1 , - 1 ) , ( 1 , 0 ) , ( 2 , - 1 ) ] :
rst = if A == [ ( 0 , 0 1 , 1 ) , ( 1 , 0 ) , ( 0 , 1 ) ] : <eos>
1203
src = 入力された文字列 を空白文字で分割した字句列 を展開し 、 それぞれ A 、 time とする
trg = A , time = input ( ) . split ( ' ' )
rst = A , time = input ( ) . split ( ' ' ) <eos>
1204
src = 入力された文字列を空白 文字で分割した字句列の各要素に 整数を適用した列のリストを展開し 、 それぞれ A 、 ネイピア数とする
trg = A , e = list ( map ( int , input ( ) . split ( ' ' ) ) )
rst = A , e = list ( map ( int , input ( ) . split ( ' ' ) ) ) <eos>
1205
src = A が B の DISTANT と等しいとき 、
trg = if A == B . DISTANT :
rst = if A == B . <unk> : <eos>
1206
src = A の 、 つまり先頭から 、 つまり末尾までの 4 間隔による部分列内の B の出現回数が 3 と等しくまたは A の 2 番目から 7 番目までの 2 間隔による部分列内の B の出現回数が 3 と等しいとき 、
trg = if A [ 0 : : 4 ] . count ( B ) == 3 or A [ 2 : 7 : 2 ] . count ( B ) == 3 :
rst = if A [ : : : 2 ] . count ( B ) == 3 or A [ 2 : 7 ] 2 ] . count ( B ) == 3 : <eos>
1207
src = C 、 C の 、 つまり末尾 から 、 つまり末尾までの部分列に C の末尾を除いた部分列を加えた値 の要素をそれぞれ組にした列を順に A 、 B として 、 繰り返 す
trg = for A , B in zip ( C , C [ - 1 : ] + C [ : - 1 ] ) :
rst = for A , B in zip ( C , C [ - 1 : ] + C ) ) : <eos>
1208
src = A の先頭の B 番目が C と等しくなくかつ D の B 番目が A の先頭の B 番目と等しくないとき 、
trg = if A [ 0 ] [ B ] != C and D [ B ] != A [ 0 ] [ B ] :
rst = if A [ 0 ] != B != C and D [ B ] != A [ 0 ] [ B ] : <eos>
1209
src = D の各要素を B 、 C とし 、 B の 列を追加して A を 更新 する
trg = A . update ( [ B for B , C in D ] )
rst = A . update ( [ B for B , C in D ] ) <eos>
1210
src = A の末尾に ( B に 10 を加えた値 、 集合 ) の組 を追加する
trg = A . append ( ( B + 10 , set ( ) ) )
rst = A . append ( ( B + 10 , ) ) <eos>
1211
src = B が 0 以上のとき C から D を引いた値 、 そうでなければ D 、 E が 0 以上のとき F から G を引いた値 、 そうでなければ G の最小値を A とする
trg = A = min ( C - D if B >= 0 else D , F - G if E >= 0 else G )
rst = A = min ( ( B - D if if if if if if if if if if if if if if if if E >= E else if B >= 0 else G ) <eos>
1212
src = A 内の B の出現回数が A 内の C の出現回数 と等しくなくまたは A 内の D の出現回数が A 内の E の出現回数 と等しくないとき 、
trg = if A . count ( B ) != A . count ( C ) or A . count ( D ) != A . count ( E ) :
rst = if A . count ( B ) != A . count ( C ) != A . count ( D ) != A . count ( E ) : <eos>
1213
src = 1 が A の長さより小さいとき 、
trg = if 1 < len ( A ) :
rst = if 1 < len ( A ) : <eos>
1214
src = ( 1、1、1 、0) からなる列を A とする
trg = A = [ 1 , 1 , 1 , 0 ]
rst = A = [ 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] <eos>
1215
src = ( B 、 C ) の組が D と等しいとき E 、 そうでなければ E に 1 を加えた値を A とする
trg = A = E if ( B , C ) == D else E + 1
rst = A = E if ( B , C ) == D else E + 1 <eos>
1216
src = mergeSort ( A ,0, B ) を無限の整数列 とする
trg = count = mergeSort ( A , 0 , B )
rst = count = mergeSort ( A , 0 , B ) <eos>
1217
src = ((-1、-1) の組 、(0、-1) の組 、(1、0) の組 、(0、1) の組 、(-1、1) の組 、(-1、0) の組 ) の組を A とする
trg = A = ( ( - 1 , - 1 ) , ( 0 , - 1 ) , ( 1 , 0 ) , ( 0 , 1 ) , ( - 1 , 1 ) , ( - 1 , 0 ) )
rst = A = ( ( - 1 , - 1 ) , ( 0 , - 1 ) , ( 0 , 0 ) , ( 1 , - 1 ) , ( - 1 , - 1 ) ) <eos>
1218
src = C の文字列を A の B 番目に する
trg = A [ B ] = str ( C )
rst = A [ B ] = str ( C ) <eos>
1219
src = is _ intersected _ ls ( A , B , C , D ) のとき 1 、 そうでなければ 0 を出力する
trg = print ( 1 if is_intersected_ls ( A , B , C , D ) else 0 )
rst = print ( 1 if <unk> ( A , B , C , D ) else 0 ) <eos>
1220
src = D . calc _ koch _ apex ( E ) を展開し 、 それぞれ A 、 B 、 C とする
trg = A , B , C = D . calc_koch_apex ( E )
rst = A , B , C = D . <unk> ( E ) <eos>
1221
src = B を C に 3 を掛けた値 だけ右シフトした値と 7 の論理積を A とする
trg = A = ( B >> ( C * 3 ) ) & 7
rst = A = B // ( C * 3 ) & C <eos>
1222
src = ( 、 つまり真 ) からなる列の 101 回分の列を A とする
trg = A = [ True ] * 101
rst = A = [ True ] * 101 <eos>
1223
src = 10 を A とする
trg = A = 10
rst = A = 10 <eos>
1224
src = A の west 、 A の bottom 、 A の east 、 A の top を A の top 、 A の west 、 A の bottom 、 A の east とする
trg = A . top , A . west , A . bottom , A . east = A . west , A . bottom , A . east , A . top
rst = A . top , A . west , A . bottom , A . west , A . west , A . bottom , A . bottom , A . bottom , A . top , A . top <eos>
1225
src = 195 に B を掛けた値を A とする
trg = A = 195 * B
rst = A = 3.141592653589 * B <eos>
1226
src = election ( A , B ) を出力する
trg = print ( election ( A , B ) )
rst = print ( <unk> ( A , B ) ) <eos>
1227
src = 入力された文字列を D で分割した字句列の各要素に 整数を適用した列のリストを展開し 、 それぞれ A 、 B 、 C とする
trg = A , B , C = list ( map ( int , input ( ) . split ( D ) ) )
rst = A , B , C = list ( map ( int , input ( ) . split ( D ) ) ) <eos>
1228
src = A が 、 つまり未定値と等しくなくまたは B が 、 つまり未定値と等しくないとき 、
trg = if A is None or B is None :
rst = if A is None or B is None : <eos>
1229
src = B の C 番目から D 未満までの E の C 番目 間隔の数列を順に A として 、 繰り返 す
trg = for A in range ( B [ C ] , D , E [ C ] ) :
rst = for A in range ( B [ C ] , D , E [ C ] ) : <eos>
1230
src = A の 0 番目が B の 0 番目と等しくかつ A の 1 番目が B の 1 番目と等しいとき 、
trg = if A [ 0 ] == B [ 0 ] and A [ 1 ] == B [ 1 ] :
rst = if A [ 0 ] == B [ 0 ] and A [ 1 ] == B [ 1 ] : <eos>
1231
src = B から読み込んだ一行 を空白で分割した字句列の各要素に 整数を適用した列の 辞書 カ ウ ンタを A とする
trg = A = Counter ( map ( int , B . readline ( ) . split ( ) ) )
rst = A = Counter ( list ( map ( int , B . readline ( ) . split ( ) ) ) <eos>
1232
src = 空文字列を B とする を A とする
trg = A = B = ''
rst = A = B = B <eos>
1233
src = E の C 番目の各要素を D 、 B とし 、 ( B 、 C ) の組の列 を追加して A を 拡張 する
trg = A . extend ( [ ( B , C ) for D , B in E [ C ] ] )
rst = A . extend ( [ ( B , C ) for D , B in E [ C ] ] ) <eos>
1234
src = ( ( B ) からなる列の 0 から A の V 未満までの数列の各要素を C とし 、 A の V の列回分の列 ) からなる列を A の distance に する
trg = A . distance = [ [ B ] * [ A . V for C in range ( A . V ) ] ]
rst = A . distance = [ [ B ] * [ A . V for C in range ( A . V ) ] <eos>
1235
src = A の末尾に B の C に 1 を加えた値番目を D の C に 1 を加えた値番目 で割った商 を追加する
trg = A . append ( B [ C + 1 ] // D [ C + 1 ] )
rst = A . append ( B [ C + 1 ] / D [ C + 1 ] ) <eos>
1236
src = A に B の C 番目を掛けた値を A とする
trg = A = A * B [ C ]
rst = A = A * B [ C ] <eos>
1237
src = A 、 B の C 番目の C に 1 を加えた値番目に B の C に 1 を加えた値番目の D に 1 を加えた値番目 を加えた値の最大値を A とする
trg = A = max ( A , B [ C ] [ C + 1 ] + B [ C + 1 ] [ D + 1 ] )
rst = A = max ( A , B [ C ] [ C + 1 ] + B [ C + 1 ] [ D + 1 ] ) <eos>
1238
src = A をソート する
trg = A . sort ( )
rst = A . sort ( ) <eos>
1239
src = B のコピーされた列を A の map に する
trg = A . map = B [ : ]
rst = A . map = B [ : ] <eos>
1240
src = dfs (0, A [0], A [1]) のとき 、
trg = if dfs ( 0 , A [ 0 ] , A [ 1 ] ) :
rst = if dfs ( 0 , A [ 0 ] , A [ 1 ] ) : <eos>
1241
src = B を A の _ size に する
trg = A . _size = B
rst = A . _nodes = B <eos>
1242
src = 0 から 1 を C だけ左シフトした値 未満までの数列の各要素を B とし 、 、 つまり空辞書の列 を A とする
trg = A = [ { } for B in range ( 1 << C ) ]
rst = A = [ { } for B in range ( 1 << C ) ] <eos>
1243
src = A の順序数が B の順序数 以下かつ B の順序数が C の順序数 以下のとき 、
trg = if ord ( A ) <= ord ( B ) and ord ( B ) <= ord ( C ) :
rst = if ord ( A ) <= B ( B ) <= ord ( B ) <= C ) : <eos>
1244
src = A の n が B と等しいとき 、
trg = if A . n == B :
rst = if A . n == B : <eos>
1245
src = B を C で割った値に 2.0 を掛けた値を A とする
trg = A = B / C * 2.0
rst = A = B / C * 2.0 <eos>
1246
src = math . atan 2( B , C ) に円周率 を 2 で割った値を加えた値を A とする
trg = A = math . atan2 ( B , C ) + math . pi / 2
rst = A = math . atan2 ( math , B , C ) / 2 / 2 <eos>
1247
src = write ( A % polygon _ area ( B ))
trg = write ( A % polygon_area ( B ) )
rst = write ( A % polygon_area ( B ) ) <eos>
1248
src = 空文字列を間に入れて A を連結した文字列の整数値を A とする
trg = A = int ( '' . join ( A ) )
rst = A = int ( '' . join ( A ) ) <eos>
1249
src = A の B 番目 、 C に D を加えた値の最小値を A の B 番目に する
trg = A [ B ] = min ( A [ B ] , C + D )
rst = A [ B ] = min ( A [ B ] , C + D ) <eos>
1250
src = A の B 番目の C から 1 を引いた値番目が 0 と等しいとき 、
trg = if A [ B ] [ C - 1 ] == 0 :
rst = if A [ B ] [ C - 1 ] == 0 : <eos>
1251
src = ソートされた順序を保ったまま C の D 番目を B に挿入できる最後の位置を A とする
trg = A = bisect . bisect_right ( B , C [ D ] )
rst = A = bisect . bisect_right ( B , C [ D ] ) <eos>
1252
src = A .__ inorder ( B . right )
trg = A . __inorder ( B . right )
rst = A . __inorder ( B . right ) <eos>
1253
src = 1299709 を A とする
trg = A = 1299709
rst = A = <unk> <eos>
1254
src = A . connected ( e [0], e [1]) でないとき 、
trg = if not A . connected ( e [ 0 ] , e [ 1 ] ) :
rst = if not A . connected ( e [ 0 ] , e [ 1 ] ) : <eos>
1255
src = A 、 2 に B に C を掛けた値 の .5 乗を掛けた値に D の E 番目 を加えた値の最大値を A とする
trg = A = max ( A , 2 * ( B * C ) ** .5 + D [ E ] )
rst = A = max ( A , 2 * B * C * ** .5 + D [ E ] ) <eos>
1256
src = A に 1 を加えた値を B の長さで割った余りを A とする
trg = A = ( A + 1 ) % len ( B )
rst = A = ( A + 1 ) % len ( B ) <eos>
1257
src = A . is _ renew ( B ) のとき 、
trg = if A . is_renew ( B ) :
rst = if A . is_parallel ( B ) : <eos>
1258
src = A の B 番目の C 番目に ( D に 1 を加えた値 、 E 、 F ) の組を追加した集まり
trg = A [ B ] [ C ] . add ( ( D + 1 , E , F ) )
rst = A [ B ] [ C ] . add ( ( D + 1 , E , F ) ) <eos>
1259
src = A の depth を返す
trg = return A . depth
rst = return A . depth <eos>
1260
src = A の B の 1 番目番目を A の B の先頭番目に する
trg = A [ B [ 0 ] ] = A [ B [ 1 ] ]
rst = A [ B [ 0 ] ] = A [ B [ 1 ] ] <eos>
1261
src = A . get _ root () の key を返す
trg = return A . get_root ( ) . key
rst = return A . get_root ( ) . key <eos>
1262
src = C に D の E 番目の先頭を加えた値 、 F に D の E 番目の 1 番目を加えた値を A 、 B とする
trg = A , B = C + D [ E ] [ 0 ] , F + D [ E ] [ 1 ]
rst = A , B = C + D [ E ] [ 0 ] , F + D [ E ] [ 1 ] <eos>
1263
src = A の末尾に 改行文字を間に入れて B を連結した文字列 を追加する
trg = A . append ( '\n' . join ( B ) )
rst = A . append ( '\n' . join ( B ) ) <eos>
1264
src = 1 から B に 2 を加えた値未満までの数列を順に A として 、 繰り返 す
trg = for A in range ( 1 , B + 2 ) :
rst = for A in range ( 1 , B + 2 ) : <eos>
1265
src = A + B *5 に C *10 を加えた値に D に 50 を掛けた値を加えた値 にネイピア数に 100 を掛けた値を加えた値に E に 500 を掛けた値を加えた値が 1000 以上のとき 、
trg = if A + B * 5 + C * 10 + D * 50 + e * 100 + E * 500 >= 1000 :
rst = if A + B * 5 + C * 10 + D * 50 * E + E * 500 >= 1000 : <eos>
1266
src = A . compute ( B , C ) を出力する
trg = print ( A . compute ( B , C ) )
rst = print ( A . <unk> ( B , C ) ) <eos>
1267
src = A の ( B の -1 番目に 1 を加えた値 、 C 、 D ) の組 番目を出力する
trg = print ( A [ ( B [ - 1 ] + 1 , C , D ) ] )
rst = print ( A [ ( B [ - 1 ] + 1 , C , D ) ] ) <eos>
1268
src = lis ( A ) を出力する
trg = print ( lis ( A ) )
rst = print ( <unk> ( A ) ) <eos>
1269
src = (-1) からなる列の A の n 回分の列を A の pv に する
trg = A . pv = [ - 1 ] * A . n
rst = A . p = [ - 1 ] * A . n <eos>
1270
src = B を A の prev に する
trg = A . prev = B
rst = A . prev = B <eos>
1271
src = 1 から 14 未満までの数列の各要素を F とし 、"{} {}" が G に含まれるとき の ( B 、 C 、 D 、 E ) からなる列の列の各要素を A とし 、"{} {}" を出力するの列
trg = [ print ( {shcd} {n} ) for A in [ [ B , C , D , E ] for F in range ( 1 , 14 ) if {shcd} {n} in G ] ]
rst = [ print ( <unk> ) for A in [ C , D , [ E , E in [ ] for F in range ( 1 , 14 ) ] for G in [ ] == G ] ) ] ) ] <eos>
1272
src = A の FLAGS と A の Masks の B 番目の論理積が 0 b 0 0 と等しくないかどうかを返す
trg = return A . FLAGS & A . Masks [ B ] != 0b00
rst = return A . FLAGS & A . Masks [ B ] != 0 0 0 ] <eos>
1273
src = A が B と等しくまたは A が C に含まれかつ D が B と等しくまたは D が E に含まれかつ F が B と等しくまたは F が G 以下かつ H が B と等しくまたは G が H 以下のとき 、
trg = if ( A == B or A in C ) and ( D == B or D in E ) and ( F == B or F <= G ) and ( H == B or G <= H ) :
rst = if A == B or C A and C D and B == B ) or ( D == E ) and F == F and G == G and H == B ) H : <eos>
1274
src = delete ( A . right , B ) を A の right に する
trg = A . right = delete ( A . right , B )
rst = A . right = delete ( A . right , B ) <eos>
1275
src = C 、0 を A の B 番目の depth 、 A の B 番目の height とする
trg = A [ B ] . depth , A [ B ] . height = C , 0
rst = A [ B ] . depth , A [ B ] = C , 0 <eos>
1276
src = A の dice が B の dice と等しいとき 、
trg = if A . dice == B . dice :
rst = if A . dice == B . dice : <eos>
1277
src = B から C を引いた値の絶対値を A とする
trg = A = abs ( B - C )
rst = A = abs ( B - C ) <eos>
1278
src = A が 2 と等しいとき 、
trg = if A == 2 :
rst = if A == 2 : <eos>
1279
src = A から B を引いた値に C を掛けた値を出力する
trg = print ( ( A - B ) * C )
rst = print ( ( A - B ) * C ) <eos>
1280
src = 入力された文字列 を空白で分割した字句列の各要素に 整数を適用した列のリストを A の B に 2 を加えた値番目の 2 番目から 12 番目までの部分列に する
trg = A [ B + 2 ] [ 2 : 12 ] = list ( map ( int , input ( ) . split ( ) ) )
rst = A [ B + 2 ] [ 2 : 2 ] = list ( map ( int , input ( ) . split ( ) ) ) <eos>
1281
src = 0、255、255 を A 、 B 、 C とする
trg = A , B , C = 0 , 255 , 255
rst = A , B , C = 0 , 2 , 3 <eos>
1282
src = parent _ search ( B , C ) を A とする
trg = A = parent_search ( B , C )
rst = A = <unk> ( B , C ) <eos>
1283
src = A を B の C 番目に D を 100 で割った値の E 乗を掛けた値だけ 増 加 させ る
trg = A += B [ C ] * ( D / 100 ) ** E
rst = A += B [ C ] * ( D / 100 ) ** E <eos>
1284
src = A が B の長さより小さい 間 、 次 を 繰り返 す
trg = while A < len ( B ) :
rst = while A < len ( B ) : <eos>
1285
src = decode _ node _ data ( A )
trg = decode_node_data ( A )
rst = <unk> ( A ) <eos>
1286
src = A が B 以上かつ C が B 以上かつ A が D から B を引いた値以下かつ C が E から B を引いた値以下のとき 、
trg = if A >= B and C >= B and A <= ( D - B ) and C <= ( E - B ) :
rst = if A >= B and C >= B and A <= ( D - B ) and C <= E - B ) : <eos>
1287
src = Bit ( B ) を A とする
trg = A = Bit ( B )
rst = A = <unk> ( B ) <eos>
1288
src = B の各要素を A とし 、 C の列の各要素を B とし 、 A の列の最大値 を出力する
trg = print ( max ( [ A for B in [ C for A in B ] ] ) )
rst = print ( max ( [ A for A in B ] for A in B ] ] ) ) <eos>
1289
src = 2 を 底 とする input () の整数値に 1 を加えた値 の対数の整数値 を出力する
trg = print ( int ( math . log ( int ( input ( ) ) + 1 , 2 ) ) )
rst = print ( int ( math . log ( int ( input ( ) ) + 1 ) ) ) <eos>
1290
src = B 内の 2 の出現回数を C とする
trg = C = B . count ( 2 )
rst = C = B . count ( 2 ) <eos>
1291
src = B 、 C の B 番目の最小値を A の B 番目に する
trg = A [ B ] = min ( B , C [ B ] )
rst = A [ B ] = min ( B , C [ B ] ) <eos>
1292
src = write ( A % B [ C [0]])
trg = write ( A % B [ C [ 0 ] ] )
rst = write ( A % B [ C [ 0 ] ] ) <eos>
1293
src = A の B 番目が C 以上かつ D が 0 より大きいとき 、
trg = if ( A [ B ] >= C ) and ( D > 0 ) :
rst = if A [ B ] >= C and D > 0 : <eos>
1294
src = A に B に C を加えた値を加えた値を A とする
trg = A = A + ( B + C )
rst = A = A + ( B + C ) <eos>
1295
src = A を 2 に B を掛けた値だけ 減 少 させ る
trg = A -= 2 * B
rst = A -= 2 * B <eos>
1296
src = A の B の先頭番目 、 A の C 番目に B の 1 番目を加えた値の最小値を A の B の先頭番目に する
trg = A [ B [ 0 ] ] = min ( A [ B [ 0 ] ] , A [ C ] + B [ 1 ] )
rst = A [ B [ 0 ] ] = min ( A [ B [ 0 ] ] , A [ C ] + B [ 1 ] ) <eos>
1297
src = B の REdge の C 番目を順に A として 、 繰り返 す
trg = for A in B . REdge [ C ] :
rst = for A in B . <unk> [ C ] : <eos>
1298
src = A . adj ( B ) の各要素をネイピア数 とし 、 、 つまりネイピア数の src が B と等しいとき の 、 つまりネイピア数の flow の列の総和を返す
trg = return sum ( [ e . flow for e in A . adj ( B ) if e . src == B ] )
rst = return sum ( [ e . count for e in A . if e if e . dest ] ) <eos>
1299
src = A を B 、 C から B を引いた値の最小値 だけ 増 加 させ る
trg = A += min ( B , C - B )
rst = A += min ( B , C - B ) <eos>
1300
src = A の B から 1 を引いた値番目の 0 番目に C の B から 1 を引いた値番目の D から A [ B -1 ] の 1 番目を引いた値番目を加えた値が C の B から 1 を引いた値番目の D 番目より大きいとき 、
trg = if A [ B - 1 ] [ 0 ] + C [ B - 1 ] [ D - A [ B - 1 ] [ 1 ] ] > C [ B - 1 ] [ D ] :
rst = if A [ B - 1 ] [ 0 ] + C [ B - 1 ] [ D - A [ B - 1 ] ] [ 1 ] - C [ B - 1 ] [ 1 ] ] > C [ B - 1 ] [ D
1301
src = checkA ( A ) のとき 、
trg = if checkA ( A ) :
rst = if <unk> ( A ) : <eos>
1302
src = B の C の D 番目から D に E を加えた値までの部分列 と等しい要素の最初の位置 を順に A として 、 繰り返 す
trg = for A in B . index ( C [ D : D + E ] ) :
rst = for A in B . index ( C [ D : D + E ] ) : <eos>
1303
src = Num ( A . x * B . x ) を返す
trg = return Num ( A . x * B . x )
rst = return Num ( A . x * B . x ) <eos>
1304
src = 入力された文字列 を空白で分割した字句列の各要素に 整数を適用した列を展開し 、 それぞれ A 、 B 、 ネイピア数 、 C 、 D 、 E とする
trg = A , B , e , C , D , E = map ( int , input ( ) . split ( ) )
rst = A , B , e , C , D , E = map ( int , input ( ) . split ( ) ) <eos>
1305
src = Graph ( B , C ,1) を A とする
trg = A = Graph ( B , C , 1 )
rst = A = Graph ( B , C , 1 ) <eos>
1306
src = C の 1 番目を展開し 、 それぞれ A 、 B とする
trg = A , B = C [ 1 ]
rst = A , B = C [ 1 ] <eos>
1307
src = sum ([ A <= BforAinC ] ) を 2 で割った余りまたは sum ([ A >= DforAinC ] ) を 2 で割った余りまたは C の各要素を A とし 、 B < AandA < D の列の総和 のとき 1 、 そうでなければ 0 を出力する
trg = print ( 1 if sum ( [ A <= B for A in C ] ) % 2 or sum ( [ A >= D for A in C ] ) % 2 or sum ( [ B < A and A < D for A in C ] ) else 0 )
rst = print ( 1 if sum ( [ 1 for A in Counter ( [ A if A == [ 2 else [ ) else [ 2 if sum ( [ 2 if 2 else [ ) if 2 else [ ) if sum ( [ 2 if 2 else [
1308
src = A の B の y 座標番目の B の x 座標 番目が -1 と等しいかどうかを返す
trg = return A [ B . y ] [ B . x ] == - 1
rst = return A [ B . y [ 0 ] . B ( B . x == - 1 <eos>
1309
src = E から 1 を引いた値 、 B に C に 2 を掛けた値を加えた値の最小値を D とする
trg = D = min ( E - 1 , B + C * 2 )
rst = D = min ( E - 1 , B + C * 2 ) <eos>
1310
src = ( < __ main __ . Cammaobjectat 0 x 10 a 10 ee 5 0> ) の集合を A の B 番目に する
trg = A [ B ] = { C }
rst = A [ B ] = { C ] } <eos>
1311
src = prev _ perm ( B [:]) を A とする
trg = A = prev_perm ( B [ : ] )
rst = A = to_gamma ( B [ : ] ) <eos>
1312
src = isPacked ( B , C , D ) を A とする
trg = A = isPacked ( B , C , D )
rst = A = <unk> ( B , C , D ) <eos>
1313
src = A を B に 1 を加えた値で割った商に A を B に 1 を加えた値 で割った余りの論理値 を加えた値を出力する
trg = print ( A // ( B + 1 ) + bool ( A % ( B + 1 ) ) )
rst = print ( A // ( B + 1 + bool ( A % B + 1 ) ) ) <eos>
1314
src = (-1、0、1、 2 ) からなる列を A とする
trg = A = [ - 1 , 0 , 1 , 2 ]
rst = A = [ 0 , 2 , 3 , 2 ] <eos>
1315
src = ( 0 、3、1、4、2、 5) の組を A とする
trg = A = ( 0 , 3 , 1 , 4 , 2 , 5 )
rst = A = ( 0 , 5 , 3 , 5 , 5 , 5 ) <eos>
1316
src = swap ( A [0])
trg = swap ( A [ 0 ] )
rst = swap ( A [ 0 ] ) <eos>
1317
src = D の C 番目を A の B 番目の C 番目に する
trg = A [ B ] [ C ] = D [ C ]
rst = A [ B ] [ C ] = D [ C ] <eos>
1318
src = 無限の整数列を A を英小文字に変換した文字列を 空白で分割した字句列内の B の出現回数 だけ 増 加 させ る
trg = count += A . lower ( ) . split ( ) . count ( B )
rst = count += A . lower ( ) . count ( B ) <eos>
1319
src = B を 100 で割った余りを 10 で割った値の整数値を A とする
trg = A = int ( ( B % 100 ) / 10 )
rst = A = int ( ( B % 100 ) / 3.305785 ) <eos>
1320
src = 空白文字に空白文字を間に入れて A の各要素に整数を適用した列 を連結した文字列を加えた値 を出力する
trg = print ( ' ' + ' ' . join ( map ( str , A ) ) )
rst = print ( ' ' + ' ' . join ( map ( str , A ) ) ) <eos>
1321
src = E を D の B 番目に する
trg = D [ B ] = E
rst = D [ B ] = E <eos>
1322
src = A の B 番目の 3 番目を A の B 番目の 4 番目の C 番目だけ 増 加 させ る
trg = A [ B ] [ 3 ] += A [ B ] [ 4 ] [ C ]
rst = A [ B ] [ 3 ] += A [ B ] [ 4 ] [ C ] <eos>
1323
src = A の B から 1 を引いた値番目の末尾に ( C から 1 を引いた値 、 D ) の組 を追加する
trg = A [ B - 1 ] . append ( ( C - 1 , D ) )
rst = A [ B - 1 ] . append ( ( C - 1 , D ) ) <eos>
1324
src = cross ( B - C , e - C ) を A とする
trg = A = cross ( B - C , e - C )
rst = A = cross ( B - C , e - C ) <eos>
1325
src = B . f ( A , B . segtree [ C -1]) を A とする
trg = A = B . f ( A , B . segtree [ C - 1 ] )
rst = A = B . f ( A , B . dist [ C - 1 ] ) <eos>
1326
src = A の長さが B の C 番目 の長さより小さいとき 、
trg = if len ( A ) < len ( B [ C ] ) :
rst = if len ( A ) < len ( B [ C ] ) : <eos>
1327
src = B . max (0, C -1) に 1 を加えた値を A とする
trg = A = B . max ( 0 , C - 1 ) + 1
rst = A = B . max ( 0 , C - 1 ) + 1 <eos>
1328
src = A の dist の B 番目が C より小さいとき 、
trg = if A . dist [ B ] < C :
rst = if A . dist [ B ] < C : <eos>
1329
src = time の 1 番目が time の 4 番目より大きいとき 、
trg = if time [ 1 ] > time [ 4 ] :
rst = if time [ 1 ] > time [ 4 ] : <eos>
1330
src = A の末尾に ( B から C の .5 乗を引いた値 、 D ) の組 を追加する
trg = A . append ( ( B - C ** .5 , D ) )
rst = A . append ( ( B - C ** .5 , D ) ) <eos>
1331
src = middle _ square ( A )
trg = middle_square ( A )
rst = <unk> ( A ) <eos>
1332
src = 空白文字を間に入れて B の逆順の各要素を A とし 、 A の文字列の列を連結した文字列 を出力する
trg = print ( ' ' . join ( [ str ( A ) for A in B [ : : - 1 ] ] ) )
rst = print ( ' ' . join ( [ str ( A ) for A in B [ : : - 1 ] ] ) ) <eos>
1333
src = A の B 番目の先頭 、 A の B 番目の 2 番目を出力する
trg = print ( A [ B ] [ 0 ] , A [ B ] [ 2 ] )
rst = print ( A [ B ] [ 0 ] , A [ B ] [ 2 ] ) <eos>
1334
src = C の D から読み込んだ一行 の両端から 空白改行を取り除いた文字列 番目の各要素を B とし 、 A の B 番目の列を A とする
trg = A = [ A [ B ] for B in C [ D . readline ( ) . strip ( ) ] ]
rst = A = [ A [ B ] for B in C . index ( ) . strip ( ) . split ( ) ] <eos>
1335
src = ( B ) からなる列を追加して A の forest を 更新 する
trg = A . forest . update ( [ B ] )
rst = A . forest = set ( [ B ] ) <eos>
1336
src = ( ( C 、 D ) の組 、 ( E 、 F ) の組 、 ( G 、 H ) の組 ) の組 を順に A 、 B として 、 繰り返 す
trg = for A , B in ( ( C , D ) , ( E , F ) , ( G , H ) ) :
rst = for A , B in ( ( C , D ) , ( E , F ) , ( G , H ) ) : <eos>
1337
src = A が B の長さより小さくかつ B の A 番目が C と等しくない 間 、 次 を 繰り返 す
trg = while A < len ( B ) and B [ A ] != C :
rst = while A < len ( B ) and B [ A ] != C : <eos>
1338
src = A の値の集まりの A の top から 1 を引いた値番目を返す
trg = return A . values [ A . top - 1 ]
rst = return A . values ( A [ - 1 ] <eos>
1339
src = A から B を引いた値を C の長さで割った余りを A とする
trg = A = ( A - B ) % len ( C )
rst = A = ( A - B ) % len ( C ) <eos>
1340
src = C の B 番目を A の segtree の A の N から 1 を引いた値に B を加えた値番目に する
trg = A . segtree [ A . N - 1 + B ] = C [ B ]
rst = A . segtree [ A . t + 1 + B ] = C [ B ] <eos>
1341
src = push ( ( A , B +1,1) )
trg = push ( ( A , B + 1 , 1 ) )
rst = push ( ( A , B + 1 , 1 ) <eos>
1342
src = D の primeFactorization のキーと値の集まりの各要素を A 、 C とし 、0 から C +1 未満までの数列の各要素を B とし 、 A の B 乗の列の総和の列を x 、 y をパラメータとして x に y を掛けた値を返す関数で集約した列 を返す
trg = return reduce ( lambda E , F : E * F , [ sum ( [ A ** B for B in range ( C + 1 ) ] ) for A , C in D . primeFactorization . items ( ) ] )
rst = return reduce ( [ C : C * B , C ) + [ A [ B ] for B in [ C + 1 ) for B in D . <unk> ) ] <eos>
1343
src = 未定値を A の B 番目の 0 番目に する
trg = A [ B ] [ 0 ] = None
rst = A [ B ] [ 0 ] = None <eos>
1344
src = A の total を A の ms の B 番目だけ 減 少 させ る
trg = A . total -= A . ms [ B ]
rst = A . parents -= B . ms [ B ] <eos>
1345
src = A が 4 より大きい 間 、 次 を 繰り返 す
trg = while A > 4 :
rst = while A > 4 : <eos>
1346
src = A を ソートされた順序を保ったまま C を B に挿入できる最後の位置から 、 つまり ソートされた順序を保ったまま C を B に挿入できる位置を引いた値 だけ 増 加 させ る
trg = A += bisect_right ( B , C ) - bisect_left ( B , C )
rst = A += bisect . bisect_left ( B , C ) , bisect . bisect_right ( B , C ) <eos>
1347
src = (0、1 、2、3、4、5、6、7、8、9 ) からなる列の う ち B 個までの順列 を順に A として 、 繰り返 す
trg = for A in permutations ( [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] , B ) :
rst = for A in permutations ( [ 1 , 2 , 3 , 3 , 3 , 5 ) : <eos>
1348
src = A . get _ value ( B ._ Dice __ RIGHT ) を出力する
trg = print ( A . get_value ( B . _Dice__RIGHT ) )
rst = print ( A . get_value ( B . <unk> ( ) ) <eos>
1349
src = A の E の 、 つまりネイピア数の to 番目の 、 つまりネイピア数の rev 番目の cap を B だけ 増 加 させ る
trg = A . E [ e . to ] [ e . rev ] . cap += B
rst = A . E [ e . to ] [ e . e ] . cap += B <eos>
1350
src = A を 3 で割った余りが B と等しいとき 、
trg = if A % 3 == B :
rst = if A % 3 == B : <eos>
1351
src = 0 から F 未満までの数列の各要素を E とし 、 D から読み込んだ一行を 空白で分割した字句列 の列を順に A 、 B 、 C として 、 繰り返 す
trg = for A , B , C in [ D . readline ( ) . split ( ) for E in range ( F ) ] :
rst = for A , B , C in [ [ . readline ( ) . split ( ) for E in range ( F ) ] : <eos>
1352
src = A を half _ move ( B - C ) だけ 増 加 させ る
trg = A += half_move ( B - C )
rst = A += <unk> ( B - C ) <eos>
1353
src = erase ( A ) を A とする
trg = A = erase ( A )
rst = A = fix ( A ) <eos>
1354
src = A の 0 番目が B より大きいとき 、
trg = if A [ 0 ] > B :
rst = if A [ 0 ] > B : <eos>
1355
src = A 内の A の B 番目の出現回数が 1 より大きいとき 、
trg = if A . count ( A [ B ] ) > 1 :
rst = if A . count ( A [ B ] ) > 1 : <eos>
1356
src = 空文字列を間に入れて C の 、 つまり先頭から D 番目までの部分列の各要素を B とし 、 B の文字列の列を連結した文字列を A とする
trg = A = '' . join ( [ str ( B ) for B in C [ : D ] ] )
rst = A = '' . join ( [ str ( B ) for B in C [ 0 D ] ] ) <eos>
1357
src = 0 x 0 3 F 5 66 ED 27179461 を A とする
trg = A = 0x03F566ED27179461
rst = A = <unk> ( <unk> , 3 ) <unk> , <unk> ) <eos>
1358
src = "{}:" を出力する
trg = print ( {d}: )
rst = print ( <unk> ) <eos>
1359
src = A に B を加えた値と A 、 B の最小値の コン ビ ネ ー シ ョ ンを C だけ左シフトした値を 100000007 で割った余りを出力する
trg = print ( ( comb ( A + B , min ( A , B ) ) << C ) % 100000007 )
rst = print ( A + max ( B , A ) , sep = B ) % sep = B ) <eos>
1360
src = A の B に C を加えた値番目の D に E を加えた値番目が F と等しいかどうかを返す
trg = return A [ B + C ] [ D + E ] == F
rst = return A [ B + C ] [ D + E ] == F <eos>
1361
src = ifprime ( A ) を A とする
trg = A = ifprime ( A )
rst = A = <unk> ( A ) <eos>
1362
src = A に B から 1 を引いた値を掛けた値を A とする
trg = A = A * ( B - 1 )
rst = A = A * ( B - 1 ) <eos>
1363
src = 0 、 B 、 C 、 D 、 E を追加して A を 更新 する
trg = A . update ( 0 , B , C , D , E )
rst = A . update ( 0 , B , C , D , E ) <eos>
1364
src = A の bit 1 に B 、 C に B を掛けた値 を追加した集まり
trg = A . bit1 . add ( B , C * B )
rst = A . bit1 . add ( B , C * B ) <eos>
1365
src = A の末尾に hukuri ( B , C , float ( D ) , int ( E )) を追加する
trg = A . append ( hukuri ( B , C , float ( D ) , int ( E ) ) )
rst = A . append ( <unk> ( B , C , float ( D ) , int ( E ) ) ) <eos>
1366
src = - B に C を掛けた値に D に E を掛けた値を加えた値を D から B を引いた値で割った値を A とする
trg = A = ( - B * C + D * E ) / ( D - B )
rst = A = ( - B * C + D * E ) / ( D - B ) <eos>
1367
src = 1 から B の height 未満までの数列を順に A として 、 繰り返 す
trg = for A in range ( 1 , B . height ) :
rst = for A in range ( 1 , B . height ) : <eos>
1368
src = A のとき neg ( B ) 、 そうでなければ B を返す
trg = return neg ( B ) if A else B
rst = return <unk> ( B ) if if B else B ) <eos>
1369
src = A に B を加えた値が C の D 番目の E 番目より小さいとき 、
trg = if A + B < C [ D ] [ E ] :
rst = if A + B < C [ D ] [ E ] : <eos>
1370
src = ( ( B , C )、( D , E )、( F , G )、( H , I )、( J , K )) からなる辞書を A とする
trg = A = { "T" : C , "L" : E , "U" : G , "R" : I , "D" : K }
rst = A = { 'J' : C , <unk> : E , 'E' : G , 'A' : K , <unk> : K } <eos>
1371
src = 1 に A に A に 1 を加えた値を掛けた値を 2 で割った商 を加えた値を出力する
trg = print ( 1 + A * ( A + 1 ) // 2 )
rst = print ( 1 + ( A * ( A + 1 ) // 2 ) <eos>
1372
src = A の長さが B と等しくかつ A が C に含まれないとき 、
trg = if len ( A ) == B and A not in C :
rst = if len ( A ) == B and A not in C : <eos>
1373
src = A の - B の C 番目番目が 0 と等しいとき 、
trg = if A [ - B [ C ] ] == 0 :
rst = if A [ - B [ C ] ] == 0 : <eos>
1374
src = A . isPrime ( B ) のとき 、
trg = if A . isPrime ( B ) :
rst = if A . solved ( B ) : <eos>
1375
src = A が B 以下かどうかの整数値を 返す
trg = return int ( A <= B )
rst = return A == sum ( B ( B ) <eos>
1376
src = dfs ( C ,0,0, - D , - E ) を展開し 、 それぞれ A 、 B とする
trg = A , B = dfs ( C , 0 , 0 , - D , - E )
rst = A , B = dfs ( C , 0 , - 1 , - D , - E ) <eos>
1377
src = A を書式として B で整形した文字列 に空白文字を間に入れて prime _ factor ( B ) の各要素に整数を適用した列 を連結した文字列を加えた値 を出力する
trg = print ( A . format ( B ) + ' ' . join ( map ( str , prime_factor ( B ) ) ) )
rst = print ( A . format ( B ) + ' ' . join ( map ( str ( B ) ) ) ) <eos>
1378
src = C のキーの集まりの各要素を B とし 、 B の列を A とする
trg = A = [ B for B in C . keys ( ) ]
rst = A = [ B for B in C . keys ( ) ] <eos>
1379
src = 0 から 100 未満までの数列と 0 から 100 未満までの数列の 直 積 を順に A 、 B として 、 繰り返 す
trg = for A , B in itertools . product ( range ( 100 ) , range ( 100 ) ) :
rst = for A , B in itertools ( range ( 100 ) + ( 100 - 100 ) ) : <eos>
1380
src = 0 が A 以下かどうかが 12 より小さくかつ 0 が B 以下かどうかが 12 より小さくかつ C の A 番目の B 番目が 1 と等しいとき 、
trg = if 0 <= A < 12 and 0 <= B < 12 and C [ A ] [ B ] == 1 :
rst = if 0 <= A < 12 and 0 <= B < 12 and C [ A ] [ B ] == 1 : <eos>
1381
src = A が B と等しくかつ A が C と等しくかつ A が D と等しいとき 、
trg = if A == B and A == C and A == D :
rst = if A == B and ( A == C and A == D ) : <eos>
1382
src = 0 を A の B 番目の C 番目の 1 番目に する
trg = A [ B ] [ C ] [ 1 ] = 0
rst = A [ B ] [ C ] [ 1 ] = 0 <eos>
1383
src = A をネイピア数の 2 番目だけ 増 加 させ る
trg = A += e [ 2 ]
rst = A += e [ 2 ] <eos>
1384
src = 0 から B 未満までの数列の各要素を A とし 、 、 つまり入力された文字列の整数値 の列をソートした列を time とする
trg = time = sorted ( [ int ( input ( ) ) for A in range ( B ) ] )
rst = time = sorted ( [ int ( input ( ) ) for A in range ( B ) ] ) <eos>
1385
src = A の B から 1 を引いた値番目の C 番目に 1 を加えた値を A の B 番目の C 番目に する
trg = A [ B ] [ C ] = A [ B - 1 ] [ C ] + 1
rst = A [ B ] [ C ] = A [ B - 1 ] [ C ] + 1 <eos>
1386
src = D の各要素を C とし 、 C の各要素に B の __ getitem __ を適用した列のリストの列を A とする
trg = A = [ list ( map ( B . __getitem__ , C ) ) for C in D ]
rst = A = [ list ( map ( B . __getitem__ , B ) ) C C in D ] <eos>
1387
src = A の parent の left が A と等しくないとき 、
trg = if A . parent . left is A :
rst = if A . parent . left != A : <eos>
1388
src = A の pip の 2 番目を出力する
trg = print ( A . pip [ 2 ] )
rst = print ( A . pip [ 2 ] ) <eos>
1389
src = 0 から C 未満までの数列の各要素を B とし 、 readline () を空白で分割した字句列の各要素に 整数を適用した列のリストに (1) からなる列を加えた値の列を A とする
trg = A = [ list ( map ( int , readline ( ) . split ( ) ) ) + [ 1 ] for B in range ( C ) ]
rst = A = [ [ list ( map ( int , readline ( ) . split ( ) ) ) [ 1 ] for B in range ( C ) ] <eos>
1390
src = A から読み込んだ一行 でないとき 、
trg = if not A . readline ( ) :
rst = if not A . readline ( ) : <eos>
1391
src = B を A の birth _ num に する
trg = A . birth_num = B
rst = A . birth_list = B <eos>
1392
src = A . add _ edge ( inM ( B ) , C ,1)
trg = A . add_edge ( inM ( B ) , C , 1 )
rst = A . add_edge ( outW ( B ) , C , 1 ) <eos>
1393
src = A の B 番目から C 番目までの部分列 の長さ を出力する
trg = print ( len ( A [ B : C ] ) )
rst = print ( len ( A [ B : C ] ) ) <eos>
1394
src = A の rt でないとき 、
trg = if not A . rt :
rst = if not A . rt : <eos>
1395
src = A を B で割った商を A とする
trg = A = A // B
rst = A = A // B <eos>
1396
src = x をパラメータとして ( x の imag 、 x の real ) の組を返す関数をキーとして B をソートした列を A とする
trg = A = sorted ( B , key = lambda C : ( C . imag , C . real ) )
rst = A = sorted ( B , key = lambda C : ( B . imag , C . real ) ) <eos>
1397
src = 関数 cross を a 、 b をパラメータとして 定 義 する
trg = def cross ( A , B ) : return A . real * B . imag - A . imag * B . real
rst = def cross ( A , B ) : return EQ ( A * B . x * A . x ) <eos>
1398
src = A に B の文字列を長さ 2 に な るように '0' 左 詰め した文字列を加えた値 を出力する
trg = print ( A + str ( B ) . zfill ( 2 ) )
rst = print ( A + str ( B ) + 2 ) <eos>
1399
src = A を 100 で割った値に 1 を加えた値 の B 乗を そうでなければ 、 とする
trg = else = ( A / 100 + 1 ) ** B
rst = else = A / 100 + 1 <eos>
1400
src = A の 0 番目を B の 0 番目に 1 を加えた値だけ 増 加 させ る
trg = A [ 0 ] += B [ 0 ] + 1
rst = A [ 0 ] += B [ 0 ] + 1 <eos>
1401
src = A の末尾に ( B 内の C の出現回数 、 B 内の D の出現回数 、 B 内の E の出現回数 、 B の先頭 ) の組 を追加する
trg = A . append ( ( B . count ( C ) , B . count ( D ) , B . count ( E ) , B [ 0 ] ) )
rst = A . append ( ( B . count ( C ) , B . count ( D ) , B . count ( E ) , B [ 0 ] ) ) <eos>
1402
src = preParse ( A [ B ] . right )
trg = preParse ( A [ B ] . right )
rst = preParse ( A [ B ] . right ) <eos>
1403
src = B に C を掛けた値に math . pi に D を掛けた値を 180 で割った値の正弦を掛けた値を 2 で割った値を A とする
trg = A = B * C * math . sin ( math . pi * D / 180 ) / 2
rst = A = B * C * math . sin ( pi * D / 180 ) / 2 <eos>
1404
src = A に B を加えた値が C に D を加えた値を 2 で割った値 より小さいとき 、
trg = if A + B < ( C + D ) / 2 :
rst = if A + B < ( C + D ) / 2 : <eos>
1405
src = 9999999999999999 を A とする
trg = A = 9999999999999999
rst = A = <unk> <eos>
1406
src = x をパラメータとして ( x の 1 番目 、 x の先頭 ) の組 を返す関数をキーとして逆順に B のキーと値の集まりをソートした列 を A とする
trg = A = sorted ( B . items ( ) , key = lambda C : ( C [ 1 ] , C [ 0 ] ) , reverse = True )
rst = A = sorted ( B . items ( ) , key = lambda C : ( B [ 1 ] , B [ 0 ] ) ) <eos>
1407
src = B を A の B 番目に する
trg = A [ B ] = B
rst = A [ B ] = B <eos>
1408
src = B に C を加えた値に 2 に D を掛けた値を加えた値を A とする
trg = A = B + C + 2 * D
rst = A = B + C + 2 * D <eos>
1409
src = A の 0 番目を B の lz だけ 減 少 させ る
trg = A [ 0 ] -= B . lz
rst = A [ 0 ] -= B . lz <eos>
1410
src = A を time だけ 増 加 させ る
trg = A += time
rst = A += time <eos>
1411
src = A 、 B 、 C 、 D を出力する
trg = print ( A , B , C , D )
rst = print ( A , B , C , D ) <eos>
1412
src = 0 から 10 未満までの数列の各要素を B とし 、 1 の列を A とする
trg = A = [ 1 for B in range ( 10 ) ]
rst = A = [ 1 for B in range ( 10 ) ] <eos>
1413
src = B に C のラジアンの正弦を掛けた値を A とする
trg = A = B * sin ( radians ( C ) )
rst = A = B * cos ( radians ( C ) ) <eos>
1414
src = power ( B * B % C , D //2, C ) を A とする
trg = A = power ( B * B % C , D // 2 , C )
rst = A = power ( B * B , C , D // 2 , C ) <eos>
1415
src = 0 を A の siz とする を A の last に する
trg = A . last = A . siz = 0
rst = A . A . A . A = A = 0 <eos>
1416
src = A 内の B の出現回数が 0 と等しくまたは C 内の B の出現回数が 0 と等しくないとき 、
trg = if A . count ( B ) == 0 or C . count ( B ) != 0 :
rst = if A . count ( B ) == 0 or C . count ( B ) != 0 : <eos>
1417
src = dfs ( A , B , C , D )
trg = dfs ( A , B , C , D )
rst = dfs ( A , B , C , D ) <eos>
1418
src = A の B から C を引いた値番目を ネイピア数とする
trg = e = A [ B - C ]
rst = e = A [ B - C ] <eos>
1419
src = A の st の 2 に B を掛けた値に 1 を加えた値番目 、 A の st の 2 に B を掛けた値に 2 を加えた値番目の最大値を A の st の B 番目に する
trg = A . st [ B ] = max ( A . st [ 2 * B + 1 ] , A . st [ 2 * B + 2 ] )
rst = A . st [ B ] = max ( A . st [ 2 * B + 1 ] , A . log [ 2 * B + 2 ] ) <eos>
1420
src = 0 から C 未満までの数列の各要素を B とし 、 I () を空白で分割した字句列の各要素に 整数を適用した列のリストの列を A とする
trg = A = [ list ( map ( int , I ( ) . split ( ) ) ) for B in range ( C ) ]
rst = A = [ list ( map ( int , I . split ( ) ) ) for B in range ( C ) ] <eos>
1421
src = A の -2 番目に A の末尾を掛けた値を A の -2 番目に する
trg = A [ - 2 ] = A [ - 2 ] * A [ - 1 ]
rst = A [ - 2 ] = A [ - 2 ] * A [ - 1 ] <eos>
1422
src = 0 から 4 未満までの数列の各要素を C とし 、0 から 13 未満までの数列の各要素を B とし 、 、 つまり偽の列の列 を A とする
trg = A = [ [ False for B in range ( 13 ) ] for C in range ( 4 ) ]
rst = A = [ [ False for B in range ( 13 ) ] for C in range ( 4 ) ] <eos>
1423
src = dot ( B , C ) を dot ( C , C ) で割った値を A とする
trg = A = dot ( B , C ) / dot ( C , C )
rst = A = dot ( B , C ) / dot ( C , C ) <eos>
1424
src = D の各要素を B とし 、 B の s から C を引いた値に B の w を加えた値の列を A とする
trg = A = [ B . s - C + B . w for B in D ]
rst = A = [ B . s - C + B . w for B in D ] <eos>
1425
src = selection _ sort ( A ) を展開し 、 それぞれ A 、 B とする
trg = A , B = selection_sort ( A )
rst = A , B = selection_sort ( A ) <eos>
1426
src = (1、5、 10、50、100、500) の組を A とする
trg = A = ( 1 , 5 , 10 , 50 , 100 , 500 )
rst = A = ( 1 , 5 , 4 ) <eos>
1427
src = Vector (0,- B / C ) を A の v に する
trg = A . v = Vector ( 0 , - B / C )
rst = A . v = math . format ( B / C ) <eos>
1428
src = A を B の 2 番目に -1 を掛けた値の文字列 だけ 増 加 させ る
trg = A += str ( B [ 2 ] * - 1 )
rst = A += B [ 2 ] * - 1 <eos>
1429
src = A を B . get _ weight ( C ) だけ 減 少 させ る
trg = A -= B . get_weight ( C )
rst = A -= B . get_weight ( C ) <eos>
1430
src = 3 に B を掛けた値に C を 3 で割った余りを加えた値を A とする
trg = A = 3 * B + C % 3
rst = A = 3 * B + ( C % 3 ) <eos>
1431
src = (0、 (0) からなる列 ) の組を返す
trg = return ( 0 , [ 0 ] )
rst = return ( 0 , [ 0 ] ) <eos>
1432
src = 16 進 表 記 D の 1 番目に D の 2 番目を加えた値の整数値 、 16 進 表 記 D の 3 番目に D の 4 番目を加えた値の整数値 、 16 進 表 記 D の 5 番目に D の 6 番目を加えた値の整数値を A 、 B 、 C とする
trg = A , B , C = int ( D [ 1 ] + D [ 2 ] , 16 ) , int ( D [ 3 ] + D [ 4 ] , 16 ) , int ( D [ 5 ] + D [ 6 ] , 16 )
rst = A , B , C = int ( D [ 1 ] + D [ 2 ] , int , 16 ) , int ( 16 [ 16 ] , 16 ) , 16 ) , 16 ) , 16 ) , 16 ) , 16 ) , 16 (
1433
src = 0 から 10 未満までの数列の各要素を B とし 、 、 つまり入力された文字列の整数値 の列を A とする
trg = A = [ int ( input ( ) ) for B in range ( 10 ) ]
rst = A = [ int ( input ( ) ) for B in range ( 10 ) ] <eos>
1434
src = 0 から E に 1 を加えた値未満までの数列の各要素 を C とし 、(( 、 つまり未定値 ) からなる列の 0 から D +1 未満までの数列の各要素を C とし 、 B に 1 を加えた値の列回分の列 ) からなる列の列を A とする
trg = A = [ [ [ None ] * [ ( B + 1 ) for C in range ( D + 1 ) ] ] for C in range ( E + 1 ) ]
rst = A = [ [ None ] * [ ( B + 1 ) for C in range ( D + 1 ) ] ] for C in range ( E + 1 ) ] <eos>
1435
src = A と B の C 番目 の論理積でないとき 、
trg = if not A & B [ C ] :
rst = if not ( A & B [ C ] ) : <eos>
1436
src = bst _ inorder ( A )
trg = bst_inorder ( A )
rst = bst_inorder ( A ) <eos>
1437
src = A を書式として B の bottom で整形した文字列を出力する
trg = print ( A . format ( B . bottom ) )
rst = print ( A . format ( B . bottom ) ) <eos>
1438
src = (0、1) からなる列の B が C の先頭 と等しいかどうか番目を A とする
trg = A = [ 0 , 1 ] [ B == C [ 0 ] ]
rst = A = [ 0 , 1 ] [ B == C [ 0 ] ] <eos>
1439
src = B を A の number の 1 番目に する
trg = A . number [ 1 ] = B
rst = A . number [ 1 ] = B <eos>
1440
src = A の 0 番目が B と等しくかつ A の 4 番目が B と等しくかつ A の 8 番目が B と等しいとき 、
trg = if A [ 0 ] == B and A [ 4 ] == B and A [ 8 ] == B :
rst = if A [ 0 ] == B and A [ 4 ] == B and A [ 8 ] == B : <eos>
1441
src = A が 0 と等しくかつ B が C 以上のとき 、
trg = if A == 0 and B >= C :
rst = if A == 0 and B >= C : <eos>
1442
src = B の size を 2 で割った商を A とする
trg = A = B . size // 2
rst = A = B . size // 2 <eos>
1443
src = A の末尾に query ( B , C +1) の文字列 を追加する
trg = A . append ( str ( query ( B , C + 1 ) ) )
rst = A . append ( str ( query ( B , C + 1 ) ) ) <eos>
1444
src = A の cur の prev が 、 つまり未定値と等しくないとき 、
trg = if A . cur . prev != None :
rst = if A . cur . prev != None : <eos>
1445
src = E 、 F の要素をそれぞれ組にした列 の各要素を B 、 C とし 、 B に C を加えた値を D で割った余りの列 の 辞書 カ ウ ンタを A とする
trg = A = Counter ( ( [ ( B + C ) % D for B , C in zip ( E , F ) ] ) )
rst = A = Counter ( [ ( B + C ) % D for B , C in zip ( E , F ) ] ) <eos>
1446
src = A の data が 0 と等しいかどうかの整数値 を出力する
trg = print ( int ( A . data == 0 ) )
rst = print ( int ( A . data == 0 ) ) <eos>
1447
src = A から 1 を引いた値を 1000 で割った商に 1 を加えた値に B を掛けた値を出力する
trg = print ( ( ( A - 1 ) // 1000 + 1 ) * B )
rst = print ( ( ( A - 1 ) // 1000 + 1 ) * B ) <eos>
1448
src = A の末尾に C の各要素を B とし 、 1 を B だけ左シフトした値の列の総和を 追加する
trg = A . append ( sum ( [ 1 << B for B in C ] ) )
rst = A . append ( sum ( [ 1 << B for B in C ] ) <eos>
1449
src = A 、 check ( B , C ) の最大値を A とする
trg = A = max ( A , check ( B , C ) )
rst = A = max ( A , check ( B , C ) ) <eos>
1450
src = (0) からなる列の A の V 回分の列を A の iter に する
trg = A . iter = [ 0 ] * A . V
rst = A . iter = [ 0 ] * A . V <eos>
1451
src = D の先頭を取り出した値 を展開し 、 それぞれ A 、 B 、 C とする
trg = A , B , C = D . pop ( )
rst = A , B , C = D . pop ( ) <eos>
1452
src = chi _ liu _ edmonds ( A , B , C [ D ] ) に cycle _ cost ( E , F ) を加えた値を返す
trg = return chi_liu_edmonds ( A , B , C [ D ] ) + cycle_cost ( E , F )
rst = return <unk> ( A , B , C [ D ] ) + <unk> ( E , F ) <eos>
1453
src = A が B 以下かどうかが C 以下かつ ( D - E ) に ( C - A ) を掛けた値から ( B - A ) に ( F - E ) を掛けた値を引いた値の絶対値が 1 e -6 より小さいとき 、
trg = if A <= B <= C and abs ( ( D - E ) * ( C - A ) - ( B - A ) * ( F - E ) ) < 1e-6 :
rst = if A <= B <= C and ( D - E ) * ( C - A ) ) - ( B - A ) ) * ( - ( * - F ) < 1e-6 : <eos>
1454
src = A に 2 を掛けた値が B 以下のとき 、
trg = if A * 2 <= B :
rst = if A * 2 <= B : <eos>
1455
src = A が B より小さいとき ( A 、 B ) の組 、 そうでなければ ( B 、 A ) の組 を展開し 、 それぞれ A 、 B とする
trg = A , B = ( A , B ) if A < B else ( B , A )
rst = A , B = ( ) if A < B else ( A , B ) , A <eos>
1456
src = A ._ add _ index ( A . tail . prev )
trg = A . _add_index ( A . tail . prev )
rst = A . <unk> ( A . tail . prev ) <eos>
1457
src = B に C を加えた値に B に B を掛けた値に C に C を掛けた値を加えた値から 2* B に C を掛けた値に D の余弦を掛けた値を引いた値 の平方根を加えた値を A とする
trg = A = B + C + math . sqrt ( B * B + C * C - 2 * B * C * math . cos ( D ) )
rst = A = B + C + ( * B * C * C ) * ( B * C * math . cos ( math . cos ( D ) ) ) <eos>
1458
src = find ( A , B +1) を出力する
trg = print ( find ( A , B + 1 ) )
rst = print ( find ( A , B + 1 ) ) <eos>
1459
src = A に B を加えた値を 4 で割った余りを A とする
trg = A = ( A + B ) % 4
rst = A = ( A + B ) % 4 <eos>
1460
src = A の末尾に ( B に 1 を加えた値 、 ( C 、 D ) の組 ) の組 を追加する
trg = A . append ( ( B + 1 , ( C , D ) ) )
rst = A . append ( ( B + 1 , ( C , D ) ) <eos>
1461
src = A の 1 番目が B の 1 番目の整数値 と等しいとき 、
trg = if A [ 1 ] == int ( B [ 1 ] ) :
rst = if A [ 1 ] == int ( B [ 1 ] ) : <eos>
1462
src = (1、-1、 B に 2 を加えた値 、 - B から 2 を引いた値 ) の組を A とする
trg = A = ( 1 , - 1 , B + 2 , - B - 2 )
rst = A = ( 1 , - 1 , B + 2 , - B - 2 ) ) <eos>
1463
src = -1 を D の B 番目に する
trg = D [ B ] = - 1
rst = D [ B ] = - 1 <eos>
1464
src = (1、0、-1、0) の組を A とする
trg = A = ( 1 , 0 , - 1 , 0 )
rst = A = ( 0 , - 1 , 0 ) <eos>
1465
src = 0 から B の graph の C 番目 の長さ未満までの数列を順に A として 、 繰り返 す
trg = for A in range ( len ( B . graph [ C ] ) ) :
rst = for A in range ( len ( B . graph [ C ] ) ) : <eos>
1466
src = add ( A , B [0], - B [2]* ( B [0]-1) )
trg = add ( A , B [ 0 ] , - B [ 2 ] * ( B [ 0 ] - 1 ) )
rst = add ( A , B [ 0 ] , - B ] * ( B [ - 1 ] ) ) <eos>
1467
src = push ( A , ( B [ C -2 ] [ D -1], C -1, D ))
trg = push ( A , ( B [ C - 2 ] [ D - 1 ] , C - 1 , D ) )
rst = push ( A , ( B [ C - 2 ] - D - 1 ] , C - 1 , D ) ) <eos>
1468
src = setHight ( B , C [ D ][1]) に 1 を加えた値を A とする
trg = A = setHight ( B , C [ D ] [ 1 ] ) + 1
rst = A = setHight ( B , C [ D ] [ 1 ] ) + 1 <eos>
1469
src = _ min ( B , C , D , E ) を A とする
trg = A = _min ( B , C , D , E )
rst = A = _min ( B , C , D , E ) <eos>
1470
src = ( Piece (0) ) からなる列を A とする
trg = A = [ Piece ( 0 ) ]
rst = A = [ <unk> 0 0 , 0 ) ] <eos>
1471
src = A の B 番目を C から D を引いた値だけ 増 加 させ る
trg = A [ B ] += ( C - D )
rst = A [ B ] += C - D <eos>
1472
src = write ( A %( B [1]- 6))
trg = write ( A % ( B [ 1 ] - 6 ) )
rst = write ( A % ( B [ 1 ] - 6 ) ) <eos>
1473
src = 空文字列を間に入れて B の各要素を A とし 、 str ( A ) . rjust (4) の列を連結した文字列を出力する
trg = print ( ( '' . join ( [ str ( A ) . rjust ( 4 ) for A in B ] ) ) )
rst = print ( '' . join ( [ str ( A ) . rjust ( rjust ( ) ) for A in B ] ) ) <eos>
1474
src = ( ( B に C を加えた値 、 D ) の組 ) からなる列を A とする
trg = A = [ ( B + C , D ) ]
rst = A = [ ( B + C , D ) ] <eos>
1475
src = ((0、0) の組 、(-1、1) の組 、(0、1) の組 、(1、1) の組 、(0、2) の組 ) からなる列を A とする
trg = A = [ ( 0 , 0 ) , ( - 1 , 1 ) , ( 0 , 1 ) , ( 1 , 1 ) , ( 0 , 2 ) ]
rst = A = [ ( 0 , 0 ) , ( 1 , 1 ) , ( 1 , 1 ) , ( 1 , 0 ) , ( 1 , 0 ) ] <eos>
1476
src = 0 を開いたファイルストリーム から読み込んだ デ ータ を空白で分割した字句列の各要素に 整数を適用した列を展開し 、 それぞれ A 、 B 、 C 、 D 、 E とする
trg = A , B , C , D , E = map ( int , open ( 0 ) . read ( ) . split ( ) )
rst = A , B , C , D , E = open ( 0 ) . split ( ) . split ( ) ) <eos>
1477
src = A を B の 、 つまり先頭から A に 1 を加えた値までの部分列の最大値 だけ 増 加 させ る
trg = A += max ( B [ : A + 1 ] )
rst = A += sum ( B [ : : A + 1 ] ) <eos>
1478
src = check ( B , C ) を A とする
trg = A = check ( B , C )
rst = A = check ( B , C ) <eos>
1479
src = A を B だけ右シフトした値と 1 の論理積が 1 より小さいとき 、
trg = if ( A >> B ) & 1 < 1 :
rst = if A >> B & 1 < 1 : <eos>
1480
src = A が 0 と等しくなくかつ B から C を引いた値が 3 以上のとき 、
trg = if A != 0 and B - C >= 3 :
rst = if A != 0 and B - C >= 3 : <eos>
1481
src = B に A を加えた値を C とする
trg = C = B + A
rst = C = B + A <eos>
1482
src = A の B 番目の C 番目 、 D に E を加えた値の最小値を A の B 番目の C 番目に する
trg = A [ B ] [ C ] = min ( A [ B ] [ C ] , D + E )
rst = A [ B ] [ C ] = min ( A [ B ] [ C ] , D + E ) <eos>
1483
src = B を A の node _ id に する
trg = A . node_id = B
rst = A . left_child = B <eos>
1484
src = cross ( B - C , C - D ) を A とする
trg = A = cross ( B - C , C - D )
rst = A = cross ( B - C , C - D ) <eos>
1485
src = C の各要素を B とし 、 B の 1 番目の列の最大値を A とする
trg = A = max ( [ B [ 1 ] for B in C ] )
rst = A = max ( [ B [ 1 ] for B in C ] ) <eos>
1486
src = 空白文字を間に入れて B の 、 つまり先頭から 5 番目までの部分列の各要素を A とし 、 A の 0 番目 の列を連結した文字列を出力する
trg = print ( ' ' . join ( [ A [ 0 ] for A in B [ : 5 ] ] ) )
rst = print ( ' ' . join ( [ A [ 0 ] for A in B [ 0 : 5 ] ] ) ) <eos>
1487
src = A を 9 だけ 増 加 させ る
trg = A += 9
rst = A += 9 <eos>
1488
src = B から C を引いた値の絶対値と D の最大公約数を A とする
trg = A = gcd ( abs ( B - C ) , D )
rst = A = gcd ( B , C ) . D , D ) <eos>
1489
src = A の末尾に B の最大値 を追加する
trg = A . append ( max ( B ) )
rst = A . append ( max ( B ) ) <eos>
1490
src = (0、0) からなる列を返す
trg = return [ 0 , 0 ]
rst = return [ 0 , 0 ] <eos>
1491
src = B の 5 番目から 、 つまり末尾までの部分列の整数値を A とする
trg = A = int ( B [ 5 : ] )
rst = A = int ( B [ 5 : ] ) <eos>
1492
src = ( (1, B )、( 2 , C )、( 3 , D ) 、 (4, E )、( 5 , F )) からなる辞書を A とする
trg = A = { 1 : B , 2 : C , 3 : D , 4 : E , 5 : F }
rst = A = { 1 : B , 2 : C , 3 : D , 4 : F , F : F } <eos>
1493
src = A を書式として B . distance ( C ) で整形した文字列を出力する
trg = print ( A . format ( B . distance ( C ) ) )
rst = print ( A . format ( B . distance ( C ) ) ) <eos>
1494
src = 無限の整数列を そうでなければ 、 とする
trg = else = count
rst = else = count <eos>
1495
src = (0) からなる列に ( 2 0、19) からなる列の B を 3 で割った余りのとき 5 、 そうでなければ (0) からなる列に [ 20 ] の 10 回分の列を 加えた値回分の列を加えた値を A とする
trg = A = [ 0 ] + [ 20 , 19 ] * 5 if B % 3 else [ 0 ] + [ 20 ] * 10
rst = A = [ 0 ] + [ if [ [ 2 ] * B B [ 2 ] * B % 3 else [ B * 10 ] <eos>
1496
src = 0 から 2 の C 乗未満までの数列の各要素を B とし 、0 の列を A とする
trg = A = [ 0 for B in range ( 2 ** C ) ]
rst = A = [ 0 for B in range ( 2 ** C ) ] <eos>
1497
src = 無限の整数列 から A を引いた値に 1 を加えた値が 0 以上のとき 、
trg = if count - A + 1 >= 0 :
rst = if count - A + A >= 0 : <eos>
1498
src = A の順序数が B の順序数 以下のとき 、
trg = if ord ( A ) <= ord ( B ) :
rst = if ord ( A ) <= B ( B ) : <eos>
1499
src = A に B を掛けた値が 0 より小さくかつ C に D を掛けた値が 0 より小さいとき 、
trg = if A * B < 0 and C * D < 0 :
rst = if A * B < 0 and C * D < 0 : <eos>
1500
src = A の dist が B 以下のとき 、
trg = if A . dist <= B :
rst = if A . dist <= B : <eos>
1501
src = B の先頭の num の文字列を A とする
trg = A = str ( B [ 0 ] . num )
rst = A = str ( B [ 0 ] . pop ( ) ) <eos>
1502
src = A の末尾に B の C . to _ hash () 番目を追加する
trg = A . append ( B [ C . to_hash ( ) ] )
rst = A . append ( B [ C . <unk> ( ) ) <eos>
1503
src = dfs ( A +1, B , C , D ) のとき 、
trg = if dfs ( A + 1 , B , C , D ) :
rst = if dfs ( A + 1 , B , C , D ) : <eos>
1504
src = B に 1 を加えた値 の文字列に空白文字を加えた値に C に 1 を加えた値の文字列を加えた値を A とする
trg = A = str ( B + 1 ) + ' ' + str ( C + 1 )
rst = A = str ( B + 1 ) + str ( C + 1 ) <eos>
1505
src = 入力された文字列 を空白で分割した字句列の各要素を A とし 、 A の整数値の列を展開し 、 それぞれ A 、 B とする
trg = A , B = [ int ( A ) for A in input ( ) . split ( ) ]
rst = A , B = [ int ( A ) for A in input ( ) . split ( ) ] <eos>
1506
src = A の cur が A の nil と等しいとき 、
trg = if A . cur == A . nil :
rst = if A . cur == A . INFINITY : <eos>
1507
src = A の B 番目の C 番目の D 番目が -1 と等しくないとき 、
trg = if A [ B ] [ C ] [ D ] != - 1 :
rst = if A [ B ] [ C ] [ D ] != - 1 : <eos>
1508
src = A 、 1 の最小値を A とする
trg = A = min ( A , 1 )
rst = A = min ( A , 1 ) <eos>
1509
src = A の bgn に B を追加した集まり を返す
trg = return A . bgn . add ( B )
rst = return A . init ( B ) <eos>
1510
src = add ( '\ n ')
trg = add ( '\n' )
rst = add ( '\n' ) <eos>
1511
src = changeBoard ( A , B , C ,1)
trg = changeBoard ( A , B , C , 1 )
rst = <unk> ( A , B , C , 1 ) <eos>
1512
src = C の D 番目 を空白で分割した字句列の各要素を B とし 、 B の浮動小数点数の列を A とする
trg = A = [ float ( B ) for B in C [ D ] . split ( ) ]
rst = A = [ float ( B ) for B in C [ D ] . split ( ) ] <eos>
1513
src = A を B に 5 から A の長さを 5 で割った余り を引いた値を掛けた値だけ 増 加 させ る
trg = A += B * ( 5 - len ( A ) % 5 )
rst = A += B * ( 5 - len ( A ) % 5 ) <eos>
1514
src = C の G 番目を展開し 、 それぞれ E 、 F とする
trg = E , F = C [ G ]
rst = E , F = C [ G ] <eos>
1515
src = B の tail を A の prev の next に する
trg = A . prev . next = B . tail
rst = A . prev . next = B . tail <eos>
1516
src = B に C を加えた値に D の E 番目を加えた値を A とする
trg = A = B + C + D [ E ]
rst = A = B + C + D [ E ] <eos>
1517
src = 入力された文字列 を空白で分割した字句列の各要素に 整数を適用した列のリスト をソートした列を順に A として 、 繰り返 す
trg = for A in sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) :
rst = for A in sorted ( list ( map ( int , input ( ) . split ( ) ) ) : <eos>
1518
src = B から読み込んだ一行を 空白で分割した字句列 に ( C 、 C ) からなる列を加えた値を A とする
trg = A = B . readline ( ) . split ( ) + [ C , C ]
rst = A = B . readline ( ) . split ( C ) , C C C ] <eos>
1519
src = register ( A , B , C ,5)
trg = register ( A , B , C , 5 )
rst = register ( A , B , C , 3 ) <eos>
1520
src = A を書式として B 、 空文字列を間に入れて C を連結した文字列 で整形した文字列を出力する
trg = print ( A . format ( B , '' . join ( C ) ) )
rst = print ( A . format ( B , '' . join ( C ) ) ) <eos>
1521
src = A が A と B の論理積 と等しいとき 、
trg = if A == A & B :
rst = if A == ( A & B ) : <eos>
1522
src = A を書式として B の長さで整形した文字列 に空白文字を間に入れて B の各要素を C とし 、 C [1] の文字列の列を連結した文字列 を加えた値を出力する
trg = print ( A . format ( len ( B ) ) + ' ' . join ( [ str ( C [ 1 ] ) for C in B ] ) )
rst = print ( A . format ( B ) + ' ' . join ( [ str ( C [ C ] ) ) for C in B ] ) ) <eos>
1523
src = A の -1 番目が B と等しくまたは A の -1 番目が C と等しいとき 、
trg = if A [ - 1 ] == B or A [ - 1 ] == C :
rst = if A [ - 1 ] == B or A [ - 1 ] == C : <eos>
1524
src = in _ triangle ( A , B , C , D ) のとき E 、 そうでなければ F を出力する
trg = print ( E if in_triangle ( A , B , C , D ) else F )
rst = print ( E if <unk> ( A , B , C , D ) else F ) <eos>
1525
src = readline () を空白で分割した字句列の各要素に 整数を適用した列を展開し 、 それぞれ A 、 B 、 C とする
trg = A , B , C = map ( int , readline ( ) . split ( ) )
rst = A , B , C = map ( int , readline ( ) . split ( ) ) <eos>
1526
src = 0 から D 未満までの数列の各要素を B とし 、 A *10** ( B +1) を C で割った商を 10 で割った余り の列の総和を出力する
trg = print ( sum ( [ A * 10 ** ( B + 1 ) // C % 10 for B in range ( D ) ] ) )
rst = print ( sum ( [ A * ( B + 1 ) // C for B in range ( D ) if % % 10 ] ) ) <eos>
1527
src = bubble _ sort ( B [:]) を A とする
trg = A = bubble_sort ( B [ : ] )
rst = A = bubble_sort ( B [ : ] ) <eos>
1528
src = 入力された文字列 を空白で分割した字句列の各要素に 整数を適用した列のリストを A の face に する
trg = A . face = list ( map ( int , input ( ) . split ( ) ) )
rst = A . face = list ( map ( int , input ( ) . split ( ) ) ) <eos>
1529
src = 0 から B に 1 を加えた値から C を引いた値 、 10 の最小値 未満までの数列を順に A として 、 繰り返 す
trg = for A in range ( min ( B + 1 - C , 10 ) ) :
rst = for A in range ( min ( B + 1 - C , 10 ) ) : <eos>
1530
src = B の 、 つまり偽 と等しい要素の最初の位置を A とする
trg = A = B . index ( False )
rst = A = B . first <eos>
1531
src = B を 10 で割った商を A とする
trg = A = B // 10
rst = A = B // 10 <eos>
1532
src = B ._ flip _ colors ( A ) を A とする
trg = A = B . _flip_colors ( A )
rst = A = B . _flip_colors ( A ) <eos>
1533
src = A を書式として B で整形した文字列 に空白文字を加えた値に A を書式として C で整形した文字列 を加えた値を出力する
trg = print ( A . format ( B ) + ' ' + A . format ( C ) )
rst = print ( A . format ( B ) + ' ' + A . format ( C ) ) <eos>
1534
src = 入力された文字列を E で分割した字句列の各要素に 整数を適用した列のリストを展開し 、 それぞれ A 、 B 、 C 、 D とする
trg = A , B , C , D = list ( map ( int , input ( ) . split ( E ) ) )
rst = A , B , C , D = list ( map ( int , input ( ) . split ( E ) ) ) <eos>
1535
src = A の node の 2 に B を掛けた値に 1 を加えた値番目 、 A の node の 2 に B を掛けた値に 2 を加えた値番目の最小値を A の node の B 番目に する
trg = A . node [ B ] = min ( A . node [ 2 * B + 1 ] , A . node [ 2 * B + 2 ] )
rst = A . node [ B ] = min ( A . node [ 2 * B + 1 ] , A . node [ 2 * B + 2 ] ) <eos>
1536
src = A が B から A を引いた値 より大きいとき 、
trg = if A > B - A :
rst = if A > B - A : <eos>
1537
src = vec ( B , C ) を A とする
trg = A = vec ( B , C )
rst = A = <unk> ( B , C ) <eos>
1538
src = ( B の 1 番目の整数値に 3 を掛けた値に B の 3 番目の整数値 を加えた値 、 - C ) からなる列を A の B の先頭番目に する
trg = A [ B [ 0 ] ] = [ int ( B [ 1 ] ) * 3 + int ( B [ 3 ] ) , - C ]
rst = A [ B [ 0 ] ] = [ int ( B [ 1 ] ) * 3 + int ( B [ 3 ] ) + C , <eos>
1539
src = A の末尾に ( B に C の D 番目の先頭を加えた値 、 E に C の D 番目の 1 番目を加えた値 ) からなる列 を追加する
trg = A . append ( [ B + C [ D ] [ 0 ] , E + C [ D ] [ 1 ] ] )
rst = A . append ( [ B + C [ D ] [ 0 ] , E + C [ D ] [ 1 ] ] ) <eos>
1540
src = bomb ( A , B + C , D )
trg = bomb ( A , B + C , D )
rst = bomb ( A , B + C , D ) <eos>
1541
src = A の先頭の B 番目の末尾に ( C 、 D ) の組 を追加する
trg = A [ 0 ] [ B ] . append ( ( C , D ) )
rst = A [ 0 ] [ B ] . append ( ( C , D ) ) <eos>
1542
src = B の _ nodes の B の cur に 2 を掛けた値から 1 を引いた値番目を A とする
trg = A = B . _nodes [ B . cur * 2 - 1 ]
rst = A = B . _nodes [ B . cur * 2 - 1 ] <eos>
1543
src = B ._ red _ left ( A ) を A とする
trg = A = B . _red_left ( A )
rst = A = B . <unk> ( A ) <eos>
1544
src = B の C から 1 を引いた値番目に D を加えた値から 1 を引いた値を 7 で割った余りを A とする
trg = A = ( B [ C - 1 ] + D - 1 ) % 7
rst = A = ( B [ C - 1 ] + D - 1 ) % 7 <eos>
1545
src = topologicalSort _ w ( A )
trg = topologicalSort_w ( A )
rst = <unk> ( A ) <eos>
1546
src = A の B から 1 を引いた値番目の先頭を 削 除 する
trg = del A [ B - 1 ] [ 0 ]
rst = del A [ B - 1 ] [ 0 ] <eos>
1547
src = A の B に C を加えた値番目の D 番目のとき 、
trg = if A [ B + C ] [ D ] :
rst = if A [ B + C ] [ D ] : <eos>
1548
src = 無限の整数列の A の B 番目番目が 1 と等しくかつ A の B 番目が C 以下のとき 、
trg = if count [ A [ B ] ] == 1 and A [ B ] <= C :
rst = if count [ A [ B ] ] == 1 and A [ B ] <= C : <eos>
1549
src = B の各要素をネイピア数 とし 、 - 、 つまりネイピア数の列を A とする
trg = A = [ - e for e in B ]
rst = A = [ e for e in B ] <eos>
1550
src = A を ( B 、 C に D の B 番目を掛けた値 ) の組で割った余り を出力する
trg = print ( A % ( B , C * D [ B ] ) )
rst = print ( A % ( B , C * D [ B ] ) ) <eos>
1551
src = 0 から 31 未満までの数列の逆順 を順に A として 、 繰り返 す
trg = for A in range ( 31 ) [ : : - 1 ] :
rst = for A in range ( 31 ) [ : : - 1 ] : <eos>
1552
src = C の D 番目 、 D を A 、 B とする
trg = A , B = C [ D ] , D
rst = A , B = C [ D ] , D <eos>
1553
src = A に (4* B * B - A * A ) の .5 乗を掛けた値に 2 に B を掛けた値に ( ( B + C ) **2- B * B ) の .5 乗を掛けた値を加えた値を 4 で割った値 を出力する
trg = print ( ( A * ( 4 * B * B - A * A ) ** .5 + 2 * B * ( ( B + C ) ** 2 - B * B ) ** .5 ) / 4 )
rst = print ( A * ( ( * B * B - A * A ) * 2 + 2 * B * ( B * C + ( B * C ** 2 + ( B * B ** 2 ) ** 0.5 ) / 4 ) <eos>
1554
src = A の B 番目に 1 を加えた値を A の B に C の D 番目 を加えた値番目に する
trg = A [ B + C [ D ] ] = A [ B ] + 1
rst = A [ B + C [ D ] ] = A [ B ] + 1 <eos>
1555
src = A を 3.305785 で割った値 を出力する
trg = print ( A / 3.305785 )
rst = print ( A / 10007 ) <eos>
1556
src = 100 を A とする
trg = A = 100
rst = A = 100 <eos>
1557
src = A と B を 1 だけ左シフトした値の論理積のとき 、
trg = if A & ( B << 1 ) :
rst = if A & ( B << 1 ) : <eos>
1558
src = A から B を引いた値を D とする
trg = D = A - B
rst = D = A - B <eos>
1559
src = heappush ( A , ( e , B ))
trg = heappush ( A , ( e , B ) )
rst = heappush ( A , ( e , B ) ) <eos>
1560
src = dfs ( B [:], 4) を A とする
trg = A = dfs ( B [ : ] , 4 )
rst = A = dfs ( B , : ] ) <eos>
1561
src = ネイピア数を A の e に する
trg = A . e = e
rst = A . e = e <eos>
1562
src = 1 を A の B に 1 を加えた値番目の B 番目とするを A の B 番目の B に 1 を加えた値番目に する
trg = A [ B ] [ B + 1 ] = A [ B + 1 ] [ B ] = 1
rst = A [ B ] [ B + 1 ] = A [ B + 1 ] [ B ] = 1 <eos>
1563
src = 改行せずに A を書式として B の C を 2 で割った商 番目で整形した文字列を出力する
trg = print ( A . format ( B [ C // 2 ] ) , end = '' )
rst = print ( A . format ( B [ C // 2 ] ) , end = '' ) <eos>
1564
src = A を B の C 番目の 0 番目に B の C 番目の 2 番目を加えた値 だけ 増 加 させ る
trg = A += B [ C ] [ 0 ] + B [ C ] [ 2 ]
rst = A += B [ C ] [ 0 ] + B [ C ] [ 2 ] <eos>
1565
src = ((0、 B ) の組 ) からなる列を A とする
trg = A = [ ( 0 , B ) ]
rst = A = [ ( 0 , B ) ] <eos>
1566
src = C を D から B を引いた値 だけ右シフトした値と 1 の論理積が E の B から 1 を引いた値番目と等しいとき F 、 そうでなければ G を A の B 番目に する
trg = A [ B ] = F if ( ( C >> ( D - B ) ) & 1 ) == E [ B - 1 ] else G
rst = A [ B ] = F if C if ( D - ( B - B ) & 1 ) if ( E - B - 1 ] else G <eos>
1567
src = ((0、 B 、 C ) からなる列に (0) からなる列の 0 から E +1 未満までの数列の各要素を C とし 、 D の列回分の列を加えた値 ) からなる列を A とする
trg = A = [ [ 0 , B , C ] + [ 0 ] * [ D for C in range ( E + 1 ) ] ]
rst = A = [ [ B , C ] + [ 0 ] * [ D [ C + 1 ] for C in range ( E + E ) ] ] <eos>
1568
src = A の末尾に ( ( B , C )、( D , E )、( F , G )、( H , I )、( J , K )、( L , M )) からなる辞書を 追加する
trg = A . append ( { 'up' : C , 'front' : E , 'right' : G , 'left' : I , 'back' : K , 'bottom' : M } )
rst = A . append ( { 'J' : C , D , E , 'E' : G , 'A' : H , 'A' : K , <unk> : <eos>
1569
src = A の B の C 番目番目を 1 だけ 増 加 させ る
trg = A [ B [ C ] ] += 1
rst = A [ B [ C ] ] += 1 <eos>
1570
src = A の 1 番目 、 A の 2 番目を出力する
trg = print ( A [ 1 ] , A [ 2 ] )
rst = print ( A [ 1 ] , A [ 2 ] ) <eos>
1571
src = A に B が C 以下のとき ( B 、 C ) の組 、 そうでなければ ( C 、 B ) の組を追加した集まり
trg = A . add ( ( B , C ) if B <= C else ( C , B ) )
rst = A . add ( ( B , C ) if B < C else ( C , B ) ) <eos>
1572
src = B に 1 を加えた値 、 C から 2 を引いた値 、 D に 1 を加えた値 、 E に お いて正規表現 A が最初にマッチする位置 のとき 、
trg = if search ( A , B + 1 , C - 2 , D + 1 , E ) :
rst = if search ( A , B + 1 , C - 2 , D + 1 , E ) : <eos>
1573
src = A の B に 1 を加えた値番目でない を A の B に 1 を加えた値番目に する
trg = A [ B + 1 ] = not A [ B + 1 ]
rst = A [ B + 1 ] = pow ( A [ B + 1 ] ) <eos>
1574
src = B の C の 0 番目から C の 1 番目までの部分列を A とする
trg = A = B [ C [ 0 ] : C [ 1 ] ]
rst = A = B [ C [ 0 ] - C [ 1 ] ] <eos>
1575
src = B . preorder () を順に A として 、 繰り返 す
trg = for A in B . preorder ( ) :
rst = for A in B . preorder ( ) : <eos>
1576
src = B の末尾の総和を A とする
trg = A = sum ( B [ - 1 ] )
rst = A = list ( B . keys ( ) ) <eos>
1577
src = A の B 番目の末尾に C の D 番目を追加する
trg = A [ B ] . append ( C [ D ] )
rst = A [ B ] . append ( C [ D ] ) <eos>
1578
src = A の -1 番目が 4 と等しいとき 、
trg = if A [ - 1 ] == 4 :
rst = if A [ - 1 ] == 4 : <eos>
1579
src = 書式 B を C で フ ォ ーマットした文字列 のリストを A とする
trg = A = list ( format ( B , C ) )
rst = A = list ( format ( B , C ) ) <eos>
1580
src = ( A を B で割った余り 、 C 、 D ) の組が E に含まれるとき 、
trg = if ( A % B , C , D ) in E :
rst = if ( A % B , C , D ) in E : <eos>
1581
src = ans (* A )
trg = ans ( * A )
rst = <unk> ( * A ) <eos>
1582
src = A の B 番目の C に 1 を加えた値番目を 1 だけ 増 加 させ る
trg = A [ B ] [ C + 1 ] += 1
rst = A [ B ] [ C + 1 ] += 1 <eos>
1583
src = BinaryIndexedTree ( B ) を A の bit 1 に する
trg = A . bit1 = BinaryIndexedTree ( B )
rst = A . bit1 = BinaryIndexedTree ( B ) <eos>
1584
src = A に 3 の B 乗を加えた値を A とする
trg = A = A + 3 ** B
rst = A = A + 3 ** B <eos>
1585
src = ( A 、 B の文字列 ) からなる列が C に含まれないとき 、
trg = if [ A , str ( B ) ] not in C :
rst = if [ A , str ( B ) ] in C : <eos>
1586
src = A の末尾に文字 コ ー ド 65 に B を加えた値の文字 を追加する
trg = A . append ( chr ( 65 + B ) )
rst = A . append ( chr ( 65 + B ) ) <eos>
1587
src = 32 に入力された文字列の整数値 を掛けた値を出力する
trg = print ( 32 * int ( input ( ) ) )
rst = print ( 32 * int ( input ( ) ) ) <eos>
1588
src = B のリストを B とする
trg = B = list ( B )
rst = B = list ( B ) <eos>
1589
src = C の 0 番目に C の 1 番目を加えた値を A の B 番目に する
trg = A [ B ] = C [ 0 ] + C [ 1 ]
rst = A [ B ] = C [ 0 ] + C [ 1 ] <eos>
1590
src = A に 2 を掛けた値が B 以下かつ A に 2 を掛けた値が C 以下かつ A に 2 を掛けた値が D 以下のとき 、
trg = if A * 2 <= B and A * 2 <= C and A * 2 <= D :
rst = if A * 2 <= B and A * 2 <= C and A * 2 <= D : <eos>
1591
src = B の集合を A とする
trg = A = set ( B )
rst = A = set ( B ) <eos>
1592
src = B に対応する値 、 もし存在しなければ 1 、0 を A とする
trg = A = B . get ( 1 , 0 )
rst = A = B . get ( 1 , 0 ) <eos>
1593
src = 0 から 31 未満までの数列を順に A として 、 繰り返 す
trg = for A in range ( 31 ) :
rst = for A in range ( 31 ) : <eos>
1594
src = B の neighbor _ dict の C 番目を順に A として 、 繰り返 す
trg = for A in B . neighbor_dict [ C ] :
rst = for A in B . neighbor_dict [ C ] : <eos>
1595
src = A . operator _ func ( A . node [2* B +1], A . node [2* B +2] ) を A の node の B 番目に する
trg = A . node [ B ] = A . operator_func ( A . node [ 2 * B + 1 ] , A . node [ 2 * B + 2 ] )
rst = A . node [ B ] = A . <unk> ( A . left * B + 1 ] , A . left * B + 2 * ) <eos>
1596
src = B の C 番目に B の C に 1 を加えた値番目を加えた値を A とする
trg = A = B [ C ] + B [ C + 1 ]
rst = A = B [ C ] + B [ C + 1 ] <eos>
1597
src = A の 0 番目が A の 3 番目と等しいとき 、
trg = if A [ 0 ] == A [ 3 ] :
rst = if A [ 0 ] == A [ 3 ] : <eos>
1598
src = C と 9 に 2 の D から 1 を引いた値乗 から 1 を引いた値を掛けた値を 割った ときの ( 商を展開し 、 それぞれ A 、 B とする
trg = A , B = divmod ( C , 9 * ( 2 ** ( D - 1 ) - 1 ) )
rst = A , B = divmod ( C , 9 ) ** 2 ** ( ( D - 1 ) - 1 ) ) <eos>
1599
src = 0 から 3 未満までの数列の各要素を E とし 、 ( (0) からなる列の 0 から D 未満までの数列の各要素を C とし 、 B の列回分の列 ) からなる列の列を A とする
trg = A = [ [ [ 0 ] * [ B for C in range ( D ) ] ] for E in range ( 3 ) ]
rst = A = [ [ [ 0 ] * [ B for C in range ( D ) ] ] for E in range ( 3 ) ] <eos>
1600
src = (0、0、 B から 1 を引いた値 、 ( 、 つまり未定値 ) からなる列の C 回分の列 ) からなる列を A とする
trg = A = [ 0 , 0 , B - 1 , [ None ] * C ]
rst = A = [ [ 0 , 0 , B - 1 , None , None ] <eos>
1601
src = A の長さが 1 より大きい 間 、 次 を 繰り返 す
trg = while len ( A ) > 1 :
rst = while len ( A ) > 1 : <eos>
1602
src = A が B の x 座標 より小さいとき 、
trg = if A < B . x :
rst = if A < B . x : <eos>
1603
src = A の B 番目が A の 2 1 番目と等しくないとき 、
trg = if A [ B ] != A [ 21 ] :
rst = if A [ B ] != A [ 2 ] : <eos>
1604
src = A が B に含まれるとき 、
trg = if A in B :
rst = if A in B : <eos>
1605
src = A の B 番目が 0 と等しいとき 、
trg = if A [ B ] == 0 :
rst = if A [ B ] == 0 : <eos>
1606
src = A が B の size より小さくかつ B の _ nodes の A 番目が B の _ nodes の C 番目より大きいとき 、
trg = if A < B . size and B . _nodes [ A ] > B . _nodes [ C ] :
rst = if A < B . size and B . _nodes [ A ] != B . _nodes [ C ] : <eos>
1607
src = 入力された文字列の両端から 空白改行を取り除いた文字列を ネイピア数とする
trg = e = input ( ) . strip ( )
rst = e = input ( ) . strip ( ) <eos>
1608
src = 逆順に 0 から 10 未満までの数列の各要素を B とし 、 、 つまり入力された文字列の整数値 の列をソートした列を A とする
trg = A = sorted ( [ int ( input ( ) ) for B in range ( 10 ) ] , reverse = True )
rst = A = sorted ( [ int ( input ( ) ) for B in range ( 10 ) ] , reverse = True ) <eos>
1609
src = A の長さを 2 で割った余りが 1 と等しいとき 、
trg = if len ( A ) % 2 == 1 :
rst = if len ( A ) % 2 == 1 : <eos>
1610
src = cross ( B , ( e - C , D - E )) の絶対値を length ( B ) で割った値を A とする
trg = A = abs ( cross ( B , ( e - C , D - E ) ) ) / length ( B )
rst = A = cross ( cross ( B , ( e - C , D - E ) ) / length ( B ) <eos>
1611
src = A の末尾に B を C ( t ) ( C , e ) で割った余り を追加する
trg = A . append ( B % C(t) ( C , e ) )
rst = A . append ( B % C ) % float ( C , e ) <eos>
1612
src = A の weights の B 番目が 0 より小さいとき 、
trg = if A . weights [ B ] < 0 :
rst = if A . weights [ B ] < 0 : <eos>
1613
src = C の haystack の長さ 、 C の needle の長さを A 、 B とする
trg = A , B = len ( C . haystack ) , len ( C . needle )
rst = A , B = len ( C . haystack ) , len ( C . needle ) <eos>
1614
src = write ('' . join ( A [ B -1 : C ]))
trg = write ( '' . join ( A [ B - 1 : C ] ) )
rst = write ( '' . join ( A [ B - 1 : C ] ) ) <eos>
1615
src = A の data の B 番目の C 番目が D と等しくない 間 、 次 を 繰り返 す
trg = while A . data [ B ] [ C ] != D :
rst = while A . data [ B ] [ C ] != D : <eos>
1616
src = Johnson ( B ) を A とする
trg = A = Johnson ( B )
rst = A = <unk> ( B ) <eos>
1617
src = ( B ) からなる列の C 回分の列を A とする
trg = A = [ B ] * C
rst = A = [ B ] * C <eos>
1618
src = D の各要素を B 、 C とし 、 B の列の最大値を A とする
trg = A = max ( [ B for B , C in D ] )
rst = A = max ( [ B for B , C in D ] ) <eos>
1619
src = 0 から A の n 未満までの数列の各要素を B とし 、 、 つまり未定値の列を A の ord に する
trg = A . ord = [ None for B in range ( A . n ) ]
rst = A . ord = [ None for B in range ( A . n ) ] <eos>
1620
src = A が B の C 番目 の部分集合のとき 、
trg = if A . issubset ( B [ C ] ) :
rst = print ( A == B [ C ] ) <eos>
1621
src = (1、1) からなる列を A とする
trg = A = [ 1 , 1 ]
rst = A = [ 1 , 1 ] <eos>
1622
src = E の 、 つまり先頭から 、 つまり末尾までの F 間隔による部分列の各要素を B 、 C 、 D とし 、 B の列を A とする
trg = A = [ B for B , C , D in E [ : : F ] ]
rst = A = [ B for B , C , D in E [ : : ] ] <eos>
1623
src = A の B 番目を 1 だけ 増 加 させ る
trg = A [ B ] += 1
rst = A [ B ] += 1 <eos>
1624
src = B に 7 を掛けた値に C を加えた値を A とする
trg = A = B * 7 + C
rst = A = B * 7 + C <eos>
1625
src = A の B 番目から A の C 番目を引いた値が D より大きい 間 、 次 を 繰り返 す
trg = while A [ B ] - A [ C ] > D :
rst = while A [ B ] - A [ C ] > D : <eos>
1626
src = A の B から 1 を引いた値番目の C から 1 を引いた値 、 D から C を引いた値の最小値 番目を 1 と の排他 的 論理和に する
trg = A [ B - 1 ] [ min ( C - 1 , D - C ) ] ^= 1
rst = A [ B - 1 ] [ min ( C - 1 , D - C ) ] <eos>
1627
src = B ._ depth ( C . right ) を A とする
trg = A = B . _depth ( C . right )
rst = A = B . _depth ( C . right ) <eos>
1628
src = A に B を掛けた値に C に D を加えた値を掛けた値を E で割った商を返す
trg = return A * B * ( C + D ) // E
rst = return A * B * ( C + D ) // E <eos>
1629
src = 空白文字を間に入れて B の各要素を A とし 、 A の 0 番目 の列を連結した文字列を出力する
trg = print ( ' ' . join ( [ A [ 0 ] for A in B ] ) )
rst = print ( ' ' . join ( [ A [ 0 ] for A in B ] ) ) <eos>
1630
src = combination ( A , B ) を C で割った余りを出力する
trg = print ( combination ( A , B ) % C )
rst = print ( combination ( A , B ) % C ) <eos>
1631
src = B に B に 1 を加えた値を掛けた値を 2 で割った商から get _ sum ( B ) を引いた値を A とする
trg = A = B * ( B + 1 ) // 2 - get_sum ( B )
rst = A = B * ( B + 1 ) // 2 - <unk> ( B ) <eos>
1632
src = input (). split () の各要素に int を 適用した列のリストをソートした列 を展開してを出力する
trg = print ( * sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) )
rst = print ( * sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <eos>
1633
src = 空白文字を間に入れて A の A . index ( B ) に 1 を加えた値番目 の各要素に整数を適用した列 を連結した文字列を出力する
trg = print ( ' ' . join ( map ( str , A [ A . index ( B ) + 1 ] ) ) )
rst = print ( ' ' . join ( map ( str , A [ A . index ( B ) + 1 ] ) ) ) <eos>
1634
src = 空白文字を間に入れて B を反転した列の各要素 を A とし 、 A の文字列の列を連結した文字列 を出力する
trg = print ( ' ' . join ( [ str ( A ) for A in reversed ( B ) ] ) )
rst = print ( ' ' . join ( [ str ( A ) for A in sorted ( set ( B ) ) ] ) ) <eos>
1635
src = time が A 以下のとき 、
trg = if time <= A :
rst = if time <= A : <eos>
1636
src = A の 1 番目の B 番目のとき 、
trg = if A [ 1 ] [ B ] :
rst = if A [ 1 ] [ B ] : <eos>
1637
src = B を A の m に する
trg = A . m = B
rst = A . g = B <eos>
1638
src = A の 2 に B を掛けた値から 1 を引いた値番目 、 A の 2 に B を掛けた値番目の最小値 に C の B から 1 を引いた値番目を加えた値を A の B から 1 を引いた値番目に する
trg = A [ B - 1 ] = min ( A [ 2 * B - 1 ] , A [ 2 * B ] ) + C [ B - 1 ]
rst = A [ B - 1 ] = A [ 2 * B - 1 ] , A [ 2 + B ] + + [ C [ B - 1 ] <eos>
1639
src = A の B の C 番目番目の D の E 番目番目を 1 だけ 減 少 させ る
trg = A [ B [ C ] ] [ D [ E ] ] -= 1
rst = A [ B [ C ] ] [ D [ E ] ] -= 1 <eos>
1640
src = B を空白で分割した字句列の各要素を A とし 、 A . casefold () が C と等しいとき の 1 の列の総和を出力する
trg = print ( sum ( [ 1 for A in B . split ( ) if A . casefold ( ) == C ] ) )
rst = print ( sum ( [ 1 for A in B . split ( ) if A . split ( ) == C ] ) <eos>
1641
src = A が B と等しいとき C 、 そうでなければ D を出力する
trg = print ( C if A == B else D )
rst = print ( C if A == B else D ) <eos>
1642
src = A の B 番目の C 番目が全て数字 かつ A の B 番目の C 番目が D と等しくないとき 、
trg = if A [ B ] [ C ] . isdigit ( ) and A [ B ] [ C ] != D :
rst = if A [ B ] [ C ] . and A [ B ] [ C ] != D : <eos>
1643
src = A 、 B の 0.5 乗から 、 つまりネイピア数 を引いた値の絶対値の最小値を A とする
trg = A = min ( A , abs ( B ** 0.5 - e ) )
rst = A = min ( A , int ( B ** 0.5 ) e ) ) <eos>
1644
src = cost ( A ) を出力する
trg = print ( cost ( A ) )
rst = print ( cost ( A ) ) <eos>
1645
src = A に B を加えた値が C 以下かつ D から E に F の A + B 番目を加えた値 を引いた値が C から A に B を加えた値 を引いた値と等しくないとき 、
trg = if A + B <= C and D - ( E + F [ A + B ] ) != C - ( A + B ) :
rst = if A + B <= C and D - E * F [ A + B ] + C - A A + B ) : <eos>
1646
src = A の末尾に B から読み込んだ一行の末尾 から空白改行を取り除いた文字列 を追加する
trg = A . append ( B . readline ( ) . rstrip ( ) )
rst = A . append ( B ) . rstrip ( ) ) <eos>
1647
src = 0 から C を 4 で割った商 未満までの数列の各要素を B とし 、 、 つまり入力された文字列の整数値 の列を A とする
trg = A = [ int ( input ( ) ) for B in range ( C // 4 ) ]
rst = A = [ int ( input ( ) ) for B in range ( C // 4 ) ] <eos>
1648
src = A の整数値に 0.5 を加えた値が A 以下のとき 、
trg = if int ( A ) + 0.5 <= A :
rst = if int ( A ) + 0.5 <= A : <eos>
1649
src = A の B 番目の B に C を加えた値から D を引いた値番目を E だけ 増 加 させ る
trg = A [ B ] [ B + C - D ] += E
rst = A [ B ] [ B + C - D ] += E <eos>
1650
src = 0 、 32 を A 、 B とする
trg = A , B = 0 , 32
rst = A , B = 0 , True <eos>
1651
src = A の tree の 、 つまりネイピア数の先頭番目 の末尾に ( 、 つまりネイピア数の 1 番目 、 ネイピア数の 2 番目 ) の組 を追加する
trg = A . tree [ e [ 0 ] ] . append ( ( e [ 1 ] , e [ 2 ] ) )
rst = A . tree [ e ] ] . append ( ( e [ e ] , e [ 2 ] ) ) <eos>
1652
src = A を bisect から bisect を引いた値だけ 増 加 させ る
trg = A += bisect ( B [ C - 1 ] , D - 1 ) - bisect ( B [ C - 1 ] , E - 1 )
rst = A += bisect ( B , C , - 1 ) <eos>
1653
src = A の B の 1 番目番目が A の B の 2 番目 番目と等しいとき 、
trg = if A [ B [ 1 ] ] == A [ B [ 2 ] ] :
rst = if A [ B [ 1 ] ] == A [ B [ 2 ] ] : <eos>
1654
src = 0 から 10005 未満までの数列を順に A として 、 繰り返 す
trg = for A in range ( 10005 ) :
rst = for A in range ( <unk> ) : <eos>
1655
src = ( < __ main __ . Cammaobjectat 0 x 10 a 1 b 7 0 7 0> ) の集合から B の集合を引いた値を A とする
trg = A = { [ C for C in range ( 1 , 10 ) ] } - set ( B )
rst = A = { B B , C ) for B in range ( C ) ] , D + 1 ] ] ) <eos>
1656
src = 円周率に B を掛けた値に C を掛けた値を 180 で割った値を A とする
trg = A = pi * B * C / 180
rst = A = math . pi * B * C / 180 <eos>
1657
src = B の 0 番目に B の 4 番目を掛けた値を A とする
trg = A = B [ 0 ] * B [ 4 ]
rst = A = B [ 0 ] * B [ 4 ] <eos>
1658
src = B に対応する値 、 もし存在しなければ C を A とする
trg = A = B . get ( C )
rst = A = B . get ( C ) <eos>
1659
src = 真を A の B の 、 つまり先頭から C 番目までの部分列番目に する
trg = A [ B [ : C ] ] = True
rst = A [ B [ : C ] = True <eos>
1660
src = A を A を 50 で割った余りだけ 増 加 させ る
trg = A += A % 50
rst = A += A % 50 <eos>
1661
src = heappop ( F ) を展開し 、 それぞれ A 、 B 、 C 、 D 、 E とする
trg = A , B , C , D , E = heappop ( F )
rst = A , B , C , D , E = heappop ( F ) <eos>
1662
src = compress ( B , C ) を A とする
trg = A = compress ( B , C )
rst = A = GCD ( B , C ) <eos>
1663
src = 改行せずに空文字列 、 A の value を出力する
trg = print ( '' , A . value , end = '' )
rst = print ( '' , A . value , end = '' ) <eos>
1664
src = fix ( int ( B )* C ) を A とする
trg = A = fix ( int ( B ) * C )
rst = A = fix ( int ( B ) * C ) <eos>
1665
src = A に B . compute ( C , D , B . inf ) を加えた値を出力する
trg = print ( A + B . compute ( C , D , B . inf ) )
rst = print ( A + B . <unk> ( C , D , B . inf ) ) <eos>
1666
src = A の B から 1 を引いた値番目の 1 番目の整数値が A の B 番目の 1 番目の整数値 より大きいとき 、
trg = if int ( A [ B - 1 ] [ 1 ] ) > int ( A [ B ] [ 1 ] ) :
rst = if int ( A [ B - 1 ] [ 1 ] ) > int ( A [ B ] [ 1 ] ) : <eos>
1667
src = set _ front ( A , B ) を A とする
trg = A = set_front ( A , B )
rst = A = to_gamma ( A , B ) <eos>
1668
src = ( ( B ) からなる列の C に 2 を加えた値回分の列 ) からなる列に 0 から E 未満までの数列の各要素を D とし 、 [ B ] に list ( input ()) を加えた値に ( B ) からなる列を加えた値の列 を加えた値に ( ( B ) からなる列の C に 2 を加えた値回分の列 ) からなる列を加えた値を A とする
trg = A = [ [ B ] * ( C + 2 ) ] + [ [ B ] + list ( input ( ) ) + [ B ] for D in range ( E ) ] + [ [ B ] * ( C + 2 ) ]
rst = A = [ [ B ] * ( C + 2 ) ] + [ B ] + [ B ] for B in range ( E ) ] + [ ] + [ B ] ] + [ C ] ] + [ C + ] <eos>
1669
src = B の各要素を C とし 、 B 内の C の出現回数の列 を A とする
trg = A = [ B . count ( C ) for C in B ]
rst = A = [ B . count ( C ) for C in B ] <eos>
1670
src = mod _ pow ( A , B ) を出力する
trg = print ( mod_pow ( A , B ) )
rst = print ( <unk> ( A , B ) ) <eos>
1671
src = 文字 コ ー ド B の順序数に C を加えた値の文字を A とする
trg = A = chr ( ord ( B ) + C )
rst = A = chr ( ord ( B ) + C ) <eos>
1672
src = ( ( ネイピア数 , C に番号付した組の列の各要素を B 、 ネイピア数とし 、 B の列 )) からなる辞書を A とする
trg = A = { e : [ B for B , e in enumerate ( C ) ] }
rst = A = { name : [ B for B , e in enumerate ( C ) ] } <eos>
1673
src = is _ solved ( B +1, C ) または is _ solved ( B +1, C - D [ B ] ) を A とする
trg = A = is_solved ( B + 1 , C ) or is_solved ( B + 1 , C - D [ B ] )
rst = A = merge_sort ( B + 1 , C ) or is_possible ( B + 1 , C - D [ B ] ) <eos>
1674
src = B の v から C の長さを引いた値を A とする
trg = A = B . v - len ( C )
rst = A = B . v - len ( C ) <eos>
1675
src = B を A の degree に する
trg = A . degree = B
rst = A . degree = B <eos>
1676
src = A の B に C を加えた値番目の D に E を加えた値番目のとき 、
trg = if A [ B + C ] [ D + E ] :
rst = if A [ B + C ] [ D + E ] : <eos>
1677
src = B に C に D を加えた値を掛けた値を A とする
trg = A = B * C + D
rst = A = B * ( C + D ) <eos>
1678
src = str ( A //3600 ) に B を加えた値に A %3600//60 の文字列を加えた値に B を加えた値に A を 60 で割った余り の文字列を加えた値を出力する
trg = print ( str ( A // 3600 ) + B + str ( A % 3600 // 60 ) + B + str ( A % 60 ) )
rst = print ( str ( A ( A ) ) + + str ( B ) % str + str ( A % % ( B % % 60 ) ) <eos>
1679
src = sys の stdin の各要素をネイピア数 とし 、 range ( int ( e ) , 600 , int ( e )) の各要素を A とし 、 A **2 の列の総和に ネイピア数 の整数値を掛けた値を出力する の列
trg = [ print ( sum ( [ A ** 2 for A in range ( int ( e ) , 600 , int ( e ) ) ] ) * int ( e ) ) for e in sys . stdin ]
rst = [ print ( [ abs ( A ) 2 ) for e in [ int ( e ) for e in input ( ) ) ) for e in [ int ( e ) for e in sys . stdin ] ) ] <eos>
1680
src = B を C だけ 増 加 させ る
trg = B += C
rst = B += C <eos>
1681
src = B の先頭から 1 を引いた値 、 C から B の D から 1 を引いた値番目 を引いた値の最大値を A とする
trg = A = max ( B [ 0 ] - 1 , C - B [ D - 1 ] )
rst = A = max ( B [ 0 ] - 1 , C - B [ D - 1 ] ) <eos>
1682
src = B 、 C の各要素に A を適用した列の総和 を返す
trg = return sum ( map ( A , B , C ) )
rst = return list ( map ( A , B , C ) ) <eos>
1683
src = B の余弦を A とする
trg = A = cos ( B )
rst = A = list ( B . keys ( ) ) <eos>
1684
src = B . TopologicalSort () の逆順 を順に A として 、 繰り返 す
trg = for A in B . TopologicalSort ( ) [ : : - 1 ] :
rst = for A in B . <unk> ( ) [ : : - 1 ] : <eos>
1685
src = 0 が A に 1 を加えた値以下かどうかが B より小さくかつ 0 が C 以下かどうかが D より小さくかつ E の A に 1 を加えた値番目の C 番目が 1 と等しいとき 、
trg = if 0 <= A + 1 < B and 0 <= C < D and E [ A + 1 ] [ C ] == 1 :
rst = if 0 <= A + 1 < B and 0 <= C < D and E [ A + 1 ] [ C ] == 1 : <eos>
1686
src = B と C を展開しての 共通 部分を A とする
trg = A = B . intersection ( * C )
rst = A = tuple ( map ( int , B ) * C ) <eos>
1687
src = A の値の集まり の末尾に B を追加する
trg = A . values . append ( B )
rst = A . append . append ( B ) <eos>
1688
src = [ int ( input ()) forAinrange (4) ] をソートした列 の先頭を除いた部分列の総和に 0 から 2 未満までの数列の各要素を A とし 、 input () の整数値の列 の最大値 を加えた値を出力する
trg = print ( sum ( sorted ( [ int ( input ( ) ) for A in range ( 4 ) ] ) [ 1 : ] ) + max ( [ int ( input ( ) ) for A in range ( 2 ) ] ) )
rst = print ( sorted ( [ list ( [ int ( input ( ) ) for A in range range ( [ int ( ) ) ) for B in range range ( 1 ) ] ) [ max ( sorted ( 2 ) ] ) ) + [ max (
1689
src = 入力された文字列の整数値 、 入力された文字列の整数値 、 入力された文字列 を空白で分割した字句列の各要素に 整数を適用した列のリストを A 、 B 、 C とする
trg = A , B , C = int ( input ( ) ) , int ( input ( ) ) , list ( map ( int , input ( ) . split ( ) ) )
rst = A , B , C = int ( input ( ) ) , list ( map ( int , input ( ) . split ( ) ) ) <eos>
1690
src = B の right を A の left に する
trg = A . left = B . right
rst = A . left = B . right <eos>
1691
src = C を追加して A の B の整数値番目を 拡張 する
trg = A [ int ( B ) ] . extend ( C )
rst = A [ int ( B ) ] . update ( C ) <eos>
1692
src = A の B に C を加えた値番目を D に 0 が B に C を加えた値以下かどうかが 20 以下かどうかを掛けた値 だけ 増 加 させ る
trg = A [ B + C ] += D * ( 0 <= B + C <= 20 )
rst = A [ B + C ] += D * ( 0 <= B + C <= 20 ) <eos>
1693
src = A の p に B 、 C に B を掛けた値 を追加した集まり
trg = A . p . add ( B , C * B )
rst = A . p . add ( B , C * B ) <eos>
1694
src = B . sub ( C . bgn ) を A とする
trg = A = B . sub ( C . bgn )
rst = A = B . sub ( C . bgn ) <eos>
1695
src = 空辞書 、 空辞書を A 、 辞書 とする
trg = A , dict = { } , { }
rst = A = { True , { } <eos>
1696
src = B を A の 1 番目に する
trg = A [ 1 ] = B
rst = A [ 1 ] = B <eos>
1697
src = A から B を引いた値に C を加えた値を A とする
trg = A = A - B + C
rst = A = A - B + C <eos>
1698
src = mst _ kruskal ( A ) を出力する
trg = print ( mst_kruskal ( A ) )
rst = print ( <unk> ( A ) ) <eos>
1699
src = A の B 番目が -1 と等しくない 間 、 次 を 繰り返 す
trg = while A [ B ] != - 1 :
rst = while A [ B ] != - 1 : <eos>
1700
src = ( ( B , C の先頭に [ MASK ] を追加する )、( D , C 内の [ MASK ] と等しい要素を取り除く )、( E , C の popleft )、( F , C の先頭を取り出した値 )) からなる辞書を A とする
trg = A = { 'insert' : C . appendleft , 'delete' : C . remove , 'deleteFirst' : C . popleft , 'deleteLast' : C . pop }
rst = A = { '+' : C . add , D . add , E , C . sub , '*' : C . sub , '*' : C . <unk> : <eos>
1701
src = B の left のとき B の left 、 そうでなければ B の right を A とする
trg = A = B . left if B . left else B . right
rst = A = B . left if B . left if B . left <eos>
1702
src = 空白文字を間に入れて B をソートした列の各要素を A とし 、 A の文字列の列を連結した文字列 を出力する
trg = print ( ' ' . join ( [ str ( A ) for A in sorted ( B ) ] ) )
rst = print ( ' ' . join ( [ str ( A ) for A in sorted ( set ( B ) ) ) ) <eos>
1703
src = Poker ( B ) を A とする
trg = A = Poker ( B )
rst = A = <unk> ( B ) <eos>
1704
src = 入力された文字列 を空白で分割した字句列 の先頭を除いた部分列 の各要素に整数を適用した列を順に A として 、 繰り返 す
trg = for A in map ( int , input ( ) . split ( ) [ 1 : ] ) :
rst = for A in map ( int , input ( ) . split ( ) [ 1 : ] ) : <eos>
1705
src = A の left の right を A の left に する
trg = A . left = A . left . right
rst = A . left = A . left . right <eos>
1706
src = 改行せずに A の A の B と等しい要素の最初の位置から 3 を引いた値番目 を出力する
trg = print ( A [ A . index ( B ) - 3 ] , end = '' )
rst = print ( A [ A [ index ( B ) - 3 ] , end = '' ) <eos>
1707
src = B のラジアンの正弦を A とする
trg = A = sin ( radians ( B ) )
rst = A = list ( B . keys ( ) ) <eos>
1708
src = A . query (0, B -1, C -1) を出力する
trg = print ( A . query ( 0 , B - 1 , C - 1 ) )
rst = print ( A . query ( 0 , B - 1 , C - 1 ) ) <eos>
1709
src = 0 から C 未満までの数列の各要素を B とし 、 、 つまり空辞書の列 を A とする
trg = A = [ { } for B in range ( C ) ]
rst = A = [ { } for B in range ( C ) ] <eos>
1710
src = 入力された文字列 を空白で分割した字句列の各要素に x をパラメータとして x の整数値から 1 を引いた値を 返す関数を適用した列を展開し 、 それぞれ A 、 B とする
trg = A , B = map ( lambda C : int ( C ) - 1 , input ( ) . split ( ) )
rst = A , B = map ( lambda C : int ( ( ( ( D ) - 1 , input ( ) . split ( ) ) <eos>
1711
src = D の B から 1 を引いた値番目の 0 番目に A の B から 1 を引いた値番目の C から D の B -1 番目の 1 番目 を引いた値番目を加えた値を A の B 番目の C 番目に する
trg = A [ B ] [ C ] = D [ B - 1 ] [ 0 ] + A [ B - 1 ] [ C - D [ B - 1 ] [ 1 ] ]
rst = A [ B ] [ C ] = D [ B - 1 ] [ 0 ] + A [ B - 1 ] [ C - D [ B - 1 ] [ 1 ] <eos>
1712
src = calc ( B , C , -1,1) を A とする
trg = A = calc ( B , C , - 1 , 1 )
rst = A = calc ( B , C , <unk> ) <eos>
1713
src = C を空白で分割した字句列の各要素に 整数を適用した列を展開し 、 それぞれ A 、 B とする
trg = A , B = map ( int , C . split ( ) )
rst = A , B = map ( int , C . split ( ) ) <eos>
1714
src = A に 10 の B 乗を掛けた値を A とする
trg = A = A * ( 10 ** B )
rst = A = A * 10 ** B <eos>
1715
src = A の 1 番目が 、 つまり未定値と等しいとき 、
trg = if A [ 1 ] is not None :
rst = if A [ 1 ] == None : <eos>
1716
src = power ( A , B , C ) を出力する
trg = print ( power ( A , B , C ) )
rst = print ( power ( A , B , C ) ) <eos>
1717
src = A に B を掛けた値を time とする
trg = time = A * B
rst = time = A * B <eos>
1718
src = A に B の t を加えた値を A とする
trg = A = A + B . t
rst = A = A + B . t <eos>
1719
src = A の B 番目の C に 2 を加えた値番目が D と等しいとき 、
trg = if A [ B ] [ C + 2 ] == D :
rst = if A [ B ] [ C + 2 ] == D : <eos>
1720
src = write ( A %( get ( B )% C ))
trg = write ( A % ( get ( B ) % C ) )
rst = write ( A % ( ( B , B ) , C ) ) <eos>
1721
src = (0、 6000 、4000、3000、2000) の組を A とする
trg = A = ( 0 , 6000 , 4000 , 3000 , 2000 )
rst = A = ( 0 , 10 , 4000 , 0 ) <eos>
1722
src = A の B 番目の C に 1 を加えた値番目に D を追加した集まり
trg = A [ B ] [ C + 1 ] . add ( D )
rst = A [ B ] [ C + 1 ] . add ( D ) <eos>
1723
src = ( A の 0 番目から B の先頭を引いた値 、 A の 1 番目から B の 1 番目を引いた値 ) からなる列を返す
trg = return [ A [ 0 ] - B [ 0 ] , A [ 1 ] - B [ 1 ] ]
rst = return [ A [ 0 ] - B [ 0 ] , A [ 1 ] - B [ 1 ] ] <eos>
1724
src = A の長さが 2 以上のとき 、
trg = if len ( A ) >= 2 :
rst = if len ( A ) >= 2 : <eos>
1725
src = A の check _ stable ( B , C ) 番目を出力する
trg = print ( A [ check_stable ( B , C ) ] )
rst = print ( A [ <unk> ( B , C ) ] ) <eos>
1726
src = B の C 番目の 1 番目から 2 に D の C 番目の 1 番目を掛けた値を引いた値を A とする
trg = A = B [ C ] [ 1 ] - 2 * D [ C ] [ 1 ]
rst = A = B [ C ] [ 1 ] - 2 * D [ C ] [ 1 ] <eos>
1727
src = 1 から B から C を引いた値に 1 を加えた値に 1 を加えた値未満までの数列を順に A として 、 繰り返 す
trg = for A in range ( 1 , B - C + 1 + 1 ) :
rst = for A in range ( 1 , B - C + 1 ) + 1 ) : <eos>
1728
src = ( A の p 1 の x 座標 、 B の a に A の p 1 の x 座標を掛けた値に B の b を加えた値 ) の組を返す
trg = return ( A . p1 . x , B . a * A . p1 . x + B . b )
rst = return ( A . p1 . x , B . a + A . p1 . y + B . p1 ) <eos>
1729
src = heappush ( A , [ - B , C ] )
trg = heappush ( A , [ - B , C ] )
rst = heappush ( A , [ - B , C ] ) <eos>
1730
src = A を 5 だけ 増 加 させ る
trg = A += 5
rst = A += 5 <eos>
1731
src = A の末尾にネイピア数の先頭 を追加する
trg = A . append ( e [ 0 ] )
rst = A . append ( '\n' ) <eos>
1732
src = A の 1 番目に B を追加した集まり
trg = A [ 1 ] . add ( B )
rst = A [ 1 ] . add ( B ) <eos>
1733
src = A 、 B に C [ D ] の E 番目の F 番目の G 番目 を加えた値の最大値を A とする
trg = A = max ( A , B + C [ D ] [ E ] [ F ] [ G ] )
rst = A = max ( A , B + C [ D ] [ E ] [ F ] [ G ] ) <eos>
1734
src = A . hasNegativeCycle () のとき 、
trg = if A . hasNegativeCycle ( ) :
rst = if A . <unk> ( ) : <eos>
1735
src = B の - C 番目から 、 つまり末尾までの部分列を A とする
trg = A = B [ - C : ]
rst = A = B [ - C : ] <eos>
1736
src = B の C 番目を E とする
trg = E = B [ C ]
rst = E = B [ C ] <eos>
1737
src = A . right . is _ red () のとき 、
trg = if A . right . is_red ( ) :
rst = if A . right . is_red ( ) : <eos>
1738
src = A の末尾に C ( t ) ( B ) を追加する
trg = A . append ( C(t) ( B ) )
rst = A . append ( C(t) ( B ) ) <eos>
1739
src = D の C から 1 を引いた値番目に C に D の C 番目を掛けた値を加えた値を E で割った余りを A の B 番目の C 番目に する
trg = A [ B ] [ C ] = ( D [ C - 1 ] + C * D [ C ] ) % E
rst = A [ B ] [ C ] = D [ C - 1 ] + C * D [ C ] ) % E <eos>
1740
src = A に 2 に project ( B , A ) から A を引いた値を掛けた値を加えた値 を返す
trg = return A + 2 * ( project ( B , A ) - A )
rst = return A + 2 * ( project ( B , A ) - A ) <eos>
1741
src = A の B [ C ] の先頭から 1 を引いた値番目の B の C 番目の 1 番目から 1 を引いた値番目の B の C 番目の 2 番目から 1 を引いた値番目を B の C 番目の 3 番目だけ 増 加 させ る
trg = A [ B [ C ] [ 0 ] - 1 ] [ B [ C ] [ 1 ] - 1 ] [ B [ C ] [ 2 ] - 1 ] += B [ C ] [ 3 ]
rst = A [ B [ C ] [ 1 ] ] [ B [ C ] [ 1 ] - 1 ] [ B [ C ] [ 1 ] - B [ C ] [ 2 ] - B [ C ] [ 3 ] <eos>
1742
src = A に A に 1 を加えた値を掛けた値を 2 で割った商から B . query ( A -1) を引いた値 を出力する
trg = print ( A * ( A + 1 ) // 2 - B . query ( A - 1 ) )
rst = print ( A * ( A + 1 ) // 2 - B . query ( A - 1 ) ) <eos>
1743
src = B が C より小さいかどうかが D より小さいとき E 、 そうでなければ F を A とする
trg = A = E if B < C < D else F
rst = A = E if B < C < D else F <eos>
1744
src = A を ( B の 1 番目の 1 番目 、 B の 1 番目の 2 番目 ) の組で割った余り を出力する
trg = print ( A % ( B [ 1 ] [ 1 ] , B [ 1 ] [ 2 ] ) )
rst = print ( A % ( B [ 1 ] [ 1 ] , B [ 1 ] [ 2 ] ) ) <eos>
1745
src = ( B の INFINITY ) からなる列の C 回分の列を A の d に する
trg = A . d = [ B . INFINITY ] * C
rst = A . d = [ B . INFINITY ] * C <eos>
1746
src = A に B を掛けた値が 10010 より小さい 間 、 次 を 繰り返 す
trg = while A * B < 10010 :
rst = while A * B < <unk> : <eos>
1747
src = 1 e 9 を A とする
trg = A = 1e9
rst = A = <unk> <eos>
1748
src = ( A の pos の B 番目の先頭 、 C 、 D に E を加えた値 、 E 、 F ) の組を返す
trg = return ( A . pos [ B ] [ 0 ] , C , D + E , E , F )
rst = return ( A . pos [ B ] [ 0 ] , C , D + E , E , F ) <eos>
1749
src = sys の version の 0 番目が A と等しいとき 、
trg = if sys . version [ 0 ] == A :
rst = if sys . maxsize [ 0 ] == A : <eos>
1750
src = ( < __ main __ . Cammaobjectat 0 x 10 a 1 db 7 3 0> ) の集合を A とする
trg = A = { B }
rst = A = { [ B for B in range ( C ) ] , C ) % 26 for C % 9 + 1 ] ] ) <eos>
1751
src = B に B を掛けた値から 1000000 未満までの B 間隔の数列を順に A として 、 繰り返 す
trg = for A in range ( B * B , 1000000 , B ) :
rst = for A in range ( B * B , 1000000 , B ) : <eos>
1752
src = - B の x 座標を A とする
trg = A = - B . x
rst = A = - B . x <eos>
1753
src = 720 から B を引いた値を A とする
trg = A = 720 - B
rst = A = <unk> - B <eos>
1754
src = A の末尾に B を 30 で割った商に 1 を加えた値 を追加する
trg = A . append ( B // 30 + 1 )
rst = A . append ( B // 30 + 1 ) <eos>
1755
src = A の fct の B 番目に B に 1 を加えた値を掛けた値を C で割った余りを A の fct の B に 1 を加えた値番目に する
trg = A . fct [ B + 1 ] = A . fct [ B ] * ( B + 1 ) % C
rst = A . fct [ B + 1 ] = A . fct [ B ] * ( B + 1 ) % C <eos>
1756
src = A を B に空白文字を加えた値 だけ 増 加 させ る
trg = A += B + ' '
rst = A += B + ' <eos>
1757
src = cross ( A , B , C , D ) が E より大きいとき 、
trg = if cross ( A , B , C , D ) > E :
rst = if cross ( A , B , C , D ) > E : <eos>
1758
src = ネイピア数が A より大きいとき 、
trg = if e > A :
rst = if e > A : <eos>
1759
src = B と 10 の最大公約数を A とする
trg = A = gcd ( B , 10 )
rst = A = gcd ( B , 10 ) <eos>
1760
src = A の B の C と等しい要素の最初の位置番目を D の整数値だけ 増 加 させ る
trg = A [ B . index ( C ) ] += int ( D )
rst = A [ int ( B . index ( C ) ] += int ( D ) <eos>
1761
src = A を書式として optimal _ cost ( B , C , D ) で整形した文字列を出力する
trg = print ( A . format ( optimal_cost ( B , C , D ) ) )
rst = print ( A . format ( <unk> ( B , C , D ) ) ) <eos>
1762
src = lca ( B , C ,0, D ) を A とする
trg = A = lca ( B , C , 0 , D )
rst = A = lca ( B , C , 0 , D ) <eos>
1763
src = A の cnt を A の ord の B 番目に する
trg = A . ord [ B ] = A . cnt
rst = A . ord [ B ] = A . bot <eos>
1764
src = mean ( A ) を出力する
trg = print ( mean ( A ) )
rst = print ( birth ( A ) ) <eos>
1765
src = A が 35.5 より小さいとき 、
trg = if A < 35.5 :
rst = if A < 1912 : <eos>
1766
src = serch ( A +1)
trg = serch ( A + 1 )
rst = rec ( A + 1 ) <eos>
1767
src = A 、 dfs ( B +1, C , D ) に E から F を引いた値の絶対値に G に H を加えた値 を掛けた値を加えた値の最小値を A とする
trg = A = min ( A , dfs ( B + 1 , C , D ) + abs ( E - F ) * ( G + H ) )
rst = A = min ( A , dfs ( B + 1 , C , D ) + ( E - F ) * ( G + H ) ) <eos>
1768
src = B から C を引いた値から 1 を引いた値を A とする
trg = A = B - C - 1
rst = A = B - C - 1 <eos>
1769
src = B の 0 と等しい要素の最初の位置を A の space に する
trg = A . space = B . index ( 0 )
rst = A . space = B . pop ( 0 ) <eos>
1770
src = B を C で割った商に B を C で割った余りを加えた値を A とする
trg = A = B // C + B % C
rst = A = B // C + ( B % C ) <eos>
1771
src = collections モ ジ ュー ル を 用 い る
trg = from collections import A
rst = import A <eos>
1772
src = B の C から D を引いた値に 1 を加えた値から C に D を加えた値に 1 を加えた値までの部分列を A とする
trg = A = B [ C - D + 1 : C + D + 1 ]
rst = A = B [ C - D + 1 : C + D + 1 ] <eos>
1773
src = Vector ( B , C . vertices [ D ] ) を A とする
trg = A = Vector ( B , C . vertices [ D ] )
rst = A = Vector ( B , C . vertices [ D ] ) <eos>
1774
src = dfs ( A +1, B , C , D , E , A +1) のとき 、
trg = if dfs ( A + 1 , B , C , D , E , A + 1 ) :
rst = if dfs ( A + 1 , B , C , D , E , A + 1 ) : <eos>
1775
src = readline () を空白で分割した字句列の各要素に 整数を適用した列の組を A とする
trg = A = tuple ( map ( int , readline ( ) . split ( ) ) )
rst = A = tuple ( map ( int , readline ( ) . split ( ) ) ) <eos>
1776
src = 0 、 未定値 に お いて正規表現 0 が最初にマッチする位置 を展開し 、 それぞれ A 、 B とする
trg = A , B = search ( 0 , 0 , None )
rst = A , B = search ( 0 , None , None ) <eos>
1777
src = ( A の hldid の B 番目 、 A の hldid の B 番目に A の size の B 番目を加えた値 ) の組を返す
trg = return ( A . hldid [ B ] , A . hldid [ B ] + A . size [ B ] )
rst = return ( A . order [ B ] , A [ B [ B ] + A . size [ B ] ) <eos>
1778
src = B の 、 つまり先頭から C に D を加えた値から E を引いた値までの部分列を A とする
trg = A = B [ 0 : C + D - E ]
rst = A = B [ : C + D - E ] <eos>
1779
src = A の末尾に 1000000007 を追加する
trg = A . append ( 1000000007 )
rst = A . append ( np ) <eos>
1780
src = 未定値を A の 1 番目に する
trg = A [ 1 ] = None
rst = A [ 1 ] = None <eos>
1781
src = 4280 から 1150 に f 1 (10) を加えた値に f 2 (10) を加えた値に f 3( A -30) を加えた値 を引いた値を返す
trg = return 4280 - ( 1150 + f1 ( 10 ) + f2 ( 10 ) + f3 ( A - 30 ) )
rst = return 4280 - ( 1150 + f1 ( 10 ) + f2 ( A + + f2 ( A + 1 ) ) <eos>
1782
src = A の 2 番目を B に C の 2 番目を掛けた値だけ 減 少 させ る
trg = A [ 2 ] -= ( B * C [ 2 ] )
rst = A [ 2 ] -= B * C [ 2 ] <eos>
1783
src = swap ( A [1])
trg = swap ( A [ 1 ] )
rst = swap ( A [ 1 ] ) <eos>
1784
src = ( A の e ) からなる列の 2 に B を掛けた値回分の列を A の node に する
trg = A . node = [ A . e ] * ( 2 * B )
rst = A . node = [ A . e ] * ( 2 * B ) <eos>
1785
src = A が B の C 番目の 2 番目より大きいとき 、
trg = if A > B [ C ] [ 2 ] :
rst = if A > B [ C ] [ 2 ] : <eos>
1786
src = B を C で割った商に D を掛けた値を C で割った商に E を掛けた値を A とする
trg = A = B // C * D // C * E
rst = A = ( B // C * D // E * E <eos>
1787
src = A の par の B 番目が B と等しいとき 、
trg = if A . par [ B ] == B :
rst = if A . par [ B ] == B : <eos>
1788
src = A . pre _ order _ traversal ()
trg = A . pre_order_traversal ( )
rst = A . <unk> ( ) <eos>
1789
src = A から B の heading を引いた値を 4 で割った余りを返す
trg = return ( A - B . heading ) % 4
rst = return ( ( A - B . heading ) % 4 <eos>
1790
src = 33554393 を A とする
trg = A = 33554393
rst = A = <unk> <eos>
1791
src = A を 4 だけ左シフト する
trg = A <<= 4
rst = A <<= 4 <eos>
1792
src = 1 に B を 100 で割った値を加えた値の C 乗を A とする
trg = A = ( 1 + B / 100 ) ** C
rst = A = ( 1 ( B / 100 ) ** C <eos>
1793
src = write ( A %( B **3 - C ))
trg = write ( A % ( B ** 3 - C ) )
rst = write ( A % ( B ** 3 - C ) ) <eos>
1794
src = A の長さが B 以下の 間 、 次 を 繰り返 す
trg = while len ( A ) <= B :
rst = while len ( A ) <= B : <eos>
1795
src = A の B 番目の C と D の論理積 番目を E だけ 増 加 させ る
trg = A [ B ] [ C & D ] += E
rst = A [ B ] [ C ^ D ] += E <eos>
1796
src = B の NIL を A とする
trg = A = B . NIL
rst = A = B . NIL <eos>
1797
src = B の C 乗に対する 1000000007 の 剰 余を A とする
trg = A = pow ( B , C , 1000000007 )
rst = A = pow ( B , C , 10 ) <eos>
1798
src = bfs ( A , B , C ) を返す
trg = return bfs ( A , B , C )
rst = return bfs ( A , B , C ) <eos>
1799
src = A を B で割った余りが 0 と等しくかつ C を B で割った余りが 0 と等しい 間 、 次 を 繰り返 す
trg = while A % B == 0 and C % B == 0 :
rst = while A % B == 0 and C % B == 0 : <eos>
1800
src = GCD ( min ( A , B ) , max ( A , B )% min ( A , B )) を返す
trg = return GCD ( min ( A , B ) , max ( A , B ) % min ( A , B ) )
rst = return rec ( min ( A , B ) , max ( A , B ) , min ( A , B ) ) <eos>
1801
src = A が 1900000 以上のとき 、
trg = if A >= 1900000 :
rst = if A >= <unk> : <eos>
1802
src = B の長さから 1 を引いた値を C の長さで割った余りを A とする
trg = A = ( len ( B ) - 1 ) % len ( C )
rst = A = len ( B ) - 1 ) % len ( C ) <eos>
1803
src = A の B から 1 を引いた値番目が C 以下かつ A の B 番目が C より大きいかどうかを返す
trg = return ( A [ B - 1 ] <= C and A [ B ] > C )
rst = return A [ B - 1 ] <= C and A [ B ] > C <eos>
1804
src = A を 2 の B の C 番目 乗だけ 増 加 させ る
trg = A += 2 ** B [ C ]
rst = A += 2 ** B [ C ] <eos>
1805
src = A の B に 1 を加えた値番目が C から D を引いた値より小さい 間 、 次 を 繰り返 す
trg = while A [ B + 1 ] < C - D :
rst = while A [ B + 1 ] < C - D : <eos>
1806
src = super () .__ init __( A . x , A . y )
trg = super ( ) . __init__ ( A . x , A . y )
rst = super ( ) . __init__ ( A . x , A . y ) <eos>
1807
src = A の末尾に B の C 番目から 、 つまり末尾までの D 間隔による部分列 を追加する
trg = A . append ( B [ C : : D ] )
rst = A . append ( B [ C : : D ] ) <eos>
1808
src = 未定値を A の sink の par に する
trg = A . sink . par = None
rst = A . sink . par = None <eos>
1809
src = A の cap を B だけ 減 少 させ る
trg = A . cap -= B
rst = A . cap -= B <eos>
1810
src = A から 1 を引いた値 、0 を A 、 B とする
trg = A , B = A - 1 , 0
rst = A , B = A - 1 , 0 <eos>
1811
src = cipher ( B , C ) を A とする
trg = A = cipher ( B , C )
rst = A = <unk> ( B , C ) <eos>
1812
src = 1 を A の B に C を掛けた値番目に する
trg = A [ B * C ] = 1
rst = A [ B * C ] = 1 <eos>
1813
src = C を D で割った値 、 D を A 、 B とする
trg = A , B = C / D , D
rst = A , B = C / D , D <eos>
1814
src = 0 から 5 未満までの数列の各要素を A とし 、 40 、 int ( input ()) の最大値の列の総和を 5 で割った商 を出力する
trg = print ( sum ( [ max ( 40 , int ( input ( ) ) ) for A in range ( 5 ) ] ) // 5 )
rst = print ( sum ( [ max ( int , input ( ) ) ) for A in range ( 5 ) ] ) // 5 ) <eos>
1815
src = pop () を展開し 、 それぞれ A 、 B とする
trg = A , B = pop ( )
rst = A , B = pop ( ) <eos>
1816
src = A 内の B を空文字列で置き換えた文字列内の C を空文字列で置き換えた文字列を A とする
trg = A = A . replace ( B , '' ) . replace ( C , '' )
rst = A = A . replace ( B , B ) * C . <eos>
1817
src = C の各要素を B とし 、 A を書式として B の先頭 、 B の 1 番目 で整形した文字列の列 を展開してを出力する
trg = print ( * [ A . format ( B [ 0 ] , B [ 1 ] ) for B in C ] )
rst = print ( * A . format ( B [ 0 ] , B [ 1 ] ) for B in C ] ) <eos>
1818
src = 1013 を A とする
trg = A = 1013
rst = A = <unk> <eos>
1819
src = A を B から 10 を引いた値に 125 を掛けた値だけ 増 加 させ る
trg = A += ( B - 10 ) * 125
rst = A += ( B - 10 ) * 125 <eos>
1820
src = A が 0 と等しくまたは B の C 番目が B の D 番目以上のとき 、
trg = if A == 0 or B [ C ] >= B [ D ] :
rst = if A == 0 or B [ C ] >= B [ D ] : <eos>
1821
src = A の末尾に B の C [ D ] から 1 を引いた値を 4 で割った余りに 2 2 を加えた値番目 を追加する
trg = A . append ( B [ ( C [ D ] - 1 ) % 4 + 22 ] )
rst = A . append ( B [ ( C [ D ] - 1 ) % 4 + 2 ] ) <eos>
1822
src = B の C 番目に B の D 番目を掛けた値を A とする
trg = A = B [ C ] * B [ D ]
rst = A = B [ C ] * B [ D ] <eos>
1823
src = C の各要素を B とし 、 B の 1 番目が D と等しいとき の B の列の先頭を A とする
trg = A = [ B for B in C if B [ 1 ] == D ] [ 0 ]
rst = A = [ B for B in C if B [ 1 ] == D ] <eos>
1824
src = B に C を掛けた値に D を加えた値を E で割った余りを A の B 番目に する
trg = A [ B ] = ( B * C + D ) % E
rst = A [ B ] = ( B * C + D ) % E <eos>
1825
src = os . path の末尾に 0 を追加する
trg = path . append ( 0 )
rst = path . append ( 0 ) <eos>
1826
src = x をパラメータとして x の 1 番目を返す関数をキーとして C のキーと値の集まりをソートした列 の逆順 を順に A 、 B として 、 繰り返 す
trg = for A , B in sorted ( C . items ( ) , key = lambda D : D [ 1 ] ) [ : : - 1 ] :
rst = for A , B in sorted ( C . items ( ) , key = lambda D : D [ 1 ] ) [ : : - 1 ] : <eos>
1827
src = A の B の 1 番目の整数値番目を 1 だけ 増 加 させ る
trg = A [ int ( B [ 1 ] ) ] += 1
rst = A [ B [ 1 ] += 1 ] += 1 <eos>
1828
src = D の B 番目の C 番目に A の B から 1 を引いた値番目の C 番目 、 A の B 番目の C から 1 を引いた値番目の最小値 を加えた値を A の B 番目の C 番目に する
trg = A [ B ] [ C ] = D [ B ] [ C ] + min ( A [ B - 1 ] [ C ] , A [ B ] [ C - 1 ] )
rst = A [ B ] [ C ] = min ( D [ B ] [ C ] + A [ B - 1 ] [ C ] , A [ B ] [ C - 1 ] ) <eos>
1829
src = A が 190.0 以上のとき 、
trg = if A >= 190.0 :
rst = if A >= <unk> : <eos>
1830
src = 空白文字を間に入れて A をソートした列を連結した文字列 を出力する
trg = print ( ' ' . join ( sorted ( A ) ) )
rst = print ( ' ' . join ( sorted ( A ) ) ) <eos>
1831
src = A の末尾に ( f ( B , C ,0) に D を E で割った値を加えた値 、 B 、 C 、 D 、 E ) の組 を追加する
trg = A . append ( ( f ( B , C , 0 ) + D / E , B , C , D , E ) )
rst = A . append ( ( ( B , C , 0 ) + D , E , B , E , ( , , E ) ) <eos>
1832
src = A 内の B の出現回数が 1 と等しい 間 、 次 を 繰り返 す
trg = while A . count ( B ) == 1 :
rst = while A . count ( B ) == 1 : <eos>
1833
src = B を A の 、 つまりネイピア数番目に する
trg = A [ e ] = B
rst = A [ e ] = B <eos>
1834
src = ((-2、0) からなる列 、(-1、-1) からなる列 、(-1、0) からなる列 、(-1、1) からなる列 、(0、-2) からなる列 、(0、-1) からなる列 、(0、0) からなる列 、(0、1) からなる列 、(0、2) からなる列 、(1、-1) からなる列 、(1、0) からなる列 、(1、1) からなる列 、(2、0) からなる列 ) からなる列を A とする
trg = A = [ [ - 2 , 0 ] , [ - 1 , - 1 ] , [ - 1 , 0 ] , [ - 1 , 1 ] , [ 0 , - 2 ] , [ 0 , - 1 ] , [ 0 , 0 ] , [ 0 , 1 ] , [ 0 , 2 ] , [ 1 , - 1 ] , [ 1 , 0 ] , [ 1 ,
rst = A = [ [ 0 , 1 ] , [ - 1 , , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , 0 ] , [ 0 , - 1 ] , [ 0 , 1 ] , [
1835
src = 2000 に B を掛けた値を A とする
trg = A = 2000 * B
rst = A = 2000 * B <eos>
1836
src = A の 2 番目が 1 と等しいとき 、
trg = if A [ 2 ] == 1 :
rst = if A [ 2 ] == 1 : <eos>
1837
src = B の list を順に A として 、 繰り返 す
trg = for A in B . list :
rst = for A in B . list : <eos>
1838
src = A が 160.0 より小さいとき 、
trg = if A < 160.0 :
rst = if A < < 3 ) : <eos>
1839
src = A の B 番目かつ C に B を加えた値が 20 以下のとき 、
trg = if A [ B ] and C + B <= 20 :
rst = if A [ B ] and C + B <= 20 : <eos>
1840
src = A の逆順を A とする
trg = A = A [ : : - 1 ]
rst = A = A [ : : - 1 ] <eos>
1841
src = A を B の 階 乗を C の 階 乗で割った値を B から C を引いた値の 階 乗で割った値 だけ 増 加 させ る
trg = A += math . factorial ( B ) / math . factorial ( C ) / math . factorial ( B - C )
rst = A += factorial ( math . factorial ( B ) . factorial ( C ) ) ( B - C ) <eos>
1842
src = A の末尾に ( B の先頭に 1 を加えた値 、 B の 1 番目 ) の組 を追加する
trg = A . append ( ( B [ 0 ] + 1 , B [ 1 ] ) )
rst = A . append ( ( B [ 0 ] + 1 , B [ 1 ] ) ) <eos>
1843
src = A の 3 番目を A の 4 番目に する
trg = A [ 4 ] = A [ 3 ]
rst = A [ 4 ] = A [ 3 ] <eos>
1844
src = 0 から D の n 未満までの数列の各要素を C とし 、 B の列を A とする
trg = A = [ B for C in range ( D . n ) ]
rst = A = [ B for C in range ( D . n ) ] <eos>
1845
src = A の B 番目を C の絶対値だけ 減 少 させ る
trg = A [ B ] -= abs ( C )
rst = A [ B ] -= abs ( C ) <eos>
1846
src = A 、 time を出力する
trg = print ( A , time )
rst = print ( A , time ) <eos>
1847
src = 0 から 15 未満までの数列の各要素を C とし 、0 から 15 未満までの数列の各要素を B とし 、0 の列の列を A とする
trg = A = [ [ 0 for B in range ( 15 ) ] for C in range ( 15 ) ]
rst = A = [ [ 0 for B in range ( 15 ) ] for C in range ( 15 ) ] <eos>
1848
src = A の top が A の S の長さから 1 を引いた値以上かどうか を返す
trg = return A . top >= len ( A . S ) - 1
rst = return A . top ( len ( A . S ) - 1 <eos>
1849
src = A の 1 番目でないとき 、
trg = if not A [ 1 ] :
rst = if not A [ 1 ] : <eos>
1850
src = A の 、 つまりネイピア数番目が B より小さいとき 、
trg = if A [ e ] < B :
rst = if A [ e ] < B : <eos>
1851
src = A の B の先頭から B の 1 番目までの部分列内の B の 2 番目の出現回数 を出力する
trg = print ( A [ B [ 0 ] : B [ 1 ] ] . count ( B [ 2 ] ) )
rst = print ( A [ B [ 0 ] - B [ 1 ] ) ] ( B [ 2 ] ) ) <eos>
1852
src = A が (-1、0) の組と等しいとき 、
trg = if A == ( - 1 , 0 ) :
rst = if A == ( 0 , - 1 ) : <eos>
1853
src = (0) からなる列の B から 1 を引いた値を 2 で割った商 回分の列を A とする
trg = A = [ 0 ] * ( ( B - 1 ) // 2 )
rst = A = [ 0 ] * ( B - 1 ) // 2 <eos>
1854
src = A 内の B の出現回数が 0 と等しいとき 、
trg = if A . count ( B ) == 0 :
rst = if A . count ( B ) == 0 : <eos>
1855
src = Graph [ int ] ( B ) を A とする
trg = A = Graph[int] ( B )
rst = A = Graph ( int ) B ) <eos>
1856
src = D のキーと値の集まりの各要素を B 、 C とし 、 Node ( char = B , value = C ) の列を A とする
trg = A = [ Node ( char = B , value = C ) for B , C in D . items ( ) ]
rst = A = [ Node ( <unk> , B , C ) for C , C in D . items ( ) ] <eos>
1857
src = F の各要素を B 、 C 、 D 、 E とし 、 ( B を C で割った値 、 D を E で割った値 ) の組の列を A とする
trg = A = [ ( B / C , D / E ) for B , C , D , E in F ]
rst = A = [ ( B / C , D / E ) for B , C , E , F ] <eos>
1858
src = 0 から 26 未満までの数列の各要素を B とし 、0 から 26 未満までの数列の各要素を A とし 、0 の列の列を os . path とする
trg = path = [ [ 0 for A in range ( 26 ) ] for B in range ( 26 ) ]
rst = path = [ [ 0 for A in range ( 26 ) ] for B in range ( 26 ) ] <eos>
1859
src = A の末尾に B から読み込んだ一行 を空白で分割した字句列の各要素に 整数を適用した列の組 を追加する
trg = A . append ( tuple ( map ( int , B . readline ( ) . split ( ) ) ) )
rst = A . append ( tuple ( map ( int , B . readline ( ) . split ( ) ) ) ) <eos>
1860
src = A の mp の B 番目の C 番目が D と等しくないとき 、
trg = if A . mp [ B ] [ C ] != D :
rst = if A . mp [ B ] [ C ] != D : <eos>
1861
src = ( A 、 os . path ) からなる列を返す
trg = return [ A , path ]
rst = return [ A , path ] <eos>
1862
src = A . query ( ( B -1)//2 , C , D ) を返す
trg = return A . query ( ( B - 1 ) // 2 , C , D )
rst = return A . query ( ( B - 1 ) // 2 , C , D ) <eos>
1863
src = A が 、 つまり未定値と等しくかつ 0 が A 以下かどうかが B より小さいとき 、
trg = if A is not None and 0 <= A < B :
rst = if A is not None and A < B < <eos>
1864
src = A を 1 を B から 1 を引いた値 だけ左シフトした値との 論理和に する
trg = A |= 1 << ( B - 1 )
rst = A |= 1 << ( B - 1 ) <eos>
1865
src = A が B と等しくまたは C と 1 を B だけ左シフトした値の論理積のとき 、
trg = if A == B or C & ( 1 << B ) :
rst = if A == B or C & ( 1 << B ) : <eos>
1866
src = 入力された文字列 を空白で分割した字句列の各要素に 整数を適用した列を展開し 、 それぞれ A 、 B 、 C 、 D 、 E とする
trg = A , B , C , D , E = map ( int , input ( ) . split ( ) )
rst = A , B , C , D , E = map ( int , input ( ) . split ( ) ) <eos>
1867
src = A . delete ( A . head . next )
trg = A . delete ( A . head . next )
rst = A . delete ( A . head . next ) <eos>
1868
src = A の B 番目の 0 番目が 、 つまり未定値と等しいとき 、
trg = if A [ B ] [ 0 ] is not None :
rst = if A [ B ] [ 0 ] is not None : <eos>
1869
src = A を書式として C の各要素を B とし 、 B の整数値の列の総和 で整形した文字列を出力する
trg = print ( A . format ( sum ( [ int ( B ) for B in C ] ) ) )
rst = print ( A . format ( sum ( [ int ( B ) for B in C ] ) ) <eos>
1870
src = B . GetNodes () を A とする
trg = A = B . GetNodes ( )
rst = A = B . prim ( ) <eos>
1871
src = A . run (0, B -1) を出力する
trg = print ( A . run ( 0 , B - 1 ) )
rst = print ( A . run ( 0 , B - 1 ) ) <eos>
1872
src = 100000.0 を A とする
trg = A = 100000.0
rst = A = <unk> <eos>
1873
src = B を 2 で割った値の整数値から -1 未満までの -1 間隔の数列を順に A として 、 繰り返 す
trg = for A in range ( int ( B / 2 ) , - 1 , - 1 ) :
rst = for A in range ( B // 2 ) - 1 , - 1 ) : <eos>
1874
src = ice _ search ( A , B , C )
trg = ice_search ( A , B , C )
rst = <unk> ( A , B , C ) <eos>
1875
src = 書式 A と B の排他論理和を C で フ ォ ーマットした文字列 を出力する
trg = print ( format ( A ^ B , C ) )
rst = print ( format ( A ^ B , C ) ) <eos>
1876
src = 0 から C 未満までの数列の各要素を B とし 、 1 の列を A の sizes に する
trg = A . sizes = [ 1 for B in range ( C ) ]
rst = A . f = [ 1 for B in range ( C ) ] <eos>
1877
src = A の B 番目の先頭 が無限大のとき 、
trg = if math . isinf ( A [ B ] [ 0 ] ) :
rst = if isinf ( A [ B ] [ 0 ] ) : <eos>
1878
src = ( A 、 B 、 C と D の最大公約数 ) の組を返す
trg = return ( A , B , gcd ( C , D ) )
rst = return ( max ( A , B , C , D ) ) <eos>
1879
src = delete _ node ( A , B . key )
trg = delete_node ( A , B . key )
rst = delete_node ( A , B . key ) <eos>
1880
src = 0 から B +1 未満までの数列の各要素に A を適用した列の最小値 の平方根 を出力する
trg = print ( math . sqrt ( min ( map ( A , range ( B + 1 ) ) ) ) )
rst = print ( math . list ( map ( str , range ( B ) + ) ) ) <eos>
1881
src = magic _ square ( B ) を A とする
trg = A = magic_square ( B )
rst = A = <unk> ( B ) <eos>
1882
src = B の平方根の切り 捨 て整数値を A とする
trg = A = floor ( sqrt ( B ) )
rst = A = math . floor ( math . sqrt ( B ) ) <eos>
1883
src = B の 2 乗に C の 2 乗を加えた値に D の 2 乗を加えた値を A とする
trg = A = B ** 2 + C ** 2 + D ** 2
rst = A = B ** 2 + C ** 2 + D ** 2 <eos>
1884
src = B を 4 で割った商を A とする
trg = A = B // 4
rst = A = B // 4 <eos>
1885
src = B 、0 の最大値から C 、 D の最小値に 1 を加えた値未満までの数列を順に A として 、 繰り返 す
trg = for A in range ( max ( B , 0 ) , min ( C , D ) + 1 ) :
rst = for A in range ( max ( B , 0 ) , min ( C , D ) + 1 ) : <eos>
1886
src = 空列を A の B の長さ番目に する
trg = A [ len ( B ) ] = [ ]
rst = A [ B [ 0 ] = [ ] <eos>
1887
src = preorder _ tree _ walk ( A , A [ B ] . right _ node _ no , C )
trg = preorder_tree_walk ( A , A [ B ] . right_node_no , C )
rst = preorder_tree_walk ( A , A [ B ] . right_node_no , C ) <eos>
1888
src = A が B より大きく ないとき 、
trg = if not A > B :
rst = if A == list ( list ( B ) ) : <eos>
1889
src = A を 10 で割った余りに A を 10 で割った商を加えた値 を返す
trg = return A % 10 + A // 10
rst = return A % 10 10 + A // 10 <eos>
1890
src = A の末尾に ( B の right 、 C に D を加えた値 ) の組 を追加する
trg = A . append ( ( B . right , C + D ) )
rst = A . append ( ( B . right , C + D ) ) <eos>
1891
src = A の 、 つまり先頭から B 番目までの部分列が C の 、 つまり先頭から B 番目までの部分列 と等しくないとき 、
trg = if A [ : B ] != C [ : B ] :
rst = if A [ : B ] != C [ : B ] : <eos>
1892
src = 0 から B 未満までの数列の 、 つまり先頭から 、 つまり先頭までの -1 間隔による部分列 を順に A として 、 繰り返 す
trg = for A in range ( B ) [ : 0 : - 1 ] :
rst = for A in range ( B ) , [ : - 1 ] : <eos>
1893
src = ス ク リー ン キー ボ ー ド
trg = スクリーンキーボード
rst = <unk> ( <unk> , 0.00000000 ) <eos>
1894
src = A の length 、 A の pointer に 1 を加えた値の最小値を A の pointer に する
trg = A . pointer = min ( A . length , A . pointer + 1 )
rst = A . pointer = min ( A . length , A . pointer + 1 ) <eos>
1895
src = 0 から D 未満までの数列の各要素を B とし 、0 から C 未満までの数列の各要素を B とし 、 -1 の列の列を A とする
trg = A = [ [ - 1 for B in range ( C ) ] for B in range ( D ) ]
rst = A = [ [ - 1 for B in range ( C ) ] for B in range ( D ) ] <eos>
1896
src = A が B 以下かつ A と 1 の論理積かつ C の A 番目が 0 と等しいとき 、
trg = if A <= B and ( A & 1 ) and C [ A ] == 0 :
rst = if A <= B and A & 1 and C [ A ] == 0 : <eos>
1897
src = B の C に 1 を加えた値番目から B の C 番目を引いた値を A とする
trg = A = B [ C + 1 ] - B [ C ]
rst = A = B [ C + 1 ] - B [ C ] <eos>
1898
src = A 、 B から 1912 を引いた値に 1 を加えた値 、 C 、 D を出力する
trg = print ( A , B - 1912 + 1 , C , D )
rst = print ( A , B - 1912 + 1 , C , D ) <eos>
1899
src = 0 から D 未満までの数列の各要素を C とし 、0 から 2 未満までの数列の各要素を B とし 、 、 つまり空列 の列の列を A とする
trg = A = [ [ [ ] for B in range ( 2 ) ] for C in range ( D ) ]
rst = A = [ [ [ ] for B in range ( 2 ) ] for C in range ( D ) ] <eos>
1900
src = A . children () の各要素を B とし 、 B の height に 1 を加えた値の列の最大値を A の height に する
trg = A . height = max ( [ B . height + 1 for B in A . children ( ) ] )
rst = A . height = [ B . size + 1 for B in A . children ] <eos>
1901
src = process _ node _ data ( A )
trg = process_node_data ( A )
rst = <unk> ( A ) <eos>
1902
src = A . put ([ B , C , D +1])
trg = A . put ( [ B , C , D + 1 ] )
rst = A . put ( B , C , D + 1 ) ] <eos>
1903
src = A の mm が 10 より小さいとき 、
trg = if A . mm < 10 :
rst = if A . mm < 10 : <eos>
1904
src = A の B 番目が C から 1 を引いた値より小さいとき 、
trg = if A [ B ] < C - 1 :
rst = if A [ B ] < C - 1 : <eos>
1905
src = B . LifoQueue () を A とする
trg = A = B . LifoQueue ( )
rst = A = B . <unk> ( ) <eos>
1906
src = tax ( B , C ) に tax ( D , C ) を加えた値 、 A の最大値を A とする
trg = A = max ( tax ( B , C ) + tax ( D , C ) , A )
rst = A = max ( [ B , C ) + tax ( D , C ) , A ) <eos>
1907
src = A の B に C を加えた値番目の D に 1 を加えた値番目 、 A の B 番目の D 番目に E を加えた値の最大値を A の B に C を加えた値番目の D に 1 を加えた値番目に する
trg = A [ B + C ] [ D + 1 ] = max ( A [ B + C ] [ D + 1 ] , A [ B ] [ D ] + E )
rst = A [ B + C ] [ D + 1 ] = max ( A [ B + C ] [ D + 1 ] , A [ B ] [ D ] + E ) <eos>
1908
src = cross ( A , B , C , D ) が - E より小さいとき 、
trg = if cross ( A , B , C , D ) < - E :
rst = if cross ( A , B , C , D ) < - E : <eos>
1909
src = A . show _ status ()
trg = A . show_status ( )
rst = A . <unk> ( ) <eos>
1910
src = B の整数値から 1 を引いた値を A とする
trg = A = int ( B ) - 1
rst = A = int ( B ) - 1 <eos>
1911
src = A . d [1] != B . d [1] または A . d [2] != B . d [2] または A . d [3] が B . d [3] と等しくなくまたは A . d の 4 番目が B . d の 4 番目と等しくなくまたは A の d の 5 番目が B の d の 5 番目と等しくなくまたは A の d の 6 番目が B の d の 6 番目と等しくないとき 、
trg = if ( A . d [ 1 ] != B . d [ 1 ] or A . d [ 2 ] != B . d [ 2 ] or A . d [ 3 ] != B . d [ 3 ] or A . d [ 4 ] != B . d [ 4 ] or A . d [ 5 ] != B . d [ 5 ] or A . d [ 6 ] != B
rst = if A . d [ 1 ] != B . d [ 1 ] or A . d [ 2 ] != B . d [ 2 ] != A . d [ 2 ] != B . d [ 2 ] != A . d [ 2 ] !=
1912
src = G _ choice ( A )
trg = G_choice ( A )
rst = <unk> ( A ) <eos>
1913
src = A を dfs ( B ,1<< B , C , ( D , E ),( F , G )) だけ 増 加 させ る
trg = A += dfs ( B , 1 << B , C , ( D , E ) , ( F , G ) )
rst = A += dfs ( B << 1 , B , ( , ( D , E ) , ( F , G ) ) <eos>
1914
src = A の末尾に C の各要素を B とし 、 B の イ ミ ュー タ ブ ルな集合 の列の集合を 追加する
trg = A . append ( set ( [ frozenset ( B ) for B in C ] ) )
rst = A . append ( set ( [ [ ( [ [ [ 2 , - B ) ) for B in C ] ) <eos>
1915
src = A に B を加えた値に 360 に ( abs ( A - B ) > 180) を掛けた値を加えた値を 2 で割った値を 360 で割った余りを出力する
trg = print ( ( A + B + 360 * ( abs ( A - B ) > 180 ) ) / 2 % 360 )
rst = print ( A + B + 360 * ( abs ( A - B ) ) , * 2 ) ) % 2 ) <eos>
1916
src = ( C の B と等しい要素の最初の位置 、 D ) からなる列を A の B の整数値番目に する
trg = A [ int ( B ) ] = [ C . index ( B ) , D ]
rst = A [ int ( B ) ] = [ C . index ( B ) , D ] <eos>
1917
src = sys の stdin の buffer から読み込んだ一行を 入力された文字列 とする
trg = input = sys . stdin . buffer . readline
rst = input = sys . stdin . buffer <eos>
1918
src = A の data を 1 を B の整数値だけ左シフトした値の 補 数と の論理積 に する
trg = A . data &= ~ ( 1 << int ( B ) )
rst = A . data = pow ( A << 1 << B ) <eos>
1919
src = A の B から 1 を引いた値番目の C から 1 を引いた値番目を 1 だけ 減 少 させ る
trg = A [ B - 1 ] [ C - 1 ] -= 1
rst = A [ B - 1 ] [ C - 1 ] -= 1 <eos>
1920
src = 0 から B に 2 を掛けた値未満までの 2 間隔の数列を順に A として 、 繰り返 す
trg = for A in range ( 0 , B * 2 , 2 ) :
rst = for A in range ( 0 , B * 2 , 2 ) : <eos>
1921
src = calc _ height ( B , C ) を A とする
trg = A = calc_height ( B , C )
rst = A = calc_height ( B , C ) <eos>
1922
src = put _ queen _ in _ row (0)
trg = put_queen_in_row ( 0 )
rst = <unk> ( 0 ) <eos>
1923
src = A の末尾 の長さが 7 と等しいとき 、
trg = if len ( A [ - 1 ] ) == 7 :
rst = if len ( A [ - 1 ] ) == 7 : <eos>
1924
src = 入力された文字列を B で分割した字句列の各要素に 整数を適用した列のリストを ソートした列を A とする
trg = A = sorted ( list ( map ( int , input ( ) . split ( B ) ) ) )
rst = A = sorted ( list ( map ( int , input ( ) . split ( B ) ) ) ) <eos>
1925
src = A の B 番目が A の B に 1 を加えた値番目から 1 を引いた値より小さいとき 、
trg = if A [ B ] < A [ B + 1 ] - 1 :
rst = if A [ B ] < A [ B + 1 ] - 1 : <eos>
1926
src = A かつ A の先頭の 0 番目が B と等しい 間 、 次 を 繰り返 す
trg = while A and A [ 0 ] [ 0 ] == B :
rst = while A and A [ 0 ] [ 0 ] == B : <eos>
1927
src = A から B を引いた値が C より小さいかどうかが D から A を引いた値に B を加えた値より小さくなくまたは A から B を引いた値が E より小さいかどうかが F から A を引いた値に B を加えた値 より小さくないとき 、
trg = if not A - B < C < D - A + B or not A - B < E < F - A + B :
rst = if ( A - B < C < D - A ) + ( not - ( A < B < E < F - A ) ) : <eos>
1928
src = A の先頭を B を C で割った商に D の先頭を掛けた値だけ 減 少 させ る
trg = A [ 0 ] -= ( B // C ) * D [ 0 ]
rst = A [ 0 ] -= B // C * D [ 0 ] <eos>
1929
src = 入力された文字列 を空白で分割した字句列の各要素に G を適用した列のリストを展開し 、 それぞれ A 、 B 、 C 、 D 、 E 、 F とする
trg = A , B , C , D , E , F = list ( map ( G , input ( ) . split ( ) ) )
rst = A , B , C , D , E , F = list ( map ( int , input ( ) . split ( ) ) ) <eos>
1930
src = A が B より小さくかつ C が 0 より大きい 間 、 次 を 繰り返 す
trg = while A < B and C > 0 :
rst = while A < B and C > 0 : <eos>
1931
src = A の末尾が B と等しいとき 、
trg = if A [ - 1 ] == B :
rst = if A [ - 1 ] == B : <eos>
1932
src = C の 1 番目の 1 番目に 1 を加えた値 、 C の先頭の 1 番目を A 、 B とする
trg = A , B = C [ 1 ] [ 1 ] + 1 , C [ 0 ] [ 1 ]
rst = A , B = C [ 1 ] [ 1 ] + 1 , C [ 0 ] [ 1 ] <eos>
1933
src = A 内の ( B 、 C から 1 を引いた値 ) からなる列 と等しい要素を取り除く
trg = A . remove ( [ B , C - 1 ] )
rst = A . remove ( [ B , C - 1 ] ) <eos>
1934
src = 0 を A の length に する
trg = A . length = 0
rst = A . length = 0 <eos>
1935
src = A の先頭が B の 5 番目と等しいとき 、
trg = if A [ 0 ] == B [ 5 ] :
rst = if A [ 0 ] == B [ 5 ] : <eos>
1936
src = ネイピア数が 、 つまり未定値と等しくないとき 、
trg = if e is None :
rst = if e is None : <eos>
1937
src = A の low の B 番目 、 A の ord の C 番目の最小値を A の low の B 番目に する
trg = A . low [ B ] = min ( A . low [ B ] , A . ord [ C ] )
rst = A . low [ B ] = min ( A . low [ B ] , A . ord [ C ] ) <eos>
1938
src = 空白文字を間に入れて A を連結した文字列を出力する
trg = print ( ' ' . join ( A ) )
rst = print ( ' ' . join ( A ) ) <eos>
1939
src = extended _ gcd ( D , E ) を展開し 、 それぞれ A 、 B 、 C とする
trg = A , B , C = extended_gcd ( D , E )
rst = A , B , C = <unk> ( D , E ) <eos>
1940
src = is _ prime _ number ( A ) のとき 、
trg = if is_prime_number ( A ) :
rst = if <unk> ( A ) : <eos>
1941
src = A . construct _ lca ()
trg = A . construct_lca ( )
rst = A . <unk> ( ) <eos>
1942
src = A の B 番目が 1 と等しくなくかつ C の D 番目の B 番目が -1 と等しくなくかつ E の B 番目が C の D 番目の B 番目より大きいとき 、
trg = if A [ B ] != 1 and C [ D ] [ B ] != - 1 and E [ B ] > C [ D ] [ B ] :
rst = if A [ B ] != 1 and C [ D ] [ B ] != - 1 and E [ B ] > C [ D ] [ B ] : <eos>
1943
src = A . area () を出力する
trg = print ( A . area ( ) )
rst = print ( A . area ( ) ) <eos>
1944
src = A . set _ renew ( B , A . get _ lf ( C +1))
trg = A . set_renew ( B , A . get_lf ( C + 1 ) )
rst = A . set_range ( B , A . <unk> ( C + 1 ) ) <eos>
1945
src = ( ( B 、 C ) の組 ) からなる列を A とする
trg = A = [ ( B , C ) ]
rst = A = [ ( B , C ) ] <eos>
1946
src = D . popleft () を展開し 、 それぞれ A 、 B 、 C 、 time とする
trg = A , B , C , time = D . popleft ( )
rst = A , B , C , D = D . popleft ( ) <eos>
1947
src = 0 から 4 未満までの数列の各要素を D とし 、 ( B 、 C 、 D ) の組の列 を追加して A を 拡張 する
trg = A . extend ( [ ( B , C , D ) for D in range ( 4 ) ] )
rst = A . extend ( [ ( B , C , D ) for D in range ( 4 ) ] ) <eos>
1948
src = 間 違 い
trg = 間違い
rst = <unk> <eos>
1949
src = ( B の 1 番目を B の 3 番目で割った値の切り 上 げ 整数値 、 B の 2 番目を B の 4 番目で割った値の切り 上 げ 整数値 ) からなる列をソートした列を A とする
trg = A = sorted ( [ math . ceil ( B [ 1 ] / B [ 3 ] ) , math . ceil ( B [ 2 ] / B [ 4 ] ) ] )
rst = A = sorted ( [ ( B [ 1 ] / B [ 3 ] ) , math . ceil ( B [ 2 ] ) / B [ 4 ] ) <eos>
1950
src = A の B 番目の children の長さが 0 と等しいとき 、
trg = if len ( A [ B ] . children ) == 0 :
rst = if len ( A [ B ] . array ) == 0 : <eos>
1951
src = 空白文字を A とする
trg = A = ' '
rst = A = ' ' <eos>
1952
src = C と 10 を 割った ときの ( 商を展開し 、 それぞれ A 、 B とする
trg = A , B = divmod ( C , 10 )
rst = A , B = divmod ( C , 10 ) <eos>
1953
src = bfs ( B , C ) のキーの集まりの集合 を A とする
trg = A = set ( bfs ( B , C ) . keys ( ) )
rst = A = set ( B ( B , C ) . keys ( ) <eos>
1954
src = B の 3 番目の C 番目の D 番目の 0 番目に B の E -1 番目の F 番目の C 番目の先頭を加えた値を A とする
trg = A = B [ 3 ] [ C ] [ D ] [ 0 ] + B [ E - 1 ] [ F ] [ C ] [ 0 ]
rst = A = B [ 3 ] [ C ] [ D ] [ 0 ] + B [ E - 1 ] [ F ] [ C ] [ C ] [ 0 ] <eos>
1955
src = A の先頭の 1 番目 、 A の 1 番目の 1 番目の最大値 を返す
trg = return max ( A [ 0 ] [ 1 ] , A [ 1 ] [ 1 ] )
rst = return max ( A [ 0 ] [ 1 ] , A [ 1 ] [ 1 ] ) <eos>
1956
src = A の dist の B 番目が 、 つまり無限大と等しくないとき A の dist の B 番目 、 そうでなければ C を出力する
trg = print ( A . dist [ B ] if A . dist [ B ] != inf else C )
rst = print ( A . dist [ B ] if A . dist [ B ] != inf else C ) <eos>
1957
src = A に B に C から 2 を引いた値に A を加えた値を掛けた値を加えた値 を出力する
trg = print ( A + B * ( C - 2 ) + A )
rst = print ( A + B * ( C - 2 ) + int ( A ) ) <eos>
1958
src = 1 から 181 未満までの数列を順に A として 、 繰り返 す
trg = for A in range ( 1 , 181 ) :
rst = for A in range ( 1 , <unk> ) : <eos>
1959
src = 入力された文字列 を空白で分割した字句列の各要素に 整数を適用した列を展開し 、 それぞれ A 、 B の C 番目の先頭 、 D 、 B の C 番目の 1 番目とする
trg = A , B [ C ] [ 0 ] , D , B [ C ] [ 1 ] = map ( int , input ( ) . split ( ) )
rst = A , B [ C ] [ 0 ] , D , B [ C ] [ 1 ] = map ( int , input ( ) . split ( ) ) <eos>
1960
src = A を B に 9 を掛けた値に 10 の B から 1 を引いた値乗を掛けた値だけ 減 少 させ る
trg = A -= B * 9 * 10 ** ( B - 1 )
rst = A -= B * 9 * 10 ** ( B - 1 ) <eos>
1961
src = (0) からなる列の B に 1 を加えた値回分の列を A の rank に する
trg = A . rank = [ 0 ] * ( B + 1 )
rst = A . rank = [ 0 ] * ( B + 1 ) <eos>
1962
src = ( 、 つまり未定値 ) からなる列の B の長さ回分の列を A とする
trg = A = [ None ] * len ( B )
rst = A = [ None ] * len ( B ) <eos>
1963
src = A を書式として B 、 C に D の B 番目を掛けた値 で整形した文字列を出力する
trg = print ( A . format ( B , C * D [ B ] ) )
rst = print ( A . format ( B , C * D [ B ] ) ) <eos>
1964
src = 0 が A から B を引いた値 以下かどうかと A に B を加えた値が C 以下かどうか の論理積 を返す
trg = return ( 0 <= A - B ) & ( A + B <= C )
rst = return 0 <= ( A - B ) + list ( A + B <= C ) <eos>
1965
src = B の A の right に C 、 D を挿入する を A の right に する
trg = A . right = B . insert ( A . right , C , D )
rst = A . right = B . insert ( A . right , C , D ) <eos>
1966
src = syakkin ( A ) を出力する
trg = print ( syakkin ( A ) )
rst = print ( <unk> ( A ) ) <eos>
1967
src = A の末尾に B の C 番目の浮動小数点数 を追加する
trg = A . append ( float ( B [ C ] ) )
rst = A . append ( float ( B [ C ] ) ) <eos>
1968
src = A ._ is _ valid ( B ) かつ B の y 座標が C より小さいとき 、
trg = if A . _is_valid ( B ) and B . y < C :
rst = if A . <unk> ( B ) and B . y < C : <eos>
1969
src = diameter ( A ) を出力する
trg = print ( diameter ( A ) )
rst = print ( <unk> ( A ) ) <eos>
1970
src = create _ path ( B ) を A の _ paths の B 番目に する
trg = A . _paths [ B ] = create_path ( B )
rst = A . official_house [ B ] = <unk> ( B ) <eos>
1971
src = A が 4 と等しいとき 、
trg = if A == 4 :
rst = if A == 4 : <eos>
1972
src = A が get ( B ^ e , 17) より小さいとき 、
trg = if A < get ( B ^ e , 17 ) :
rst = if A < get ( B ^ e , A ) : <eos>
1973
src = A の B 番目でなくかつ C が 0 より大きいとき 、
trg = if not A [ B ] and C > 0 :
rst = if not A [ B ] and C > 0 : <eos>
1974
src = A 、 B の C 番目の D 番目の E 番目の最大値を A とする
trg = A = max ( A , B [ C ] [ D ] [ E ] )
rst = A = max ( A , B [ C ] [ D ] [ E ] ) <eos>
1975
src = find ( B , C +1,0,0, D ) を A とする
trg = A = find ( B , C + 1 , 0 , 0 , D )
rst = A = find ( B , C + 1 , 0 , 0 , D ) <eos>
1976
src = ( B 、 C ) からなる列の D 番目を A とする
trg = A = [ B , C ] [ D ]
rst = A = [ B , C ] [ D ] <eos>
1977
src = Dice (* B ) を A とする
trg = A = Dice ( * B )
rst = A = Dice ( * B ) <eos>
1978
src = heappush ( A , ( B , time , C , D , E ))
trg = heappush ( A , ( B , time , C , D , E ) )
rst = heappush ( A , ( B , time , C , D , E ) ) <eos>
1979
src = 0 から C 未満までの数列の各要素を B とし 、(0、 B に 1 を加えた値 ) からなる列の列を A とする
trg = A = [ [ 0 , B + 1 ] for B in range ( C ) ]
rst = A = [ [ 0 , B + 1 ] for B in range ( C ) ] <eos>
1980
src = A に B を掛けた値を calc _ gcd ( A , B ) で割った値の整数値を返す
trg = return int ( ( A * B ) / calc_gcd ( A , B ) )
rst = return int ( A * B / math ( A ( B ) ) ) <eos>
1981
src = magicall ( B ,0,0) を A とする
trg = A = magicall ( B , 0 , 0 )
rst = A = <unk> ( B , 0 ) <eos>
1982
src = print _ inorder ( A )
trg = print_inorder ( A )
rst = print_inorder ( A ) <eos>
1983
src = 0 、1、3 を A 、 B 、 C とする
trg = A , B , C = 0 , 1 , 3
rst = A , B , C = 0 , 1 <eos>
1984
src = A に B の A 番目を加えた値を C で割った余りを A とする
trg = A = ( A + B [ A ] ) % C
rst = A = ( A + B [ A ] ) % C <eos>
1985
src = A を 文字 コ ー ド ord ( B ) から ord ( C ) を引いた値に 1 を加えた値を 26 で割った余りに C の順序数を加えた値の文字 だけ 増 加 させ る
trg = A += chr ( ( ord ( B ) - ord ( C ) + 1 ) % 26 + ord ( C ) )
rst = A += chr ( ord ( B ) - ord ( C ) + 1 ) + 26 ) ord ( ord ) ) <eos>
1986
src = 入力された文字列 を空白で分割した字句列の各要素に x をパラメータとして 空文字列を間に入れて C を D で分割した字句列を連結した文字列 の整数値を返す関数を適用した列 を展開し 、 それぞれ A 、 B とする
trg = A , B = map ( lambda C : int ( '' . join ( C . split ( D ) ) ) , input ( ) . split ( ) )
rst = A , B = lambda C : ( map ( ( D % int ( D ) , input ( ) . split ( ) ) ) <eos>
1987
src = poly _ area ( A , B ) を出力する
trg = print ( poly_area ( A , B ) )
rst = print ( <unk> ( A , B ) ) <eos>
1988
src = A ._ replace ( right = _ delete ( B )) を A とする
trg = A = A . _replace ( right = _delete ( B ) )
rst = A = A . _replace ( right = _delete ( B ) ) <eos>
1989
src = A の総和が B より小さいとき 、
trg = if sum ( A ) < B :
rst = if sum ( A ) < B : <eos>
1990
src = 1000 から 、 つまり入力された文字列の整数値 を引いた値を A とする
trg = A = 1000 - int ( input ( ) )
rst = A = 1000 - int ( input ( ) ) <eos>
1991
src = C を A の B 番目の parent に する
trg = A [ B ] . parent = C
rst = A [ B ] . parent = C <eos>
1992
src = C の D 番目から 1 を引いた値 、 C の D に 1 を加えた値番目から 1 を引いた値を A 、 B とする
trg = A , B = C [ D ] - 1 , C [ D + 1 ] - 1
rst = A , B = C [ D ] - 1 , C [ D + 1 ] - 1 <eos>
1993
src = A が B に C を掛けた値から 1 を引いた値以上のとき 、
trg = if A >= B * C - 1 :
rst = if A >= B * C - 1 : <eos>
1994
src = 10 の 18 乗を A とする
trg = A = 10 ** 18
rst = A = 10 ** 18 <eos>
1995
src = B の各要素を A とし 、 A が 0 以上かどうかの列が全てが真または B の各要素を A とし 、 A が 0 以下かどうかの列が全てが真 かどうかを返す
trg = return all ( [ A >= 0 for A in B ] ) or all ( [ A <= 0 for A in B ] )
rst = return all ( [ A >= 0 for A in B ] ) all all ( [ 0 for all ( 0 <= 0 ] ) <eos>
1996
src = B の最大値から B の最小値 を引いた値の絶対値を A とする
trg = A = abs ( max ( B ) - min ( B ) )
rst = A = abs ( max ( B ) - min ( B ) ) <eos>
1997
src = Edge ( B . lt [ C ],1) を A とする
trg = A = Edge ( B . lt [ C ] , 1 )
rst = A = Edge ( B . lt [ C : ] ) <eos>
1998
src = check ( min ( C + D [ E ] , F ) , G ) を展開し 、 それぞれ A 、 B とする
trg = A , B = check ( min ( C + D [ E ] , F ) , G )
rst = A , B = check ( ) , ( C + D [ E ] , F ) , G ) <eos>
1999
src = A を B の .5 乗で割った値 の絶対値を返す
trg = return abs ( A / B ** .5 )
rst = return abs ( A / B ** .5 ) <eos>
2000
src = A の末尾にネイピア数の 2 番目を追加する
trg = A . append ( e [ 2 ] )
rst = A . append ( e [ 2 ] ) <eos>
2001
src = A が B より小さくまたは C が D より小さいとき 、
trg = if A < B or C < D :
rst = if A < B or C < D : <eos>
2002
src = A の key が B と等しくない 間 、 次 を 繰り返 す
trg = while A . key != B :
rst = while A . key != B : <eos>
2003
src = is _ intersection ( A , B , C , D ) のとき 、
trg = if is_intersection ( A , B , C , D ) :
rst = if is_intersection ( A , B , C , D ) : <eos>
2004
src = 2 に B を掛けた値から A を引いた値を A とする
trg = A = 2 * B - A
rst = A = 2 * B - A <eos>
2005
src = ( ( B の先頭 、 空文字列 ) の組 ) からなる列を A とする
trg = A = [ ( B [ 0 ] , '' ) ]
rst = A = [ ( B [ 0 ] , B ) ] <eos>
2006
src = add ( A , B + C +1,1)
trg = add ( A , B + C + 1 , 1 )
rst = add ( A , B + C + 1 , 1 ) <eos>
2007
src = A から B を引いた値が C から D を引いた値より小さいとき 、
trg = if A - B < C - D :
rst = if A - B < C - D : <eos>
2008
src = 入力された文字列 を空白で分割した字句列の各要素に 整数を適用した列を展開し 、 それぞれ A の B 番目 、 C の B 番目 、 D の B 番目とする
trg = A [ B ] , C [ B ] , D [ B ] = map ( int , input ( ) . split ( ) )
rst = A [ B ] , C [ B ] , D [ B ] = map ( int , input ( ) . split ( ) ) <eos>
2009
src = p をパラメータとして atan 2( B [1]- C , B [0]) を返す関数を key として A をソート する
trg = A . sort ( key = lambda B : atan2 ( B [ 1 ] - C , B [ 0 ] ) )
rst = A . sort ( key = lambda B : atan2 ( B [ 1 ] - C , B [ 0 ] ) ) <eos>
2010
src = B の C を 2 で割った余りのとき C を 2 で割った商 、 そうでなければ C を 2 で割った商から 1 を引いた値番目を A とする
trg = A = B [ C // 2 if C % 2 else C // 2 - 1 ]
rst = A = B if C // 2 if C // 2 else C // 2 - 1 ] <eos>
2011
src = 1 から 10 未満までの数列の各要素を C とし 、 1 から 10 未満までの数列の列の各要素を B とし 、 A を書式として B 、 C 、 B に C を掛けた値で整形した文字列 を出力するの列
trg = [ print ( A . format ( B , C , B * C ) ) for B in [ range ( 1 , 10 ) for C in range ( 1 , 10 ) ] ]
rst = [ print ( A . format ( B , C , B + C ) for B in [ range ( 1 , 10 ) for C in range ( 1 , 10 ) ] ] ) <eos>
2012
src = B に C から D を引いた値の絶対値を E で割った値を加えた値を A とする
trg = A = B + abs ( C - D ) / E
rst = A = B + abs ( C - D ) / E <eos>
2013
src = B から time を引いた値を A とする
trg = A = B - time
rst = A = B - time <eos>
2014
src = 0 を辞書の A 番目に する
trg = dict [ A ] = 0
rst = dict [ A ] = 0 <eos>
2015
src = A に対応する値 、 もし存在しなければ B に C を加えた値 、0 に 1 を加えた値を A の B に C を加えた値番目に する
trg = A [ B + C ] = A . get ( B + C , 0 ) + 1
rst = A [ B + C ] = A . get ( B + C , 0 ) + 1 <eos>
2016
src = Simulator ( B , C , D ) を A とする
trg = A = Simulator ( B , C , D )
rst = A = <unk> ( B , C , D ) <eos>
2017
src = 0 から C 未満までの数列の各要素を B とし 、 、 つまり空列の列を A の _ edges に する
trg = A . _edges = [ [ ] for B in range ( C ) ]
rst = A . _nodes = [ [ ] for B in range ( C ) ] <eos>
2018
src = A の y 座標が B の y 座標 より大きいとき 、
trg = if A . y > B . y :
rst = if A . y > B . y : <eos>
2019
src = A の B 番目から B に C を加えた値までの部分列の各要素に x をパラメータとして x が A の B 番目と等しいかどうか を返す関数を適用した列 が全てが真のとき 、
trg = if all ( map ( lambda D : D == A [ B ] , A [ B : B + C ] ) ) :
rst = if all ( [ A : : A == B : A == B ] ) : <eos>
2020
src = B のリストの各要素 に整数を適用した列のリストを A とする
trg = A = list ( map ( int , list ( B ) ) )
rst = A = list ( map ( int , list ( B ) ) ) <eos>
2021
src = A を書式として B 、 C で整形した文字列を A とする
trg = A = A . format ( B , C )
rst = A = A . format ( B , C ) <eos>
2022
src = 0 が A を B で割った余り と等しいとき 、
trg = if 0 == ( A % B ) :
rst = if ( 0 == A % B ) : <eos>
2023
src = 入力された文字列を空白 文字で分割した字句列の各要素を B とし 、 B の両端から C を取り除いた文字列 の列を A とする
trg = A = [ B . strip ( C ) for B in input ( ) . split ( ' ' ) ]
rst = A = [ B . strip ( C ) for B in input ( ) . split ( ' ' ) ] <eos>
2024
src = A の 0 番目が B 以上のとき 、
trg = if A [ 0 ] >= B :
rst = if A [ 0 ] >= B : <eos>
2025
src = A に B から A に C を掛けた値を引いた値を D で割った商を加えた値が E より小さいとき 、
trg = if A + ( B - A * C ) // D < E :
rst = if A + ( B - A * C < D ) < E : <eos>
2026
src = isSolved ( A ) を出力する
trg = print ( isSolved ( A ) )
rst = print ( <unk> ( A ) ) <eos>
2027
src = 改行せずに A の B 番目の 1 番目 、 空文字列 を出力する
trg = print ( A [ B ] [ 1 ] , '' , end = '' )
rst = print ( A [ B ] [ 1 ] , '' , end = '' ) <eos>
2028
src = ( B の 0 番目から C の先頭を引いた値 、 B の 1 番目から C の 1 番目を引いた値 ) の組を A とする
trg = A = ( B [ 0 ] - C [ 0 ] , B [ 1 ] - C [ 1 ] )
rst = A = ( B [ 0 ] - C [ 0 ] , B [ 1 ] - C [ 1 ] ) <eos>
2029
src = B の最大値を A とする
trg = A = max ( B )
rst = A = max ( B ) <eos>
2030
src = A の B 番目を出力する
trg = print ( A [ B ] )
rst = print ( A [ B ] ) <eos>
2031
src = funcs [ int ( op ) ] ( A )
trg = funcs[int(op)] ( A )
rst = <unk> ( <unk> ( A ) ) <eos>
2032
src = A の valuelist の末尾に ( A の valuelist の先頭の先頭 、 A . valuelist の先頭の 1 番目から time を引いた値 ) からなる列 を追加する
trg = A . valuelist . append ( [ A . valuelist [ 0 ] [ 0 ] , A . valuelist [ 0 ] [ 1 ] - time ] )
rst = A . valuelist . append ( [ A . valuelist [ 0 ] [ 0 ] , A . valuelist [ 0 ] [ 1 ] - time ] ) <eos>
2033
src = B の 2 乗に 1 を加えた値を A とする
trg = A = B ** 2 + 1
rst = A = B ** 2 + 1 <eos>
2034
src = A の root の B 番目が 0 より小さいとき 、
trg = if A . root [ B ] < 0 :
rst = if A . root [ B ] < 0 : <eos>
2035
src = B のとき C 、 そうでなければ D を A とする
trg = A = ( C if B else D )
rst = A = C if B else D <eos>
2036
src = 0 を A の B 番目の先頭の 0 番目に する
trg = A [ B ] [ 0 ] [ 0 ] = 0
rst = A [ B ] [ 0 ] = 0 <eos>
2037
src = (0、1、-1、0 ) からなる列を A とする
trg = A = [ 0 , 1 , - 1 , 0 ]
rst = A = [ 0 , 3 , 3 , 5 ] <eos>
2038
src = push ( A )
trg = push ( A )
rst = push ( A ) <eos>
2039
src = find ( A , B , C ) のとき 、
trg = if find ( A , B , C ) :
rst = if find ( A , B , C ) : <eos>
2040
src = C から D の長さを引いた値を A の B 番目に する
trg = A [ B ] = C - len ( D )
rst = A [ B ] = C - len ( D ) <eos>
2041
src = B の先頭を A の x 座標に する
trg = A . x = B [ 0 ]
rst = A . x1 = B [ 0 ] <eos>
2042
src = B の先頭の 1 番目を A とする
trg = A = B [ 0 ] [ 1 ]
rst = A = B [ 0 ] [ 1 ] <eos>
2043
src = A 内の B の出現回数が 2 と等しいとき 、
trg = if A . count ( B ) == 2 :
rst = if A . count ( B ) == 2 : <eos>
2044
src = A の 1 番目と 1 の論理積かつ A の 2 番目と 1 の論理積のとき B 、 そうでなければ C を出力する
trg = print ( B if A [ 1 ] & 1 and A [ 2 ] & 1 else C )
rst = print ( B if A [ 1 ] & 1 and A [ 2 ] & 1 else C ) <eos>
2045
src = A が 0 以上かつ A が 8 より小さいとき 、
trg = if A >= 0 and A < 8 :
rst = if A >= 0 and A < 8 : <eos>
2046
src = 改行せずに A を間に入れて B の C 番目の children の各要素に整数を適用した列 を連結した文字列を出力する
trg = print ( A . join ( map ( str , B [ C ] . children ) ) , end = '' )
rst = print ( A . format ( B [ C ] . . ) , end = '' ) <eos>
2047
src = solve ( A )
trg = solve ( A )
rst = solve ( A ) <eos>
2048
src = A でなくかつ B が 0 と等しいとき 、
trg = if not A and B == 0 :
rst = if not A and B == 0 : <eos>
2049
src = C の各要素を B とし 、 B が D 以下のとき の B の列を A とする
trg = A = [ B for B in C if B <= D ]
rst = A = [ B for B in C if B <= D ] <eos>
2050
src = A が B より小さくまたは C が A より小さいとき 、
trg = if A < B or C < A :
rst = if A < B or C < A : <eos>
2051
src = A の B から 1 を引いた値番目が C と等しいとき 、
trg = if A [ B - 1 ] == C :
rst = if A [ B - 1 ] == C : <eos>
2052
src = ( (0、1、2、3 ) の組 、 (1、2、3、0) の組 、 (2、3、0、1) の組 、 (3、0、1、2) の組 ) の組を A とする
trg = A = ( ( 0 , 1 , 2 , 3 ) , ( 1 , 2 , 3 , 0 ) , ( 2 , 3 , 0 , 1 ) , ( 3 , 0 , 1 , 2 ) )
rst = A = ( ( 0 , 1 , 3 , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
2053
src = merge _ sort ( B ,0, C ) を A とする
trg = A = merge_sort ( B , 0 , C )
rst = A = merge_sort ( B , 0 , C ) <eos>
2054
src = A の B 番目の 1 番目が 10 より小さいとき 、
trg = if A [ B ] [ 1 ] < 10 :
rst = if A [ B ] [ 1 ] < 10 : <eos>
2055
src = A の先頭 を展開してを出力する
trg = print ( * A [ 0 ] )
rst = print ( * A [ 0 ] ) <eos>
2056
src = C 、 D 、 E に お いて正規表現 B から 1 を引いた値が最初にマッチする位置 を A とする
trg = A = search ( B - 1 , C , D , E )
rst = A = min ( B - 1 , C , D , E ) <eos>
2057
src = A の A の 0 と等しい要素の最初の位置番目を 削 除 する
trg = del A [ A . index ( 0 ) ]
rst = del A A A . index ( 0 ) . pop ( ) <eos>
2058
src = B を A の (6、4) の組番目に する
trg = A [ ( 6 , 4 ) ] = B
rst = A [ 6 ] 6 ] = B <eos>
2059
src = B の 2 進 数文字列の - C の長さから 、 つまり末尾までの部分列内の D の出現回数を A とする
trg = A = bin ( B ) [ - len ( C ) : ] . count ( D )
rst = A = B ( bin ( bin ( - ) ) , len ( C ) , D ) <eos>
2060
src = B の C に 1 を加えた値から 、 つまり末尾までの部分列を A とする
trg = A = B [ C + 1 : ]
rst = A = B [ C + 1 : ] <eos>
2061
src = B の長さに 16 の C 乗を掛けた値を A とする
trg = A = len ( B ) * ( 16 ** C )
rst = A = len ( B ) * ( 10 ** C ) <eos>
2062
src = A の B 番目が A の B に 1 を加えた値番目 より大きいとき 、
trg = if A [ B ] > A [ B + 1 ] :
rst = if A [ B ] > A [ B + 1 ] : <eos>
2063
src = A に B を加えた値が get ( C & D , 17) より小さいとき 、
trg = if A + B < get ( C & D , 17 ) :
rst = if A + B < get ( C ^ D , 17 ) : <eos>
2064
src = A を B 、 2 に C を掛けた値の最小値 だけ 増 加 させ る
trg = A += min ( B , 2 * C )
rst = A += min ( B , 2 * C ) <eos>
2065
src = - 2 の 31 乗を A とする
trg = A = - 2 ** 31
rst = A = - 2 ** 31 <eos>
2066
src = (1、0、0) からなる列を A とする
trg = A = [ 1 , 0 , 0 ]
rst = A = [ 0 , 3 , 0 , 0 ] <eos>
2067
src = 5 に B を 1461 で割った余りを 4 で割った商を掛けた値に 2 を加えた値を A とする
trg = A = 5 * ( ( B % 1461 ) // 4 ) + 2
rst = A = 5 * ( B % ( ) // 4 ) + 2 <eos>
2068
src = .5 、 1 、 1 を A 、 B 、 C とする
trg = A , B , C = .5 , 1 , 1
rst = A , B , C = - 1 , 1 , 1 <eos>
2069
src = A の末尾に ( B 、 - C ) からなる列 を追加する
trg = A . append ( [ B , - C ] )
rst = A . append ( [ B , - C ] ) <eos>
2070
src = D の D の ( E **2 に F **2 を加えた値 、 E 、 F ) の組 と等しい要素の最初の位置に 1 を加えた値番目を展開し 、 それぞれ A 、 B 、 C とする
trg = A , B , C = D [ D . index ( ( E ** 2 + F ** 2 , E , F ) ) + 1 ]
rst = A , B , C = D [ D . index ( ( E , 2 ) + F , F ) + F , ( F , F ) + 1 <eos>
2071
src = 円周率の C に 1 を加えた値を F で割った余り 番目を展開し 、 それぞれ D 、 E とする
trg = D , E = pi [ ( C + 1 ) % F ]
rst = D , E = ( ( C + 1 ) % F ] <eos>
2072
src = C の各要素に B を適用した列を A とする
trg = A = map ( B , C )
rst = A = map ( B , C ) <eos>
2073
src = A の -1 番目を B の 、 つまり現在の日時番目 だけ 減 少 させ る
trg = A [ - 1 ] -= B [ now ]
rst = A [ - 1 ] -= B [ now ] <eos>
2074
src = A の B から 1 を引いた値に C を掛けた値に D に 1 を加えた値 を加えた値番目の末尾に ( B から 1 を引いた値に C を掛けた値に D を加えた値 、 E に 1 を加えた値 ) の組 を追加する
trg = A [ ( B - 1 ) * C + ( D + 1 ) ] . append ( ( ( B - 1 ) * C + D , E + 1 ) )
rst = A [ ( B - 1 ) * C + ( D + 1 ) ] . append ( ( B - 1 ) * C + D , E + 1 ) ) <eos>
2075
src = A の先頭 、 B を出力する
trg = print ( A [ 0 ] , B )
rst = print ( A [ 0 ] , B ) <eos>
2076
src = A の 1 番目 、 A の 5 番目 、 A の 4 番目 、 A の先頭を A の先頭 、 A の 1 番目 、 A の 5 番目 、 A の 4 番目とする
trg = A [ 0 ] , A [ 1 ] , A [ 5 ] , A [ 4 ] = A [ 1 ] , A [ 5 ] , A [ 4 ] , A [ 0 ]
rst = A [ 0 ] , A [ 1 ] , A [ 5 ] , A [ 5 ] , A [ 5 ] , A [ 5 ] , A [ 5 ] , A [ 5 ] , A [ 0 ] <eos>
2077
src = 0 をネイピア数とする
trg = e = 0
rst = e = 0 <eos>
2078
src = A から 1 を引いた値を返す
trg = return A - 1
rst = return A - 1 <eos>
2079
src = A の B 番目の 1 番目が A の B から 1 を引いた値番目の 1 番目より小さいとき 、
trg = if A [ B ] [ 1 ] < A [ B - 1 ] [ 1 ] :
rst = if A [ B ] [ 1 ] < A [ B - 1 ] [ 1 ] : <eos>
2080
src = dfs (1, A , B , C )
trg = dfs ( 1 , A , B , C )
rst = dfs ( 1 , A , B , C ) <eos>
2081
src = A の先頭の B 番目が C と等しくかつ A の 1 番目の B 番目が C と等しくかつ A の 2 番目の B 番目が C と等しいとき 、
trg = if A [ 0 ] [ B ] == C and A [ 1 ] [ B ] == C and A [ 2 ] [ B ] == C :
rst = if A [ 0 ] [ B ] == C and A [ 1 ] [ B ] == C and A [ 2 ] [ B ] == C : <eos>
2082
src = ((0、0、 円周率 ) の組 、(1、 0 、 B ) の組 ) からなる列を A とする
trg = A = [ ( 0 , 0 , pi ) , ( 1 , 0 , B ) ]
rst = A = [ ( 0 , 0 , 0 ) , ( 0 , B ) ] <eos>
2083
src = Step _ Check ( A ) のとき 、
trg = if Step_Check ( A ) :
rst = if <unk> ( A ) : <eos>
2084
src = 2 に 60 を掛けた値に 60 を掛けた値から time を引いた値に 3 を掛けた値を A とする
trg = A = ( 2 * 60 * 60 - time ) * 3
rst = A = ( 2 * 60 * 60 - time ) * 3 <eos>
2085
src = A の B と C の論理和番目 、 A の B 番目に D を加えた値の最大値を A の B と C の論理和 番目に する
trg = A [ B | C ] = max ( A [ B | C ] , A [ B ] + D )
rst = A [ B | C ] = max ( A [ B ^ C ] , A [ B ] + D ) <eos>
2086
src = 0 が A 以下かどうかが B より小さくなくまたは 0 が C 以下かどうかが B より小さくないとき 、
trg = if not 0 <= A < B or not 0 <= C < B :
rst = if not 0 <= A < B or not 0 <= C < B : <eos>
2087
src = B から B の 3 乗から C を引いた値を 3 に B の 2 乗を掛けた値で割った値 を引いた値を A とする
trg = A = B - ( B ** 3 - C ) / ( 3 * B ** 2 )
rst = A = B - ( B ** 3 - C ) / ( 3 * B ** 2 ) <eos>
2088
src = D の各要素を C とし 、 C の列を A の B 番目に する
trg = A [ B ] = [ C for C in D ]
rst = A [ B ] = [ C for C in D ] <eos>
2089
src = E の B 番目の D 番目を A の B に C を掛けた値に D を加えた値番目に する
trg = A [ B * C + D ] = E [ B ] [ D ]
rst = A [ B * C + D ] = E [ B ] [ D ] <eos>
2090
src = A の B 番目の末尾に (0、 C 、 D ) からなる列 を追加する
trg = A [ B ] . append ( [ 0 , C , D ] )
rst = A [ B ] . append ( [ 0 , C , D ] ) <eos>
2091
src = C を A の B から 1 を引いた値番目の 、 つまり先頭から 、 つまり末尾までの部分列に する
trg = A [ B - 1 ] [ : ] = C
rst = A [ B - 1 ] [ : ] = C <eos>
2092
src = A が 60 より大きいとき 、
trg = if A > 60 :
rst = if A > 60 : <eos>
2093
src = 0 から C 未満までの数列の各要素を D とし 、(( 、 つまり無限大 ) からなる列の 0 から C 未満までの数列の各要素を B とし 、 31 の列回分の列 ) からなる列の列を A とする
trg = A = [ [ [ inf ] * [ 31 for B in range ( C ) ] ] for D in range ( C ) ]
rst = A = [ [ [ inf ] * [ 31 for B in range ( C ) ] ] for D in range ( C ) ] <eos>
2094
src = C の先頭 を空白で分割した字句列 を展開し 、 それぞれ A 、 B とする
trg = A , B = C [ 0 ] . split ( )
rst = A , B = C [ 0 ] . split ( ) <eos>
2095
src = A の B の C 番目番目に 1 を加えた値を A の B の C 番目番目に する
trg = A [ B [ C ] ] = A [ B [ C ] ] + 1
rst = A [ B [ C ] ] = A [ B [ C ] ] + 1 <eos>
2096
src = A 、 ( B の 0 番目に abs ( C [ D ] - C [ E ] ) を 2000 で割った値に F を掛けた値を加えた値 、 ( E ) からなる列に B の 1 番目を加えた値 ) の組 の最小値を A とする
trg = A = min ( A , ( B [ 0 ] + abs ( C [ D ] - C [ E ] ) / 2000 * ( F ) , [ E ] + B [ 1 ] ) )
rst = A = min ( A , ( B [ 0 ] + abs ( [ C [ D ] - [ C ] ) / 9 ] * F , [ E ] ) <eos>
2097
src = D の各要素を C 、 B とし 、 B の列の最大値を A とする
trg = A = max ( [ B for C , B in D ] )
rst = A = max ( [ B for C , B in D ] ) <eos>
2098
src = saizo ( list ( map ( int , input (). split ())))
trg = saizo ( list ( map ( int , input ( ) . split ( ) ) ) )
rst = <unk> ( list ( map ( int , input ( ) . split ( ) ) ) ) <eos>
2099
src = BIT ( B +1) を A の q に する
trg = A . q = BIT ( B + 1 )
rst = A . q = BIT ( B + 1 ) <eos>
2100
src = A の score が B の score と等しいとき 、
trg = if A . score == B . score :
rst = if A . score == B . score : <eos>
2101
src = (0) からなる列の 128 回分の列 、 (0) からなる列の 128 回分の列を A 、 B とする
trg = A , B = [ 0 ] * 128 , [ 0 ] * 128
rst = A , B = [ 0 ] * * , 0 ] * 128 <eos>
2102
src = 改行せずに A の ( B の real 、 B の imag ) の組 番目を出力する
trg = print ( A [ ( B . real , B . imag ) ] , end = '' )
rst = print ( A [ ( B . real , B . imag ) ] , end = '' ) <eos>
2103
src = A を 7 に B を掛けた値に C を加えた値だけ 増 加 させ る
trg = A += 7 * B + C
rst = A += 7 * B + C <eos>
2104
src = B . projection ( Point ( C , D )) を A とする
trg = A = B . projection ( Point ( C , D ) )
rst = A = B . projection ( Point ( C , D ) ) <eos>
2105
src = ( < __ main __ . Cammaobjectat 0 x 10 a 2034 3 0> ) の集合を A とする
trg = A = { [ tuple ( map ( int , input ( ) . split ( ) ) ) for B in range ( C ) ] }
rst = A = { [ B for B in range ( C ) ] ) <eos>
2106
src = A を A に 1 を加えた値と の 論理和に する
trg = A |= ( A + 1 )
rst = A |= ( A + 1 ) <eos>
2107
src = translate ( int ( A /4) ) に A を 4 で割った余りの文字列 を加えた値を返す
trg = return translate ( int ( A / 4 ) ) + str ( A % 4 )
rst = return translate ( int ( map ( A ) + ) ) + ( A % 4 ) ) <eos>
2108
src = A を ryoukin ( B , C , D , E ) だけ 増 加 させ る
trg = A += ryoukin ( B , C , D , E )
rst = A += <unk> ( B , C , D , E ) <eos>
2109
src = A の B + C 番目に B - C に 1 を加えた値を掛けた値を D で割った余りに E の C 番目に E の B +1 番目を掛けた値を D で割った余りを掛けた値を D で割った余りを返す
trg = return ( A [ B + C ] * ( B - C + 1 ) % D ) * ( E [ C ] * E [ B + 1 ] % D ) % D
rst = return ( A [ B + C ] * ( B - C ) 1 ) * D ) * ( E [ C ] * E [ B + 1 ] % D ) % D ) <eos>
2110
src = C の D に 1 を加えた値番目を A の B の文字列番目の C の D 番目の文字列 番目に する
trg = A [ str ( B ) ] [ str ( C [ D ] ) ] = C [ D + 1 ]
rst = A [ str ( B ) ] . C [ D ] ] = C [ D + 1 ] <eos>
2111
src = create _ prime _ list ( 999999) を A とする
trg = A = create_prime_list ( 999999 )
rst = A = create_prime_list ( <unk> ( A ) ) <eos>
2112
src = B が C と等しいとき A に C を加えた値 、 そうでなければ A に空白文字を加えた値を A とする
trg = A = A + C if B == C else A + ' '
rst = A = A + C if A == C else A <eos>
2113
src = A が B の先頭の絶対値 以下の 間 、 次 を 繰り返 す
trg = while A <= abs ( B [ 0 ] ) :
rst = while A <= len ( B ) : <eos>
2114
src = B から 1 を引いた値から C に 1 を加えた値未満までの -1 間隔の数列を順に A として 、 繰り返 す
trg = for A in range ( B - 1 , C + 1 , - 1 ) :
rst = for A in range ( B - 1 , C + 1 , - 1 ) : <eos>
2115
src = C を A の find ( B ) 番目に する
trg = A [ find ( B ) ] = C
rst = A [ find ( B ) ] = C <eos>
2116
src = levenshtein ( A , B ) を出力する
trg = print ( levenshtein ( A , B ) )
rst = print ( <unk> ( A , B ) ) <eos>
2117
src = E 、 F の要素をそれぞれ組にした列 の各要素を B 、 C とし 、 B から C を引いた値の絶対値の D 乗の列の総和を A とする
trg = A = sum ( [ pow ( abs ( B - C ) , D ) for B , C in zip ( E , F ) ] )
rst = A = sum ( [ abs ( B - C ) for D , C in zip ( E , F ) ] ) <eos>
2118
src = A が B より小さいかどうかが C より小さいとき D 、 そうでなければ E を出力する
trg = print ( D if A < B < C else E )
rst = print ( D if A < B < C else E ) <eos>
2119
src = c をパラメータとして c の 1 番目から c の先頭 を引いた値を返す関数を key として A をソート する
trg = A . sort ( key = lambda B : B [ 1 ] - B [ 0 ] )
rst = A . sort ( key = lambda B : B [ 1 ] - B [ 0 ] ) <eos>
2120
src = A の A の A の最大値と等しい要素の最初の位置 を取り出した値
trg = A . pop ( A . index ( max ( A ) ) )
rst = A . pop ( A . index ( max ( A ) ) ) <eos>
2121
src = Segment ( e , B , C , D ) を A とする
trg = A = Segment ( e , B , C , D )
rst = A = Segment ( e , B , C , D ) <eos>
2122
src = ( A の 0 番目に B を加えた値 、 A の 1 番目に C を加えた値 ) の組が D に含まれないとき 、
trg = if not ( A [ 0 ] + B , A [ 1 ] + C ) in D :
rst = if ( A [ 0 ] + B , A [ 1 ] + C ) not in D : <eos>
2123
src = B の C 番目から C に 3 を加えた値までの部分列を A とする
trg = A = B [ C : C + 3 ]
rst = A = B [ C : C + 3 ] <eos>
2124
src = B 、 C の最小値から D を引いた値を A とする
trg = A = min ( B , C ) - D
rst = A = min ( B , C ) - D <eos>
2125
src = A の B を 2 で割った商番目が ( C 、 D ) からなる列 に含まれないとき 、
trg = if A [ B // 2 ] not in [ C , D ] :
rst = if A [ B // 2 ] not in C , D ] : <eos>
2126
src = B の x 座標から C の x 座標を引いた値を A の x 座標に する
trg = A . x = B . x - C . x
rst = A . x = B . x - C . x <eos>
2127
src = A の 1 番目が B 以下かつ A の 2 番目が C 以下かつ A の 3 番目が D 以下かつ E が F 以下のとき 、
trg = if A [ 1 ] <= B and A [ 2 ] <= C and A [ 3 ] <= D and E <= F :
rst = if A [ 1 ] <= B and A [ 2 ] <= C and A [ 3 ] <= D and F <= F : <eos>
2128
src = 0 から E に 1 を加えた値未満までの数列の各要素 を D とし 、 、 つまり 改行せずに A を書式として B [ C ] の D 番目の文字列で整形した文字列 を出力するの列
trg = [ print ( A . format ( str ( B [ C ] [ D ] ) ) , end = '' ) for D in range ( E + 1 ) ]
rst = [ print ( map ( A . format ( B [ C ] [ D ] ) ) , ) for D in range ( E + 1 ) ] <eos>
2129
src = cross ( B , C ) を 2 で割った値を A とする
trg = A = cross ( B , C ) / 2
rst = A = cross ( B , C ) / 2 <eos>
2130
src = B の 1 番目を A にソート順で 挿入する
trg = bisect . insort_left ( A , B [ 1 ] )
rst = insort_left ( A , B [ 1 ] ) <eos>
2131
src = A の -1 番目が 0 と等しいとき 、
trg = if A [ - 1 ] == 0 :
rst = if A [ - 1 ] == 0 : <eos>
2132
src = allocate ( A , B ) を出力する
trg = print ( allocate ( A , B ) )
rst = print ( <unk> ( A , B ) ) <eos>
2133
src = 1 から B 、 C から B を引いた値の最小値 未満までの数列を順に A として 、 繰り返 す
trg = for A in range ( 1 , min ( B , C - B ) ) :
rst = for A in range ( 1 , min ( B , C - B ) ) : <eos>
2134
src = 入力された文字列 に C を加えた値 を空白で分割した字句列の 、 つまり先頭から 2 番目までの部分列を展開し 、 それぞれ A 、 B とする
trg = A , B = ( input ( ) + C ) . split ( ) [ : 2 ]
rst = A , B = input ( ) + C ) . split ( ) [ : 2 ] <eos>
2135
src = B の pos の長さを A とする
trg = A = len ( B . pos )
rst = A = B . len ( B ) <eos>
2136
src = A の B 番目が C の浮動小数点数 と等しいとき 、
trg = if A [ B ] == float ( C ) :
rst = if A [ B ] == float ( C ) : <eos>
2137
src = A が ((0、0) の組 、(0、1) の組 、(1、0) の組 、(1、1) の組 ) からなる列と等しいとき 、
trg = if A == [ ( 0 , 0 ) , ( 0 , 1 ) , ( 1 , 0 ) , ( 1 , 1 ) ] :
rst = if A == [ ( 0 , 0 ) , ( 1 , 0 ) , ( 1 , 1 ) , ( 1 , 1 ) ] : <eos>
2138
src = 2 の 32 乗を A とする
trg = A = 2 ** 32
rst = A = 2 ** 32 <eos>
2139
src = A を A から 1 を引いた値を 5 で割った余りだけ 減 少 させ る
trg = A -= ( A - 1 ) % 5
rst = A -= ( A - 1 ) % 5 <eos>
2140
src = A を 2 で割った余りが 0 と等しくかつ B が 10 より小さいとき 、
trg = if A % 2 == 0 and B < 10 :
rst = if A % 2 == 0 and B < 10 : <eos>
2141
src = A の station _ count から A の init を引いた値に B を加えた値を A の station _ count で割った余りを返す
trg = return ( A . station_count - A . init + B ) % A . station_count
rst = return A . <unk> ( ( A . <unk> + B ) A . <unk> ) <eos>
2142
src = A の 15 番目 、 A の 17 番目を A の 17 番目 、 A の 15 番目とする
trg = A [ 17 ] , A [ 15 ] = A [ 15 ] , A [ 17 ]
rst = A [ 17 ] , A [ 15 ] = A [ 15 ] , A [ 17 ] <eos>
2143
src = A を B と の排他 的 論理和に する
trg = A ^= B
rst = A |= B <eos>
2144
src = ( < __ main __ . Cammaobjectat 0 x 109 e 4 1 37 0> ) の集合を A とする
trg = A = { B , C , D }
rst = A = { [ ( B ) for B in range ( C ) if D ) & set ( C ) ] <eos>
2145
src = f ( D , E ,1) 、 f ( F , G ,1) 、 f ( H , I ,1) を A 、 B 、 C とする
trg = A , B , C = f ( D , E , 1 ) , f ( F , G , 1 ) , f ( H , I , 1 )
rst = A , B , C = f ( D , E , E ) , f ( F , G , G ) , ( G , G , , ( 1 , G , 1 ) <eos>
2146
src = A に B が 1 と等しいかどうかに C に ( B == 2 ) に D *( B == 3)+ E *( B == 4 )+ F *( B == 5)+ G *( B == 6 )+ H *( B == 7 )+ I を加えた値を掛けた値を加えた値 を掛けた値を出力する
trg = print ( A * ( B == 1 ) + C * ( B == 2 ) + D * ( B == 3 ) + E * ( B == 4 ) + F * ( B == 5 ) + G * ( B == 6 ) + H * ( B == 7 ) + I )
rst = print ( A * ( B == 1 ) + ( * ( B * 2 ) * ( B * ( B * ( B * ( B * ( B * ( B * ( B * ( B * ( B * ( B * B )
2147
src = namedtuple ( B , C ) を A とする
trg = A = namedtuple ( B , C )
rst = A = namedtuple ( B , C ) <eos>
2148
src = 1 を A とする
trg = A = 1
rst = A = 1 <eos>
2149
src = A が B の NIL と等しくない 間 、 次 を 繰り返 す
trg = while A != B . NIL :
rst = while A != B . NIL : <eos>
2150
src = A が 0 と等しくかつ 、 つまりネイピア数が 2 と等しいとき 、
trg = if A == 0 and e == 2 :
rst = if A == 0 and e == 2 : <eos>
2151
src = x をパラメータとして x の 1 番目を返す関数をキーとして 0 から 8 未満までの数列の各要素を A とし 、 input () を空白で分割した字句列の各要素に 浮動小数点数を適用した列のリスト の列をソートした列 を返す
trg = return sorted ( [ list ( map ( float , input ( ) . split ( ) ) ) for A in range ( 8 ) ] , key = lambda B : B [ 1 ] )
rst = return lambda lambda A : sum ( map ( float , input ( ) . split ( ) ) ) for A in range ( 8 ) ] ) <eos>
2152
src = fix ( A * B ) を A とする
trg = A = fix ( A * B )
rst = A = fix ( A * B ) <eos>
2153
src = 空列を A の lt に する
trg = A . lt = [ ]
rst = A . lt = [ ] <eos>
2154
src = A を A の絶対値で割った値を ネイピア数とする
trg = e = A / abs ( A )
rst = e = A / abs ( A ) <eos>
2155
src = A かつ B が ( 10、11、12、13、14 ) からなる列と等しいとき 、
trg = if A and B == [ 10 , 11 , 12 , 13 , 14 ] :
rst = if A and B == [ : [ - 1 ] : <eos>
2156
src = can _ construct _ q ( A , B +1, C + D [ B ] ) のとき 、
trg = if can_construct_q ( A , B + 1 , C + D [ B ] ) :
rst = if <unk> ( A , B + 1 , C + D [ B ] ) : <eos>
2157
src = A の -1 番目を B 倍 に する
trg = A [ - 1 ] *= B
rst = A [ - 1 ] *= B <eos>
2158
src = -1 を D とする
trg = D = - 1
rst = D = - 1 <eos>
2159
src = A の 0 番目を 3 だけ 増 加 させ る
trg = A [ 0 ] += 3
rst = A [ 0 ] += 3 <eos>
2160
src = A の末尾に ( B 、 C から 1 を引いた値 ) からなる列 を追加する
trg = A . append ( [ B , C - 1 ] )
rst = A . append ( [ B , C - 1 ] ) <eos>
2161
src = A の B から 1 を引いた値番目の C 番目 、 A の B 番目の C から 1 を引いた値番目 、 A の B から 1 を引いた値番目の C から 1 を引いた値番目の最小値に 1 を加えた値を A の B 番目の C 番目に する
trg = A [ B ] [ C ] = min ( A [ B - 1 ] [ C ] , A [ B ] [ C - 1 ] , A [ B - 1 ] [ C - 1 ] ) + 1
rst = A [ B ] [ C ] = min ( A [ B - 1 ] [ C ] , A [ B ] [ C - 1 ] , A [ B - 1 ] [ C - 1 ] ) + 1 <eos>
2162
src = (0) からなる列の 12 回分の列を A とする
trg = A = [ 0 ] * 12
rst = A = [ 0 ] * 12 <eos>
2163
src = A ._ add _ index _ left ( B )
trg = A . _add_index_left ( B )
rst = A . <unk> ( B ) <eos>
2164
src = A の先頭を取り出した値 が - B の C 番目と等しくないとき 、
trg = if ( A . pop ( ) != - B [ C ] ) :
rst = if A . pop != - B != C ] : <eos>
2165
src = A が B の _ cache に含まれるとき 、
trg = if A in B . _cache :
rst = if A in B . _cache : <eos>
2166
src = A の各要素をネイピア数 とし 、 、 つまりネイピア数が 0 以下かどうかの列が全てが真 または A の各要素をネイピア数 とし 、 、 つまりネイピア数が 0 以上かどうかの列が全てが真 のとき 、
trg = if all ( [ e <= 0 for e in A ] ) or all ( [ e >= 0 for e in A ] ) :
rst = if all ( [ e <= 0 for e in A if all ( [ e or all ( e ) if e <= 0 for e in A ] ) : <eos>
2167
src = A が B の 2 乗 以下のとき 、
trg = if ( A <= B ** 2 ) :
rst = if A <= B ** 2 : <eos>
2168
src = A の 0 番目が 0 より大きいとき 、
trg = if A [ 0 ] > 0 :
rst = if A [ 0 ] > 0 : <eos>
2169
src = B の 、 つまり先頭から C 番目までの部分列の総和を A とする
trg = A = sum ( B [ : C ] )
rst = A = sum ( B [ : C ] ) <eos>
2170
src = A が B 以下かつ A が C 以上のとき 、
trg = if A <= B and A >= C :
rst = if A <= B and A >= C : <eos>
2171
src = - A の B の先頭番目の先頭 を出力する
trg = print ( - A [ B [ 0 ] ] [ 0 ] )
rst = print ( - A [ B ] [ 0 ] ] ) <eos>
2172
src = A の B 番目の 1 番目を C に D を掛けた値だけ 増 加 させ る
trg = A [ B ] [ 1 ] += ( C * D )
rst = A [ B ] [ 1 ] += C * D <eos>
2173
src = full _ move 1 ( B -1) に 3 を掛けた値に 2 を加えた値を A とする
trg = A = full_move1 ( B - 1 ) * 3 + 2
rst = A = full_move1 ( B - 1 ) * 3 + 2 <eos>
2174
src = reachable ( B , C ) と reachable ( D , E ) の 差 を A とする
trg = A = reachable ( B , C ) . difference ( reachable ( D , E ) )
rst = A = <unk> ( <unk> ( B , C ) , <unk> ( D , E ) ) <eos>
2175
src = 文字列 A を 評価 した値を出力する
trg = print ( eval ( A ) )
rst = print ( eval ( A ) ) <eos>
2176
src = A の tree の長さを返す
trg = return len ( A . tree )
rst = return len ( A . tree ) <eos>
2177
src = A . max _ flow (0, B -1) を出力する
trg = print ( A . max_flow ( 0 , B - 1 ) )
rst = print ( A . max_flow ( 0 , B - 1 ) ) <eos>
2178
src = C を空白で分割した字句列 を展開し 、 それぞれ A 、 B とする
trg = A , B = C . split ( )
rst = A , B = C . split ( ) <eos>
2179
src = A の集合の長さ から 1 を引いた値 を出力する
trg = print ( len ( set ( A ) ) - 1 )
rst = print ( len ( set ( A ) ) - 1 ) <eos>
2180
src = C 、 C の先頭を除いた部分列 に ( C の先頭 ) からなる列を加えた値 の要素をそれぞれ組にした列 の各要素を B 、 A とし 、 A から B を引いた値の列を ネイピア数とする
trg = e = [ A - B for B , A in zip ( C , C [ 1 : ] + [ C [ 0 ] ] ) ]
rst = e = [ A - B for B , A in zip ( C , C [ 1 : ] + [ ] [ 0 ] ] ) ] <eos>
2181
src = B から読み込んだ一行を A とする
trg = A = B . readline ( )
rst = A = B . readline ( ) <eos>
2182
src = 文字 コ ー ド A に B を加えた値に 26 を加えた値の文字 を英大文字に変換した文字列を返す
trg = return chr ( A + B + 26 ) . upper ( )
rst = return chr ( A + B + 26 ) . upper ( ) <eos>
2183
src = x 、 y をパラメータとして A から B を引いた値の 2 乗に C から D を引いた値の 2 乗を加えた値の平方根 を返す関数を 返す
trg = return lambda A , C : sqrt ( ( A - B ) ** 2 + ( C - D ) ** 2 )
rst = return lambda D , A : ( ( ( A - B ) ** 2 + ( C - D ) ** 2 ) <eos>
2184
src = A が B の C 番目の 0 番目より小さくかつ D が B の C 番目の 1 番目より小さいとき 、
trg = if A < B [ C ] [ 0 ] and D < B [ C ] [ 1 ] :
rst = if A < B [ C ] [ 0 ] and D < B [ C ] [ 1 ] : <eos>
2185
src = 0 から input () の整数値未満までの数列の各要素を D とし 、 input () を空白で分割した字句列 の各要素に整数を適用した列 の列の各要素を B 、 C とし 、 B に C を掛けた値の列の総和を A とする
trg = A = sum ( [ B * C for B , C in [ map ( int , input ( ) . split ( ) ) for D in range ( int ( input ( ) ) ) ] ] )
rst = A = [ list ( [ B * C for B , [ map ( int , input ( ) . split ( ) ) ] for D in range ( int ( input ( ) ) ) ] ) ] ) ] ) <eos>
2186
src = B に 1 を加えた値に 2 に B に C を掛けた値から C *( C +1)*( D -1) を 2 で割った商を引いた値に C を加えた値を掛けた値を加えた値を A とする
trg = A = B + 1 + 2 * ( B * C - C * ( C + 1 ) * ( D - 1 ) // 2 + C )
rst = A = ( B + 1 ) * 2 * ( B * C - C ) * ( D - 1 ) * ( e + C ) <eos>
2187
src = A の 2 番目 、 A の 1 番目を A の 1 番目 、 A の 2 番目とする
trg = A [ 1 ] , A [ 2 ] = A [ 2 ] , A [ 1 ]
rst = A [ 1 ] , A [ 2 ] = A [ 2 ] , A [ 1 ] <eos>
2188
src = A 、 dfs ( B +1, C | D [ B ] ) に 1 を加えた値の最小値を A とする
trg = A = min ( A , dfs ( B + 1 , C | D [ B ] ) + 1 )
rst = A = min ( A , dfs ( B + 1 , C | D [ B ] ) + 1 ) <eos>
2189
src = A の B の C 番目の 2 番目から 1 を引いた値番目 、 A の B の C 番目の 1 番目から 1 を引いた値番目を A の B の C 番目の 1 番目から 1 を引いた値番目 、 A の B の C 番目の 2 番目から 1 を引いた値番目とする
trg = A [ B [ C ] [ 1 ] - 1 ] , A [ B [ C ] [ 2 ] - 1 ] = A [ B [ C ] [ 2 ] - 1 ] , A [ B [ C ] [ 1 ] - 1 ]
rst = A [ B [ C ] [ 1 ] , A [ B [ C ] [ 2 ] = A [ B [ C ] [ 2 ] - 1 ] , A [ B [ C ] [ 1 ] - 1 ] <eos>
2190
src = A の整数値が B 以下のとき 、
trg = if int ( A ) <= B :
rst = if int ( A ) <= B : <eos>
2191
src = A を 2 で割った商が B に 1 を加えた値より小さいとき 、
trg = if A // 2 < B + 1 :
rst = if A // 2 < B + 1 : <eos>
2192
src = B . dot ( C - D . p 1 ) を B . norm () で割った値を A とする
trg = A = B . dot ( C - D . p1 ) / B . norm ( )
rst = A = B . dot ( C - D . p1 ) / B . norm ( ) <eos>
2193
src = 24 を A とする
trg = A = 24
rst = A = 300000 <eos>
2194
src = A が -1 と等しくかつ B が -1 と等しくかつ C が -1 と等しくかつ D が -1 と等しいとき 、
trg = if A == - 1 and B == - 1 and C == - 1 and D == - 1 :
rst = if A == - 1 and B == - 1 and C == - 1 and D == - 1 : <eos>
2195
src = A の 、 つまり先頭から B 番目までの部分列に A の B 番目から e 番目までの部分列を反転した列 のリストを加えた値に A の 、 つまりネイピア数番目から 、 つまり末尾までの部分列を加えた値 を A とする
trg = A = A [ : B ] + list ( reversed ( A [ B : e ] ) ) + A [ e : ]
rst = A = A [ : B ] + list ( reversed ( A [ B : e ] ) + A [ e : ] <eos>
2196
src = A を acos ( B [0]* C / B [ D ] ) だけ 増 加 させ る
trg = A += acos ( B [ 0 ] * C / B [ D ] )
rst = A += acos ( B [ 0 ] + C / B [ D ] ) <eos>
2197
src = ネイピア数の cap が 0 より大きくかつ A の B 番目から C の e の to 番目を引いた値が A の e . to 番目から e の cost を引いた値から C の B 番目を引いた値 より小さいとき 、
trg = if e . cap > 0 and A [ B ] - C [ e . to ] < A [ e . to ] - e . cost - C [ B ] :
rst = if e . cap > 0 and A [ B ] - C . to ] < A . e . to ] < e . e - C < B - B ] : <eos>
2198
src = ( ( B , map ( int , input (). split ()) のリスト に番号付した組の列の各要素を C 、 B とし 、 C の列 )) からなる辞書を A とする
trg = A = { v : [ C for C , B in enumerate ( list ( map ( int , input ( ) . split ( ) ) ) ) ] }
rst = A = { name : [ C for C , C in enumerate ( list ( map ( int , input ( ) . split ( ) ) ) ] ) <eos>
2199
src = push ( pop (-2) - pop (-1) )
trg = push ( pop ( - 2 ) - pop ( - 1 ) )
rst = push ( pop ( 2 , - 1 ) , - 1 ) <eos>
2200
src = ( 48.0、 51.0 、 54.0 、 57.0 、 60.0 、 64.0 、 69.0 、 75.0、81.0、91.0、1 50.0 ) からなる列 に番号付した組の列を順に A 、 B として 、 繰り返 す
trg = for A , B in enumerate ( [ 48.0 , 51.0 , 54.0 , 57.0 , 60.0 , 64.0 , 69.0 , 75.0 , 81.0 , 91.0 , 150.0 ] ) :
rst = for A , B in enumerate ( [ <unk> : <unk> , <unk> , <unk> , <unk> , <unk> , <unk> , <unk> , <unk> , <unk> , <unk> , <unk> , <unk> , <unk> , <unk> , <unk> , <unk> , <unk> , <unk> , <unk> , <unk> ,
2201
src = A を B の weights の C 番目だけ 増 加 させ る
trg = A += B . weights [ C ]
rst = A += B . weights [ C ] <eos>
2202
src = postorder ( A )
trg = postorder ( A )
rst = <unk> ( A ) <eos>
2203
src = A の先頭と A の 2 番目を 入れ 替 え る
trg = A [ 0 ] , A [ 2 ] = A [ 2 ] , A [ 0 ]
rst = A [ 0 ] , A [ 2 ] = A [ 2 ] , A [ 0 ] <eos>
2204
src = A の B に 1 を加えた値番目の先頭の B に 1 を加えた値番目を A の B 番目の 2 番目の C 番目に B から C を引いた値に 1 を加えた値を掛けた値だけ 増 加 させ る
trg = A [ B + 1 ] [ 0 ] [ B + 1 ] += A [ B ] [ 2 ] [ C ] * ( B - C + 1 )
rst = A [ B + 1 ] ] * B + 1 ] += A [ B ] [ 2 ] * B + 1 ] * ( B - C + 1 ) <eos>
2205
src = A 、 B の A と等しい要素の最初の位置 を出力する
trg = print ( A , B . index ( A ) )
rst = print ( A , B . index ( A ) ) <eos>
2206
src = A . compute (0, B -1, C ) を出力する
trg = print ( A . compute ( 0 , B - 1 , C ) )
rst = print ( A . compute ( 0 , B - 1 , C ) ) <eos>
2207
src = 0 から C 未満までの数列の各要素を B とし 、(0、0、 B に 1 を加えた値 ) からなる列の列を A とする
trg = A = [ [ 0 , 0 , B + 1 ] for B in range ( C ) ]
rst = A = [ [ B + 1 , B + 1 ] for B in range ( C ) ] <eos>
2208
src = ( B 、 C に D を掛けた値 ) の組を A の 、 つまりネイピア数番目に する
trg = A [ e ] = ( B , C * D )
rst = A [ e ] = ( B , C * D ) <eos>
2209
src = B にネイピア数を加えた値に C から 1 を引いた値を掛けた値を A とする
trg = A = ( B + e ) * ( C - 1 )
rst = A = B * e * ( C - 1 ) <eos>
2210
src = A . addEdge ( B , C , D )
trg = A . addEdge ( B , C , D )
rst = A . <unk> ( B , C , D ) <eos>
2211
src = rightRotate ( A ) を A とする
trg = A = rightRotate ( A )
rst = A = <unk> ( A ) <eos>
2212
src = E を 2 で割った余りを A の B 番目の C 番目の D 番目に する
trg = A [ B ] [ C ] [ D ] = E % 2
rst = A [ B ] [ C ] [ D ] = E % 2 <eos>
2213
src = A の B から C を引いた値番目に D を加えた値を A の B 番目に する
trg = A [ B ] = A [ B - C ] + D
rst = A [ B ] = A [ B - C ] + D <eos>
2214
src = A の siz を 1 だけ 増 加 させ る
trg = A . siz += 1
rst = A . siz += 1 <eos>
2215
src = B の各要素を A とし 、 B の A 番目が B の値の集まりの最大値 と等しいとき の A の列をソートした列 を順に A として 、 繰り返 す
trg = for A in sorted ( [ A for A in B if B [ A ] == max ( B . values ( ) ) ] ) :
rst = for A in reversed ( [ str for B in B if A [ B ] == B ) ) : <eos>
2216
src = intersection 0 1 (0,0, B , C , D , E , F ) を A とする
trg = A = intersection01 ( 0 , 0 , B , C , D , E , F )
rst = A = dfs0 ( B , C , D , E , F , 0 , E , F ) <eos>
2217
src = F の各要素を B とし 、 B . r から C を引いた値の 2 乗に B . g から D を引いた値の 2 乗を加えた値に B の b から E を引いた値の 2 乗を加えた値 の列を A とする
trg = A = [ ( ( B . r - C ) ** 2 + ( B . g - D ) ** 2 + ( B . b - E ) ** 2 ) for B in F ]
rst = A = [ B . ( B - C ) ** 2 + B . ( - D ) ** 2 + B B . ( B - E ) ** 2 ] <eos>
2218
src = ( A ) からなる列に 0 から 4 未満までの数列の各要素を B とし 、 、 つまり入力された文字列の整数値 の列を加えた値を A とする
trg = A = [ A ] + [ int ( input ( ) ) for B in range ( 4 ) ]
rst = A = [ A ] + [ int ( input ( ) ) for B in range ( 4 ) ] <eos>
2219
src = heappush ( A . heap , B )
trg = heappush ( A . heap , B )
rst = heappush ( A . Node ( B ) <eos>
2220
src = 10 の 6 乗を A とする
trg = A = 10 ** 6
rst = A = 10 ** 6 <eos>
2221
src = preorder _ bfs ( A [ B ] . left )
trg = preorder_bfs ( A [ B ] . left )
rst = preorder_bfs ( A [ B ] . left ) <eos>
2222
src = 無限の整数列を A の長さから B を引いた値から 1 を引いた値だけ 増 加 させ る
trg = count += len ( A ) - B - 1
rst = count += len ( A ) - B - 1 <eos>
2223
src = B の C 番目の D 番目から B の C 番目の E 番目を引いた値を A とする
trg = A = B [ C ] [ D ] - B [ C ] [ E ]
rst = A = B [ C ] [ D ] - B [ C ] [ E ] <eos>
2224
src = 偽を A の B から C を引いた値に 7 を加えた値番目に する
trg = A [ B - C + 7 ] = False
rst = A [ B - C + 7 ] = False <eos>
2225
src = myhash ( B ) を A とする
trg = A = myhash ( B )
rst = A = <unk> ( B ) <eos>
2226
src = A の先頭から B の 1 番目の整数値 を探して見つかった位置を出力する
trg = print ( A . find ( int ( B [ 1 ] ) ) )
rst = print ( A . find ( int ( B [ 1 ] ) ) <eos>
2227
src = A . heappush ( B , ( C . distance [ D ] , D ))
trg = A . heappush ( B , ( C . distance [ D ] , D ) )
rst = A . heappush ( B , ( C . distance [ D ] , D ) ) <eos>
2228
src = A の end を A の cur に する
trg = A . cur = A . end
rst = A . cur = A . Node <eos>
2229
src = distf (* B [ C ] ) を A とする
trg = A = distf ( * B [ C ] )
rst = A = <unk> ( * B [ C ] ) <eos>
2230
src = B に 1 を加えた値に 2 を掛けた値を A とする
trg = A = ( B + 1 ) * 2
rst = A = ( B + 1 ) * 2 <eos>
2231
src = 入力された文字列内の B を C で置き換えた文字列内の D を E で置き換えた文字列を A とする
trg = A = input ( ) . replace ( B , C ) . replace ( D , E )
rst = A = str ( B . replace ( B , C ) . replace ( D , E ) <eos>
2232
src = B の浮動小数点数を C の浮動小数点数で割った値を A とする
trg = A = float ( B ) / float ( C )
rst = A = B ( float ( B ) / float ( C ) <eos>
2233
src = B の C 番目に B の C に 1 を加えた値番目を加えた値に B の C に 2 を加えた値番目を加えた値を A とする
trg = A = B [ C ] + B [ C + 1 ] + B [ C + 2 ]
rst = A = B [ C ] + B [ C + 1 ] + B [ C + 2 ] <eos>
2234
src = (4) からなる列の 6 回分の列を A とする
trg = A = [ 4 ] * 6
rst = A = [ 4 ] * 6 <eos>
2235
src = update ( A +1, B + C +1)
trg = update ( A + 1 , B + C + 1 )
rst = update ( A + 1 , B + C + 1 ) <eos>
2236
src = A の D 番目に E を加えた値を C とする を A の B 番目に する
trg = A [ B ] = C = A [ D ] + E
rst = A [ B ] = C = A [ D ] + E <eos>
2237
src = time を順に A 、 B として 、 繰り返 す
trg = for A , B in time :
rst = for A , B in time : <eos>
2238
src = B の 、 つまり先頭から C に D を掛けた値までの部分列 を A の 、 つまり先頭から 、 つまり末尾までの部分列に する
trg = A [ : ] = B [ : C * D ]
rst = A [ : : ] = B [ : C * D ] <eos>
2239
src = A の B に 1 を加えた値番目の C に 1 を加えた値番目が -1 と等しいとき -1 、 そうでなければ 1 を A の B に 1 を加えた値番目の C に 1 を加えた値番目に する
trg = A [ B + 1 ] [ C + 1 ] = - 1 if A [ B + 1 ] [ C + 1 ] == - 1 else 1
rst = A [ B + 1 ] [ C + 1 ] = - 1 if A [ B + 1 ] [ C + 1 ] == - 1 else 1 <eos>
2240
src = 0 から D 未満までの数列の各要素を C とし 、 B から読み込んだ一行 を空白で分割した字句列の各要素に 整数を適用した列の列を A とする
trg = A = ( [ map ( int , B . readline ( ) . split ( ) ) for C in range ( D ) ] )
rst = A = [ map ( int , B . readline ( ) . split ( ) ) for C in range ( D ) ] <eos>
2241
src = A に 1 を加えた値を B で割った余りを A とする
trg = A = ( A + 1 ) % B
rst = A = ( A + 1 ) % B <eos>
2242
src = set 1 ( B ) を A とする
trg = A = set1 ( B )
rst = A = jarvis ( B ) <eos>
2243
src = A が B から 1 を引いた値より小さくかつ C の A に 1 を加えた値番目の D 番目が E と等しいとき 、
trg = if A < B - 1 and C [ A + 1 ] [ D ] == E :
rst = if A < B - 1 and C [ A + 1 ] [ D ] == E : <eos>
2244
src = calc ( B , C , D , E ) を A とする
trg = A = calc ( B , C , D , E )
rst = A = calc ( B , C , D , E ) <eos>
2245
src = 40 を A の B 番目に する
trg = A [ B ] = 40
rst = A [ B ] = 40 <eos>
2246
src = B の整数値に 200 を掛けた値に C の整数値に 300 を掛けた値を加えた値を A とする
trg = A = int ( B ) * 200 + int ( C ) * 300
rst = A = int ( B ) * 200 + int ( C ) * 200 <eos>
2247
src = f ( int ( A /4) ) に A を 4 で割った余りの文字列 を加えた値を返す
trg = return ( f ( int ( A / 4 ) ) + str ( A % 4 ) )
rst = return ( str ( f ( A ) + ) ) + ( A % 4 ) ) <eos>
2248
src = B の x 座標から C の x 座標を引いた値に D の余弦を掛けた値から B の y 座標から C の y 座標を引いた値に D の正弦を掛けた値を引いた値 に C の x 座標 を加えた値を A の x 座標に する
trg = A . x = ( B . x - C . x ) * cos ( D ) - ( B . y - C . y ) * sin ( D ) + C . x
rst = A . x = B . x - ( C . x ) * ( ( D ) - ( B . y - C . y ) * sin ( D ) + C . sin ( D ) <eos>
2249
src = A が -1 と等しくなくかつ B に C の長さを加えた値が D の長さ以下のとき 、
trg = if A != - 1 and B + len ( C ) <= len ( D ) :
rst = if A != - 1 and B * C ( C ) - D ) : <eos>
2250
src = C の 2 個までの 重複 コン ビ ネ ー シ ョ ンの各要素に B を適用した列を A とする
trg = A = map ( B , itertools . combinations_with_replacement ( C , 2 ) )
rst = A = map ( B , combinations ( C , 2 ) ) <eos>
2251
src = A の 2 番目に A の 6 番目を掛けた値から A の 3 番目に A の 7 番目を掛けた値を引いた値
trg = A [ 2 ] * A [ 6 ] - A [ 3 ] * A [ 7 ]
rst = A [ 2 ] * A [ 6 ] - A [ 3 ] * A [ 7 ] <eos>
2252
src = B の出現 頻 度順の列を A とする
trg = A = B . most_common ( )
rst = A = B . most_common ( ) <eos>
2253
src = A を F に番号付した組の列の各要素を E 、 C とし 、 B に C を掛けた値に D の E 番目を加えた値の列 だけ 増 加 させ る
trg = A += [ B * C + D [ E ] for E , C in enumerate ( F ) ]
rst = += += [ ( * C * D [ E for E , C in enumerate ( F ) ] ) <eos>
2254
src = B [ C ] . get _ type () を A とする
trg = A = B [ C ] . get_type ( )
rst = A = B [ C ] . <unk> ( ) <eos>
2255
src = B を C で分割した字句列の各要素に 整数を適用した列を展開し 、 それぞれ A 、 B とする
trg = A , B = map ( int , B . split ( C ) )
rst = A , B = map ( int , B . split ( C ) ) <eos>
2256
src = B [0] から C [0] を引いた値に 3 の平方根を掛けた値を 2 で割った値に B の 1 番目から C の 1 番目を引いた値を 2 で割った値を加えた値に C の 1 番目を加えた値を A とする
trg = A = ( B [ 0 ] - C [ 0 ] ) * math . sqrt ( 3 ) / 2 + ( B [ 1 ] - C [ 1 ] ) / 2 + C [ 1 ]
rst = A = ( ( B [ 0 ] - C [ 0 ] ) / 3 ) / ( 2 + ( B [ 1 ] - C [ 1 ] ) / 2 + C [ 1 ] <eos>
2257
src = write ( A % B [ C . index (1) ] )
trg = write ( A % B [ C . index ( 1 ) ] )
rst = write ( A % B [ C . index ( 1 ) ] ) <eos>
2258
src = 入力された文字列 の 辞書 カ ウ ンタを A とする
trg = A = Counter ( input ( ) )
rst = A = Counter ( input ( ) ) <eos>
2259
src = A の 0 番目が 2 と等しいとき 、
trg = if A [ 0 ] == 2 :
rst = if A [ 0 ] == 2 : <eos>
2260
src = A に B に C を掛けた値を加えた値が D に含まれるとき 、
trg = if A + B * C in D :
rst = if A + B * C in D : <eos>
2261
src = A の B 番目の C 番目が 1 と等しいとき 、
trg = if A [ B ] [ C ] == 1 :
rst = if A [ B ] [ C ] == 1 : <eos>
2262
src = B の C +1 番目の D 番目の E から 1 を引いた値番目の F 番目に 1 を加えた値を A とする
trg = A = B [ C + 1 ] [ D ] [ E - 1 ] [ F ] + 1
rst = A = B [ C + 1 ] [ D ] [ E - 1 ] [ F ] + 1 <eos>
2263
src = A を 39 で割った余りの文字列を A とする
trg = A = str ( A % 39 )
rst = A = str ( A % len ( A ) ) <eos>
2264
src = A * 1 500+ B * 1200 に C * 1000 を加えた値に D に 500 を掛けた値を加えた値に E に 300 を掛けた値を加えた値に F に 200 を掛けた値を加えた値が G と等しいとき 、
trg = if A * 1500 + B * 1200 + C * 1000 + D * 500 + E * 300 + F * 200 == G :
rst = if A * 1 + 1 * B * 1870 + C * 1000 + D * 500 + E * F + F * F : <eos>
2265
src = A の長さが 2 以上かつ f ( A [0], B ) が f ( A [1], B ) 以上の 間 、 次 を 繰り返 す
trg = while len ( A ) >= 2 and f ( A [ 0 ] , B ) >= f ( A [ 1 ] , B ) :
rst = while len ( A ) >= 2 and f ( A [ 0 ] , B ) >= f ( A [ 1 ] , B ) : <eos>
2266
src = A の B に 1 を加えた値番目の C に 1 を加えた値番目のとき 、
trg = if A [ B + 1 ] [ C + 1 ] :
rst = if A [ B + 1 ] [ C + 1 ] : <eos>
2267
src = A を ( B の先頭に 3 の ( 1 /2) 乗を掛けた値を 2 で割った値に B の 1 番目を 2 で割った値を加えた値 ) からなる列 だけ 増 加 させ る
trg = A += [ B [ 0 ] * 3 ** ( 1 / 2 ) / 2 + B [ 1 ] / 2 ]
rst = A += [ B [ 0 ] ** 3 ** ( 1 / 2 / 2 ) / 2 ] <eos>
2268
src = A の 、 つまりネイピア数番目が 0 と等しくかつ B の 、 つまりネイピア数番目が 、 つまり偽 と等しいとき 、
trg = if A [ e ] == 0 and B [ e ] == False :
rst = if A [ e ] == 0 and B [ e ] == False : <eos>
2269
src = F . itemgetter (0) を key として D の各要素を C とし 、 E の B 番目の列の各要素を D とし 、 C の列の最小値を A の B 番目に する
trg = A [ B ] = min ( [ C for D in [ E [ B ] for C in D ] ] , key = F . itemgetter ( 0 ) )
rst = A [ B ] = min ( [ C for D in E [ B [ 0 ] ] ) for C in D ] ) ] <eos>
2270
src = B に C を加えた値を 2 で割った商を A とする
trg = A = ( B + C ) // 2
rst = A = ( B + C ) // 2 <eos>
2271
src = B 、 C から 1 を引いた値の総和を A とする
trg = A = B . sum ( C - 1 )
rst = A = B . add ( C , 1 ) <eos>
2272
src = C を A の B の 1 番目の整数値から B の 2 番目の整数値に 1 を加えた値までの部分列に する
trg = A [ int ( B [ 1 ] ) : int ( B [ 2 ] ) + 1 ] = C
rst = A [ int ( B [ 1 ] ) : int ( B [ 2 ] ) + 1 ] = C <eos>
2273
src = -10 の 18 乗を A とする
trg = A = - 10 ** 18
rst = A = - pow ** 18 <eos>
2274
src = A の 英大 小文字 を 交 換した文字列 を返す
trg = return A . swapcase ( )
rst = return A . swapcase ( ) <eos>
2275
src = 0 から 始 まる無限の整数列 を順に A として 、 繰り返 す
trg = for A in count ( 0 ) :
rst = for A in count ( ) : <eos>
2276
src = 2 に A を掛けた値が B 以下のとき 、
trg = if 2 * A <= B :
rst = if 2 * A <= B : <eos>
2277
src = B の nums のリストを A とする
trg = A = list ( B . nums )
rst = A = B . Node ( ) <eos>
2278
src = C が D 以下のとき C の 2 乗に D の 2 乗を加えた値を 2 に C を掛けた値で割った値 、 そうでなければ D を B とする
trg = B = ( ( C ** 2 + D ** 2 ) / ( 2 * C ) if C <= D else D )
rst = B = ( C ** 2 + D ** 2 ) / ( 2 if C <= D else ) if D <eos>
2279
src = B を (- float ( C ) 、 C の浮動小数点数 ) の組を 初 期 値として A で集約した列 の先頭を出力する
trg = print ( reduce ( A , B , ( - float ( C ) , float ( C ) ) ) [ 0 ] )
rst = print ( format ( A , format ( float ( C ) , float ( C ) , C ) ) <eos>
2280
src = A の E の B 番目の末尾に A . Edge ( C ,0, len ( A . E [ C ] ) -1,- D ) を追加する
trg = A . E [ B ] . append ( A . Edge ( C , 0 , len ( A . E [ C ] ) - 1 , - D ) )
rst = A . E [ B ] . append ( A . Edge ( C , 0 , len ( A . E [ C ] ) . bit_length ( ) ) <eos>
2281
src = A を 24 、 A から 1 を引いた値を 1461 で割った商の最小値に 1461 を掛けた値だけ 減 少 させ る
trg = A -= min ( 24 , ( A - 1 ) // 1461 ) * 1461
rst = A -= ( ( ( A , ( 1 - // ) * * <eos>
2282
src = 空文字列を間に入れて B を連結した文字列の整数値 から 、 つまり空文字列を間に入れて C を連結した文字列の整数値 を引いた値を A とする
trg = A = int ( '' . join ( B ) ) - int ( '' . join ( C ) )
rst = A = int ( '' . join ( B ) ) - int ( '' . join ( C ) ) <eos>
2283
src = 真を A の B の C と等しい要素の最初の位置番目の D の整数値から 1 を引いた値番目に する
trg = A [ B . index ( C ) ] [ int ( D ) - 1 ] = True
rst = A [ int ( B [ C [ C ) - int ( D ) - 1 ] = True <eos>
2284
src = A を書式として B を 3600 で割った商 、 B を 60 で割った商を 60 で割った余り 、 B を 60 で割った余り で整形した文字列を出力する
trg = print ( A . format ( B // 3600 , B // 60 % 60 , B % 60 ) )
rst = print ( A . format ( B // 3600 , ( B // 60 ) % 60 , B % 60 ) ) <eos>
2285
src = 1 から 26 未満までの 2 間隔の数列を順に A として 、 繰り返 す
trg = for A in range ( 1 , 26 , 2 ) :
rst = for A in range ( 1 , 26 , 2 ) : <eos>
2286
src = A の B から 1 を引いた値番目の C 番目 、 A の B から 1 を引いた値番目の 0 、 C から D を引いた値の最大値 番目に E を加えた値 、 A の B 番目の 0 、 C から D を引いた値の最大値 番目に E を加えた値の最小値を A の B 番目の C 番目に する
trg = A [ B ] [ C ] = min ( A [ B - 1 ] [ C ] , A [ B - 1 ] [ max ( 0 , C - D ) ] + E , A [ B ] [ max ( 0 , C - D ) ] + E )
rst = A [ B ] [ C ] = min ( A [ B - 1 ] [ C ] , A [ B - 1 ] [ 0 ] + max ( D - D ] ) , E + max ( D [ 0 ] , 0 ) +
2287
src = A から [ len ( B ) forBinC ] の総和を引いた値から C の長さを引いた値の絶対値 を出力する
trg = print ( abs ( A - sum ( [ len ( B ) for B in C ] ) - len ( C ) ) )
rst = print ( A - sum ( [ len ( B ) for B in [ C [ - 1 ] ] C C C ) ) <eos>
2288
src = calc ( B -1, C [1:], 0 ) に (- D ) からなる列を加えた値を A とする
trg = A = calc ( B - 1 , C [ 1 : ] , 0 ) + [ - D ]
rst = A = calc ( B - 1 , C [ 1 : ] , 0 ) + [ - D ) ] <eos>
2289
src = A が B の real より小さいとき 、
trg = if A < B . real :
rst = if A < B . real : <eos>
2290
src = stableCheck ( A , B )
trg = stableCheck ( A , B )
rst = <unk> ( A , B ) <eos>
2291
src = 3.141592653589 793238 を円周率 とする
trg = pi = 3.141592653589793238
rst = pi = <unk> <eos>
2292
src = C を A の B の先頭番目の B の 1 番目番目に する
trg = A [ B [ 0 ] ] [ B [ 1 ] ] = C
rst = A [ B [ 0 ] ] [ B [ 1 ] ] = C <eos>
2293
src = A の B 番目を C の B 番目だけ 減 少 させ る
trg = A [ B ] -= C [ B ]
rst = A [ B ] -= C [ B ] <eos>
2294
src = 0 から E 未満までの数列の各要素を D とし 、0 から C 未満までの数列の各要素を B とし 、0 の列の列を A とする
trg = A = [ [ 0 for B in range ( C ) ] for D in range ( E ) ]
rst = A = [ [ 0 for B in range ( C ) ] for D in range ( E ) ] <eos>
2295
src = 関数 connected を self 、 x 、 y をパラメータとして 定 義 する
trg = def connected ( A , B , C ) : return A . find ( B ) == A . find ( C )
rst = def connected ( A , B , C ) : return A . root ( B ) <eos>
2296
src = (0) からなる列の 26 回分の列を A とする
trg = A = [ 0 ] * 26
rst = A = [ 0 ] * 26 <eos>
2297
src = C の各要素を B とし 、 B を 2 で割った余りが 1 と等しいとき の B の列を A とする
trg = A = [ B for B in C if B % 2 == 1 ]
rst = A = [ B for B in C if B % 2 == 1 ] <eos>
2298
src = put _ queen _ in _ row ( A +1) でないとき 、
trg = if not put_queen_in_row ( A + 1 ) :
rst = if not <unk> ( A + 1 ) : <eos>
2299
src = A の B 番目が 10 と等しいとき 、
trg = if A [ B ] == 10 :
rst = if A [ B ] == 10 : <eos>
2300
src = ( B 、 空列 ) の組を A とする
trg = A = ( B , [ ] )
rst = A = ( B , [ ] ) <eos>
2301
src = 0 から A から 1 を引いた値未満までの数列を順に 無限の整数列 として 、 繰り返 す
trg = for count in range ( A - 1 ) :
rst = for count in range ( A - 1 ) : <eos>
2302
src = write ( A %( B [0] +1))
trg = write ( A % ( B [ 0 ] + 1 ) )
rst = write ( A % ( B [ 0 ] + 1 ) ) <eos>
2303
src = A の B から 2 を引いた値番目の先頭 を出力する
trg = print ( A [ B - 2 ] [ 0 ] )
rst = print ( A [ B - 2 ] [ 0 ] ) <eos>
2304
src = B に C を掛けた値が A より小さいとき B に C を掛けた値 、 そうでなければ A を A とする
trg = A = B * C if B * C < A else A
rst = A = B * C if B * C < A else A <eos>
2305
src = 未定値を A の nskip に する
trg = A . nskip = None
rst = A . nskip = None <eos>
2306
src = A の B を 1 だけ右シフトした値番目 を出力する
trg = print ( A [ B >> 1 ] )
rst = print ( A [ B // 1 ] ) <eos>
2307
src = length ( B , C ) を A とする
trg = A = length ( B , C )
rst = A = length ( B , C ) <eos>
2308
src = C を A の hldrev の B 番目に する
trg = A . hldrev [ B ] = C
rst = A . <unk> [ B ] = C <eos>
2309
src = B の C 番目から 1 を引いた値を 3 で割った余りを A とする
trg = A = ( B [ C ] - 1 ) % 3
rst = A = ( B [ C ] - 1 ) % 3 <eos>
2310
src = A を B の最大値から B の最小値を引いた値 だけ 増 加 させ る
trg = A += max ( B ) - min ( B )
rst = A += max ( B ) - min ( B ) <eos>
2311
src = B の逆順 の整数値を A とする
trg = A = int ( B [ : : - 1 ] )
rst = A = int ( B [ : : - 1 ] ) <eos>
2312
src = B . Node ( C ) を A の right に する
trg = A . right = B . Node ( C )
rst = A . right = B . Node ( C ) <eos>
2313
src = update ( A , B , A [1])
trg = update ( A , B , A [ 1 ] )
rst = update ( A , B , A [ 1 ] ) <eos>
2314
src = A の集合と input () を空白で分割した字句列 の集合の論理積の長さ を出力する
trg = print ( len ( set ( A ) & set ( input ( ) . split ( ) ) ) )
rst = print ( max ( set ( A ) ) . split ( ) ) ) <eos>
2315
src = 0 を A の B 番目の C から B を引いた値番目に する
trg = A [ B ] [ C - B ] = 0
rst = A [ B ] [ C - B ] = 0 <eos>
2316
src = B から 1 を引いた値に 4 を掛けた値に C を加えた値から 1 を引いた値を A とする
trg = A = ( B - 1 ) * 4 + C - 1
rst = A = ( B - 1 ) * 4 + C - 1 <eos>
2317
src = 空白文字を間に入れて B の各要素を A とし 、 len ( A ) の列をソートした列 の各要素に整数を適用した列 を連結した文字列 、 C の長さ を出力する
trg = print ( ' ' . join ( map ( str , sorted ( [ len ( A ) for A in B ] ) ) ) , len ( C ) )
rst = print ( ' ' . join ( [ str ( A ) ) , [ str ( map ( str , A ) for A in B ] ) ) <eos>
2318
src = A に B を掛けた値に C に D を掛けた値を加えた値が 0 より小さいとき 、
trg = if A * B + C * D < 0 :
rst = if A * B + C * D < 0 : <eos>
2319
src = A の末尾に B が C 以下のとき ( B 、 C ) の組 、 そうでなければ ( C 、 B ) の組 を追加する
trg = A . append ( ( B , C ) if B <= C else ( C , B ) )
rst = A . append ( ( B , C ) if B <= C else ( C , B ) ) <eos>
2320
src = A が 0 と等しくまたは B が 0 より小さいとき 、
trg = if A == 0 or B < 0 :
rst = if A == 0 or B < 0 : <eos>
2321
src = 0 から 8 未満までの数列の各要素を B とし 、 、 つまり入力された文字列のリスト の列を A とする
trg = A = [ list ( input ( ) ) for B in range ( 8 ) ]
rst = A = [ list ( input ( ) ) for B in range ( 8 ) ] <eos>
2322
src = A の B に C の B 番目を加えた値を D で割った余り 番目の末尾に B を追加する
trg = A [ ( B + C [ B ] ) % D ] . append ( B )
rst = A [ B + C [ B ] ] % D ] append append ( B ) <eos>
2323
src = 0 が A 以下かどうかが B より小さいとき 、
trg = if 0 <= A < B :
rst = if 0 <= A < B : <eos>
2324
src = A の prev が 、 つまり未定値と等しいとき 、
trg = if A . prev == None :
rst = if A . prev == None : <eos>
2325
src = A が B の 1 番目以上かつ A が B の 2 番目より小さいとき 、
trg = if A >= B [ 1 ] and A < B [ 2 ] :
rst = if A >= B [ 1 ] and A < B [ 2 ] : <eos>
2326
src = 0 から B の長さ未満までの数列の各要素を C とし 、 cross 3( B [ C -1], B [ C ] , D ) の列を A とする
trg = A = [ cross3 ( B [ C - 1 ] , B [ C ] , D ) for C in range ( len ( B ) ) ]
rst = A = [ cross3 ( B [ C - 1 ] , B [ C ] , D ) for C in range ( len ( B ) ) ] <eos>
2327
src = inside ( A + B [ C ] , D + E [ C ] ) でないとき 、
trg = if not inside ( A + B [ C ] , D + E [ C ] ) :
rst = if ( ( A + B [ C ] , D + E [ C ] ) : <eos>
2328
src = A の imag が B の imag より小さいかどうかが C の imag より小さいとき 、
trg = if A . imag < B . imag < C . imag :
rst = if A . imag < B . imag < C . imag : <eos>
2329
src = score ( B +1, C ,0) 、 D から E を引いた値に score ( B , C +1,0) を加えた値の最小値を A とする
trg = A = min ( score ( B + 1 , C , 0 ) , D - E + score ( B , C + 1 , 0 ) )
rst = A = min ( score ( B + 1 , C , 0 ) + score ( D - E ) score score ( B , C + 1 ) ) <eos>
2330
src = A の 、 つまり先頭から 2 番目までの部分列が B と等しくかつ A の -1 番目が C と等しいとき 、
trg = if A [ : 2 ] == B and A [ - 1 ] == C :
rst = if A [ : 2 ] == B and A [ - 1 ] == C : <eos>
2331
src = ( B の先頭から C の先頭を引いた値 、 B の 1 番目から C の 1 番目を引いた値 ) の組を A とする
trg = A = ( B [ 0 ] - C [ 0 ] , B [ 1 ] - C [ 1 ] )
rst = A = ( B [ 0 ] , C [ 0 ] , B [ 1 ] - C [ 1 ] ) <eos>
2332
src = D の各要素を C 、 B とし 、 B の列の集合を A とする
trg = A = set ( [ B for C , B in D ] )
rst = A = set ( [ B for C , B in D ] ) <eos>
2333
src = A から 1 を引いた値が 0 以上の 間 、 次 を 繰り返 す
trg = while A - 1 >= 0 :
rst = while A - 1 >= 0 : <eos>
2334
src = A に B を加えた値が C 以下または B に C を加えた値が A 以下または C に A を加えた値が B 以下のとき 、
trg = if A + B <= C or B + C <= A or C + A <= B :
rst = if A + B <= C or B + C <= A or C + A <= B : <eos>
2335
src = A の key が B の right と等しいとき 、
trg = if A . key == B . right :
rst = if A . key == B . right : <eos>
2336
src = A 、 B 、 C の最小値の最小値 を A とする
trg = A = min ( A , min ( B , C ) )
rst = A = min ( A , min ( B , C ) ) <eos>
2337
src = D を A の B 番目の C 番目に する
trg = A [ B ] [ C ] = D
rst = A [ B ] [ C ] = D <eos>
2338
src = A の B 番目から B に 3 を加えた値までの部分列が ( C 、 D 、 E ) からなる列と等しいとき 、
trg = if A [ B : B + 3 ] == [ C , D , E ] :
rst = if A [ B : B + 3 ] [ [ C , D , E ] : <eos>
2339
src = solve (0, A ) のとき B 、 そうでなければ C を出力する
trg = print ( B if solve ( 0 , A ) else C )
rst = print ( B if solve ( 0 , A ) else C ) <eos>
2340
src = minkowsuki ( A , B ,1) を出力する
trg = print ( minkowsuki ( A , B , 1 ) )
rst = print ( minkowsuki ( A , B , 1 ) ) <eos>
2341
src = 0 から C 未満までの数列の各要素を B とし 、 、 つまり入力された文字列の整数値 の列 の両端キューを A とする
trg = A = deque ( [ int ( input ( ) ) for B in range ( C ) ] )
rst = A = deque ( [ int ( input ( ) ) for B in range ( C ) ] ) <eos>
2342
src = A の位置 C の left から B を探して見つかった位置 を返す
trg = return A . find ( B , C . left )
rst = return A . find ( B , C . left ) <eos>
2343
src = A の先頭に B を加えた値が A の B 番目と等しいとき 、
trg = if A [ 0 ] + B == A [ B ] :
rst = if A [ 0 ] + B == A [ B ] : <eos>
2344
src = put _ queen ( A , B )
trg = put_queen ( A , B )
rst = put_queen ( A , B ) <eos>
2345
src = drop ( B , C , D +1, E ) を A とする
trg = A = drop ( B , C , D + 1 , E )
rst = A = drop ( B , C , D + 1 , E ) <eos>
2346
src = B の長さを A の child _ cnt に する
trg = A . child_cnt = len ( B )
rst = A . queen_pos = len ( B ) <eos>
2347
src = A の B の 1 番目番目の B の先頭番目が C と等しいとき 、
trg = if A [ B [ 1 ] ] [ B [ 0 ] ] == C :
rst = if A [ B [ 1 ] ] [ B [ 0 ] ] == C : <eos>
2348
src = 1
trg = 1
rst = 1 <eos>
2349
src = B の両端から 空白改行を取り除いた文字列 の浮動小数点数を A とする
trg = A = float ( B . strip ( ) )
rst = A = float ( B . strip ( ) ) <eos>
2350
src = judge ( A , B )
trg = judge ( A , B )
rst = judge ( A , B ) <eos>
2351
src = A に B を掛けた値から C に D [ E ] の F 番目を掛けた値を引いた値 に D の E 番目の F に G を加えた値番目を加えた値 と H の論理積を A とする
trg = A = ( A * B - C * D [ E ] [ F ] + D [ E ] [ F + G ] ) & H
rst = A = ( A * B - C * D [ E ] [ F ] + D [ E ] [ F + G ] + F ) <eos>
2352
src = A 、 B に C を加えた値 、 B に 200 を掛けた値に C に 300 を掛けた値を加えた値 を出力する
trg = print ( A , B + C , B * 200 + C * 300 )
rst = print ( A , B + C , B * 200 + C * 300 ) <eos>
2353
src = A の B 番目の C 番目の 1 番目を 1 だけ 増 加 させ る
trg = A [ B ] [ C ] [ 1 ] += 1
rst = A [ B ] [ C ] [ 1 ] += 1 <eos>
2354
src = ( 4 、 A の B 番目 ) からなる列を返す
trg = return [ 4 , A [ B ] ]
rst = return [ 4 , A [ B ] ] <eos>
2355
src = time は グ ロー バ ル 変数 とする
trg = global time
rst = global time <eos>
2356
src = A が 5 以上の 間 、 次 を 繰り返 す
trg = while A >= 5 :
rst = while A >= 5 : <eos>
2357
src = 空白文字を間に入れて 、 つまり逆順に input (). split () の各要素を B とし 、 int ( B ) の列をソートした列の各要素を A とし 、 A の文字列の列を連結した文字列 を出力する
trg = print ( ' ' . join ( [ str ( A ) for A in sorted ( [ int ( B ) for B in input ( ) . split ( ) ] , reverse = True ) ] ) )
rst = print ( ' ' . join ( [ str ( A ) for A in [ int ( [ int ( B ) for B in input ( ) ) ) for B in input ( ) . split ( ) ] ) ) ) <eos>
2358
src = (0) からなる列の B に 1 を加えた値回分の列を C とする
trg = C = [ 0 ] * ( B + 1 )
rst = C = [ 0 ] * ( B + 1 ) <eos>
2359
src = (0) からなる列の 100 回分の列 のリストを A とする
trg = A = list ( [ 0 ] * 100 )
rst = A = list ( [ 0 ] * 100 ) <eos>
2360
src = A の B 番目の C 番目 、0 の最大値に D の C に 1 を加えた値番目を加えた値から D の B 番目を引いた値を A の B 番目の C 番目に する
trg = A [ B ] [ C ] = max ( A [ B ] [ C ] , 0 ) + D [ C + 1 ] - D [ B ]
rst = A [ B ] [ C ] = max ( A [ B ] [ C ] , 0 ) + D [ C + 1 ] ) + D [ B ] <eos>
2361
src = A を B に C を掛けた値 、 D に C を掛けた値に E を加えた値の最小値 だけ 増 加 させ る
trg = A += min ( B * C , D * C + E )
rst = A += min ( B * C , D * C + E ) <eos>
2362
src = 2 に 10 の 6 乗を掛けた値を A とする
trg = A = 2 * 10 ** 6
rst = A = 2 * 10 ** 6 <eos>
2363
src = 0 が A の長さ と等しいとき 、
trg = if 0 == len ( A ) :
rst = if ( 0 == len ( A ) ) : <eos>
2364
src = A を B に C から 1 を引いた値を掛けた値を D で割った余りだけ 増 加 させ る
trg = A += B * ( C - 1 ) % D
rst = A += B * ( C - 1 ) % D <eos>
2365
src = A の末尾に B 、 C から 1 を引いた値 、 D の総和 を追加する
trg = A . append ( B . sum ( C - 1 , D ) )
rst = A . append ( max ( B , C - 1 , D ) ) <eos>
2366
src = pt をパラメータとして ( C の y 座標 、 C の x 座標 ) の組を返す関数をキーとして B をソートした列の先頭を A とする
trg = A = sorted ( B , key = lambda C : ( C . y , C . x ) ) [ 0 ]
rst = A = sorted ( B , key = lambda C : C . y , C . x ) ] <eos>
2367
src = (0、1) からなる列の各要素を D とし 、0 から C 未満までの数列の列の各要素を B とし 、 A の B に C に D を掛けた値を加えた値 番目の列を A とする
trg = A = [ A [ B + C * D ] for B in [ range ( C ) for D in [ 0 , 1 ] ] ]
rst = A = [ [ B + C * D for B in [ range ( C ) ] for D in [ 0 , D ] ] ] <eos>
2368
src = A が 5 より小さくかつ B の A 番目が C と等しい 間 、 次 を 繰り返 す
trg = while A < 5 and B [ A ] == C :
rst = while A < 5 and B [ A ] == C : <eos>
2369
src = 0 から B 未満までの数列を A とする
trg = A = range ( B )
rst = A = range ( B ) <eos>
2370
src = exec ( A + B + C )
trg = exec ( A + B + C )
rst = <unk> ( A + B + C ) <eos>
2371
src = C の 1 番目を B の 1 番目に する
trg = B [ 1 ] = C [ 1 ]
rst = B [ 1 ] = C [ 1 ] <eos>
2372
src = A の各要素をネイピア数 とし 、 、 つまりネイピア数が 2 と等しいかどうかの列の総和 を出力する
trg = print ( sum ( [ e == 2 for e in A ] ) )
rst = print ( sum ( [ e == 2 for e in A ] ) ) <eos>
2373
src = A 、 B に C を掛けた値を A で割った値の整数値 を出力する
trg = print ( A , int ( B * C / A ) )
rst = print ( int ( A , B * C / A ) ) <eos>
2374
src = A の B から 1 を引いた値番目が A の C から 1 を引いた値番目と等しいとき 、
trg = if A [ B - 1 ] == A [ C - 1 ] :
rst = if A [ B - 1 ] == A [ C - 1 ] : <eos>
2375
src = ネイピア数を 1 だけ 増 加 させ る
trg = e += 1
rst = e += 1 <eos>
2376
src = A から B を引いた値が 3 より大きいとき 、
trg = if A - B > 3 :
rst = if A - B > 3 : <eos>
2377
src = 1000000000 を A とする
trg = A = 1000000000
rst = A = 1000000000 <eos>
2378
src = B に C から D を引いた値を掛けた値に E から D を引いた値に F から B を引いた値を掛けた値を加えた値を A とする
trg = A = ( B * ( C - D ) + ( E - D ) * ( F - B ) )
rst = A = B * ( C - D ) + ( E - D ) * ( F - B ) <eos>
2379
src = B に C の D 番目を加えた値を A とする
trg = A = B + C [ D ]
rst = A = B + C [ D ] <eos>
2380
src = A を B で割った商に 1 を加えた値 、0 の最大値 を出力する
trg = print ( max ( A // B + 1 , 0 ) )
rst = print ( max ( A // B + 1 , 0 ) ) <eos>
2381
src = 0 が A の B 番目より小さいとき C に A の B 番目を掛けた値 、 そうでなければ D を出力する
trg = print ( C * A [ B ] if 0 < A [ B ] else D )
rst = print ( C * A [ B ] if C < A [ B ] else D ) <eos>
2382
src = A が 9 より大きいとき 、
trg = if A > 9 :
rst = if A > 9 : <eos>
2383
src = A を B で割った余りが C に含まれるとき 、
trg = if A % B in C :
rst = if A % B in C : <eos>
2384
src = A の B 番目の C 番目が 0 と等しいとき 、
trg = if A [ B ] [ C ] == 0 :
rst = if A [ B ] [ C ] == 0 : <eos>
2385
src = bfs 2( A , B )
trg = bfs2 ( A , B )
rst = f2 ( A , B ) <eos>
2386
src = A に 2 を掛けた値から 1 を引いた値を A とする
trg = A = A * 2 - 1
rst = A = A * 2 - 1 <eos>
2387
src = 改行文字を間に入れて B の各要素に A を適用した列を連結した文字列 を出力する
trg = print ( '\n' . join ( map ( A , B ) ) )
rst = print ( '\n' . join ( map ( A , B ) ) ) <eos>
2388
src = 0 から B +1 から C を引いた値から D を引いた値から E を引いた値 、 10 の最小値 未満までの数列を順に A として 、 繰り返 す
trg = for A in range ( min ( B + 1 - C - D - E , 10 ) ) :
rst = for A in range ( min ( B + 1 - C - D - E , 0 ) ) : <eos>
2389
src = 0 から B 未満までの数列のリストを A の par に する
trg = A . par = list ( range ( B ) )
rst = A . par = list ( range ( B ) ) <eos>
2390
src = 空文字列を間に入れて A を連結した文字列を A とする
trg = A = '' . join ( A )
rst = A = '' . join ( A ) <eos>
2391
src = _ add ( A . left ) を A の left に する
trg = A . left = _add ( A . left )
rst = A . left = _add ( A . left ) <eos>
2392
src = A に B の C 番目を掛けた値から D に B の C 番目に E を加えた値 を掛けた値を引いた値を返す
trg = return A * B [ C ] - D * ( B [ C ] + E )
rst = return A * B [ C ] * D + B [ C ] + E <eos>
2393
src = heappush ( A , ( B , C , D , E , F +1))
trg = heappush ( A , ( B , C , D , E , F + 1 ) )
rst = heappush ( A , ( B , C , D , E , F + 1 ) ) <eos>
2394
src = A を 100 だけ 減 少 させ る
trg = A -= 100
rst = A -= 100 <eos>
2395
src = A を B の C の D 番目番目だけ 減 少 させ る
trg = A -= B [ C [ D ] ]
rst = A -= B [ C [ D ] ] <eos>
2396
src = calc ( D * E * F - G * H * I , I * E * F ) を A の B 番目の C 番目に する
trg = A [ B ] [ C ] = calc ( D * E * F - G * H * I , I * E * F )
rst = A [ B ] [ C ] = calc ( D * E * F - G * H * G * I * E * F * E ) <eos>
2397
src = A に Edge ( B , C , D , E ) を追加した集まり
trg = A . add ( Edge ( B , C , D , E ) )
rst = A . add ( Edge ( B , C , D , E ) ) <eos>
2398
src = A が ((0、0) の組 、(1、0) の組 、(2、0) の組 、(3、0) の組 ) からなる列と等しいとき 、
trg = if A == [ ( 0 , 0 ) , ( 1 , 0 ) , ( 2 , 0 ) , ( 3 , 0 ) ] :
rst = if A == [ ( 0 , 0 ) , ( 2 , 0 ) , ( 0 , 2 ) , ( 0 , 1 ) ] : <eos>
2399
src = 0 から C の長さに 1 を加えた値未満までの数列の各要素 を B とし 、0 の列を A とする
trg = A = [ 0 for B in range ( len ( C ) + 1 ) ]
rst = A = [ 0 for B in range ( len ( C ) + 1 ) ] <eos>
2400
src = A の B 番目の C 番目を A の B に 1 を加えた値番目の C 番目に する
trg = A [ B + 1 ] [ C ] = A [ B ] [ C ]
rst = A [ B + 1 ] [ C ] = A [ B ] [ C ] <eos>
2401
src = A を B を 2 で割った余りの文字列 だけ 増 加 させ る
trg = A += str ( B % 2 )
rst = A += str ( B % 2 ) <eos>
2402
src = 0 から 2 の A . height に 1 を加えた値 乗から 1 を引いた値 未満までの数列の各要素を B とし 、0 の列を A の nodes に する
trg = A . nodes = [ 0 for B in range ( pow ( 2 , A . height + 1 ) - 1 ) ]
rst = A . nodes = [ 0 for B in range ( 2 ** 2 . + 1 ) - 1 ) ] <eos>
2403
src = check ( int ( input ())) のとき 、
trg = if check ( int ( input ( ) ) ) :
rst = if check ( int ( input ( ) ) ) : <eos>
2404
src = f _ dfs ( A )
trg = f_dfs ( A )
rst = <unk> ( A ) <eos>
2405
src = A . all () のとき 、
trg = if A . all ( ) :
rst = if A . <unk> ( ) : <eos>
2406
src = query (0,0, A . size ) を返す
trg = return query ( 0 , 0 , A . size )
rst = return rec ( 0 , 0 , A . size ) <eos>
2407
src = 0 が A より小さいかどうかが B の width から 1 を引いた値 より小さくなくまたは 0 が C より小さいかどうかが B の height から 1 を引いた値 より小さくないとき 、
trg = if ( not 0 < A < B . width - 1 ) or ( not 0 < C < B . height - 1 ) :
rst = if not 0 < A < B . width - 1 < not 0 < C < B . height - 1 ) : <eos>
2408
src = A の B 番目の長さが 2 と等しい 間 、 次 を 繰り返 す
trg = while len ( A [ B ] ) == 2 :
rst = while len ( A [ B ] ) == 2 : <eos>
2409
src = 100+ A * 16 +15* B +15* C に 7* D を加えた値に 2 に E を掛けた値を加えた値に 3 に F を掛けた値を加えた値から G に 3 を掛けた値を引いた値 を出力する
trg = print ( 100 + A * 16 + 15 * B + 15 * C + 7 * D + 2 * E + 3 * F - G * 3 )
rst = print ( 100 + A * 16 ** B ) + C * D + 2 * E + 2 * E + 3 * F - F * 3 ) <eos>
2410
src = B . intersect ( C ) を A とする
trg = A = B . intersect ( C )
rst = A = B . Node ( C ) <eos>
2411
src = 0 から C 未満までの数列の各要素を B とし 、 B に 1 を加えた値の列 の逆順を A とする
trg = A = [ B + 1 for B in range ( C ) ] [ : : - 1 ]
rst = A = [ B + 1 for B in range ( C ) ] [ : : - 1 ] <eos>
2412
src = B の長さが 6 と等しくかつ C の長さが 6 と等しいとき 、 つまり真 、 そうでなければ 、 つまり偽 を A とする
trg = A = True if len ( B ) == 6 and len ( C ) == 6 else False
rst = A = True if len ( B ) == 6 and len ( C ) == 6 else False <eos>
2413
src = erase ( A , count , B [1]) を展開し 、 それぞれ A 、 無限の整数列 とする
trg = A , count = erase ( A , count , B [ 1 ] )
rst = A , count = erase ( A , count , B [ 1 ] ) <eos>
2414
src = 入力された文字列を空白 文字で分割した字句列の各要素を B とし 、 B の整数値の列の組を A とする
trg = A = tuple ( [ int ( B ) for B in input ( ) . split ( ' ' ) ] )
rst = A = tuple ( [ int ( B ) for B in input ( ) . split ( ' ' ) ] ) <eos>
2415
src = calc ( A ) を返す
trg = return calc ( A )
rst = return calc ( A ) <eos>
2416
src = C の D に E を加えた値番目の F に G を加えた値番目の H 番目の I から 1 を引いた値番目 を順に A 、 B 、 ネイピア数 として 、 繰り返 す
trg = for A , B , e in C [ D + E ] [ F + G ] [ H ] [ I - 1 ] :
rst = for A , B , e in C [ D + E ] [ F + G ] [ H ] H ] ] : <eos>
2417
src = 0 から C 未満までの数列の各要素を B とし 、 B に 1 を加えた値の列の順列のリストを 順に A として 、 繰り返 す
trg = for A in list ( itertools . permutations ( [ B + 1 for B in range ( C ) ] ) ) :
rst = for A in reversed ( [ B + 1 for B in range ( C ) ] ) : <eos>
2418
src = CHECK _ NUM ( A , B )
trg = CHECK_NUM ( A , B )
rst = <unk> ( A , B ) <eos>
2419
src = A の B 番目から 、 つまり末尾までの部分列に A の 、 つまり先頭から B 番目までの部分列を加えた値を そうでなければ 、 とする
trg = else = A [ B : ] + A [ : B ]
rst = else = A [ B : ] + A [ : B ] <eos>
2420
src = dfs (0, A [0]) を出力する
trg = print ( dfs ( 0 , A [ 0 ] ) )
rst = print ( dfs ( 0 , A [ 0 ] ) ) <eos>
2421
src = A . spin _ left ()
trg = A . spin_left ( )
rst = A . <unk> ( ) <eos>
2422
src = - manhattan ( A . size , B , C )
trg = - manhattan ( A . size , B , C )
rst = - ( - A . size , B , C ) <eos>
2423
src = - C から A の weights の D 番目を引いた値に A の weights の E 番目を加えた値を A の weights の B 番目に する
trg = A . weights [ B ] = - C - A . weights [ D ] + A . weights [ E ]
rst = A . weights [ B ] = - C - A . weights [ D ] + A . weights [ E ] <eos>
2424
src = A の B 番目の C 番目 、 A の B に 1 を加えた値番目の C 番目の最大値を A の B に 1 を加えた値番目の C 番目に する
trg = A [ B + 1 ] [ C ] = max ( A [ B ] [ C ] , A [ B + 1 ] [ C ] )
rst = A [ B + 1 ] [ C ] = max ( A [ B ] [ C ] , A [ B + 1 ] [ C ] ) <eos>
2425
src = B を空白で分割した字句列を A とする
trg = A = B . split ( )
rst = A = B . split ( ) <eos>
2426
src = 辞書の A の B 番目番目が 0 より大きいとき 、
trg = if dict [ A [ B ] ] > 0 :
rst = if dict [ A [ B ] ] > 0 : <eos>
2427
src = 改行せずに A を ( B 、 C の B 番目の p 、 C の B 番目の sib 、 2 から C [ B ] . c 内の -1 の出現回数を引いた値 ) の組で割った余り を出力する
trg = print ( A % ( B , C [ B ] . p , C [ B ] . sib , 2 - C [ B ] . c . count ( - 1 ) ) , end = '' )
rst = print ( A % ( B , C [ B . . p , C [ B ] . . , 2 - C [ B ] . . quantize ( 1 , - 1 ) ) <eos>
2428
src = A を B に対応する値 、 もし存在しなければ ( C の末尾 、 C の先頭 ) の組 、0 だけ 増 加 させ る
trg = A += B . get ( ( C [ - 1 ] , C [ 0 ] ) , 0 )
rst = A += B . get ( ( C - 1 ] , C [ 0 ] ) , 0 <eos>
2429
src = A に B を加えた値を C で割った余りが D と等しいとき 、
trg = if ( A + B ) % C == D :
rst = if ( A + B ) % C == D : <eos>
2430
src = 空文字列を間に入れて A の B 番目を連結した文字列を出力する
trg = print ( '' . join ( A [ B ] ) )
rst = print ( '' . join ( A [ B ] ) ) <eos>
2431
src = slide ( B , C * D ) を A とする
trg = A = slide ( B , C * D )
rst = A = slide ( B , C * D ) <eos>
2432
src = B を 100 で割った商を A とする
trg = A = B // 100
rst = A = B // 100 <eos>
2433
src = closest _ part 2( B [ : C ] , C ) 、 closest _ part 2( B [ C : ] , D - C ) の最小値を A とする
trg = A = min ( closest_part2 ( B [ : C ] , C ) , closest_part2 ( B [ C : ] , D - C ) )
rst = A = min ( closest_part1 ( B [ : C ] , C ) , closest_part1 = B [ C : ] , D - C ) ) <eos>
2434
src = 空文字列を間に入れて 0 から C 未満までの数列の各要素を B とし 、 readline () の両端から 空白改行を取り除いた文字列 の列を連結した文字列を A とする
trg = A = '' . join ( [ readline ( ) . strip ( ) for B in range ( C ) ] )
rst = A = '' . join ( [ readline ( ) . strip ( ) for B in range ( C ) ] ) <eos>
2435
src = ( A の B と等しい要素の最初の位置 、 B ) の組を返す
trg = return ( A . index ( B ) , B )
rst = return ( A . index ( B ) , B ) <eos>
2436
src = A 、 B の C 番目の先頭 、 B の C 番目の末尾 の最小値を A とする
trg = A = min ( A , B [ C ] [ 0 ] , B [ C ] [ - 1 ] )
rst = A = min ( A , B [ C ] [ 0 ] , B [ C ] [ - 1 ] ) <eos>
2437
src = A の 、 つまり先頭から B に 1 を加えた値までの部分列に ( C ) からなる列を加えた値に A の B に 1 を加えた値から 、 つまり末尾までの部分列を加えた値 を A とする
trg = A = A [ : B + 1 ] + [ C ] + A [ B + 1 : ]
rst = A = A [ : B + 1 ] + [ C ] + A [ B + 1 : ] <eos>
2438
src = 0 から A の長さから 1 を引いた値 未満までの数列の各要素を B とし 、 A の B 番目に A の B に 1 を加えた値番目を加えた値を 10 で割った余りの列を A とする
trg = A = [ ( A [ B ] + A [ B + 1 ] ) % 10 for B in range ( len ( A ) - 1 ) ]
rst = A = [ ( B [ B ] + A [ B + 1 ] ) % ( for B in range ( len ( A ) - 1 ) ] <eos>
2439
src = 0 から 、 つまりネイピア数 未満までの数列の各要素を B とし 、 、 つまり入力された文字列 を空白で分割した字句列の各要素に 整数を適用した列のリストの列を A とする
trg = A = [ list ( map ( int , input ( ) . split ( ) ) ) for B in range ( e ) ]
rst = A = [ list ( map ( int , input ( ) . split ( ) ) ) for B in range ( e ) ] <eos>
2440
src = A の B に C を加えた値番目と A の B 番目を 入れ 替 え る
trg = A [ B + C ] , A [ B ] = A [ B ] , A [ B + C ]
rst = A [ B + C ] , A [ B ] = A [ B ] , A [ B + C ] <eos>
2441
src = A の総和に B の総和 を掛けた値を出力する
trg = print ( sum ( A ) * sum ( B ) )
rst = print ( sum ( A ) * sum ( B ) ) <eos>
2442
src = A の長さが 10 より小さい 間 、 次 を 繰り返 す
trg = while len ( A ) < 10 :
rst = while len ( A ) < 10 : <eos>
2443
src = 0 から C 未満までの数列の各要素を B とし 、0 の列を A の deg に する
trg = A . deg = [ 0 for B in range ( C ) ]
rst = A . parents = [ 0 for B in range ( C ) ] <eos>
2444
src = A の末尾に ( B 、 C の D +1 番目の B 番目のとき D 、 そうでなければ D に 1 を加えた値 、 E 、 C の F -1 番目の E 番目のとき F 、 そうでなければ F から 1 を引いた値 、 G ) の組 を追加する
trg = A . append ( ( B , D if C [ D + 1 ] [ B ] else D + 1 , E , F if C [ F - 1 ] [ E ] else F - 1 , G ) )
rst = A . append ( D if B if C [ D + 1 ] [ B ] if D if D [ 1 ] - E else E if F , ( F , F - 1 ) else F ) ) <eos>
2445
src = _ remove ( A . left )
trg = _remove ( A . left )
rst = _remove ( A . left ) <eos>
2446
src = A のとき A の末尾の 0 番目 、 そうでなければ 0 が B の C 番目の D 番目より小さいとき 、
trg = if ( A [ - 1 ] [ 0 ] if A else 0 ) < B [ C ] [ D ] :
rst = if A A [ - 1 ] [ 0 ] if B < 0 < B < C [ D ] [ D ] : <eos>
2447
src = A を 0 から C //2+1 未満までの数列の各要素を B とし 、 ( B **2+( C - B )**2)**0.5 - e の絶対値の列の最小値 で割った余りを出力する
trg = print ( A % ( min ( [ abs ( ( B ** 2 + ( C - B ) ** 2 ) ** 0.5 - e ) for B in range ( C // 2 + 1 ) ] ) ) )
rst = print ( max ( A [ ( [ 2 : ] - ( - B B [ - 1 ] ) ) for B in range ( C ) C ) ] ) <eos>
2448
src = dfs (0, B ) を A とする
trg = A = dfs ( 0 , B )
rst = A = dfs ( 0 , B ) <eos>
2449
src = A の末尾に ( B 、 - C 、 D ) の組 を追加する
trg = A . append ( ( B , - C , D ) )
rst = A . append ( ( B , - C , D ) ) <eos>
2450
src = 2*( B - C )* D から E **2 を引いた値から B の 2 乗を引いた値に F の 2 乗を加えた値に C の 2 乗を加えた値を 2 に F から E を引いた値 を掛けた値で割った値を A とする
trg = A = ( 2 * ( B - C ) * D - E ** 2 - B ** 2 + F ** 2 + C ** 2 ) / ( 2 * ( F - E ) )
rst = A = ( ( ( - B - C ) * ( D - E ) ** 2 - ( ** 2 + F ** 2 ) / 2 + ( F - F ) * ( F - E ) <eos>
2451
src = ( 、 つまり無限大 ) からなる列の B に 1 を加えた値回分の列を A とする
trg = A = [ inf ] * ( B + 1 )
rst = A = [ inf ] * ( B + 1 ) <eos>
2452
src = A の B 番目の末尾に ( C 、0、- D 、 A の C 番目の長さから 1 を引いた値 ) からなる列 を追加する
trg = A [ B ] . append ( [ C , 0 , - D , len ( A [ C ] ) - 1 ] )
rst = A [ B ] . append ( [ C [ - 1 ] , D , len ( A [ C ] ) - 1 ] ) <eos>
2453
src = reconstruction ( A , B )
trg = reconstruction ( A , B )
rst = <unk> ( A , B ) <eos>
2454
src = 0 から D 未満までの数列の各要素を C とし 、 、 つまり入力された文字列を空白 文字で分割した字句列の各要素を B とし 、 B の整数値の列の列を A とする
trg = A = [ [ int ( B ) for B in input ( ) . split ( ' ' ) ] for C in range ( D ) ]
rst = A = [ [ int ( B ) for B in input ( ) . split ( ' ' ) ] for C in range ( D ) ] <eos>
2455
src = B に C を掛けた値に D のラジアンの正弦を掛けた値を 2 で割った値を A とする
trg = A = B * C * math . sin ( math . radians ( D ) ) / 2
rst = A = B * C * math . sin ( math . radians ( D ) ) / 2 <eos>
2456
src = ( 771 、 16843009 、15、 66306 、 1539 、 131841 、 774 ) からなる列を A とする
trg = A = [ 771 , 16843009 , 15 , 66306 , 1539 , 131841 , 774 ]
rst = A = [ <unk> , <unk> , <unk> , <unk> , <unk> , <unk> , <unk> , <unk> , <unk> , <unk> , <unk> , <unk> , <unk> , <unk> , <unk> , <unk> ] <eos>
2457
src = 0 から C に C から 1 を引いた値を掛けた値を 2 で割った商 未満までの数列の各要素を B とし 、 、 つまり入力された文字列 を空白で分割した字句列の各要素に 整数を適用した列のリストの列を A とする
trg = A = [ list ( map ( int , input ( ) . split ( ) ) ) for B in range ( C * ( C - 1 ) // 2 ) ]
rst = A = [ list ( map ( int , input ( ) . split ( ) ) ) for B in range ( C C - 1 ) // 2 ) ] <eos>
2458
src = G に C に H を掛けた値を E で割った値を加えた値を F とする
trg = F = G + C * H / E
rst = F = G G + C * H / E <eos>
2459
src = A を B の C の D の 、 つまり先頭から 4 番目までの部分列 と等しい要素の最初の位置番目 だけ 増 加 させ る
trg = A += B [ C . index ( D [ : 4 ] ) ]
rst = A += B [ C . index ( D [ : 4 ] ) ] <eos>
2460
src = ( B の 0 番目を C で割った値 、 B の 1 番目を C で割った値 ) からなる列を A とする
trg = A = [ B [ 0 ] / C , B [ 1 ] / C ]
rst = A = [ B [ 0 ] / C , B [ 1 ] / C ] <eos>
2461
src = A の文字列を B とする
trg = B = str ( A )
rst = B = int ( A ) <eos>
2462
src = 0 から C 未満までの数列の各要素を B とし 、 、 つまり入力された文字列 を空白文字で分割した字句列 の先頭 の整数値の列を A とする
trg = A = [ int ( input ( ) . split ( ' ' ) [ 0 ] ) for B in range ( C ) ]
rst = A = [ int ( input ( ) . split ( ' ' ) ) for B in range ( C ) ] <eos>
2463
src = B を _ pow (10,2 0 ) で割った商を A とする
trg = A = B // _pow ( 10 , 20 )
rst = A = B // _pow ( 10 , 0 ) <eos>
2464
src = A の graph の 、 つまりネイピア数の先頭番目 の末尾にネイピア数の 1 番目を追加する
trg = A . graph [ e [ 0 ] ] . append ( e [ 1 ] )
rst = A . graph [ e [ e ] ] [ 1 ] ] <eos>
2465
src = solve ( C , D ) を展開し 、 それぞれ A 、 B とする
trg = A , B = solve ( C , D )
rst = A , B = solve ( C , D ) <eos>
2466
src = A の B 番目から C を引いた値から D を引いた値が E 以上のとき 、
trg = if A [ B ] - C - D >= E :
rst = if A [ B ] - C - D >= E : <eos>
2467
src = A の 、 つまり先頭から 9 番目までの 4 間隔による部分列内の B の出現回数が 3 と等しくまたは A の 2 番目から 7 番目までの 2 間隔による部分列内の B の出現回数が 3 と等しいとき 、
trg = if A [ 0 : 9 : 4 ] . count ( B ) == 3 or A [ 2 : 7 : 2 ] . count ( B ) == 3 :
rst = if A [ : 9 : 4 ] . count ( B ) == 3 or A [ 2 : 7 ] 2 ] . count ( B ) == 3 : <eos>
2468
src = 空文字列を間に入れて 1 を reverse として B をソートした列を連結した文字列 の整数値から 、 つまり空文字列を間に入れて B をソートした列を連結した文字列 の整数値を引いた値を A とする
trg = A = int ( '' . join ( sorted ( B , reverse = 1 ) ) ) - int ( '' . join ( sorted ( B ) ) )
rst = A = '' . join ( sorted ( list ( sorted ( B ) ) ) - int ( '' ) ) ) ) ) ) ) ) <eos>
2469
src = ネイピア数が 5 以下のとき 、
trg = if e <= 5 :
rst = if e <= 5 : <eos>
2470
src = Multi _ map () を A とする
trg = A = Multi_map ( )
rst = A = <unk> ( ) <eos>
2471
src = B . next ( C ) を A とする
trg = A = B . next ( C )
rst = A = B . Node ( C ) <eos>
2472
src = ( A が B より小さいかどうか 、 C が D より小さいかどうか 、 E が F より小さいかどうか 、 G が H より小さいかどうか ) の組が 少 なく と も ひ とつは真 のとき 、
trg = if any ( ( A < B , C < D , E < F , G < H ) ) :
rst = if any ( A < B ) , C < D , E < F , ( F < H ) : <eos>
2473
src = B から読み込んだ一行を 空白で分割した字句列 の各要素に整数を適用した列を順に A として 、 繰り返 す
trg = for A in map ( int , B . readline ( ) . split ( ) ) :
rst = for A in map ( int , B . readline ( ) . split ( ) ) : <eos>
2474
src = 改行せずに A に 1 を加えた値を出力する
trg = print ( A + 1 , end = '' )
rst = print ( A + 1 , end = '' ) <eos>
2475
src = A が 0 と等しいとき 1 、 そうでなければ 2 を A で割った商 を出力する
trg = print ( 1 if A == 0 else 2 // A )
rst = print ( 1 if A == 0 else 2 // A ) <eos>
2476
src = B の 2 番目から -2 番目までの部分列の整数値を A とする
trg = A = int ( B [ 2 : - 2 ] )
rst = A = int ( B [ 2 : - 2 ] ) <eos>
2477
src = B のコピーされた列を A とする
trg = A = B [ : ]
rst = A = B [ : ] <eos>
2478
src = A 、 B から C を引いた値に D を掛けた値の最大値を A とする
trg = A = max ( A , ( B - C ) * D )
rst = A = max ( A , ( B - C ) * D ) <eos>
2479
src = A の B 番目でない を A の B 番目に する
trg = A [ B ] = not A [ B ]
rst = A [ B ] = sum ( A [ B ] ) <eos>
2480
src = 0 から B 未満までの数列の各要素を C とし 、0 から B 未満までの数列のリスト の列を A とする
trg = A = [ list ( range ( B ) ) for C in range ( B ) ]
rst = A = [ list ( range ( B ) ) for C in range ( B ) ] <eos>
2481
src = A を 2 の B 乗 の文字列に空白文字を加えた値 だけ 増 加 させ る
trg = A += str ( 2 ** B ) + ' '
rst = A += str ( 2 ** B ) ** ( ) <eos>
2482
src = A に count の文字列を加えた値に B を加えた値に C の文字列を加えた値を出力する
trg = print ( A + str ( count ) + B + str ( C ) )
rst = print ( A + str ( str ) + B + str ( C ) ) <eos>
2483
src = A の先頭の整数値に A [1] に A [2] を加えた値の整数値 を加えた値に A [3] に A [4] を加えた値に A の 5 番目を加えた値の整数値 を加えた値が A の 6 番目に A の 7 番目を加えた値に A の 8 番目を加えた値の整数値 と等しいとき 、
trg = if int ( A [ 0 ] ) + int ( A [ 1 ] + A [ 2 ] ) + int ( A [ 3 ] + A [ 4 ] + A [ 5 ] ) == int ( A [ 6 ] + A [ 7 ] + A [ 8 ] ) :
rst = if int ( A [ 0 ] + A [ 1 ] + int ( A [ 2 ] + A ) == int ( A [ 5 ] + A [ 5 ] + A [ 5 ] + A [ 5 ] + A [ 5 ] +
2484
src = A の末尾に ( B 、 C の ADD 、 D ) の組 を追加する
trg = A . append ( ( B , C . ADD , D ) )
rst = A . append ( ( B , C . <unk> , D ) ) <eos>
2485
src = A の B から 1 を引いた値番目 、 A の B 番目から 1 を引いた値 、0 の最大値の最大値を A の B から 1 を引いた値番目に する
trg = A [ B - 1 ] = max ( A [ B - 1 ] , max ( A [ B ] - 1 , 0 ) )
rst = A [ B - 1 ] = max ( A [ B - 1 ] , max ( A [ B ] - 1 , 0 ) ) <eos>
2486
src = 1 を そうでなければ 、 とする
trg = else = 1
rst = else = 1 <eos>
2487
src = A の B から 1 を引いた値番目の C 番目に D の B 番目の C 番目を加えた値を A の B 番目の C 番目に する
trg = A [ B ] [ C ] = A [ B - 1 ] [ C ] + D [ B ] [ C ]
rst = A [ B ] [ C ] = A [ B - 1 ] [ C ] + D [ B ] [ C ] <eos>
2488
src = A の B に 1 を加えた値番目の C に 1 を加えた値番目かつ D の B 番目でないとき 、
trg = if A [ B + 1 ] [ C + 1 ] and not D [ B ] :
rst = if A [ B + 1 ] [ C + 1 ] and not D [ B ] : <eos>
2489
src = D の先頭の整数値 、 D の 1 番目の浮動小数点数 、 D の 2 番目の整数値を A 、 B 、 C とする
trg = A , B , C = int ( D [ 0 ] ) , float ( D [ 1 ] ) , int ( D [ 2 ] )
rst = A , B , C = int ( D [ 0 ] ) , int ( D [ 1 ] ) , int ( D [ 2 ] ) <eos>
2490
src = check ( A , B , C , D , E , F ) のとき 、
trg = if check ( A , B , C , D , E , F ) :
rst = if check ( A , B , C , D , E , F ) : <eos>
2491
src = A ._ insert _ main ( A . root , B , C ) を A の root に する
trg = A . root = A . _insert_main ( A . root , B , C )
rst = A . root = A . _insert ( A . root , B , C ) <eos>
2492
src = 入力された文字列の両端から 空白改行を取り除いた文字列 を空白で分割した字句列の各要素に 浮動小数点数を適用した列を展開し 、 それぞれ A 、 B 、 C 、 D 、 E 、 F とする
trg = A , B , C , D , E , F = map ( float , input ( ) . strip ( ) . split ( ) )
rst = A , B , C , D , E , F = map ( float , input ( ) . strip ( ) . split ( ) ) <eos>
2493
src = 入力された文字列 が A と等しいとき 、
trg = if input ( ) == A :
rst = if ( input ( ) == A : <eos>
2494
src = A から 1 を引いた値を 5 で割った余りを返す
trg = return ( A - 1 ) % 5
rst = return ( A - 1 ) % 5 <eos>
2495
src = A の B 番目から B に C を加えた値までの部分列 の先頭が D で 始 まるとき 、
trg = if A [ B : B + C ] . startswith ( D ) :
rst = if A [ B : B + C ] ] , D ) : <eos>
2496
src = heappush ( A , ( B , C , (1, D )))
trg = heappush ( A , ( B , C , ( 1 , D ) ) )
rst = heappush ( A , ( B , C , ( 1 , D ) ) ) <eos>
2497
src = 0 が A 以下かどうかが 30 より小さいとき 、
trg = if 0 <= A < 30 :
rst = if 0 <= A < 30 : <eos>
2498
src = 688 に B から C を引いた値を掛けた値を A とする
trg = A = 688 * ( B - C )
rst = A = <unk> * ( B - C ) <eos>
2499
src = A の FLAGS と A の ALL _ ON の論理積が A の ALL _ OFF と等しくないかどうかを返す
trg = return A . FLAGS & A . ALL_ON != A . ALL_OFF
rst = return A . FLAGS & A . <unk> != A . ALL_OFF <eos>
2500
src = - A 、 B を出力する
trg = print ( - A , B )
rst = print ( - A , B ) <eos>
2501
src = A かつ A を 5 で割った余り でない 間 、 次 を 繰り返 す
trg = while A and not A % 5 :
rst = while not A and ( A % 5 ) : <eos>
2502
src = B を 2 で割った商の整数値を A とする
trg = A = int ( B // 2 )
rst = A = int ( B // 2 ) <eos>
2503
src = A の B から C を引いた値番目の D 番目のとき 、
trg = if A [ B - C ] [ D ] :
rst = if A [ B - C ] [ D ] : <eos>
2504
src = 0 から 8 未満までの数列を順に A として 、 繰り返 す
trg = for A in range ( 8 ) :
rst = for A in range ( 8 ) : <eos>
2505
src = D の E から 1 を引いた値から E に 2 を加えた値までの部分列を展開し 、 それぞれ A 、 B 、 C とする
trg = A , B , C = D [ E - 1 : E + 2 ]
rst = A , B , C = D [ E - 1 - E + 2 ] <eos>
2506
src = C の D から 3 を引いた値番目 、 C の D から 4 を引いた値番目を A 、 B とする
trg = A , B = C [ D - 3 ] , C [ D - 4 ]
rst = A , B = C [ D - 3 ] , C [ D - 4 ] <eos>
2507
src = ( 、 つまり未定値 、 未定値 、 未定値 、0、 B 、 1、0、0) からなる列を A の B 番目に する
trg = A [ B ] = [ None , None , None , 0 , B , 1 , 0 , 0 ]
rst = A [ B ] = [ None , None , None , 0 , B , [ ] <eos>
2508
src = A の r が 0 と等しいとき 、
trg = if A . r == 0 :
rst = if A . r == 0 : <eos>
2509
src = B に 0.05 を掛けた値を A とする
trg = A = B * 0.05
rst = A = B * <unk> <eos>
2510
src = D の E から 1 を引いた値番目 を順に A 、 B 、 C として 、 繰り返 す
trg = for A , B , C in D [ E - 1 ] :
rst = for A , B , C in D [ E - 1 ] : <eos>
2511
src = A を B を英小文字に変換した文字列を 空白で分割した字句列内の C の出現回数 だけ 増 加 させ る
trg = A += B . lower ( ) . split ( ) . count ( C )
rst = A += B . lower ( ) . count ( C ) <eos>
2512
src = dfs (0,[0]* A ) を出力する
trg = print ( dfs ( 0 , [ 0 ] * A ) )
rst = print ( dfs ( 0 , [ 0 ] * A ) ) <eos>
2513
src = f ( B , C , D )
trg = f ( B , C , D )
rst = f ( B , C , D ) <eos>
2514
src = 1 から 2* B に 1 を加えた値 未満までの数列の集合から C の集合を引いた値をソートした列を A とする
trg = A = sorted ( set ( range ( 1 , 2 * B + 1 ) ) - set ( C ) )
rst = A = set ( range ( 1 , - ( ( B + 1 ) ) ) C C ) <eos>
2515
src = isAvailableAreas ( A ) でないとき 、
trg = if not isAvailableAreas ( A ) :
rst = if not <unk> ( A ) : <eos>
2516
src = A を 7 で割った余りが 0 と等しいとき 、
trg = if A % 7 == 0 :
rst = if A % 7 == 0 : <eos>
2517
src = B の -1 番目に 1 を加えた値を A とする
trg = A = B [ - 1 ] + 1
rst = A = B [ - 1 ] + 1 <eos>
2518
src = A の is _ right _ triangle ( B ) 番目を 1 だけ 増 加 させ る
trg = A [ is_right_triangle ( B ) ] += 1
rst = A . <unk> ( B ) ] += 1 <eos>
2519
src = B の tree の C 番目 の逆順 を順に A として 、 繰り返 す
trg = for A in B . tree [ C ] [ : : - 1 ] :
rst = for A in B . tree [ C ] [ : : - 1 ] : <eos>
2520
src = A の末尾に extract ( B ) を追加する
trg = A . append ( extract ( B ) )
rst = A . append ( <unk> ( B ) ) <eos>
2521
src = check ( A , B ) が 1 と等しいとき 、
trg = if check ( A , B ) == 1 :
rst = if check ( A , B ) == 1 : <eos>
2522
src = A の sink の edge の末尾に B を追加する
trg = A . sink . edge . append ( B )
rst = A . . . . append ( B ) <eos>
2523
src = 0 から C 未満までの数列の各要素を B とし 、 B の列を A の par に する
trg = A . par = [ B for B in range ( C ) ]
rst = A . par = [ B for B in range ( C ) ] <eos>
2524
src = A . is _ orthogonal ( B , C ) のとき 、
trg = if A . is_orthogonal ( B , C ) :
rst = if A . is_orthogonal ( B , C ) : <eos>
2525
src = write ( A % min ( B [ C -1]))
trg = write ( A % min ( B [ C - 1 ] ) )
rst = write ( A % min ( B [ C - 1 ] ) ) <eos>
2526
src = A の B から C を引いた値番目が -1 と等しくなくかつ A の B から C を引いた値番目が D 以下のとき 、
trg = if A [ B - C ] != - 1 and A [ B - C ] <= D :
rst = if A [ B - C ] != - 1 and A [ B - C ] <= D : <eos>
2527
src = A の B 番目の C 番目の D に 1 を加えた値を 4 で割った余り 番目でないとき 、
trg = if not A [ B ] [ C ] [ ( D + 1 ) % 4 ] :
rst = if not A [ B ] [ C ] [ D + 1 ] % 4 : <eos>
2528
src = is _ triangle ( A ) でないとき 、
trg = if not is_triangle ( A ) :
rst = if not <unk> ( A ) : <eos>
2529
src = ( 2 、 A の B の 2 番目番目 、 A の B の 3 番目番目 、 A の B の 4 番目番目 ) からなる列を返す
trg = return [ 2 , A [ B [ 2 ] ] , A [ B [ 3 ] ] , A [ B [ 4 ] ] ]
rst = return [ 2 , A [ B [ 2 ] ] , A [ B [ 3 ] ] , A [ B [ 4 ] ] <eos>
2530
src = A の B 番目が C と等しくかつ D の E に 1 を加えた値番目の B 番目かつ D の B に 1 を加えた値番目の F から 1 を引いた値番目のとき 、
trg = if A [ B ] == C and D [ E + 1 ] [ B ] and D [ B + 1 ] [ F - 1 ] :
rst = if A [ B ] == C and D [ E + 1 ] [ B ] and D [ B + 1 ] [ F - 1 ] : <eos>
2531
src = C のキーの集まりの各要素を B とし 、 ( B の長さ 、 B ) の組の列をソートした列を A とする
trg = A = sorted ( [ ( len ( B ) , B ) for B in C . keys ( ) ] )
rst = A = sorted ( [ ( len ( B ) , B ) ) for B in C . keys ( ) ] ) <eos>
2532
src = E の整数値を E とする
trg = E = int ( E )
rst = E = int ( E ) <eos>
2533
src = B . leader ( C ) を A とする
trg = A = B . leader ( C )
rst = A = B . leader ( C ) <eos>
2534
src = A から 1 を引いた値が -1 と等しいとき 、
trg = if A - 1 == - 1 :
rst = if A - 1 == - 1 : <eos>
2535
src = A 内の B の C 番目の先頭の出現回数が 1 と等しいとき 、
trg = if A . count ( B [ C ] [ 0 ] ) == 1 :
rst = if A . count ( B [ C [ 0 ] ) == 1 : <eos>
2536
src = A + B *5 + C *10+ D *50 に e *100 を加えた値に E に 500 を掛けた値を加えた値が 1000 以上かどうかの整数値 を出力する
trg = print ( int ( A + B * 5 + C * 10 + D * 50 + e * 100 + E * 500 >= 1000 ) )
rst = print ( A + B * 5 * C * D + D ) // 100 + e * e * ( 100 * 1000 ) 1000 ) ) <eos>
2537
src = A を B の先頭に B の 1 番目を掛けた値だけ 減 少 させ る
trg = A -= B [ 0 ] * B [ 1 ]
rst = A -= B [ 0 ] * B [ 1 ] <eos>
2538
src = ( A を B で割った商 、 C を B で割った商 ) の組を返す
trg = return ( A // B , C // B )
rst = return ( A // B , C // B ) <eos>
2539
src = - 1000 を A とする
trg = A = - 1000
rst = A = - 1000 <eos>
2540
src = B 内の 、 つまり文字 コ ー ド C の文字の出現回数 を A とする
trg = A = B . count ( chr ( C ) )
rst = A = B . replace ( chr ( C ) ) <eos>
2541
src = B の絶対値と C の最大公約数を A とする
trg = A = gcd ( abs ( B ) , C )
rst = A = gcd ( B ( B ) , C ) <eos>
2542
src = A . add _ edge ( B + C -1, D + E ,1)
trg = A . add_edge ( B + C - 1 , D + E , 1 )
rst = A . add_edge ( B + C , 1 , D + E , 1 ) <eos>
2543
src = 1 、0 を A 、 現在の日時とする
trg = A , now = 1 , 0
rst = A , now = 1 , 0 <eos>
2544
src = B の 5 番目を A の 1 番目に する
trg = A [ 1 ] = B [ 5 ]
rst = A [ 1 ] = B [ 5 ] <eos>
2545
src = A が B の nodes の A 番目と等しくない 間 、 次 を 繰り返 す
trg = while A != B . nodes [ A ] :
rst = while A != B . nodes [ A ] : <eos>
2546
src = A 内の B の出現回数が C 以上かつ D が A 内の B の出現回数 より小さいとき 、
trg = if A . count ( B ) >= C and D < A . count ( B ) :
rst = if A . count ( B ) >= C and D < A . count ( B ) : <eos>
2547
src = 0 から A [0] を引いた値に A の 2 番目を掛けた値に A の 3 番目を加えた値に A の 1 番目に A の 4 番目を掛けた値を加えた値 を出力する
trg = print ( ( 0 - A [ 0 ] ) * A [ 2 ] + A [ 3 ] + A [ 1 ] * A [ 4 ] )
rst = print ( 0 ( A - [ 0 ] * A [ 2 ] + A [ 3 ] + A [ 3 ] * A [ 4 ] ) <eos>
2548
src = ( D 、 ( E 、 F 、 G ) からなる列 ) からなる列を A の B 番目の C 番目に する
trg = A [ B ] [ C ] = [ D , [ E , F , G ] ]
rst = A [ B ] [ C ] = [ D , [ E , F , G ] ] <eos>
2549
src = B を 3600 で割った余りを 60 で割った商を A とする
trg = A = ( B % 3600 ) // 60
rst = A = ( B % 3600 ) // 60 <eos>
2550
src = ( ( B 、 C ) からなる列 、 ( B 、 C から 1 を引いた値 ) からなる列 、 ( B から 1 を引いた値 、 C ) からなる列 、 ( B に 1 を加えた値 、 C ) からなる列 、 ( B 、 C に 1 を加えた値 ) からなる列 ) からなる列を A とする
trg = A = [ [ B , C ] , [ B , C - 1 ] , [ B - 1 , C ] , [ B + 1 , C ] , [ B , C + 1 ] ]
rst = A = [ [ B , C ] , [ B , C - 1 ] , [ B B - 1 ] , [ B B + 1 ] , [ B , C + 1 ] ] , [ B , C + 1 ] ] <eos>
2551
src = A の B 番目の先頭の 0 番目が C と等しいとき 、
trg = if A [ B ] [ 0 ] [ 0 ] == C :
rst = if A [ B ] [ 0 ] [ 0 ] == C : <eos>
2552
src = A ._ replace ( left = B ) を A とする
trg = A = A . _replace ( left = B )
rst = A = A . _replace ( left = B ) <eos>
2553
src = A を _ pow (10,2 4) で割った余りを A とする
trg = A = A % _pow ( 10 , 24 )
rst = A = A % _pow ( 10 , 64 ) <eos>
2554
src = B の C から D を引いた値番目 を追加して A を 拡張 する
trg = A . extend ( B [ C - D ] )
rst = A . extend ( B [ C - D ] ) <eos>
2555
src = A の末尾に B 内の 1 の出現回数 を追加する
trg = A . append ( B . count ( 1 ) )
rst = A . append ( B . count ( 1 ) ) <eos>
2556
src = A に 1 を加えた値が B に含まれかつ A に 2 を加えた値が B に含まれかつ A に 3 を加えた値が B に含まれるとき 、
trg = if A + 1 in B and A + 2 in B and A + 3 in B :
rst = if A + 1 in B and A + 2 in B and A + 3 in B : <eos>
2557
src = B から C を引いた値 、 D の最小値を A とする
trg = A = min ( B - C , D )
rst = A = min ( B - C , D ) <eos>
2558
src = insertion _ sort ( A , B , C [ D ] )
trg = insertion_sort ( A , B , C [ D ] )
rst = insertion_sort ( A , B , C [ D ] ) <eos>
2559
src = A の末尾に 2020 を追加する
trg = A . append ( 2020 )
rst = A . append ( 2020 ) <eos>
2560
src = A の p の B 番目を返す
trg = return A . p [ B ]
rst = return A . p [ B ] <eos>
2561
src = B と 1000 を 割った ときの ( 商を展開し 、 それぞれ A 、 B とする
trg = A , B = divmod ( B , 1000 )
rst = A , B = divmod ( B , 1000 ) <eos>
2562
src = A に B を加えた値から 1 を引いた値を C の長さで割った余りを A とする
trg = A = ( A + B - 1 ) % len ( C )
rst = A = ( A + B - 1 ) % len ( C ) <eos>
2563
src = list ( map ( str , input (). split ())) の先頭を除いた部分列の 2 個までの コン ビ ネ ー シ ョ ンのリスト の各要素を B とし 、0 から D 未満までの数列の列の各要素を C とし 、 B をソートした列の列を A とする
trg = A = [ sorted ( B ) for C in [ range ( D ) for B in list ( combinations ( list ( map ( str , input ( ) . split ( ) ) ) [ 1 : ] , 2 ) ) ] ]
rst = A = sorted ( [ str ( B ) for C in [ D ) for C in [ range ( ) ) ) [ 1 ] ] , [ 2 ] ) ) for B in sys . stdin ] ) ] <eos>
2564
src = A の末尾に B の C [ D ] から 1 を引いた値を 4 で割った余りに 15 を加えた値番目 を追加する
trg = A . append ( B [ ( C [ D ] - 1 ) % 4 + 15 ] )
rst = A . append ( B [ ( C [ D ] - 1 ) % 4 + [ ] ) <eos>
2565
src = C から D を引いた値の絶対値の 2 乗 、 E から F を引いた値の絶対値の 2 乗を A 、 B とする
trg = A , B = abs ( C - D ) ** 2 , abs ( E - F ) ** 2
rst = A , B = ( C - D ) ** 2 , ( E - F ) ** 2 <eos>
2566
src = A . printl (3)
trg = A . printl ( 3 )
rst = A . <unk> ( 1 ) <eos>
2567
src = A の B -1 番目の整数値を A の B +1 番目の整数値 で割った商に 1 を加えた値の文字列を A の B から 1 を引いた値番目に する
trg = A [ B - 1 ] = str ( int ( A [ B - 1 ] ) // int ( A [ B + 1 ] ) + 1 )
rst = A [ B - 1 ] = str ( A [ B - 1 ] ) int ( A [ B + 1 ) ) + 1 ) <eos>
2568
src = ( C の末尾を除いた部分列 、 C の末尾 ) の組を A の B 番目に する
trg = A [ B ] = ( C [ : - 1 ] , C [ - 1 ] )
rst = A [ B ] = ( C [ : - 1 ] , C [ - 1 ] ) <eos>
2569
src = A の sizes の B 番目を A の sizes の C 番目だけ 増 加 させ る
trg = A . sizes [ B ] += A . sizes [ C ]
rst = A . one [ B ] += A . sizes [ C ] <eos>
2570
src = ( ( (0、0、1) の組 , 0 )) からなる辞書を A とする
trg = A = { (0, 0, 1) : 0 }
rst = A = { <unk> : 0 , 0 } <eos>
2571
src = 空文字列を間に入れて B の C 番目から D 番目までの部分列 を連結した文字列の整数値を A とする
trg = A = int ( '' . join ( B [ C : D ] ) )
rst = A = int ( '' . join ( B ( C [ : D ] ) ) <eos>
2572
src = B を 1 だけ左シフトした値 の 2 進 数文字列の 2 番目から 、 つまり末尾までの部分列を長さ 32 に な るように '0' 左 詰め した文字列を A とする
trg = A = bin ( B << 1 ) [ 2 : ] . zfill ( 32 )
rst = A = bin ( B << 1 ) [ 2 : ] . zfill ( 32 ) <eos>
2573
src = BinaryIndexedTree ( B +1) を A の bit 2 に する
trg = A . bit2 = BinaryIndexedTree ( B + 1 )
rst = A . bit2 = BinaryIndexedTree ( B + 1 ) <eos>
2574
src = B 、0 を A 、 B とする
trg = A , B = B , 0
rst = A , B = B , 0 <eos>
2575
src = A の -1 番目が B より大きいとき 、
trg = if A [ - 1 ] > B :
rst = if A [ - 1 ] > B : <eos>
2576
src = C の長さから 1 を引いた値を A の B 番目に する
trg = A [ B ] = len ( C ) - 1
rst = A [ B ] = len ( C ) - 1 <eos>
2577
src = 2 に B を掛けた値から 110000 未満までの B 間隔の数列を順に A として 、 繰り返 す
trg = for A in range ( 2 * B , 110000 , B ) :
rst = for A in range ( 2 * B , 104743 , B ) : <eos>
2578
src = 集合を 返す
trg = return set ( )
rst = return set ( ) <eos>
2579
src = A の cursor の next が 、 つまり未定値と等しい 間 、 次 を 繰り返 す
trg = while A . cursor . next is not None :
rst = while A . cursor . next is not None : <eos>
2580
src = B から 1 を引いた値を C で割った余りを A とする
trg = A = ( B - 1 ) % C
rst = A = ( B - 1 ) % C <eos>
2581
src = 3 を A の B 番目に する
trg = A [ B ] = 3
rst = A [ B ] = 3 <eos>
2582
src = trucks ( A , B -1) が C 以下のとき 、
trg = if trucks ( A , B - 1 ) <= C :
rst = if ( ( A , B - 1 ) <= C : <eos>
2583
src = paint ( A , B , C -3) を A とする
trg = A = paint ( A , B , C - 3 )
rst = A = paint ( A , B , C - 3 ) <eos>
2584
src = A の B に C の D に 1 を加えた値番目 を挿入する
trg = A . insert ( B , C [ D + 1 ] )
rst = A . insert ( B , C [ D + 1 ] ) <eos>
2585
src = D の B 番目 、 D の E 番目を A の B 番目 、 A の C 番目とする
trg = A [ B ] , A [ C ] = D [ B ] , D [ E ]
rst = A [ B ] , A [ C ] = D [ B ] , D [ E ] <eos>
2586
src = 0 から C に D を加えた値に 1 を加えた値未満までの数列の各要素 を B とし 、 1 の列を A とする
trg = A = [ 1 for B in range ( C + D + 1 ) ]
rst = A = [ 1 for B in range ( C + D + 1 ) ] <eos>
2587
src = A から 1867 を引いた値 を出力する
trg = print ( A - 1867 )
rst = print ( A - 1867 ) <eos>
2588
src = 1 から B 未満までの 整数 乱 数を A とする
trg = A = randrange ( 1 , B )
rst = A = random . append ( 1 , B . <eos>
2589
src = ut 2 jd ( A , B , C ) から ut 2 jd ( D , E , F ) を引いた値 を出力する
trg = print ( ut2jd ( A , B , C ) - ut2jd ( D , E , F ) )
rst = print ( <unk> ( <unk> , A , B , C ) - 2 ) - <unk> , - ( D , E , F ) ) <eos>
2590
src = A の B から C を引いた値番目のとき 、
trg = if A [ B - C ] :
rst = if A [ B - C ] : <eos>
2591
src = D から読み込んだ一行を 空白で分割した字句列 を展開し 、 それぞれ A 、 B 、 C とする
trg = A , B , C = D . readline ( ) . split ( )
rst = A , B , C = D . readline ( ) . split ( ) <eos>
2592
src = ( ( B , C の各要素を B とし 、 ( < __ main __ . Cammaobjectat 0 x 10 a 10 eca 0> ) の集合の列 )) からなる辞書を A とする
trg = A = { suit : [ { [ D for D in range ( 1 , 14 ) ] } for B in C ] }
rst = A = { suit : [ { [ : [ 0 for B in range ( C ) ] ) for B in C ] <eos>
2593
src = A に B を加えた値が C 以下かつ D の A に B を加えた値番目が 0 と等しいとき 、
trg = if A + B <= C and D [ A + B ] == 0 :
rst = if A + B <= C and D [ A + B ] == 0 : <eos>
2594
src = A 内の 0 の出現回数が 1 より大きいとき 、
trg = if A . count ( 0 ) > 1 :
rst = if A . count ( 0 ) > 1 : <eos>
2595
src = B に C から D を引いた値を掛けた値から E に F から G を引いた値を掛けた値を引いた値を A とする
trg = A = B * ( C - D ) - E * ( F - G )
rst = A = B * ( C - D ) - E * ( F - G ) <eos>
2596
src = write ( A %( B + C +( D - E )))
trg = write ( A % ( B + C + ( D - E ) ) )
rst = write ( A % ( B + C + ( D - E ) ) ) <eos>
2597
src = A を B が C と等しいかどうか だけ 増 加 させ る
trg = A += ( B == C )
rst = A += ( B == C ) <eos>
2598
src = A の ( B 、 C ) の組 番目の D 番目を出力する
trg = print ( A [ ( B , C ) ] [ D ] )
rst = print ( A [ ( B , C ) ] [ D ] ) <eos>
2599
src = 改行文字を間に入れて C . roots () の各要素を B とし 、 A を書式として B 、 C . members ( B ) で整形した文字列の列 を連結した文字列を返す
trg = return '\n' . join ( [ A . format ( B , C . members ( B ) ) for B in C . roots ( ) ] )
rst = return [ . . . . format ( [ B , C . <unk> ( B ) for B in C . roots ( ) ] ) <eos>
2600
src = 空文字列を間に入れて A の逆順 の各要素に整数を適用した列 を連結した文字列を出力する
trg = print ( '' . join ( map ( str , A [ : : - 1 ] ) ) )
rst = print ( '' . join ( map ( str , A [ : : - 1 ] ) ) ) <eos>
2601
src = A . solve ( B , C , 1 , 1,1,0) を出力する
trg = print ( A . solve ( B , C , 1 , 1 , 1 , 0 ) )
rst = print ( A . solve ( B , C , 1 , 0 , 0 , 0 , 0 ) ) <eos>
2602
src = B に 2 の 0.5 乗を掛けた値を A とする
trg = A = B * pow ( 2 , 0.5 )
rst = A = B * 2 ** 0.5 <eos>
2603
src = A に B を加えた値に C を加えた値に D を加えた値が E の整数値 と等しいとき 、
trg = if A + B + C + D == int ( E ) :
rst = if A + B + C + D == int ( E ) : <eos>
2604
src = x をパラメータとして x の 1 番目を返す関数を key として A に番号付した組の列 の最大値を返す
trg = return max ( enumerate ( A ) , key = lambda B : B [ 1 ] )
rst = return max ( A , key = lambda B : A [ 1 ] , key = True ) <eos>
2605
src = A から B を引いた値から dij ( C , D ) を引いた値から dij ( D , C ) を引いた値 を出力する
trg = print ( A - B - dij ( C , D ) - dij ( D , C ) )
rst = print ( A - B - <unk> ( C , D ) - <unk> ( D , C ) ) <eos>
2606
src = A の 0 番目が B の 0 番目と等しいとき 、
trg = if A [ 0 ] == B [ 0 ] :
rst = if A [ 0 ] == B [ 0 ] : <eos>
2607
src = A の 0 番目が B の先頭と等しくないとき 、
trg = if A [ 0 ] != B [ 0 ] :
rst = if A [ 0 ] != B [ 0 ] : <eos>
2608
src = A の cnt を A の low の B 番目に する
trg = A . low [ B ] = A . cnt
rst = A . low [ B ] = A . cnt <eos>
2609
src = 0 から A の長さ未満までの数列の各要素を B とし 、 A の B 番目のときの 2 に A [ B ] を掛けた値 の B 乗の列 を展開してを出力する
trg = print ( * [ pow ( 2 * A [ B ] , B ) for B in range ( len ( A ) ) if A [ B ] ] )
rst = print ( * ( [ 2 * A [ B ] ) for B in range ( len ( A ) ) if B [ A ] ) ) <eos>
2610
src = ( B に 1 を加えた値 ) からなる列の 4 回分の列を A とする
trg = A = [ B + 1 ] * 4
rst = A = [ B + 1 ] * 4 <eos>
2611
src = A ._ max ( A . root ) を返す
trg = return A . _max ( A . root )
rst = return A . <unk> ( A . root ) <eos>
2612
src = A . heappush ( B , ( C , e ))
trg = A . heappush ( B , ( C , e ) )
rst = A . heappush ( B , ( C , e ) ) <eos>
2613
src = A の f の B 番目が B に 1 を加えた値 と等しくないとき 、
trg = if A . f [ B ] != B + 1 :
rst = if A . f [ B ] != B + 1 : <eos>
2614
src = get _ par ( C ) 、 get _ par ( D ) を A 、 B とする
trg = A , B = get_par ( C ) , get_par ( D )
rst = A , B = get_par ( C ) , get_par ( D ) <eos>
2615
src = A の B 番目の 3 番目の整数値を A の B 番目の 3 番目に する
trg = A [ B ] [ 3 ] = int ( A [ B ] [ 3 ] )
rst = A [ B ] [ 3 ] = int ( A [ B ] [ 3 ] ) <eos>
2616
src = ( [ MASK ] を追加して B を 更新 する 、 x 、 y をパラメータとして B の位置 y から x を探して見つかった位置を出力する を返す関数 ) の組を A とする
trg = A = ( B . update , lambda C , D : print ( B . find ( C , D ) ) )
rst = A = tuple ( [ B , B : C , B : ( B . find ( - 1 , ) <eos>
2617
src = A 、 B の C 番目の 1 番目から 1 を引いた値の最小値を A とする
trg = A = min ( A , B [ C ] [ 1 ] - 1 )
rst = A = min ( A , B [ C ] [ 1 ] - 1 ) <eos>
2618
src = 整数 を順に A として 、 繰り返 す
trg = for A in str :
rst = for A in str ( ) : <eos>
2619
src = A から B を引いた値と C と A の論理積の論理和 の長さ を出力する
trg = print ( len ( ( A - B ) | ( C & A ) ) )
rst = print ( ( A - B , ( C & A ) ) <eos>
2620
src = ( A の総和 、 B から 1 を引いた値 ) の組を返す
trg = return ( sum ( A ) , B - 1 )
rst = return ( sum ( A ) , B - 1 ) <eos>
2621
src = A が B と等しくまたは C の B 番目が D と等しいとき 、
trg = if A == B or C [ B ] == D :
rst = if A == B or C [ B ] == D : <eos>
2622
src = shell _ sort ( A , len ( A ))
trg = shell_sort ( A , len ( A ) )
rst = shell_sort ( A , len ( A ) ) <eos>
2623
src = combi ( A +1, B , C + D [ E ][2])
trg = combi ( A + 1 , B , C + D [ E ] [ 2 ] )
rst = combi ( A + 1 , B , C + D [ E ] [ 2 ] ) <eos>
2624
src = C 、 D 、 E の最小値 、 C 、 D 、 E の最大値を A 、 B とする
trg = A , B = min ( C , D , E ) , max ( C , D , E )
rst = A , B = min ( C , D , E ) , max ( C , D , E ) <eos>
2625
src = A の B 番目が A の B から 1 を引いた値番目 と等しくないとき 、
trg = if A [ B ] != A [ B - 1 ] :
rst = if A [ B ] != A [ B - 1 ] : <eos>
2626
src = heapreplace ( A , B )
trg = heapreplace ( A , B )
rst = <unk> ( A , B ) <eos>
2627
src = A に B を加えた値が C より大きくかつ B に C を加えた値が A より大きくかつ C に A を加えた値が B より大きいとき 、
trg = if A + B > C and B + C > A and C + A > B :
rst = if A + B > C and B + C > A and C + A > B : <eos>
2628
src = A の B 番目の順序数が C の B 番目の順序数 より大きいとき 、
trg = if ord ( A [ B ] ) > ord ( C [ B ] ) :
rst = if ord ( A [ B ] ) > ord ( C [ B ] ) : <eos>
2629
src = B の -2 を取り出した値の浮動小数点数 に B の -1 を取り出した値の浮動小数点数 を掛けた値を A とする
trg = A = float ( B . pop ( - 2 ) ) * float ( B . pop ( - 1 ) )
rst = A = float ( B . pop ( - 2 ) ) * float ( B . pop ( - 1 ) ) <eos>
2630
src = write ( A %( B -1988 , C , D ))
trg = write ( A % ( B - 1988 , C , D ) )
rst = write ( A % ( B - 1925 , C , D ) ) <eos>
2631
src = B を C で割った商を A とする
trg = A = B // C
rst = A = B // C <eos>
2632
src = A の B 番目の長さが C の B 番目と等しいとき 、
trg = if len ( A [ B ] ) == C [ B ] :
rst = if len ( A [ B ] ) == C [ B ] : <eos>
2633
src = A . relations ( B , C )
trg = A . relations ( B , C )
rst = A . <unk> ( B , C ) <eos>
2634
src = A の末尾に B から C 内の D の出現回数を引いた値 を追加する
trg = A . append ( B - C . count ( D ) )
rst = A . append ( B - C . count ( D ) ) <eos>
2635
src = read ( B ) を A とする
trg = A = read ( B )
rst = A = read ( B ) <eos>
2636
src = A の末尾に (0、 B 、 - C 、 D ) からなる列 を追加する
trg = A . append ( [ 0 , B , - C , D ] )
rst = A . append ( [ 0 , B , - C , D ] ) <eos>
2637
src = 円周率 を展開し 、 それぞれ A 、 B とする
trg = A , B = pi
rst = A , B = pi <eos>
2638
src = B の C 番目から D 番目までの部分列に ( E の浮動小数点数 ) からなる列を加えた値を A とする
trg = A = B [ C : D ] + [ float ( E ) ]
rst = A = B [ C : D ] + [ float ( E ) ] <eos>
2639
src = A を 5 で割った商を A とする
trg = A = A // 5
rst = A = A // 5 <eos>
2640
src = A を書式として 、 つまり無限の整数列 で整形した文字列を出力する
trg = print ( A . format ( count ) )
rst = print ( A . format ( count ) ) <eos>
2641
src = 0 から 12 未満までの数列を順に A として 、 繰り返 す
trg = for A in range ( 12 ) :
rst = for A in range ( 12 ) : <eos>
2642
src = A の B 番目の 1 番目が C より大きいとき 、
trg = if A [ B ] [ 1 ] > C :
rst = if A [ B ] [ 1 ] > C : <eos>
2643
src = A の top を 1 だけ 増 加 させ る
trg = A . top += 1
rst = A . top += 1 <eos>
2644
src = 0 から 1000 未満までの数列の各要素を C とし 、 B を 10 の C 乗 で割った余りが B と等しくないときの B を 10 の ( C +1) 乗で割った余りを 10 の C 乗で割った商 の列の総和を A とする
trg = A = sum ( [ B % 10 ** ( C + 1 ) // 10 ** C for C in range ( 1000 ) if B % 10 ** C != B ] )
rst = A = sum ( [ ( B % 10 ** C ] ) % B B [ 10 ** ) for B in range ( 1000 ) if C != 10 ] ) ) % 10 ] ) <eos>
2645
src = 1 を A の先頭の 0 番目に する
trg = A [ 0 ] [ 0 ] = 1
rst = A [ 0 ] [ 0 ] = 1 <eos>
2646
src = A の末尾に B の 2 進 数文字列の - C の長さから 、 つまり末尾までの部分列 を追加する
trg = A . append ( bin ( B ) [ - len ( C ) : ] )
rst = A . append ( bin ( B ) [ len ( C ) ) , ) <eos>
2647
src = C の primeFactorization のキーと値の集まり を順に A 、 B として 、 繰り返 す
trg = for A , B in C . primeFactorization . items ( ) :
rst = for A , B in C . tree : <eos>
2648
src = C . findSet ( A . p [ B ] ) を A の p の B 番目に する
trg = A . p [ B ] = C . findSet ( A . p [ B ] )
rst = A . p [ B ] = C . findSet ( A . p [ B ] ) <eos>
2649
src = ( B の 0 番目に 2 に C [0] を掛けた値を加えた値を 3 で割った値 、 5 を 四捨五 入した整数値 、 B の 1 番目に 2 に C [1] を掛けた値を加えた値を 3 で割った値 、 5 を 四捨五 入した整数値 ) の組を A とする
trg = A = ( round ( ( B [ 0 ] + 2 * C [ 0 ] ) / 3 , 5 ) , round ( ( B [ 1 ] + 2 * C [ 1 ] ) / 3 , 5 ) )
rst = A = ( ( ( B [ 0 ] + 2 * C [ 0 ] ) / 3 , 5 ) , ( round ( B [ 1 ] + 2 ) ) / 5 , 5 ) ) <eos>
2650
src = 10000 を A とする
trg = A = 10000
rst = A = 10000 <eos>
2651
src = 0 が A 以下かどうかが B より小さくかつ 0 が C から 1 を引いた値以下かどうかが D より小さくかつ E の A 番目の C から 1 を引いた値番目が 1 と等しいとき 、
trg = if 0 <= A < B and 0 <= C - 1 < D and E [ A ] [ C - 1 ] == 1 :
rst = if 0 <= A < B and 0 <= C - 1 < D and E [ A ] [ C - 1 ] == 1 : <eos>
2652
src = A の末尾に B の文字列に C の文字列を加えた値の整数値 を追加する
trg = A . append ( int ( str ( B ) + str ( C ) ) )
rst = A . append ( str ( str ( B ) + int ( C ) ) ) <eos>
2653
src = A . check ()
trg = A . check ( )
rst = A . check ( ) <eos>
2654
src = chessboard ( A , B )
trg = chessboard ( A , B )
rst = <unk> ( A , B ) <eos>
2655
src = A の長さが B の長さより小さいとき 、
trg = if len ( A ) < len ( B ) :
rst = if len ( A ) < len ( B ) : <eos>
2656
src = rotate ( A ) を A とする
trg = A = rotate ( A )
rst = A = rotate ( A ) <eos>
2657
src = A の B の C 番目の順序数から 97 を引いた値番目を 1 だけ 増 加 させ る
trg = A [ ord ( B [ C ] ) - 97 ] += 1
rst = A [ ord ( B [ C ] ) - 97 ] += 1 <eos>
2658
src = (0) からなる列に ( B の浮動小数点数 ) からなる列の C 回分の列を加えた値を A とする
trg = A = [ 0 ] + [ float ( B ) ] * ( C )
rst = A = [ 0 ] + [ float ( B ) ] * C <eos>
2659
src = ソートされた順序を保ったまま D を B の C 番目 に挿入できる位置を A とする
trg = A = bisect . bisect_left ( B [ C ] , D )
rst = A = bisect_left ( B , C , D ) <eos>
2660
src = B に B を掛けた値に C に C を掛けた値を加えた値から D に D を掛けた値を引いた値を A とする
trg = A = ( B * B + C * C ) - D * D
rst = A = B * B + C * C - D * D <eos>
2661
src = B . itemgetter (2) を key として A をソート する
trg = A . sort ( key = B . itemgetter ( 2 ) )
rst = A . sort ( key = B . itemgetter ( 2 ) ) <eos>
2662
src = rot 60 ( Point ( ( B . x - C . x )/3,( B . y - C . y )/3) ) を A とする
trg = A = rot60 ( Point ( ( B . x - C . x ) / 3 , ( B . y - C . y ) / 3 ) )
rst = A = bs ( ( B . x - C . x ) / 3 , B . y - C . y ) / 3 ) <eos>
2663
src = B に入力された文字列を加えた値に C を加えた値を A とする
trg = A = B + input ( ) + C
rst = A = B + input ( ) + C <eos>
2664
src = A が 0 と等しいとき 1 、 そうでなければ A を出力する
trg = print ( 1 if A == 0 else A )
rst = print ( 1 if A == 0 else A ) <eos>
2665
src = write ( A %( B - C , D -1))
trg = write ( A % ( B - C , D - 1 ) )
rst = write ( A % ( B - C , D - 1 ) ) <eos>
2666
src = namedtuple ( B , ( C , D , E )) を A とする
trg = A = namedtuple ( B , ( C , D , E ) )
rst = A = namedtuple ( B , ( C , D , E ) ) <eos>
2667
src = 1 から - B の 補 数 未満までの数列を順に A として 、 繰り返 す
trg = for A in range ( 1 , - ~ B ) :
rst = for A in range ( 1 , - B ) ) : <eos>
2668
src = operator ( C , D , E [ F ] ) を A の B 番目に する
trg = A [ B ] = operator ( C , D , E [ F ] )
rst = A [ B ] = <unk> ( C , D , E [ F ] ) <eos>
2669
src = A に B に C を掛けた値を加えた値を返す
trg = return A + B * C
rst = return A + B * C <eos>
2670
src = lcm _ mul ( B ) を A とする
trg = A = lcm_mul ( B )
rst = A = <unk> ( B ) <eos>
2671
src = ネイピア数の 1 番目が 0 と等しいとき 、
trg = if e [ 1 ] == 0 :
rst = if e [ 1 ] == 0 : <eos>
2672
src = A かつ B の長さの 間 、 次 を 繰り返 す
trg = while A and len ( B ) :
rst = while A and len ( B ) : <eos>
2673
src = A の 、 つまり先頭から 1 から B を引いた値までの部分列の総和 を出力する
trg = print ( sum ( A [ : 1 - B ] ) )
rst = print ( sum ( A [ : 1 - B ] ) ) <eos>
2674
src = ( ( B , C の ascii _ lowercase の各要素を B とし 、 [ MASK ] の 辞書 カ ウ ンタの列 )) からなる辞書を A とする
trg = A = { c : [ Counter ( ) for B in C . ascii_lowercase ] }
rst = A = { name : Counter ( [ 1 for B in C . ascii_lowercase ] ) <eos>
2675
src = A に B を掛けた値が 0 以上のとき 、
trg = if A * B >= 0 :
rst = if A * B >= 0 : <eos>
2676
src = A 、 B に C を掛けた値の最大値を A とする
trg = A = max ( A , B * C )
rst = A = max ( A , B * C ) <eos>
2677
src = B を 2 で割った値を C から D を引いた値で割った値に C に E を加えた値から B を引いた値から F を引いた値から 、 つまりネイピア数 を引いた値を掛けた値を A とする
trg = A = B / 2 / ( C - D ) * ( C + E - B - F - e )
rst = A = B / 2 / ( C - D ) * ( C + E - B - F - F - e ) <eos>
2678
src = polar _ to _ cartesian (2* C /3, D ) を展開し 、 それぞれ A 、 B とする
trg = A , B = polar_to_cartesian ( 2 * C / 3 , D )
rst = A , B = <unk> ( * 2 , C ( 4 ) , D ) <eos>
2679
src = A の tree の 、 つまりネイピア数の 1 番目番目の末尾に ( 、 つまりネイピア数の先頭 、 ネイピア数の 2 番目 ) の組 を追加する
trg = A . tree [ e [ 1 ] ] . append ( ( e [ 0 ] , e [ 2 ] ) )
rst = A . tree [ e [ 1 ] ] . append ( [ e , e [ 2 ] ) ) <eos>
2680
src = (0) からなる列の 105 回分の列を A とする
trg = A = [ 0 ] * 105
rst = A = [ 0 ] * 999999 <eos>
2681
src = A 、 B を C で割った商の最小値を A とする
trg = A = min ( A , B // C )
rst = A = min ( A , B // C ) <eos>
2682
src = ネイピア数の 1 番目から 、 つまり末尾までの部分列の各要素に B の [ MASK ] と等しい要素の最初の位置 を適用した列を順に A として 、 繰り返 す
trg = for A in map ( B . index , e [ 1 : - 1 ] ) :
rst = for A in B ( B ) . count ( B ) , <eos>
2683
src = B の S の末尾を A とする
trg = A = B . S [ - 1 ]
rst = A = B . S [ - 1 ] <eos>
2684
src = A の tree の 、 つまりネイピア数の先頭 から 1 を 引いた値番目の末尾にネイピア数の 1 番目から 1 を引いた値 を追加する
trg = A . tree [ e [ 0 ] - 1 ] . append ( e [ 1 ] - 1 )
rst = A . tree [ e [ 0 ] - 1 ] . append ( e [ 1 ] - 1 ) <eos>
2685
src = 2 から B の 0.5 乗の整数値に 2 を加えた値未満までの数列を順に A として 、 繰り返 す
trg = for A in range ( 2 , int ( B ** 0.5 ) + 2 ) :
rst = for A in range ( 2 , int ( B ** 0.5 ) + 2 ) : <eos>
2686
src = C を A の _ cache の B 番目に する
trg = A . _cache [ B ] = C
rst = A . _cache [ B ] = C <eos>
2687
src = A が 3 以上のとき 、
trg = if A >= 3 :
rst = if A >= 3 : <eos>
2688
src = 0 から 4 未満までの数列の各要素を B とし 、 readline () を空白で分割した字句列の各要素に 整数を適用した列の列を A とする
trg = A = ( [ map ( int , readline ( ) . split ( ) ) for B in range ( 4 ) ] )
rst = A = [ map ( int , readline ( ) . split ( ) ) for B in range ( 4 ) ] <eos>
2689
src = 未定値を A の head に する
trg = A . head = None
rst = A . head = None <eos>
2690
src = A の head の B 番目を A の head の A の next の B 番目番目に する
trg = A . head [ A . next [ B ] ] = A . head [ B ]
rst = A . head [ A . B [ B ] ] = A . head [ B ] <eos>
2691
src = B の 2 乗の整数値を A とする
trg = A = int ( pow ( B , 2 ) )
rst = A = int ( B ** 2 ) <eos>
2692
src = B の data を A とする
trg = A = B . data
rst = A = B . data <eos>
2693
src = Dice ( C ) を A の B 番目に する
trg = A [ B ] = Dice ( C )
rst = A [ B ] = Dice ( C ) <eos>
2694
src = C から D を引いた値に E を加えた値を A の weights の B 番目に する
trg = A . weights [ B ] = C - D + E
rst = A . weights [ B ] = ( C - D + E ) <eos>
2695
src = "{} {}" を出力する
trg = print ( {X:.3f} {Y:.3f} )
rst = print ( <unk> <unk> <eos>
2696
src = 空辞書を A の idx に する
trg = A . idx = { }
rst = A . start = { } <eos>
2697
src = A を - B の C 番目の先頭に D を掛けた値だけ 増 加 させ る
trg = A += ( - B [ C ] [ 0 ] ) * D
rst = A += - B - C ] [ D ] <eos>
2698
src = get _ co ( C -1, D ) を展開し 、 それぞれ A 、 B とする
trg = A , B = get_co ( C - 1 , D )
rst = A , B = get_co ( C - 1 , D ) <eos>
2699
src = B の 3 番目から 、 つまり末尾までの部分列を A とする
trg = A = B [ 3 : ]
rst = A = B [ 3 : ] <eos>
2700
src = A を B 、 C の最小値だけ 増 加 させ る
trg = A += min ( B , C )
rst = A += min ( B , C ) <eos>
2701
src = to _ gamma ( B [0]) から to _ gamma ( B [3]) を引いた値に 26 を加えた値を 26 で割った余りを A とする
trg = A = ( to_gamma ( B [ 0 ] ) - to_gamma ( B [ 3 ] ) + 26 ) % 26
rst = A = to_gamma ( ( B [ 0 ] ) - ( ( B [ 3 ] + + 26 ) % 26 <eos>
2702
src = A 、 B に お いて正規表現 0 が最初にマッチする位置
trg = search ( 0 , A , B )
rst = search ( A , B , B ) <eos>
2703
src = C の D 番目の先頭 を展開し 、 それぞれ A 、 B とする
trg = A , B = C [ D ] [ 0 ]
rst = A , B = C [ D ] [ 0 ] <eos>
2704
src = 65 から 9 1 未満までの数列を順に A として 、 繰り返 す
trg = for A in range ( 65 , 91 ) :
rst = for A in range ( 65 , 9 ) : <eos>
2705
src = _ find ( A . left ) を返す
trg = return _find ( A . left )
rst = return _find ( A . left ) <eos>
2706
src = A の rp の末尾に ( ( A の d の先頭 、 A の d の 1 番目 ) からなる列 、 A の d の 2 番目 ) の組 を追加する
trg = A . rp . append ( ( [ A . d [ 0 ] , A . d [ 1 ] ] , A . d [ 2 ] ) )
rst = A . rp . append ( [ ( A . d [ 0 ] , A . d [ 1 ] ] , A . d [ 2 ] ) ) <eos>
2707
src = D を A の B に 3 を加えた値番目の C に 1 を加えた値番目に する
trg = A [ B + 3 ] [ C + 1 ] = D
rst = A [ B + 3 ] [ C + 1 ] = D <eos>
2708
src = A が B より大きくかつ C が B より大きいとき 、
trg = if A > B and C > B :
rst = if A > B and C > B : <eos>
2709
src = A . marge _ next _ wait ( B )
trg = A . marge_next_wait ( B )
rst = A . <unk> ( B ) <eos>
2710
src = A の B が C より小さいかどうかが D より小さく ない から 、 つまり末尾までの 2 間隔による部分列 を出力する
trg = print ( A [ not ( B < C < D ) : : 2 ] )
rst = print ( A [ B < C < D : math . count ( 2 ) ] ) <eos>
2711
src = B の INFINITY を A とする
trg = A = B . INFINITY
rst = A = B . INFINITY <eos>
2712
src = A の先頭が B と等しくかつ C が 0 より大きいとき 、
trg = if A [ 0 ] == B and C > 0 :
rst = if A [ 0 ] == B and C > 0 : <eos>
2713
src = 整数の A 番目から B 番目までの部分列 を出力する
trg = print ( str [ A : B ] )
rst = print ( str [ A : B ] ) <eos>
2714
src = 1 、1、0 を A 、 B 、 C とする
trg = A , B , C = 1 , 1 , 0
rst = A , B , C = 1 , 1 <eos>
2715
src = B に C の文字列を加えた値に B の逆順を加えた値 の整数値を A とする
trg = A = int ( B + str ( C ) + B [ : : - 1 ] )
rst = A = int ( B + str ( C ) + B [ : : - 1 ] ) <eos>
2716
src = A の末尾に A の C 番目の各要素を B とし 、 B に 1 を加えた値の列 を追加する
trg = A . append ( [ B + 1 for B in A [ C ] ] )
rst = A . append ( [ B + 1 for B in A [ C ] ] ) <eos>
2717
src = B の先頭 、 B の 1 番目 、 1、1、 C 、 B の 2 番目 を追加して A を 更新 する
trg = A . update ( B [ 0 ] , B [ 1 ] , 1 , 1 , C , B [ 2 ] )
rst = A . update ( B [ 0 ] , B [ 1 ] , <unk> ( C , 2 ] ) <eos>
2718
src = B の C 番目 の集合を A とする
trg = A = set ( B [ C ] )
rst = A = set ( B [ C ] ) <eos>
2719
src = prim () を A とする
trg = A = prim ( )
rst = A = prim ( ) <eos>
2720
src = A の B の先頭番目を A の B の 1 番目番目に する
trg = A [ B [ 1 ] ] = A [ B [ 0 ] ]
rst = A [ B [ 1 ] ] = A [ B [ 0 ] ] <eos>
2721
src = shcd _ order ( B ) を A とする
trg = A = shcd_order ( B )
rst = A = <unk> ( B ) <eos>
2722
src = B が C と等しいとき 1 、 そうでなければ 0 から D 未満までの数列の各要素を C とし 、0 の列の組を A とする
trg = A = tuple ( 1 if B == C else [ 0 for C in range ( D ) ] )
rst = A = tuple ( [ 1 if B == C else [ 0 for C in range ( D ) ] ) <eos>
2723
src = A の A の最大値と等しい要素の最初の位置 を出力する
trg = print ( A . index ( max ( A ) ) )
rst = print ( A . index ( max ( A ) ) ) <eos>
2724
src = B [ C ] . intersect ( B [ D ] ) を A とする
trg = A = B [ C ] . intersect ( B [ D ] )
rst = A = B [ C ] . Node ( B [ D ] ) <eos>
2725
src = ( 999999999 ) からなる列の B に 1 を加えた値回分の列を A とする
trg = A = [ 999999999 ] * ( B + 1 )
rst = A = [ 250000 ] * ( B + 1 ) <eos>
2726
src = A が 100 と等しいとき 、
trg = if A == 100 :
rst = if A == 100 : <eos>
2727
src = cross 3( A , B , C [ D ] ) が 0 以下のとき 、
trg = if cross3 ( A , B , C [ D ] ) <= 0 :
rst = if cross3 ( A , B , C [ D ] ) <= 0 : <eos>
2728
src = A の 2 番目を 1 だけ 減 少 させ る
trg = A [ 2 ] -= 1
rst = A [ 2 ] -= 1 <eos>
2729
src = B の E の C 番目 に番号付した組の列を順に A 、 ネイピア数 として 、 繰り返 す
trg = for A , e in enumerate ( B . E [ C ] ) :
rst = for A , e in enumerate ( B . E [ C ] ) : <eos>
2730
src = dfs ( A , B , C , D , E ) を 10 の 9 乗に 7 を加えた値 で割った余りを出力する
trg = print ( dfs ( A , B , C , D , E ) % ( 10 ** 9 + 7 ) )
rst = print ( dfs ( A , B , C , D , E ) % ( 10 ** 9 + 7 ) ) <eos>
2731
src = A を A を B で割った商だけ 減 少 させ る
trg = A -= A // B
rst = A -= A // B <eos>
2732
src = B に C を掛けた値の整数値を A とする
trg = A = int ( B * C )
rst = A = int ( B * C ) <eos>
2733
src = A の value が B の value と等しいかどうかを返す
trg = return A . value == B . value
rst = return A . value == B . value <eos>
2734
src = A が B のキーの集まり に含まれないとき 、
trg = if ( A not in B . keys ( ) ) :
rst = if A not in B . keys : <eos>
2735
src = 1 をネイピア数の A の先頭から 1 を引いた値番目の A の B 番目から 1 を引いた値番目に する
trg = e [ A [ 0 ] - 1 ] [ A [ B ] - 1 ] = 1
rst = A [ A [ B ] - 1 ] = A [ 0 ] - 1 ] <eos>
2736
src = A の末尾に ( B の C 番目 、 C ) の組 を追加する
trg = A . append ( ( B [ C ] , C ) )
rst = A . append ( ( B [ C ] , C ) ) <eos>
2737
src = B を 2 で割った値の整数値 、 C の最小値を A とする
trg = A = min ( int ( B / 2 ) , C )
rst = A = min ( B / 2 ) , C ) <eos>
2738
src = dfs ( A [ B ] )
trg = dfs ( A [ B ] )
rst = dfs ( A [ B ] ) <eos>
2739
src = A の先頭が B の 2 番目と等しいとき 、
trg = if A [ 0 ] == B [ 2 ] :
rst = if A [ 0 ] == B [ 2 ] : <eos>
2740
src = A の末尾 のとき 、
trg = if A [ - 1 ] :
rst = if A [ - 1 ] : <eos>
2741
src = A が io の長さから 1 を引いた値と等しくないとき 、
trg = if A != len ( io ) - 1 :
rst = if A != len ( ) ) - 1 : <eos>
2742
src = B に C に D から E を引いた値を掛けた値を F で割った商を加えた値を A とする
trg = A = B + C * ( D - E ) // F
rst = A = B + C * ( D - E ) // F <eos>
2743
src = fill ( A -1, B +1)
trg = fill ( A - 1 , B + 1 )
rst = fill ( A - 1 , B + 1 ) <eos>
2744
src = ( B ) からなる列の A の offset に C を加えた値に ( B ) からなる列の A の offset から C の長さを引いた値 回分の列を加えた値回分の列を A の table に する
trg = A . table = [ B ] * A . offset + C + [ B ] * ( A . offset - len ( C ) )
rst = A . table = [ B ] * A . offset + C * [ B B * * . . len ( C ) ) <eos>
2745
src = A を 100 で割った余りを 10 で割った商が B を 100 で割った余りを 10 で割った商 と等しいとき 、
trg = if ( A % 100 ) // 10 == ( B % 100 ) // 10 :
rst = if ( A % 100 ) // 10 == ( B % 100 == 10 : <eos>
2746
src = MultiSet () を A とする
trg = A = MultiSet ( )
rst = A = <unk> ( ) <eos>
2747
src = B を A の prev の next に する
trg = A . prev . next = B
rst = A . prev . next = B <eos>
2748
src = B の C 番目の D 番目に 2 を加えた値が B の C に 1 を加えた値番目の D 番目と等しいかどうかを A とする
trg = A = ( B [ C ] [ D ] + 2 == B [ C + 1 ] [ D ] )
rst = A = B [ C ] [ D ] + 2 == B [ C + 1 ] [ D ] <eos>
2749
src = A から B の逆順の B の最小値と等しい要素の最初の位置 を引いた値 を出力する
trg = print ( A - B [ : : - 1 ] . index ( min ( B ) ) )
rst = print ( A - B [ : : - 1 ] . index ( B ) ) <eos>
2750
src = 整数の 、 つまり先頭から A 番目までの部分列 を出力する
trg = print ( str [ : A ] )
rst = print ( str [ : A ] ) <eos>
2751
src = print _ preorder ( A . left )
trg = print_preorder ( A . left )
rst = print_preorder ( A . left ) <eos>
2752
src = A を B を C で割った商だけ 増 加 させ る
trg = A += B // C
rst = A += B // C <eos>
2753
src = A . access ( int ( B )) を出力する
trg = print ( A . access ( int ( B ) ) )
rst = print ( A . <unk> ( int ( B ) ) ) <eos>
2754
src = C の MAX 、 C の MAX を A 、 B とする
trg = A , B = C . MAX , C . MAX
rst = A , B = C . keylen , C . <unk> <eos>
2755
src = ((0、0、0、0) の組 ) からなる列を A とする
trg = A = [ ( 0 , 0 , 0 , 0 ) ]
rst = A = [ ( 0 , 0 , 3 , 0 ) ] <eos>
2756
src = 0 から C 未満までの数列の各要素を B とし 、 、 つまり整数の B 番目の列を A とする
trg = A = [ str [ B ] for B in range ( C ) ]
rst = A = [ [ ( B ) for B in range ( C ) ] <eos>
2757
src = A の B 番目の C 番目が D と等しくまたは E の B 番目の C 番目のとき 、
trg = if A [ B ] [ C ] == D or E [ B ] [ C ] :
rst = if A [ B ] [ C ] == D or E [ B ] [ C ] : <eos>
2758
src = A を 15 に B を掛けた値に 15 から 2 を引いた値に 5 を掛けた値に B を掛けた値を加えた値だけ 増 加 させ る
trg = A += 15 * B + ( 15 - 2 ) * 5 * B
rst = A += 15 * B + ( 15 - 2 ) * * * B <eos>
2759
src = A . update _ depth ()
trg = A . update_depth ( )
rst = A . <unk> ( ) <eos>
2760
src = B を A の A の末尾番目の type に する
trg = A [ A [ - 1 ] ] . type = B
rst = A [ A [ A . <unk> ] = B <eos>
2761
src = fill ( A , B )
trg = fill ( A , B )
rst = fill ( A , B ) <eos>
2762
src = A が B 以上かつ A が C 以下かつ D が E 以上かつ D が F 以下のとき 、
trg = if ( A >= B and A <= C ) and ( D >= E and D <= F ) :
rst = if A >= B and A <= C and D >= E and D <= F : <eos>
2763
src = A の末尾に ( B の整数値 、 C の整数値 、 D 、 E の整数値 、 ネイピア数 ) の組 を追加する
trg = A . append ( ( int ( B ) , int ( C ) , D , int ( E ) , e ) )
rst = A . append ( ( int ( B ) , int ( C ) , D , int ( E ) , e ) ) <eos>
2764
src = B 、 C 、 D 、 E に お いて正規表現 A が最初にマッチする位置
trg = search ( A , B , C , D , E )
rst = search ( A , B , C , D , E ) <eos>
2765
src = A から B を引いた値が C から D を引いた値と等しいとき 、
trg = if A - B == C - D :
rst = if A - B == C - D : <eos>
2766
src = f ( A [ B *2], A [ B *2+1] ) を A の B 番目に する
trg = A [ B ] = f ( A [ B * 2 ] , A [ B * 2 + 1 ] )
rst = A [ B ] = ( f ( A [ B ] ) - 1 ] * A [ B * 2 * ) ) ) <eos>
2767
src = B の C の先頭を取り出した値 番目を A とする
trg = A = B [ C . pop ( ) ]
rst = A = B [ C . pop ( ) [ 0 ] <eos>
2768
src = B の bst に対応する値 、 もし存在しなければ C に 1 を加えた値を A とする
trg = A = B . bst . get ( C ) + 1
rst = A = B . bst . get ( C + 1 ) <eos>
2769
src = A から B を引いた値から C を引いた値が C より小さくかつ A から B を引いた値から C を引いた値が 0 より大きいとき 、
trg = if A - B - C < C and A - B - C > 0 :
rst = if A - B - C < C and A - B - C > 0 : <eos>
2770
src = A を B から C を引いた値を D で割った商だけ 増 加 させ る
trg = A += ( B - C ) // D
rst = A += ( B - C ) // D <eos>
2771
src = 1 を A の先頭の B から 1 を引いた値番目に する
trg = A [ 0 ] [ B - 1 ] = 1
rst = A [ 0 ] [ B - 1 ] = 1 <eos>
2772
src = 1 に B に C の 1 番目を掛けた値を 100 で割った値を加えた値を A とする
trg = A = 1 + B * C [ 1 ] / 100
rst = A = 1 + B * C [ 1 ] / 100 <eos>
2773
src = A を B の 、 つまり先頭から C 番目までの部分列 だけ 増 加 させ る
trg = A += B [ : C ]
rst = A += B [ : C ] <eos>
2774
src = A の全てが英大文字のとき 、
trg = if A . isupper ( ) :
rst = if A . isupper ( ) : <eos>
2775
src = A をネイピア数の c だけ 増 加 させ る
trg = A += e . c
rst = A += e . c <eos>
2776
src = A の value を返す
trg = return A . value
rst = return A . value <eos>
2777
src = time を A の B 番目の 1 番目だけ 増 加 させ る
trg = time += A [ B ] [ 1 ]
rst = time += A [ B ] [ 1 ] <eos>
2778
src = A から 1 を引いた値の 間 、 次 を 繰り返 す
trg = while A - 1 :
rst = while A - 1 : <eos>
2779
src = move ( A )
trg = move ( A )
rst = move ( A ) <eos>
2780
src = 改行せずに空白文字に A を加えた値に B の C 番目の文字列を加えた値に D を加えた値を出力する
trg = print ( ' ' + A + str ( B [ C ] ) + D , end = '' )
rst = print ( ' ' + str + str ( B [ C ] ) + D , end = '' ) <eos>
2781
src = A . spin ()
trg = A . spin ( )
rst = A . move ( ) <eos>
2782
src = 0 を A の left に する
trg = A . left = 0
rst = A . left = 0 <eos>
2783
src = E の B から 1 を引いた値番目の各要素を D とし 、 D が C 以下のとき の A の B から 1 を引いた値番目の C から D を引いた値番目の列の総和を A の B 番目の C 番目に する
trg = A [ B ] [ C ] = sum ( [ A [ B - 1 ] [ C - D ] for D in E [ B - 1 ] if D <= C ] )
rst = A [ B ] [ C ] = sum ( [ B [ 1 - [ C - D ] for D in E [ B - 1 ] ] ) <eos>
2784
src = D の log を順に A 、 B 、 C として 、 繰り返 す
trg = for A , B , C in D . log :
rst = for A , B , C in D . log : <eos>
2785
src = ( 、 つまり偽 、 偽 、 偽 ) からなる列を A とする
trg = A = [ False , False , False ]
rst = A = [ False , False , False ] <eos>
2786
src = 0 から B に 1 を加えた値未満までの数列の各要素 を C とし 、 ( (0) からなる列の 0 から 3 未満までの数列の各要素を C とし 、 B に 1 を加えた値の列回分の列 ) からなる列の列を A とする
trg = A = [ [ [ 0 ] * [ ( B + 1 ) for C in range ( 3 ) ] ] for C in range ( B + 1 ) ]
rst = A = [ [ [ 0 ] * [ ( B + 1 ) for C in range ( 3 ) ] ] for C in range ( B + 1 ) ] <eos>
2787
src = root ( A , A [ B ] ) を A の B 番目に する
trg = A [ B ] = root ( A , A [ B ] )
rst = A [ B ] = root ( A , A [ B ] ) <eos>
2788
src = ( (1、4) の組 、 (0、2、5 ) の組 、(1、3、 6) の組 、(2、 7 ) の組 、(0、5 ) の組 、(1、 4、6) の組 、(2、 5、7) の組 、 ( 3、6) の組 ) の組を A とする
trg = A = ( ( 1 , 4 ) , ( 0 , 2 , 5 ) , ( 1 , 3 , 6 ) , ( 2 , 7 ) , ( 0 , 5 ) , ( 1 , 4 , 6 ) , ( 2 , 5 , 7 ) , ( 3 , 6 ) )
rst = A = ( ( 5 , 1 ) , ( 1 , 1 ) , ( 5 , 5 ) , ( 5 , 5 ) , ( 5 , 5 ) , ( 5 , 5 ) , ( 5 , 5 ) , ( 1 , 5 )
2789
src = defaultdict ( int ,{ a : 1 }) を A とする
trg = A = defaultdict ( int , { a : 1 } )
rst = A = list ( int ( int ( 10 ** + 1 : ] ) ) <eos>
2790
src = A . cross ( B , C ) が D の epsilon より大きいとき 、
trg = if A . cross ( B , C ) > D . epsilon :
rst = if A . cross ( B , C ) > D . epsilon : <eos>
2791
src = A の先頭から B を探して見つかった位置が A の先頭から C を探して見つかった位置 と等しいかどうかを返す
trg = return A . find ( B ) == A . find ( C )
rst = return A . find ( B ) == A . find ( C ) <eos>
2792
src = A の B 番目の C 番目 、 A の B に 1 を加えた値番目の C から D の B 番目を引いた値番目に E の B 番目 を加えた値の最大値を A の B に 1 を加えた値番目の C 番目に する
trg = A [ B + 1 ] [ C ] = max ( A [ B ] [ C ] , A [ B + 1 ] [ C - D [ B ] ] + E [ B ] )
rst = A [ B + 1 ] [ C ] = max ( A [ B ] [ C ] , A [ B + 1 ] [ C - D [ B ] ] + E [ B ] ) <eos>
2793
src = 0 から D 未満までの数列の各要素を C とし 、 ( A に B を掛けた値 ) からなる列 を展開してを出力するの列
trg = [ print ( * [ A * B ] ) for C in range ( D ) ]
rst = [ print ( [ A * B ] for C in range ( D ) ] ) <eos>
2794
src = A の B 番目から 、 つまり末尾までの部分列の逆順 に A の 、 つまり先頭から B 番目までの部分列の逆順を加えた値
trg = A [ B : ] [ : : - 1 ] + A [ : B ] [ : : - 1 ]
rst = A . insert ( B , e [ A ] ) + B [ : : ] ) <eos>
2795
src = A . Node () を A の tail に する
trg = A . tail = A . Node ( )
rst = A . tail = A . Node ( ) <eos>
2796
src = ( ( A 、 B 、 C ) の組 ) からなる列に divide ([ A , C ] + D ) を加えた値を返す
trg = return [ ( A , B , C ) ] + divide ( [ A , C ] + D )
rst = return [ [ A , B , C ) ] + [ [ [ A , C ] + D ) <eos>
2797
src = get ( B , C , D , E , E [5], 5) のコピーされた列を A とする
trg = A = get ( B , C , D , E , E [ 5 ] , 5 ) [ : ]
rst = A = get ( B , C , D , E , E [ 5 : ] ) [ : ] <eos>
2798
src = A の 、 つまり円周率から B を引いた値番目に 1 を加えた値を A の 、 つまり円周率 番目に する
trg = A [ pi ] = A [ pi - B ] + 1
rst = A [ pi ] = A [ pi - B ] + 1 <eos>
2799
src = 100 を A の B 番目に する
trg = A [ B ] = 100
rst = A [ B ] = 100 <eos>
2800
src = A を書式として B の先頭 、 B の 1 番目で整形した文字列を出力する
trg = print ( A . format ( B [ 0 ] , B [ 1 ] ) )
rst = print ( A . format ( B [ 0 ] , B [ 1 ] ) ) <eos>
2801
src = A に 1 を加えた値が B より小さくかつ C の D 番目の A に 1 を加えた値番目が E と等しくなくかつ F の D 番目の A に 1 を加えた値 番目でないとき 、
trg = if A + 1 < B and C [ D ] [ A + 1 ] != E and not F [ D ] [ A + 1 ] :
rst = if A + 1 < B and C [ D ] [ A + 1 ] != E and not F [ D ] [ A + 1 ] : <eos>
2802
src = swap _ count ( A ) を無限の整数列 とする
trg = count = swap_count ( A )
rst = count = <unk> ( A ) <eos>
2803
src = A の B 番目を C で割った余りが A の B に 1 を加えた値番目を C で割った余り より大きいとき 、
trg = if A [ B ] % C > A [ B + 1 ] % C :
rst = if A [ B ] % C > A [ B + 1 ] % C : <eos>
2804
src = A の末尾に ( B の C 番目 ) からなる列 を追加する
trg = A . append ( [ B [ C ] ] )
rst = A . append ( [ B [ C ] ] ) <eos>
2805
src = 0 を D を C を B とする とするとするを A とする
trg = A = B = C = D = 0
rst = A = B = C = D = 0 <eos>
2806
src = A を B の C から 26 を引いた値番目だけ 増 加 させ る
trg = A += B [ C - 26 ]
rst = A += B [ C - 26 ] <eos>
2807
src = A が 4 以上のとき B 、 そうでなければ C を出力する
trg = print ( B if A >= 4 else C )
rst = print ( B if A >= 4 else C ) <eos>
2808
src = E を正規表現 D で分割した文字列リスト の各要素を B とし 、 B の長さが 1 より大きくかつ B の先頭が C と等しいかどうかの列が 少 なく と も ひ とつは真かどうかを A とする
trg = A = any ( [ len ( B ) > 1 and B [ 0 ] == C for B in re . split ( D , E ) ] )
rst = A = sorted ( [ ( len ( B ) > 1 and B B [ 0 ] == C for B in D , D in D ] ) <eos>
2809
src = getSum ( B , C , D *2+2, E +1, F ) を A とする
trg = A = getSum ( B , C , D * 2 + 2 , E + 1 , F )
rst = A = getSum ( B , C , D * 2 + 2 , E + 1 , F ) <eos>
2810
src = A の B 番目の C 番目内の D と等しい要素を取り除く
trg = A [ B ] [ C ] . remove ( D )
rst = A [ B ] [ C ] . remove ( D ) <eos>
2811
src = ( ( B , 0 から C 未満までの数列の各要素を B とし 、 、 つまり偽の列 )) からなる辞書を A とする
trg = A = { i : [ False for B in range ( C ) ] }
rst = A = { name : [ False for B in range ( C ) ] } <eos>
2812
src = calc ( A ) のとき 、
trg = if calc ( A ) :
rst = if calc ( A ) : <eos>
2813
src = B 、 C 、 D から 1 を引いた値 、 E に お いて正規表現 A が最初にマッチする位置
trg = search ( A , B , C , D - 1 , E )
rst = search ( A , B , C , D - 1 , E ) <eos>
2814
src = A . dinic ( B , C ) を出力する
trg = print ( A . dinic ( B , C ) )
rst = print ( A . dinic ( B , C ) ) <eos>
2815
src = A の先頭の p を出力する
trg = print ( A [ 0 ] . p )
rst = A . find ( 0 ) p ) <eos>
2816
src = A の B 番目の先頭を除いた部分列 を出力する
trg = print ( A [ B ] [ 1 : ] )
rst = print ( A [ B [ 1 : ] ) <eos>
2817
src = A の B 番目の C 番目の D 番目を E だけ 増 加 させ る
trg = A [ B ] [ C ] [ D ] += E
rst = A [ B ] [ C ] [ D ] += E <eos>
2818
src = readline () を空白で分割した字句列の各要素に 整数を適用した列を展開し 、 それぞれ A の B 番目 、 ネイピア数とする
trg = A [ B ] , e = map ( int , readline ( ) . split ( ) )
rst = A [ B ] , e = map ( int , readline ( ) . split ( ) ) <eos>
2819
src = ( B 、 C 、 D ) からなる列の集合を A とする
trg = A = set ( [ B , C , D ] )
rst = A = set ( [ B , C , D ] ) <eos>
2820
src = A の B から 1 を引いた値番目に 1 を加えた値が A に含まれまたは A の B から 1 を引いた値番目が 2019 と等しいとき 、
trg = if A [ B - 1 ] + 1 in A or A [ B - 1 ] == 2019 :
rst = if A [ B - 1 ] + 1 == A or A [ B - 1 ] == 2019 : <eos>
2821
src = (0) からなる列の B 回分の列を A の level に する
trg = A . level = [ 0 ] * B
rst = A . level = [ 0 ] * B <eos>
2822
src = B に B を掛けた値から 10001 未満までの B 間隔の数列を順に A として 、 繰り返 す
trg = for A in range ( B * B , 10001 , B ) :
rst = for A in range ( B * B , 10000001 ) B ) : <eos>
2823
src = A に円周率を掛けた値を 180. で割った値を A とする
trg = A = A * pi / 180.
rst = A = A * pi * pi <eos>
2824
src = A に B を掛けた値に C に D を掛けた値を加えた値に E を加えた値に A に B を掛けた値に C に D を掛けた値を加えた値に E を加えた値を掛けた値が F に F を掛けた値に A に A を掛けた値に C に C を掛けた値を加えた値を掛けた値 以下のとき 、
trg = if ( A * B + C * D + E ) * ( A * B + C * D + E ) <= F * F * ( A * A + C * C ) :
rst = if ( A * B + C * D + E + A * B + E ) + ( F * F + F * * A + C * C ) : <eos>
2825
src = A を ( < __ main __ . Cammaobjectat 0 x 109 e 4 1 c 7 0> ) の集合と の 論理和に する
trg = A |= { [ B + C for B in A ] }
rst = A |= { B } <eos>
2826
src = C の先頭の整数値を A の B 番目の left に する
trg = A [ B ] . left = int ( C [ 0 ] )
rst = A [ B ] . left = int ( C [ 0 ] ) <eos>
2827
src = 0 から C 未満までの数列の各要素を B とし 、 B の列を A の elements に する
trg = A . elements = [ B for B in range ( C ) ]
rst = A . prt = [ B for B in range ( C ) ] <eos>
2828
src = A と 10000 を 割った ときの ( 商を展開し 、 それぞれ A 、 B とする
trg = A , B = divmod ( A , 10000 )
rst = A , B = divmod ( A , 10000 ) <eos>
2829
src = D の各要素を A とし 、 A の C の各要素を B とし 、 B の A 番目 の列の最大値乗 の列を順に A として 、 繰り返 す
trg = for A in [ A ** max ( [ B [ A ] for B in C ] ) for A in D ] :
rst = for A in [ ( [ int ( B [ A ] for B in C ] ) for A in D ] ) : <eos>
2830
src = os . path の A 番目の B 番目でないとき 、
trg = if not path [ A ] [ B ] :
rst = if not path [ A ] [ B ] : <eos>
2831
src = C を 2 で割った余りのとき D 、 そうでなければ E を順に A 、 B として 、 繰り返 す
trg = for A , B in ( D if C % 2 else E ) :
rst = for A , B in D in 2 : <eos>
2832
src = B の C から 2 を引いた値番目を A とする
trg = A = B [ C - 2 ]
rst = A = B [ C - 2 ] <eos>
2833
src = A の B 番目の C から 3 を引いた値番目のとき 、
trg = if A [ B ] [ C - 3 ] :
rst = if A [ B ] [ C - 3 ] : <eos>
2834
src = A を B の C を D で割った余り番目だけ 減 少 させ る
trg = A -= B [ C % D ]
rst = A -= B [ C % D ] <eos>
2835
src = A の 0 と等しい要素の最初の位置に 1 を加えた値を返す
trg = return A . index ( 0 ) + 1
rst = return A . index ( 0 ) + 1 <eos>
2836
src = C を A の prev の B 番目に する
trg = A . prev [ B ] = C
rst = A . prev [ B ] = C <eos>
2837
src = A に 100 に B を加えた値を掛けた値を 100 で割った商に C に 100 に B を加えた値を掛けた値を 100 で割った商を加えた値が D と等しいとき 、
trg = if ( A * ( 100 + B ) // 100 ) + ( C * ( 100 + B ) // 100 ) == D :
rst = if ( A * ( 100 + B ) // 100 + C * ( 100 + B == 100 ) == D : <eos>
2838
src = F に G を加えた値を H で割った余りを E とする
trg = E = ( F + G ) % H
rst = E = ( F + G ) % H <eos>
2839
src = A の B の先頭番目の末尾に C の先頭 を追加する
trg = A [ B [ 0 ] ] . append ( C [ 0 ] )
rst = A [ B [ 0 ] ] . append ( C [ 0 ] ) <eos>
2840
src = D の各要素を B とし 、 ( B - C ) の 2 乗の列の総和を E で割った値の平方根を A とする
trg = A = math . sqrt ( sum ( [ ( B - C ) ** 2 for B in D ] ) / E )
rst = A = math . sqrt ( sum ( [ ( B - C ) ** 2 for B in D ] ) / E ) <eos>
2841
src = (1) からなる列に (0) からなる列の B から 1 を引いた値回分の列を加えた値 を A とする
trg = A = [ 1 ] + [ 0 ] * ( B - 1 )
rst = A = [ 1 ] + [ 0 ] * ( B - 1 ) <eos>
2842
src = F ( A , B , C [0]) が D と等しくかつ F ( A , B , C [1]) が E と等しいとき 、
trg = if F ( A , B , C [ 0 ] ) == D and F ( A , B , C [ 1 ] ) == E :
rst = if F ( A , B , C [ 0 ] == == D and F ( A , B , C [ 1 ] == E ) : <eos>
2843
src = B の C の末尾番目を D とする
trg = D = B [ C [ - 1 ] ]
rst = D = sorted ( B [ C [ 0 ] ] ) <eos>
2844
src = (3、2 ) からなる列を A の 1 番目に する
trg = A [ 1 ] = [ 3 , 2 ]
rst = A [ 1 ] = [ 0 , 2 , 5 ] <eos>
2845
src = A の末尾に 入力された文字列の両端から 空白改行を取り除いた文字列 を空白で分割した字句列の各要素を B とし 、 B の整数値の列 を追加する
trg = A . append ( [ int ( B ) for B in input ( ) . strip ( ) . split ( ) ] )
rst = A . append ( [ int ( B ) for B in input ( ) . strip ( ) . split ( ) ] ) <eos>
2846
src = 0、0 から 5 未満までの数列の各要素を C とし 、 、 つまり入力された文字列の整数値 の列を A 、 B とする
trg = A , B = 0 , [ int ( input ( ) ) for C in range ( 5 ) ]
rst = A , B = [ int ( input ( ) ) for C in range ( 5 ) ] <eos>
2847
src = A の nil を A の nil の prev に する
trg = A . nil . prev = A . nil
rst = A . nil . prev = A . nil <eos>
2848
src = A の 型 が B と等しいとき 、
trg = if type ( A ) == B :
rst = if type ( A ) == B : <eos>
2849
src = A に B に int ( input ()) を 100 で割った商に 3 を加えた値を掛けた値を加えた値 を出力する
trg = print ( A + B * ( int ( input ( ) ) // 100 + 3 ) )
rst = print ( A + B * int ( int ( input ( ) ) // 100 ) ) <eos>
2850
src = A 、 dfs ( B ,1<< B ) の最小値を A とする
trg = A = min ( A , dfs ( B , 1 << B ) )
rst = A = min ( A , dfs ( B << 1 , B ) ) <eos>
2851
src = A が B の elements に含まれるとき 、
trg = if A in B . elements :
rst = if A in B . 80 : <eos>
2852
src = A の B 番目の末尾に C に 100 を加えた値 を追加する
trg = A [ B ] . append ( C + 100 )
rst = A [ B ] . append ( C + 100 ) <eos>
2853
src = A の d の B 番目が C より小さいとき 、
trg = if A . d [ B ] < C :
rst = if A . d [ B ] < C : <eos>
2854
src = 2 の 2 を 底 とする B . size +1 の対数 に 1 を加えた値 乗の整数値から 1 を引いた値を A とする
trg = A = int ( 2 ** ( math . log2 ( B . size + 1 ) + 1 ) ) - 1
rst = A = 2 ** 2 math . log2 ( B . size + 1 ) + 1 <eos>
2855
src = - 10001 を A とする
trg = A = - 10001
rst = A = - 10001 <eos>
2856
src = B の -2 番目を B の -2 番目から 、 つまり末尾までの部分列の総和 で割った値を A とする
trg = A = B [ - 2 ] / sum ( B [ - 2 : ] )
rst = A = B [ - 2 ] / sum ( B [ - 2 : ] ) <eos>
2857
src = A を B が C に含まれるとき C の B 番目 、 そうでなければ B だけ 増 加 させ る
trg = A += C [ B ] if B in C else B
rst = A [ C [ B ] if B in C else B <eos>
2858
src = A の B 番目の C 番目が A の B から 1 を引いた値番目の C から 1 を引いた値番目と等しいとき 、
trg = if A [ B ] [ C ] == A [ B - 1 ] [ C - 1 ] :
rst = if A [ B ] [ C ] == A [ B - 1 ] [ C - 1 ] : <eos>
2859
src = A の B 番目の 0 番目が A の C 番目の先頭 より小さいとき 、
trg = if A [ B ] [ 0 ] < A [ C ] [ 0 ] :
rst = if A [ B ] [ 0 ] < A [ C ] [ 0 ] : <eos>
2860
src = A . delete () を A とする
trg = A = A . delete ( )
rst = A = A . delete ( ) <eos>
2861
src = A の B 番目の末尾に ( C 、 D 、 E 、 ネイピア数 ) の組 を追加する
trg = A [ B ] . append ( ( C , D , E , e ) )
rst = A [ B ] . append ( ( C , D , E , e ) ) <eos>
2862
src = ( (1、0) の組 、(0、1) の組 ) の組を A とする
trg = A = ( ( 1 , 0 ) , ( 0 , 1 ) )
rst = A = ( ( 1 , 0 ) , ( 1 , 1 ) ) <eos>
2863
src = vector _ minus ( B , C ) を A とする
trg = A = vector_minus ( B , C )
rst = A = <unk> ( B , C ) <eos>
2864
src = C にネイピア数を加えた値を A の B 番目に する
trg = A [ B ] = C + e
rst = A [ B ] = C + e <eos>
2865
src = A . spin 90 ()
trg = A . spin90 ( )
rst = A . put ( ) <eos>
2866
src = A の x 座標に A の x 座標を掛けた値に A の y 座標に A の y 座標を掛けた値を加えた値 の 1.0 を 2.0 で割った値乗 を返す
trg = return ( A . x * A . x + A . y * A . y ) ** ( 1.0 / 2.0 )
rst = return A . x * A . x + A . y * A . y * ( 1.0 / 2.0 ) <eos>
2867
src = - C を A の 1 番目の B 番目に する
trg = A [ 1 ] [ B ] = - C
rst = A [ 1 ] [ B ] = - C <eos>
2868
src = 0 から C 未満までの数列の各要素を D とし 、0 から C 未満までの数列の各要素を B とし 、 、 つまり無限大の列 の列を A とする
trg = A = [ [ inf for B in range ( C ) ] for D in range ( C ) ]
rst = A = [ [ inf for B in range ( C ) ] for D in range ( C ) ] <eos>
2869
src = B の先頭を除いた部分列の集合 を A とする
trg = A = set ( B [ 1 : ] )
rst = A = set ( B [ 1 : ] ) <eos>
2870
src = A の B から 1 を引いた値番目の 1 番目が A の B 番目の 1 番目と等しくかつ A の B から 1 を引いた値番目の 2 番目が A の B 番目の 2 番目と等しいとき 、
trg = if A [ B - 1 ] [ 1 ] == A [ B ] [ 1 ] and A [ B - 1 ] [ 2 ] == A [ B ] [ 2 ] :
rst = if A [ B - 1 ] [ 1 ] == A [ B ] [ 1 ] and A [ B - 1 ] [ A ] == A [ B ] [ 2 ] : <eos>
2871
src = 0 から G 未満までの数列の各要素を F とし 、0 から E 未満までの数列の各要素を D とし 、0 から C 未満までの数列の各要素を B とし 、0 の列の列の列 を A とする
trg = A = [ [ [ 0 for B in range ( C ) ] for D in range ( E ) ] for F in range ( G ) ]
rst = A = [ [ [ 0 for B in range ( C ) ] for D in range ( E ) ] for F in range ( G ) ] <eos>
2872
src = rotate _ dice ( B , C ) を A とする
trg = A = rotate_dice ( B , C )
rst = A = rotate_dice ( B , C ) <eos>
2873
src = A から B を引いた値が C 以下のとき 、
trg = if A - B <= C :
rst = if A - B <= C : <eos>
2874
src = A の B 番目 、 C の B 番目の最大値 を出力する
trg = print ( max ( A [ B ] , C [ B ] ) )
rst = print ( max ( A [ B ] , C [ B ] ) ) <eos>
2875
src = A の要素を右に - B 個 、 回転する
trg = A . rotate ( - B )
rst = A . rotate ( - B ) <eos>
2876
src = A の board が 、 つまり未定値と等しくないとき 、
trg = if A . board is None :
rst = if A . group is None : <eos>
2877
src = A が 0 以上かつ B が 0 以上かつ A が 9 以下かつ B が 9 以下のとき 、
trg = if A >= 0 and B >= 0 and A <= 9 and B <= 9 :
rst = if A >= 0 and B >= 0 and A <= 9 and B <= 9 : <eos>
2878
src = 文字 コ ー ド C の最小値に D の順序数を加えた値の文字を A の B 番目に する
trg = A [ B ] = chr ( min ( C ) + ord ( D ) )
rst = A [ B ] = chr ( ord ( C ) + ord ( D ) ) <eos>
2879
src = cwr ( C ,2) を順に A 、 B として 、 繰り返 す
trg = for A , B in cwr ( C , 2 ) :
rst = for A , B in <unk> ( C , 2 ) : <eos>
2880
src = A が B の C 番目より大きいとき 、
trg = if ( A > B [ C ] ) :
rst = if A > B [ C ] : <eos>
2881
src = C . flow _ with _ limit (0, D -1, E ) を展開し 、 それぞれ A 、 B とする
trg = A , B = C . flow_with_limit ( 0 , D - 1 , E )
rst = A , B = C . <unk> ( 0 , D - 1 , E ) <eos>
2882
src = A かつ B が C の D 番目に 1 を加えた値 より大きいかどうかが E 以下のとき 、
trg = if A and B > C [ D ] + 1 <= E :
rst = if A and B <= C [ D ] + 1 ] <= E : <eos>
2883
src = add ( A , B [0], B [2])
trg = add ( A , B [ 0 ] , B [ 2 ] )
rst = add ( A , B [ 0 ] , B [ 2 ] ) <eos>
2884
src = ( A の B 番目 、 A の B に 1 を加えた値番目 、 A の B に 2 を加えた値番目 ) からなる列が C と等しいとき 、
trg = if [ A [ B ] , A [ B + 1 ] , A [ B + 2 ] ] == C :
rst = if ( A [ B ] , A [ B + 1 ] , A [ B + 2 ] ] == C : <eos>
2885
src = A の B の長さから 1 を引いた値番目の末尾に B を追加する
trg = A [ len ( B ) - 1 ] . append ( B )
rst = A [ len ( B ) - 1 ] . append ( B ) <eos>
2886
src = A が B の部分集合のとき 1 、 そうでなければ 0 を出力する
trg = print ( 1 if A . issubset ( B ) else 0 )
rst = print ( 1 if A . issubset ( B ) else 0 ) <eos>
2887
src = ( B から 1 を引いた値 、 C から 1 を引いた値 、 D から 1 を引いた値 、 E から 1 を引いた値 ) の組を A とする
trg = A = ( B - 1 , C - 1 , D - 1 , E - 1 )
rst = A = ( B - 1 , C - 1 , D - 1 , E - 1 ) <eos>
2888
src = A に B を掛けた値に C に D を掛けた値を加えた値に A を 10 で割った商に E を掛けた値を加えた値に C を 20 で割った商に F を掛けた値を加えた値を返す
trg = return A * B + C * D + ( A // 10 ) * E + ( C // 20 ) * F
rst = return A * B + C * D + ( A // 10 * E + C // 20 * F <eos>
2889
src = next _ perm ( A [:]) を np とする
trg = np = next_perm ( A [ : ] )
rst = np = to_gamma ( A [ : ] ) <eos>
2890
src = A の B から 1 を引いた値番目に A の B 番目を加えた値を A の B 番目に する
trg = A [ B ] = A [ B - 1 ] + A [ B ]
rst = A [ B ] = A [ B - 1 ] + A [ B ] <eos>
2891
src = A を 4 で割った余りが 0 と等しくかつ A を 100 で割った余りが 0 と等しくなくまたは A を 400 で割った余りが 0 と等しいとき 、
trg = if A % 4 == 0 and ( A % 100 != 0 or A % 400 == 0 ) :
rst = if A % 4 == 0 and A % 100 != 0 or A % 400 == 0 : <eos>
2892
src = B の imag を 実 部 、 - B の real を 虚 部 とし た 複 素数を A とする
trg = A = complex ( B . imag , - B . real )
rst = A = complex ( B . imag , - B . real ) ) <eos>
2893
src = copy の 4 番目を A の 0 番目に する
trg = A [ 0 ] = copy [ 4 ]
rst = A [ 0 ] = copy [ 4 ] <eos>
2894
src = A . add _ edge ( B , C , D ,0)
trg = A . add_edge ( B , C , D , 0 )
rst = A . add_edge ( B , C , D , 0 ) <eos>
2895
src = A の 2 に B を掛けた値に 2 を加えた値番目を A の B 番目に する
trg = A [ B ] = A [ 2 * B + 2 ]
rst = A [ B ] = A [ 2 * B + 2 ] <eos>
2896
src = A が 、 つまりネイピア数より小さいとき (0、1) の組を ( B 、 C ) の組 とする 、 そうでなければ (1、0) の組
trg = ( B , C ) = ( 0 , 1 ) if A < e else ( 1 , 0 )
rst = ( ( A , ( 1 , ( 1 , ( 1 , ( 0 , B ) , A ) if ( 1 , 1 ) else 0 ) <eos>
2897
src = ネイピア数の cap を A だけ 減 少 させ る
trg = e . cap -= A
rst = e . cap -= A <eos>
2898
src = push ( A [1], A [2])
trg = push ( A [ 1 ] , A [ 2 ] )
rst = push ( A [ 1 ] , A [ 2 ] ) <eos>
2899
src = judge ( A )
trg = judge ( A )
rst = parents ( A ) <eos>
2900
src = B に C を加えた値に 1 を加えた値を A とする
trg = A = B + C + 1
rst = A = B + C + 1 <eos>
2901
src = (1) からなる列の B 回分の列を A の size に する
trg = A . size = [ 1 ] * B
rst = A . size = [ 1 ] * B <eos>
2902
src = A の C 番目に 1 を加えた値を A の B 番目に する
trg = A [ B ] = A [ C ] + 1
rst = A [ B ] = A [ C ] + 1 <eos>
2903
src = A が -1 と等しくないかどうかが B と等しくないかどうかが A と等しくないとき 、
trg = if A != - 1 != B != A :
rst = if A != - 1 != B != A : <eos>
2904
src = A を 362880 分の 一 に する
trg = A /= 362880
rst = A /= <unk> <eos>
2905
src = bfs ( A , B , C )
trg = bfs ( A , B , C )
rst = bfs ( A , B , C ) <eos>
2906
src = B の 2 乗に C の 2 乗を加えた値の 0.5 乗を 2 で割った商を A とする
trg = A = ( B ** 2 + C ** 2 ) ** 0.5 // 2
rst = A = ( B ** 2 + C ** 2 ) ** 0.5 <eos>
2907
src = D の C 番目を A の B に C を加えた値番目に する
trg = A [ B + C ] = D [ C ]
rst = A [ B + C ] = D [ C ] <eos>
2908
src = (0) からなる列の 、 つまり入力された文字列の整数値 回分の列 を順に A として 、 繰り返 す
trg = for A in [ 0 ] * int ( input ( ) ) :
rst = for A in [ 0 ] * int ( input ( ) ) : <eos>
2909
src = A の B と等しい要素の最初の位置に 1 を加えた値が 2020 より小さくかつ A の A の B と等しい要素の最初の位置に 1 を加えた値番目が 200 と等しいとき 、
trg = if A . index ( B ) + 1 < 2020 and A [ A . index ( B ) + 1 ] == 200 :
rst = if A . index ( B ) + 1 < A and A [ A . index ( B ) + 1 ] == 200 : <eos>
2910
src = A を B から C を引いた値の絶対値 、 D から E を引いた値の絶対値の最大値 だけ 増 加 させ る
trg = A += max ( abs ( B - C ) , abs ( D - E ) )
rst = A += max ( abs ( B - C ) , abs ( D - E ) ) <eos>
2911
src = D の整数値を A の B の順序数から C を引いた値番目に する
trg = A [ ord ( B ) - C ] = int ( D )
rst = A [ ord ( B ) - C ] = int ( D ) <eos>
2912
src = A の west を A の top に する
trg = A . top = A . west
rst = A . top = A . west <eos>
2913
src = B の先頭の浮動小数点数を A とする
trg = A = float ( B [ 0 ] )
rst = A = list ( B . keys ( ) ) <eos>
2914
src = register ( A , B , C ,2)
trg = register ( A , B , C , 2 )
rst = register ( A , B , C , 2 ) <eos>
2915
src = E 、 F 、 E に G を加えた値 、 F に H を加えた値を A 、 B 、 C 、 D とする
trg = A , B , C , D = E , F , E + G , F + H
rst = A , B , C , D = E , F , E + G , F + H <eos>
2916
src = A から B を引いた値を そうでなければ 、 とする
trg = else = A - B
rst = else = A - B <eos>
2917
src = lt ( A , B ) かつ lt ( B , pi ) または lt ( pi , B ) かつ lt ( B , A ) のとき 、
trg = if ( lt ( A , B ) and lt ( B , pi ) ) or ( lt ( pi , B ) and lt ( B , A ) ) :
rst = if ( lt ( A , B ) and lt ( B , pi ) ) < ( ( pi , B ) and EQ ( B , A ) : <eos>
2918
src = B から C に 1 を加えた値未満までの B 間隔の数列を順に A として 、 繰り返 す
trg = for A in range ( B , C + 1 , B ) :
rst = for A in range ( B , C + 1 , B ) : <eos>
2919
src = A . dfs ( B )
trg = A . dfs ( B )
rst = A . dfs ( B ) <eos>
2920
src = ((-1、0) の組 、(0、-1) の組 、(0、0) の組 、(0、1) の組 、(1、0) の組 ) からなる列を A とする
trg = A = [ ( - 1 , 0 ) , ( 0 , - 1 ) , ( 0 , 0 ) , ( 0 , 1 ) , ( 1 , 0 ) ]
rst = A = [ ( - 1 , 0 ) , ( 0 , 0 ) , ( 0 , 0 ) , ( 0 , 0 ) , ( 0 , 0 ) ] <eos>
2921
src = _ max ( A *2+1, B , C ) 、 _ max ( A *2+2, C +1, D ) の最大値を返す
trg = return max ( _max ( A * 2 + 1 , B , C ) , _max ( A * 2 + 2 , C + 1 , D ) )
rst = return max ( <unk> ( A * 2 + 1 , B , C ) , <unk> ( A * 2 + 2 , C , D ) <eos>
2922
src = query ( B , C ,2* D +1, E , ( E + F )//2) を A とする
trg = A = query ( B , C , 2 * D + 1 , E , ( E + F ) // 2 )
rst = A = query ( B , C , 2 , D + 1 , E , ( E + F ) // 2 ) <eos>
2923
src = B 、 C 、 D を A の to 、 A の cap 、 A の rev とする
trg = A . to , A . cap , A . rev = B , C , D
rst = A . rev , A . head , A . rev = B , C , D <eos>
2924
src = ( D 、 E 、 F ) の組を A の B 番目の C 番目に する
trg = A [ B ] [ C ] = ( D , E , F )
rst = A [ B ] [ C ] = ( D , E , F ) <eos>
2925
src = A の B 乗 を出力する
trg = print ( pow ( A , B ) )
rst = print ( A ** B ) <eos>
2926
src = A の先頭の 0 番目が B から C を引いた値と等しいとき 、
trg = if A [ 0 ] [ 0 ] == B - C :
rst = if A [ 0 ] [ 0 ] == B - C : <eos>
2927
src = A の next が 、 つまり未定値と等しいとき 、
trg = if A . next is not None :
rst = if A . next is not None : <eos>
2928
src = A の ( B 、 C 、 D ) の組番目に E を加えた値を A の ( B 、 C 、 D ) の組番目に する
trg = A [ ( B , C , D ) ] = A [ ( B , C , D ) ] + E
rst = A [ ( B , C , D ) ] = A [ ( B , C , D ) ] E ] <eos>
2929
src = B に C を掛けた値に D に pi を掛けた値を 180 で割った値の正弦を掛けた値を 2 で割った値を A とする
trg = A = B * C * sin ( D * pi / 180 ) / 2
rst = A = B * C * ( D * pi / 180 / 180 <eos>
2930
src = A の末尾に ( B の先頭から 1 を引いた値 、 B の 1 番目 ) の組 を追加する
trg = A . append ( ( B [ 0 ] - 1 , B [ 1 ] ) )
rst = A . append ( ( B [ 0 ] , 1 , B [ 1 ] ) ) <eos>
2931
src = A の B に 1 を加えた値番目を C を 2 で割った商に 1 を加えた値だけ 増 加 させ る
trg = A [ B + 1 ] += C // 2 + 1
rst = A [ B + 1 ] += C // 2 + 1 <eos>
2932
src = B の 1 番目から B の先頭に 1 を加えた値までの部分列を A とする
trg = A = B [ 1 : B [ 0 ] + 1 ]
rst = A = B [ 1 : B [ 0 ] + 1 ] <eos>
2933
src = 2001 を A とする
trg = A = 2001
rst = A = 2001 <eos>
2934
src = A の 7 番目を出力する
trg = print ( A [ 7 ] )
rst = print ( A [ 7 ] ) <eos>
2935
src = 改行せずに " leftkey = {}, " を出力する
trg = print ( left key = {lk}, , end = '' )
rst = print ( <unk> key = <unk> , end = '' ) <eos>
2936
src = ( (0) からなる列の 0 から 5 未満までの数列の各要素を C とし 、 B の列回分の列 ) からなる列を A とする
trg = A = [ [ 0 ] * [ B for C in range ( 5 ) ] ]
rst = A = [ [ 0 ] * [ B for C in range ( 5 ) ] ] <eos>
2937
src = B を C で割った値に D に E を加えた値を掛けた値から F を引いた値を A とする
trg = A = B / C * ( D + E ) - F
rst = A = B // C * ( D + E ) - F <eos>
2938
src = B に C から B を引いた値に math . pi を 3 で割った値の余弦を掛けた値 を加えた値から D から E を引いた値に円周率を 3 で割った値の正弦 を掛けた値を引いた値を A とする
trg = A = B + ( C - B ) * math . cos ( math . pi / 3 ) - ( D - E ) * math . sin ( math . pi / 3 )
rst = A = B + ( C - B ) * math . sin ( math . pi / 3 ) - D D * E ) <eos>
2939
src = 改行文字を A とする
trg = A = '\n'
rst = A = 100000 <eos>
2940
src = ( B に C を加えた値 、 D 、0、 E ) からなる列を A の 、 つまり先頭から 4 番目までの部分列に する
trg = A [ : 4 ] = [ B + C , D , 0 , E ]
rst = A [ : 4 ] = [ B + C , D , 0 , E , <eos>
2941
src = B の C 番目から D を引いた値に E を加えた値を A とする
trg = A = B [ C ] - D + E
rst = A = B [ C ] - D + E <eos>
2942
src = B の 、 つまり空白文字 と等しい要素の最初の位置を A とする
trg = A = B . index ( ' ' )
rst = A = B . index ( ' ' ) <eos>
2943
src = A の B 番目の C 番目の D に 1 を加えた値番目を 1 だけ 増 加 させ る
trg = A [ B ] [ C ] [ D + 1 ] += 1
rst = A [ B ] [ C ] [ D + 1 ] += 1 <eos>
2944
src = l をパラメータとして D ( B [2]) から D ( B [0]) を引いた値に D ( B [6] ) から D ( B [4]) を引いた値を掛けた値に D ( B [3]) から D ( B [1]) を引いた値に D ( B [7]) から D ( B [5]) を引いた値を掛けた値を加えた値 を返す関数を A とする
trg = A = lambda B : ( ( D ( B [ 2 ] ) - D ( B [ 0 ] ) ) * ( D ( B [ 6 ] ) - D ( B [ 4 ] ) ) + ( D ( B [ 3 ] ) - D ( B [ 1 ] ) ) * ( D ( B [ 7 ] ) - D ( B [ 5 ] ) ) )
rst = A = lambda B : ( D D [ D ] ) - ( D [ B ] ) - D D [ B ] ) ) * ( D D [ B ] ) - D D [ B ] ) ) - D D [ D ] )
2945
src = B の先頭の 1 番目に B の 2 番目の 1 番目を加えた値を 2 で割った値を A とする
trg = A = ( B [ 0 ] [ 1 ] + B [ 2 ] [ 1 ] ) / 2
rst = A = ( B [ 0 ] [ 1 ] + B [ 2 ] [ 1 ] ) / 2 <eos>
2946
src = A の 2 番目を B だけ 増 加 させ る
trg = A [ 2 ] += B
rst = A [ 2 ] += B <eos>
2947
src = A の B に C を加えた値番目が D と等しいとき 、
trg = if A [ B + C ] == D :
rst = if A [ B + C ] == D : <eos>
2948
src = A の B 番目が 4 より大きいとき 、
trg = if A [ B ] > 4 :
rst = if A [ B ] > 4 : <eos>
2949
src = B に 5 を加えた値を 5 で割った商の整数値を A とする
trg = A = int ( ( B + 5 ) // 5 )
rst = A = int ( ( B + 5 ) // 5 ) <eos>
2950
src = 0 から B から C を引いた値未満までの数列を順に A として 、 繰り返 す
trg = for A in range ( B - C ) :
rst = for A in range ( B - C ) : <eos>
2951
src = e . residual _ capacity ( A ) が 0 より大きくかつ B の C 番目が B の A 番目に D を加えた値 より大きいとき 、
trg = if e . residual_capacity ( A ) > 0 and B [ C ] > B [ A ] + D :
rst = if e . A ( A ) > > 0 and B [ C ] > B [ A ] + D : <eos>
2952
src = (1、2、3、0) からなる列 を順に A として 、 繰り返 す
trg = for A in [ 1 , 2 , 3 , 0 ] :
rst = for A in [ 0 , 3 ] : <eos>
2953
src = A の末尾に B の C に 1 を加えた値番目を D の C に 1 を加えた値番目 で割った余り を追加する
trg = A . append ( B [ C + 1 ] % D [ C + 1 ] )
rst = A . append ( B [ C + 1 ] % D [ C + 1 ] ) <eos>
2954
src = ネイピア数の 、 つまり無限大 の先頭番目の末尾に ( 、 つまり無限大の 2 に A に 2 を掛けた値を加えた値番目 、 無限大 の 2 に A *2 を加えた値に 1 を加えた値番目 ) からなる列 を追加する
trg = e [ inf [ 0 ] ] . append ( [ inf [ 2 + A * 2 ] , inf [ 2 + A * 2 + 1 ] ] )
rst = e . append ( [ e [ 0 ] , [ 2 2 * 2 + 2 * A [ 2 + 2 * 2 ] ) , [ 2 + [ 2 ] ) <eos>
2955
src = 入力された文字列 を空白で分割した字句列の各要素 に整数を適用した列の組に 10 の 18 乗を加えた値を A とする
trg = A = tuple ( map ( int , input ( ) . split ( ) ) ) + ( 10 ** 18 )
rst = A = sum ( map ( int , input ( ) . split ( ) ) ) ** 8 <eos>
2956
src = A が 、 つまり未定値と等しくなくかつ B が A の right と等しい 間 、 次 を 繰り返 す
trg = while A != None and B == A . right :
rst = while A != None and B == A . right : <eos>
2957
src = 0 から F 未満までの数列の各要素を E とし 、 D から読み込んだ一行を 空白で分割した字句列 の各要素に整数を適用した列 の列を順に A 、 B 、 C として 、 繰り返 す
trg = for A , B , C in ( [ map ( int , D . readline ( ) . split ( ) ) for E in range ( F ) ] ) :
rst = for A , B , C in [ [ ( int , D . readline ( ) . split ( ) ) for E in range ( F ) ] : <eos>
2958
src = closest _ pair _ distance ( B ) を A とする
trg = A = closest_pair_distance ( B )
rst = A = closest_pair_distance ( B ) <eos>
2959
src = 0 を A の mincost に する
trg = A . mincost = 0
rst = A . <unk> = 0 <eos>
2960
src = A の FLAGS と A の ALL _ ON の論理積が A の ALL _ ON と等しいかどうかを返す
trg = return A . FLAGS & A . ALL_ON == A . ALL_ON
rst = return A . FLAGS & A . <unk> == A . ALL_OFF <eos>
2961
src = ( 、 つまりネイピア数から 2 に円周率を掛けた値 を引いた値 、1) の組を A にソート順で 最後 に 挿入する
trg = insort ( A , ( e - 2 * pi , 1 ) )
rst = insort ( A , ( e - 2 , 1 ) ) <eos>
2962
src = 0 から C 未満までの数列の各要素を B とし 、0 の列を A とする
trg = A = [ 0 for B in range ( C ) ]
rst = A = [ 0 for B in range ( C ) ] <eos>
2963
src = A の B に 1 を加えた値番目の C に 1 を加えた値番目を 1 だけ 増 加 させ る
trg = A [ B + 1 ] [ C + 1 ] += 1
rst = A [ B + 1 ] [ C + 1 ] += 1 <eos>
2964
src = 0 から D 未満までの数列の各要素を B とし 、 A [ B ] から C [ B ] を引いた値の絶対値 の列の総和を出力する
trg = print ( sum ( [ abs ( A [ B ] - C [ B ] ) for B in range ( D ) ] ) )
rst = print ( sum ( [ A [ B ] - ( C [ B ] ) for B in range ( D ) ] ) ) <eos>
2965
src = A の B に 6 を加えた値を 7 で割った余り番目 を出力する
trg = print ( A [ ( B + 6 ) % 7 ] )
rst = print ( A [ ( B + 6 ) % 7 ] ) <eos>
2966
src = A < B または C < D または E が F より小さくまたは G が H より小さいとき I 、 そうでなければ J を出力する
trg = print ( I if A < B or C < D or E < F or G < H else J )
rst = print ( I if A < ( B < C ) or D < E < F < G < H < J else J ) <eos>
2967
src = 真を A の cdused の B 番目に する
trg = A . cdused [ B ] = True
rst = A . cdused [ B ] = True <eos>
2968
src = rot 60 _ on _ complex _ plane ( B , C ) を A とする
trg = A = rot60_on_complex_plane ( B , C )
rst = A = <unk> ( B , C ) <eos>
2969
src = 集合 、 集合を A 、 B とする
trg = A , B = set ( ) , set ( )
rst = A , B = set ( ) , set ( ) <eos>
2970
src = B の 2 乗に C の 2 乗を加えた値から 2 に B を掛けた値に C を掛けた値に D の余弦を掛けた値を引いた値 を A とする
trg = A = B ** 2 + C ** 2 - 2 * B * C * math . cos ( D )
rst = A = B ** 2 + ( C ** 2 - 2 * B * C * math . cos ( D ) ) <eos>
2971
src = A が 1 以上かつ B が 8 以下のとき 、
trg = if A >= 1 and B <= 8 :
rst = if A >= 1 and B <= 8 : <eos>
2972
src = A の長さが 0 と等しくまたは B の長さが 0 と等しいとき 、
trg = if len ( A ) == 0 or len ( B ) == 0 :
rst = if len ( A ) == 0 or len ( B ) == 0 : <eos>
2973
src = A . masks の C 番目の各要素を B とし 、 A . data &1 を B だけ左シフトした値の列 が全てが真かどうか の整数値を出力する
trg = print ( int ( all ( [ A . data & 1 << B for B in A . masks [ C ] ] ) ) )
rst = print ( int ( [ A . Counter ( range ( A ) for B << A . masks [ C ] ] ) ) <eos>
2974
src = A に 1000 を掛けた値を出力する
trg = print ( A * 1000 )
rst = print ( A * 1000 ) <eos>
2975
src = A から B を引いた値に C から B を引いた値を加えた値を A とする
trg = A = A - B + ( C - B )
rst = A = ( A - B ) + ( C - B ) <eos>
2976
src = A の各要素を B とし 、 B の 、 つまり先頭から - C 番目までの部分列 の列を A とする
trg = A = [ B [ : - C ] for B in A ]
rst = A = [ B [ : - C ] for B in A ] <eos>
2977
src = A . is _ same ( B ) のとき 、
trg = if A . is_same ( B ) :
rst = if A . <unk> ( B ) : <eos>
2978
src = 1 を A の B 番目の B 番目とするを A の B 番目の 0 番目に する
trg = A [ B ] [ 0 ] = A [ B ] [ B ] = 1
rst = A [ B ] [ 0 ] = A [ B ] [ B ] = 1 <eos>
2979
src = (0) からなる列の B 回分の列を A の data に する
trg = A . data = [ 0 ] * B
rst = A . data = [ 0 ] * B <eos>
2980
src = B の順序数から B の順序数に 26 を加えた値未満までの数列を順に A として 、 繰り返 す
trg = for A in range ( ord ( B ) , ord ( B ) + 26 ) :
rst = for A in range ( ord ( B ) - ord ( B ) + 26 ) : <eos>
2981
src = time を入力された文字列の整数値だけ 増 加 させ る
trg = time += int ( input ( ) )
rst = time += int ( input ( ) ) <eos>
2982
src = 入力された文字列 を空白で分割した字句列 を展開し 、 それぞれ A 、 整数 とする
trg = A , str = input ( ) . split ( )
rst = A , str = input ( ) . split ( ) <eos>
2983
src = B の 1 番目から C を引いた値を A とする
trg = A = B [ 1 ] - C
rst = A = B [ 1 ] - C <eos>
2984
src = 空白文字を 代わ りの行末として A の B 番目 の総和を出力する
trg = print ( sum ( A [ B ] ) , end = ' ' )
rst = print ( sum ( A [ B ] ) , end = ' ' ) <eos>
2985
src = 1 が A の B の先頭 番目と等しいとき 、
trg = if ( 1 == A [ B [ 0 ] ] ) :
rst = if ( 1 == A [ B [ 0 ] ] : <eos>
2986
src = calc ( A -2, B , C , D ) に [ MASK ] を加えた値
trg = + calc ( A - 2 , B , C , D )
rst = + calc ( A - 2 , B , C , D ) <eos>
2987
src = A * B から C * D を引いた値の絶対値が 1 e -10 より小さいとき E 、 そうでなければ F を出力する
trg = print ( E if abs ( A * B - C * D ) < 1e-10 else F )
rst = print ( E if abs ( A * ( B - C * D ) < 1e-10 else F ) <eos>
2988
src = ( C 、 D ) の組 、 ( E から C を引いた値 、 D ) の組を A 、 B とする
trg = A , B = ( C , D ) , ( E - C , D )
rst = A , B = ( C , D ) , ( E - C , D ) <eos>
2989
src = B のとき B の整数値 、 そうでなければ 1 を A の -2 番目に する
trg = A [ - 2 ] = int ( B ) if B else 1
rst = A [ - 2 ] = B ( B ) if B else 1 <eos>
2990
src = C を 1 だけ右シフトした値を B とする を A とする
trg = A = B = C >> 1
rst = A = B = C >> 1 <eos>
2991
src = ( (0, 0)、( 1 , 0)、( 2 , 0)、( 3 , 0)、( 4 , 0)、( 5 , 0 )) からなる辞書を A とする
trg = A = { 0 : 0 , 1 : 0 , 2 : 0 , 3 : 0 , 4 : 0 , 5 : 0 }
rst = A = { 0 : 0 , 0 : 0 , 'E' : 3 , 'E' : 0 , 'E' : 0 , <unk> : 0 , <unk> : 0 , 0 : <eos>
2992
src = 0 から D 未満までの数列の各要素を C とし 、0 から D 未満までの数列の各要素を B とし 、 B から C を引いた値の 2 乗 の列の列を A とする
trg = A = [ [ ( B - C ) ** 2 for B in range ( D ) ] for C in range ( D ) ]
rst = A = [ [ ( B - C ) ** 2 for B in range ( D ) ] for C in range ( D ) ] <eos>
2993
src = time の先頭を A とする
trg = A = time [ 0 ]
rst = A = time [ 0 ] <eos>
2994
src = A を書式として _ str ( B ) 、 C 、 D 、 _ str ( E ) で整形した文字列を返す
trg = return A . format ( _str ( B ) , C , D , _str ( E ) )
rst = return A . format ( str ( B ) , C , D ( E ) ) <eos>
2995
src = _ heights ( A ) を返す
trg = return _heights ( A )
rst = return <unk> ( A ) <eos>
2996
src = A の 3 番目の B 番目を A の C 番目の B 番目だけ 増 加 させ る
trg = A [ 3 ] [ B ] += A [ C ] [ B ]
rst = A [ 3 ] [ B ] += A [ C ] [ B ] <eos>
2997
src = A の総和から B を引いた値 を出力する
trg = print ( sum ( A ) - B )
rst = print ( sum ( A ) - B ) <eos>
2998
src = ( 、 つまり空文字列 ) からなる列の 100 回分の列を A とする
trg = A = [ '' ] * 100
rst = A = [ '' ] * 100 <eos>
2999
src = A の B 番目が 0 より大きくかつ A の C 番目が 0 より大きいとき 、
trg = if A [ B ] > 0 and A [ C ] > 0 :
rst = if A [ B ] > 0 and A [ C ] > 0 : <eos>
3000
src = A 、 D の各要素に pre 、 cur をパラメータとして B に 1 を加えた値に C と 1 の排他論理和 を掛けた値を 返す関数を適用した列のリストを A とする
trg = A = list ( map ( lambda B , C : ( B + 1 ) * ( C ^ 1 ) , A , D ) )
rst = A = gcd ( A , B , lambda B + 1 : C + 1 ) , , , , D ) <eos>
3001
src = A の集合のリストの長さ を出力する
trg = print ( len ( list ( set ( A ) ) ) )
rst = print ( len ( str ( A ) ) ) <eos>
3002
src = 区 切りなしで A 、 B に C から 2 を引いた値を掛けた値 、 A を出力する
trg = print ( A , B * ( C - 2 ) , A , sep = '' )
rst = print ( A , B * ( C - 2 , A , sep = '' ) <eos>
3003
src = A に B を加えた値が C より大きくまたは D に B を加えた値が E より大きくまたは A から B を引いた値が 0 より小さくまたは D から B を引いた値が 0 より小さいとき 、
trg = if A + B > C or D + B > E or A - B < 0 or D - B < 0 :
rst = if A + B > C or D + B > E or ( A < B or 0 or D < B < 0 ) : <eos>
3004
src = A の bits が 0 と等しくないかどうかを返す
trg = return A . bits != 0
rst = return A . bits != 0 <eos>
3005
src = C の D 番目を空白で分割した字句列 を展開し 、 それぞれ A 、 B とする
trg = A , B = C [ D ] . split ( )
rst = A , B = C [ D [ 0 ] ] <eos>
3006
src = A が B の C 番目より小さい 間 、 次 を 繰り返 す
trg = while A < B [ C ] :
rst = while A < B [ C ] : <eos>
3007
src = B の 1 番目に 4 を掛けた値に B の 2 番目に 9 を掛けた値を加えた値に B の 3 番目に 4 を掛けた値を加えた値を A とする
trg = A = B [ 1 ] * 4 + B [ 2 ] * 9 + B [ 3 ] * 4
rst = A = B [ 1 ] * 4 + B [ 2 ] * 9 + B [ 3 ] * 4 <eos>
3008
src = 入力された文字列の整数値を A の 3 番目に する
trg = A [ 3 ] = int ( input ( ) )
rst = A [ 3 ] = int ( input ( ) ) <eos>
3009
src = A の - B 番目から 、 つまり末尾までの部分列を A とする
trg = A = A [ - B : ]
rst = A = A [ - B : ] <eos>
3010
src = A が B と等しいとき C 、 そうでなければ D を返す
trg = return C if A == B else D
rst = return C if A == B else D <eos>
3011
src = B を A の graph に する
trg = A . graph = B
rst = A . graph = B <eos>
3012
src = A が B に C を掛けた値と等しいとき 、
trg = if A == B * C :
rst = if A == B * C : <eos>
3013
src = A の bst に対応する値 、 もし存在しなければ B が 0 より大きいかどうかを返す
trg = return A . bst . get ( B ) > 0
rst = return A . bst . get ( B , 0 ) <eos>
3014
src = A の B に 1 を加えた値番目の C に D を加えた値番目を A の B 番目の C 番目だけ 増 加 させ る
trg = A [ B + 1 ] [ C + D ] += A [ B ] [ C ]
rst = A [ B + 1 ] [ C + D ] += A [ B ] [ C ] <eos>
3015
src = reverse _ polish _ calculator ( A ) を出力する
trg = print ( reverse_polish_calculator ( A ) )
rst = print ( <unk> ( A ) ) <eos>
3016
src = A 、 B の ( C に D を加えた値 、 E に F を加えた値 ) の組 番目の最大値を A とする
trg = A = max ( A , B [ ( C + D , E + F ) ] )
rst = A = max ( A , B [ ( C + D , E + F ) ) <eos>
3017
src = heappush ( A ,(- ( B + C ) , D , E +1))
trg = heappush ( A , ( - ( B + C ) , D , E + 1 ) )
rst = heappush ( A , ( - ( B + C ) , D , E + 1 ) ) <eos>
3018
src = A 内の A の最小値 と等しい要素を取り除く
trg = A . remove ( min ( A ) )
rst = A . remove ( min ( A ) ) <eos>
3019
src = ソートされた順序を保ったまま B の C 番目に D を加えた値を C から A に 1 を加えた値までの 範囲 で B に挿入できる位置から 1 を引いた値を A とする
trg = A = bisect_right ( B , B [ C ] + D , C , A + 1 ) - 1
rst = A = bisect_left ( B , B [ C ] + D ) % ( C - A + 1 ) - 1 <eos>
3020
src = ((0、0) の組 、(1、0) の組 ) からなる列を A とする
trg = A = [ ( 0 , 0 ) , ( 1 , 0 ) ]
rst = A = [ ( 0 , 0 ) , ( 1 , 0 ) ] <eos>
3021
src = 0 が A 以下かどうかが 7 以下かつ 0 が B 以下かどうかが 7 以下かつ C の B 番目の A 番目が D と等しいとき 、
trg = if 0 <= A <= 7 and 0 <= B <= 7 and C [ B ] [ A ] == D :
rst = if 0 <= A <= 7 and 0 <= B <= 7 and C [ B ] [ A ] == D : <eos>
3022
src = A の B 番目が 0 以上のとき 、
trg = if A [ B ] >= 0 :
rst = if A [ B ] >= 0 : <eos>
3023
src = MinimumSpanningTree ( B , C ) を A とする
trg = A = MinimumSpanningTree ( B , C )
rst = A = <unk> ( B , C ) <eos>
3024
src = B の最大値から B の最小値を引いた値を A とする
trg = A = max ( B ) - min ( B )
rst = A = max ( B ) - min ( B ) <eos>
3025
src = A が 0 以下または B が 0 以下または C が 0 以下のとき 、
trg = if A <= 0 or B <= 0 or C <= 0 :
rst = if A <= 0 or B <= 0 or C <= 0 : <eos>
3026
src = B と C の論理和のリストを A とする
trg = A = list ( B | C )
rst = A = list ( B ^ C ) <eos>
3027
src = A [ B ] が C と等しくかつ A [ B +1] が D と等しくかつ A の B +2 番目が E と等しくかつ A の B に 3 を加えた値番目が F と等しくかつ A の B に 4 を加えた値番目が G と等しいとき 、
trg = if A [ B ] == C and A [ B + 1 ] == D and A [ B + 2 ] == E and A [ B + 3 ] == F and A [ B + 4 ] == G :
rst = if A [ B ] == C and A [ B + 1 ] == D and A [ B + 2 ] == E and A [ B + 3 ] == F and A [ B + 4 ] == G : <eos>
3028
src = sieve () を A とする
trg = A = sieve ( )
rst = A = Stack ( ) <eos>
3029
src = 空白文字を 代わ りの行末として A + str ( B )+ C + str ( D [ B ][0]) に E を加えた値に getDepth ( D [ B ] ) を加えた値に F を加えた値に G を加えた値を出力する
trg = print ( A + str ( B ) + C + str ( D [ B ] [ 0 ] ) + E + getDepth ( D [ B ] ) + F + G , end = ' ' )
rst = print ( A + str ( B ) + C + str ( D [ B ] [ 0 ] + E ) + E ) + ( D D [ B ] ) + F + G ) <eos>
3030
src = A が B より小さい 間 、 次 を 繰り返 す
trg = while A < B :
rst = while A < B : <eos>
3031
src = A を B から C を引いた値の絶対値の D 乗だけ 増 加 させ る
trg = A += abs ( B - C ) ** D
rst = A += ( abs ( B - C ) ) D ) <eos>
3032
src = 0 から F に 1 を加えた値未満までの数列の各要素 を C とし 、 B の C に D を掛けた値に E を加えた値 番目の列の最小値を A とする
trg = A = min ( [ B [ C * D + E ] for C in range ( F + 1 ) ] )
rst = A = min ( [ B [ C * D + E ] for C in range ( F + 1 ) ] <eos>
3033
src = 0 から B から 1 を引いた値未満までの数列を順に A として 、 繰り返 す
trg = for A in range ( B - 1 ) :
rst = for A in range ( B - 1 ) : <eos>
3034
src = A . heappush ( B , Node ( C . dst , D . dist [ C . dst ]))
trg = A . heappush ( B , Node ( C . dst , D . dist [ C . dst ] ) )
rst = A . heappush ( B , Node ( C . dst , D . dist [ C . dst ] ) ) <eos>
3035
src = ( A 、 B 、 C 、 D 、 E 、 F ) の組を返す
trg = return ( A , B , C , D , E , F )
rst = return ( A , B , C , D , E , F ) <eos>
3036
src = C の 0 番目から D の先頭を引いた値 、 C の 1 番目から D の 1 番目を引いた値を A 、 B とする
trg = A , B = C [ 0 ] - D [ 0 ] , C [ 1 ] - D [ 1 ]
rst = A , B = C [ 0 ] - D [ 0 ] , C [ 1 ] - D [ 1 ] <eos>
3037
src = A を書式として B の real 、 B の imag 、 C の real 、 C の imag で整形した文字列を出力する
trg = print ( A . format ( B . real , B . imag , C . real , C . imag ) )
rst = print ( A . format ( B . real , B . imag , C . real , C . imag ) ) <eos>
3038
src = D に E を加えた値を A の B 番目の C に 1 を加えた値番目に する
trg = A [ B ] [ C + 1 ] = D + E
rst = A [ B ] [ C + 1 ] = D + E <eos>
3039
src = Pre _ order ( A )
trg = Pre_order ( A )
rst = set_height ( A ) <eos>
3040
src = A に B を加えた値が 12 より小さい 間 、 次 を 繰り返 す
trg = while A + B < 12 :
rst = while A + B < 12 : <eos>
3041
src = ( B 、 C 、 D 、 E 、 F 、 G 、 H 、 I ) の組を A とする
trg = A = ( B , C , D , E , F , G , H , I )
rst = A = ( B , C , D , E , F , G , H , I ) <eos>
3042
src = A に D に E を掛けた値を加えた値 、 B に E を加えた値 、 C に 1 を加えた値を A 、 B 、 C とする
trg = A , B , C = A + D * E , B + E , C + 1
rst = A , B , C = A + D * E , B + E , C + 1 <eos>
3043
src = A 、 B の総和から A 、 C から 1 を引いた値 の総和を引いた値 を出力する
trg = print ( A . sum ( B ) - A . sum ( C - 1 ) )
rst = print ( A , sum ( B ) - A , C - 1 ) . <eos>
3044
src = A の 0 に 0 を挿入する
trg = A . insert ( 0 , 0 )
rst = A . insert ( 0 , 0 ) <eos>
3045
src = A の graph の 、 つまりネイピア数の先頭番目 の末尾に ( 、 つまりネイピア数の 1 番目 、 ネイピア数の 2 番目 ) の組 を追加する
trg = A . graph [ e [ 0 ] ] . append ( ( e [ 1 ] , e [ 2 ] ) )
rst = A . graph [ e [ e ] . append ( ( e [ e ] , e [ 2 ] ) ) <eos>
3046
src = intersection _ of _ perpendicular ( B , C , D ) を A とする
trg = A = intersection_of_perpendicular ( B , C , D )
rst = A = <unk> ( B , C , D ) <eos>
3047
src = A を B から 始 まり C 間隔 で 続 く無限の整数列 だけ 増 加 させ る
trg = A += count ( B , C )
rst = A += <unk> ( B ( B ) C ( C ) ) <eos>
3048
src = A を書式として B の t 、 B の b 、 B の n 、 B の s 、 B の e 、 B の w で整形した文字列を出力する
trg = print ( A . format ( B . t , B . b , B . n , B . s , B . e , B . w ) )
rst = print ( A . format ( B . t , B . b , B . n , B . s , B . e , B . e , B . w ) ) <eos>
3049
src = cross ( A - B , C - D ) の絶対値が 1 e -10 より小さいとき E 、 そうでなければ F を出力する
trg = print ( E if abs ( cross ( A - B , C - D ) ) < 1e-10 else F )
rst = print ( E if abs ( cross ( A - B , C - D ) ) < 1e-10 else F ) <eos>
3050
src = ネイピア数が 0 と等しくまたは A が B と等しいとき 、
trg = if e == 0 or A == B :
rst = if e == 0 or A == B : <eos>
3051
src = A の B の 1 番目の整数値から B の 2 番目の整数値に 1 を加えた値までの部分列 を出力する
trg = print ( A [ int ( B [ 1 ] ) : int ( B [ 2 ] ) + 1 ] )
rst = print ( A [ int ( B [ 1 ] ) : int ( B [ 2 ] ) + 1 ] ) <eos>
3052
src = B を A の south に する
trg = A . south = B
rst = A . south = B <eos>
3053
src = A に B を掛けた値 、 C が A 以上のとき D 、 そうでなければ D に ( A - C ) に E を掛けた値を加えた値の最小値 を出力する
trg = print ( min ( A * B , D if C >= A else D + ( A - C ) * E ) )
rst = print ( min ( A if B * B , C >= A ) + ( D * A ) C * E ) ) <eos>
3054
src = B に 10 の -5 乗を掛けた値を A とする
trg = A = B * 10 ** - 5
rst = A = B * 10 ** 5 <eos>
3055
src = A を 6 に B を掛けた値だけ 減 少 させ る
trg = A -= 6 * B
rst = A -= 6 * B <eos>
3056
src = A の末尾に ( B 、 C 、0) からなる列 を追加する
trg = A . append ( [ B , C , 0 ] )
rst = A . append ( [ B , C , 0 ] ) <eos>
3057
src = B の C に D を加えた値から C に D を加えた値に E を加えた値までの部分列を A とする
trg = A = B [ C + D : C + D + E ]
rst = A = B [ C + D : C + D + E ] <eos>
3058
src = B に 151 を掛けた値を A とする
trg = A = B * 151
rst = A = B * <unk> <eos>
3059
src = A の next が 、 つまり未定値と等しくかつ A の next の key が B と等しくない 間 、 次 を 繰り返 す
trg = while A . next is not None and A . next . key != B :
rst = while A . next is not None and A . next . key != B : <eos>
3060
src = A の総和が B と等しくかつ C が D と等しいかどうかを返す
trg = return sum ( A ) == B and C == D
rst = return sum ( A ) == B and C == D <eos>
3061
src = C の各要素を B とし 、 B の総和が D と等しいとき の B の列を A とする
trg = A = [ B for B in C if sum ( B ) == D ]
rst = A = [ B for B in C if sum ( B ) == D ] <eos>
3062
src = bfs (0) を展開し 、 それぞれ A 、 B とする
trg = A , B = bfs ( 0 )
rst = A , B = bfs ( 0 ) <eos>
3063
src = A の _ paths の値の集まり を返す
trg = return A . _paths . values ( )
rst = return A . _paths . <eos>
3064
src = ( A 、 B の C 番目の 2 番目 、 D ) の組を返す
trg = return ( A , B [ C ] [ 2 ] , D )
rst = return ( A , B [ C ] [ 2 ] , D ) <eos>
3065
src = A の B 番目を C に D を掛けた値の正弦に C に D を掛けた値の余弦を掛けた値 だけ 増 加 させ る
trg = A [ B ] += math . sin ( C * D ) * math . cos ( C * D )
rst = A [ B ] += ( C + D ) ] ) * ( C + D ) <eos>
3066
src = A の 3 番目の末尾に B を追加する
trg = A [ 3 ] . append ( B )
rst = A [ 3 ] . append ( B ) <eos>
3067
src = A の B 番目に C を加えた値が D に含まれるとき 、
trg = if ( A [ B ] + C ) in D :
rst = if A [ B ] + C in D : <eos>
3068
src = A の先頭の 0 番目が B と等しくかつ A の 1 番目の 1 番目が B と等しくかつ A の 2 番目の 2 番目が B と等しいとき 、
trg = if A [ 0 ] [ 0 ] == B and A [ 1 ] [ 1 ] == B and A [ 2 ] [ 2 ] == B :
rst = if A [ 0 ] [ 0 ] == B and A [ 1 ] [ 1 ] == B and A [ 2 ] [ 2 ] == B : <eos>
3069
src = 0 から B 未満までの数列の各要素を A とし 、 、 つまり未定値の列を 辞書 とする
trg = dict = [ None for A in range ( B ) ]
rst = copy = [ None for A in range ( B ) ] <eos>
3070
src = calc ( A +1, B - C , D - E , F - G )
trg = calc ( A + 1 , B - C , D - E , F - G )
rst = calc ( A + 1 , B - C , D - E , F - G ) <eos>
3071
src = A の末尾に B を C に (100- D ) を掛けた値を E で割った値の整数値 で割った余り を追加する
trg = A . append ( B % int ( C * ( 100 - D ) / E ) )
rst = A . append ( int ( B / ( C * <unk> * D ) ) / E ) <eos>
3072
src = calc _ hash ( A , B , C )
trg = calc_hash ( A , B , C )
rst = calc_hash ( A , B , C ) <eos>
3073
src = A の 3 番目を B が 0 より小さいかどうか だけ 増 加 させ る
trg = A [ 3 ] += B < 0
rst = A [ 3 ] += B < 0 <eos>
3074
src = A と B の C に D を加えた値番目 の論理積のとき 、
trg = if A & B [ C + D ] :
rst = if A & B [ C + D ] : <eos>
3075
src = ( B ) からなる列に A をソートした列 を加えた値を A とする
trg = A = [ B ] + sorted ( A )
rst = A = [ B ] + A ( sorted ( ) ) <eos>
3076
src = A の B 番目の C 番目に 1 を加えた値を A の B 番目の C 番目に する
trg = A [ B ] [ C ] = A [ B ] [ C ] + 1
rst = A [ B ] [ C ] = A [ B ] [ C ] + 1 <eos>
3077
src = C の 1 番目から 、 つまり末尾までの部分列の各要素を B とし 、 B の整数値 でないとき の 1 の列の総和を A とする
trg = A = sum ( [ 1 for B in C [ 1 : ] if not int ( B ) ] )
rst = A = sum ( [ 1 for B in [ C ( 1 , if B [ 1 : ] ] ) <eos>
3078
src = pwr ( A , B ) を出力する
trg = print ( pwr ( A , B ) )
rst = print ( <unk> ( A , B ) ) <eos>
3079
src = A の B 番目が C の A の B 番目 番目と等しくないとき 、
trg = if A [ B ] != C [ A [ B ] ] :
rst = if A [ B ] != C [ A [ B ] ] : <eos>
3080
src = dfs ( B +1, C ) から D の C 番目の B 番目を引いた値 、 dfs ( B , C +1) に E の C 番目の B 番目を加えた値の最小値を A とする
trg = A = min ( dfs ( B + 1 , C ) - D [ C ] [ B ] , dfs ( B , C + 1 ) + E [ C ] [ B ] )
rst = A = min ( dfs ( B + 1 , C ) - D [ C ] [ B ] , dfs ( B , C + 1 ) + E [ C ] [ B ] ) <eos>
3081
src = 0 から 27 未満までの数列を順に A として 、 繰り返 す
trg = for A in range ( 27 ) :
rst = for A in range ( 27 ) : <eos>
3082
src = B のキーと値の集まりのリストを A とする
trg = A = list ( B . items ( ) )
rst = A = list ( B . keys ( ) ) <eos>
3083
src = A を B から 100 を引いた値を 100 で割った商だけ 増 加 させ る
trg = A += ( B - 100 ) // 100
rst = A += ( B - 100 ) // 100 <eos>
3084
src = fibo ( A -1) に fibo ( A -2) を加えた値を返す
trg = return fibo ( A - 1 ) + fibo ( A - 2 )
rst = return <unk> ( A - 1 ) + <unk> ( A - 2 ) <eos>
3085
src = A の末尾に [ MASK ] の両端キューを 追加する
trg = A . append ( deque ( ) )
rst = A . append ( append ( ) ) <eos>
3086
src = A に B を加えた値が C の D に 2 を加えた値 番目より小さいとき 、
trg = if A + B < C [ D + 2 ] :
rst = if A + B < C [ D + 2 ] : <eos>
3087
src = A の _ edges の B 番目を返す
trg = return A . _edges [ B ]
rst = return A . _index [ B ] <eos>
3088
src = heappush ( A , ( B ,0, C ))
trg = heappush ( A , ( B , 0 , C ) )
rst = heappush ( A , ( B , 0 , C ) ) <eos>
3089
src = A が B と等しくまたは A が C と等しくまたは A が D と等しいとき 、
trg = if A == B or A == C or A == D :
rst = if A == B or ( A == C or A == D ) : <eos>
3090
src = 0 から C に 1 を加えた値未満までの数列の各要素 を B とし 、 、 つまり辞書の列 を A とする
trg = A = [ dict ( ) for B in range ( C + 1 ) ]
rst = A = [ [ ( ) for B in range ( C + 1 ) ] <eos>
3091
src = A 内の B から 3 を引いた値 の出現回数 を出力する
trg = print ( A . count ( B - 3 ) )
rst = print ( A . count ( B - 3 ) ) <eos>
3092
src = (0、 B ) からなる列を A とする
trg = A = [ 0 , B ]
rst = A = [ 0 , B ] <eos>
3093
src = A が 60 以下かつ B が 2 以下のとき 、
trg = if A <= 60 and B <= 2 :
rst = if A <= 60 and B <= 2 : <eos>
3094
src = ( F 、 G に 2 を加えた値を 4 で割った余り 、 H の D に E を加えた値番目の B に C を加えた値番目 ) の組を A の ( B に C を加えた値 、 D に E を加えた値 ) の組番目に する
trg = A [ ( B + C , D + E ) ] = ( F , ( G + 2 ) % 4 , H [ D + E ] [ B + C ] )
rst = A [ ( B + C , D + E ) ] = ( F , G + E ] , ( F , D + C ] ) <eos>
3095
src = A ._ make _ matrix ( B , C ) を A の M に する
trg = A . M = A . _make_matrix ( B , C )
rst = A . M = A . _make_matrix ( B , C ) <eos>
3096
src = A に 2 を加えた値が B の C 番目以下のとき 、
trg = if A + 2 <= B [ C ] :
rst = if A + 2 <= B [ C ] : <eos>
3097
src = B にネイピア数を掛けた値から C に D を掛けた値を引いた値を E にネイピア数を掛けた値から D に F を掛けた値を引いた値で割った値 を A とする
trg = A = ( B * e - C * D ) / ( E * e - D * F )
rst = A = ( B * e - C * D ) / ( E * e - D * F ) <eos>
3098
src = 空列を A の primes に する
trg = A . primes = [ ]
rst = A . primes = [ ] <eos>
3099
src = A を B から読み込んだ一行の整数値 だけ 増 加 させ る
trg = A += int ( B . readline ( ) )
rst = A += int ( B . readline ( ) ) <eos>
3100
src = A 、 minimum _ cost ( B +1, C , update _ state ( D , B +1) , min ( E + F -1, G ) , H , I , J , G ) に K を加えた値の最小値を A とする
trg = A = min ( A , minimum_cost ( B + 1 , C , update_state ( D , B + 1 ) , min ( E + F - 1 , G ) , H , I , J , G ) + K )
rst = A = min ( A , minimum_cost ( B + 1 , C , 0 ) , min ( D + 1 ) , min ( E + F + 1 ) , min ( G , F , G , K , G ) ) <eos>
3101
src = A の B 番目から B に C を加えた値までの部分列に A の 、 つまり先頭から B 番目までの部分列を加えた値に A の B に C を加えた値から 、 つまり末尾までの部分列を加えた値 を A とする
trg = A = A [ B : B + C ] + A [ : B ] + A [ B + C : ]
rst = A = A [ B : B + C ] + A [ : B ] + A [ B + C : ] <eos>
3102
src = A が B の C 番目の 1 番目から B の D 番目の 1 番目を引いた値 より小さいとき 、
trg = if A < B [ C ] [ 1 ] - B [ D ] [ 1 ] :
rst = if A < B [ C ] [ 1 ] - B [ D ] [ 1 ] : <eos>
3103
src = A の長さが 0 と等しくない 間 、 次 を 繰り返 す
trg = while len ( A ) != 0 :
rst = while len ( A ) != 0 : <eos>
3104
src = B の 、 つまり先頭から C に 1 を加えた値までの部分列を A とする
trg = A = B [ : C + 1 ]
rst = A = B [ : C + 1 ] <eos>
3105
src = 100000000000001 を A とする
trg = A = 100000000000001
rst = A = <unk> <eos>
3106
src = A の末尾に入力された文字列 を空白で分割した字句列の各要素に 整数を適用した列のリスト を追加する
trg = A . append ( list ( map ( int , input ( ) . split ( ) ) ) )
rst = A . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <eos>
3107
src = 0 から D 未満までの数列の各要素を C とし 、 B の C 番目の総和 の列を A とする
trg = A = [ sum ( B [ C ] ) for C in range ( D ) ]
rst = A = [ sum ( [ B [ C ] ) for C in range ( D ) ] <eos>
3108
src = A の B 番目の C 番目が 4 より小さいとき 、
trg = if A [ B ] [ C ] < 4 :
rst = if A [ B ] [ C ] < 4 : <eos>
3109
src = MST ( B ) を A とする
trg = A = MST ( B )
rst = A = <unk> ( B ) <eos>
3110
src = input () を空白で分割した字句列の各要素に 整数を適用した列のリストを ソートした列の逆順を A とする
trg = A = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) [ : : - 1 ]
rst = A = list ( list ( map ( int , input ( ) . split ( ) ) ) ) <eos>
3111
src = A を 2 から E に 1 を加えた値未満までの数列の各要素 を C とし 、 E を C で割った余りが 0 と等しいとき の B の C 番目に C の D から 2 を引いた値乗に対する D の 剰 余 を掛けた値の列の総和 だけ 増 加 させ る
trg = A += sum ( [ B [ C ] * pow ( C , D - 2 , D ) for C in range ( 2 , E + 1 ) if E % C == 0 ] )
rst = A += pow [ B [ C ] * pow ( [ C [ D - 2 , D [ C ] ) D C C C C C ) for C in range ( 2 , E + 1 ) ] ) ] <eos>
3112
src = time から C を引いた値を A の B 番目に する
trg = A [ B ] = time - C
rst = A [ B ] = time - C <eos>
3113
src = copy の B 番目の C 番目を A の B 番目の C から D を引いた値番目に する
trg = A [ B ] [ C - D ] = copy [ B ] [ C ]
rst = A [ B ] [ C - D ] = copy [ B ] [ C ] <eos>
3114
src = A の answers の末尾に B を追加する
trg = A . answers . append ( B )
rst = A . vs . append ( B ) <eos>
3115
src = readline () の両端から 空白改行を取り除いた文字列 の各要素に B の先頭から [ MASK ] を探して見つかった位置 を適用した列のリストを A とする
trg = A = list ( map ( B . find , readline ( ) . strip ( ) ) )
rst = A = list ( map ( B . find , readline ( ) . strip ( ) ) ) <eos>
3116
src = B 内の C の出現回数を A とする
trg = A = B . count ( C )
rst = A = B . count ( C ) <eos>
3117
src = A が B の C 番目から D の C 番目を引いた値の絶対値 以下のとき 、
trg = if A <= abs ( B [ C ] - D [ C ] ) :
rst = if A <= abs ( B [ C ] - D [ C ] ) : <eos>
3118
src = B を反転した列を展開して の要素をそれぞれ組にした列 の各要素を A とし 、 A のリストの列を 返す
trg = return [ list ( A ) for A in zip ( * reversed ( B ) ) ]
rst = return [ tuple ( A ) for A in zip ( B ) B ) ] <eos>
3119
src = A を B の C 番目に D を加えた値から 2 に B の E の root ( C ) 番目 番目を掛けた値を引いた値 だけ 増 加 させ る
trg = A += B [ C ] + D - 2 * B [ E [ root ( C ) ] ]
rst = A += B [ C ] + D - 2 * B [ E . root ( C ) ] <eos>
3120
src = B の C から 1 を引いた値から D 番目までの部分列を A とする
trg = A = B [ C - 1 : D ]
rst = A = B [ C - 1 : D ] <eos>
3121
src = C から読み込んだ一行 の両端から 空白改行を取り除いた文字列 を空白で分割した字句列 を展開し 、 それぞれ A 、 B とする
trg = A , B = C . readline ( ) . strip ( ) . split ( )
rst = A , B = C . readline ( ) . strip ( ) . split ( ) <eos>
3122
src = 0 から C 未満までの数列の各要素を B とし 、 -1 の列を A とする
trg = A = [ - 1 for B in range ( C ) ]
rst = A = [ - 1 for B in range ( C ) ] <eos>
3123
src = A が 30 より大きくかつ B が 4 より大きいとき 、
trg = if A > 30 and B > 4 :
rst = if A > 30 and B > 4 : <eos>
3124
src = A を 2 の 32 乗だけ 減 少 させ る
trg = A -= 2 ** 32
rst = A -= 2 ** 32 <eos>
3125
src = sys の stdout に空白文字を間に入れて B を反転した列の各要素 を A とし 、 A の 1 番目のときの A の 0 番目の列を連結した文字列 を書き込む
trg = sys . stdout . write ( ' ' . join ( [ A [ 0 ] for A in reversed ( B ) if A [ 1 ] ] ) )
rst = sys . stdout . write ( [ A for A in range ( B ) if A . maxsize ) if A [ 1 ] ] ) <eos>
3126
src = write ( A %( min ( B ) , max ( B )))
trg = write ( A % ( min ( B ) , max ( B ) ) )
rst = write ( A % ( min ( B ) , max ( B ) ) ) <eos>
3127
src = ( C 、 D ) からなる列を A の B 番目の c に する
trg = A [ B ] . c = [ C , D ]
rst = A [ B ] . c = [ C , D ] <eos>
3128
src = Cp ( B , C , D ) を A とする
trg = A = Cp ( B , C , D )
rst = A = <unk> ( B , C , D ) <eos>
3129
src = ( 2 に B を加えた値 、 1 、 未定値 ) からなる列を A とする
trg = A = [ 2 + B , 1 , None ]
rst = A = [ 2 + B , 1 , None ] <eos>
3130
src = A の末尾に ( B 、 C の整数値 ) の組 を追加する
trg = A . append ( ( B , int ( C ) ) )
rst = A . append ( ( B , int ( C ) ) ) <eos>
3131
src = A の末尾に ( B ) からなる列 を追加する
trg = A . append ( [ B ] )
rst = A . append ( [ B ] ) <eos>
3132
src = 0 を A の steps に する
trg = A . steps = 0
rst = A . lz = 0 <eos>
3133
src = A に B を加えた値に ( 、 つまり空白文字 ) からなる列を加えた値を A とする
trg = A = A + B + [ ' ' ]
rst = A = A + B + [ ' ' ] <eos>
3134
src = treewalk _ inorder ( A [ B ] [ C ] )
trg = treewalk_inorder ( A [ B ] [ C ] )
rst = treewalk_inorder ( A [ B ] [ C ] ) <eos>
3135
src = A の B から 1 を引いた値番目の C から 1 を引いた値番目 、 A の B から 1 を引いた値番目の C 番目 、 A の B 番目の C から 1 を引いた値番目の最小値を A の B 番目の C 番目に する
trg = A [ B ] [ C ] = min ( A [ B - 1 ] [ C - 1 ] , A [ B - 1 ] [ C ] , A [ B ] [ C - 1 ] )
rst = A [ B ] [ C ] = min ( A [ B - 1 ] [ C - 1 ] , A [ B - 1 ] [ C ] , A [ B ] [ C - 1 ] ) <eos>
3136
src = 入力された文字列 を空白で分割した字句列の各要素に x をパラメータとして x の浮動小数点数を 返す関数を適用した列を展開し 、 それぞれ A 、 B 、 C とする
trg = A , B , C = map ( lambda D : float ( D ) , input ( ) . split ( ) )
rst = A , B , C = map ( lambda D : float ( A ) , input ( ) . split ( ) ) <eos>
3137
src = B の real に C の imag を掛けた値から B の imag に C の real を掛けた値を引いた値に D の real に E の imag を掛けた値を加えた値から D の imag に E の real を掛けた値を引いた値を A とする
trg = A = B . real * C . imag - B . imag * C . real + D . real * E . imag - D . imag * E . real
rst = A = B . real * C . imag - B . real * D . real * E . imag - D . imag * E . real <eos>
3138
src = A の各要素を D とし 、 ( D の x 座標 、 D の y 座標 ) の組 の列をソートした列の各要素を B 、 C とし 、 Point ( B , C ) の列を A とする
trg = A = [ Point ( B , C ) for B , C in sorted ( [ ( D . x , D . y ) for D in A ] ) ]
rst = A = [ [ ( B , C ) for D , C in [ D ( D . y , ] ] for D in A ] <eos>
3139
src = C の 10 番目 、 C の 1 1 番目を A 、 B とする
trg = A , B = C [ 10 ] , C [ 11 ]
rst = A , B = C [ 10 ] , C [ 11 ] <eos>
3140
src = A の E の B 番目の末尾に Edge ( C , D ) を追加する
trg = A . E [ B ] . append ( Edge ( C , D ) )
rst = A . E [ B ] . append ( Edge ( C , D ) ) <eos>
3141
src = A を B . area () だけ 増 加 させ る
trg = A += B . area ( )
rst = A += B . area ( ) <eos>
3142
src = C に D の E を 1 だけ左シフトした値 番目を加えた値 、 F に D の E を 1 だけ左シフトした値に 1 を加えた値番目を加えた値を A 、 B とする
trg = A , B = C + D [ E << 1 ] , F + D [ ( E << 1 ) + 1 ]
rst = A , B = C + D [ E << 1 ] , F + D [ ( E << 1 << + 1 ) + 1 ] <eos>
3143
src = 3 から B の平方根の整数値に 1 を加えた値未満までの 2 間隔の数列を順に A として 、 繰り返 す
trg = for A in range ( 3 , int ( math . sqrt ( B ) ) + 1 , 2 ) :
rst = for A in range ( 3 , int ( math . sqrt ( B ) ) + 1 , 2 ) : <eos>
3144
src = A が 50 以下かつ B の A 番目が 0 と等しくまたは B の A 番目が C より大きいとき 、
trg = if ( A <= 50 and B [ A ] == 0 ) or B [ A ] > C :
rst = if A <= 50 and B [ A ] == 0 or B [ A ] > C : <eos>
3145
src = D の各要素を C 、 B とし 、 B の列の総和を A とする
trg = A = sum ( [ B for C , B in D ] )
rst = A = sum ( [ B for C , B in D ] ) <eos>
3146
src = A が B より小さくかつ - B が C より小さくかつ D に C から A を引いた値を掛けた値から A に E から D を引いた値を掛けた値を引いた値 が - B より大きいとき 、
trg = if A < B and - B < C and D * ( C - A ) - A * ( E - D ) > - B :
rst = if A < B and - < C and D * ( C - C ) A ) + ( A * E - D ) ) > - : <eos>
3147
src = math . pow ( A [0], 2 ) に math . pow ( A [1], 2 ) を加えた値が math . pow ( A [2], 2 ) と等しいとき 、
trg = if math . pow ( A [ 0 ] , 2 ) + math . pow ( A [ 1 ] , 2 ) == math . pow ( A [ 2 ] , 2 ) :
rst = if math . pow ( A [ 0 ] , 2 ) + math . y ) + 2 ) == math . pi [ 2 ] , 2 ) == math . pi ( A [ 2 ] ) : <eos>
3148
src = ( ( A , ( D 、 E 、 F 、 G ) からなる列の各要素を A とし 、(( B , 0)、( C , 0 )) からなる辞書の列 )) からなる辞書を 無限の整数列 とする
trg = count = { char : [ { "left" : 0 , "right" : 0 } for A in [ D , E , F , G ] ] }
rst = count = [ { : : [ { : : C , <unk> : ] for A in [ D , E , F ] ] <eos>
3149
src = 0 、 B から C を引いた値の最大値を 無限の整数列の A 番目に する
trg = count [ A ] = max ( 0 , B - C )
rst = A [ 0 ] = set ( 0 , B - C ) <eos>
3150
src = A . walk _ inorder ( B . left )
trg = A . walk_inorder ( B . left )
rst = A . walk_inorder ( B . left ) <eos>
3151
src = A が 30 より大きいとき 、
trg = if A > 30 :
rst = if A > 30 : <eos>
3152
src = ( ( B 、 C ) の組 、 ( B に D を加えた値 、 C に E を加えた値 ) の組 、 ( B に D を加えた値に F を加えた値 、 C に E を加えた値に G を加えた値 ) の組 、 ( B に G を加えた値 、 C に G を加えた値 ) の組 ) からなる列を A とする
trg = A = [ ( B , C ) , ( B + D , C + E ) , ( B + D + F , C + E + G ) , ( B + G , C + G ) ]
rst = A = [ ( B , C ) , ( B + D , E + F ) , ( B + E ) + ( B + E ) , ( B + G ) , ( B + G ) , ( B + G ) ] <eos>
3153
src = B の 3 番目から 、 つまり末尾までの部分列を C とする
trg = C = B [ 3 : ]
rst = C = B [ 3 : ] <eos>
3154
src = time を出力する
trg = print ( time )
rst = print ( time ) <eos>
3155
src = 1 を A の先頭の先頭に する
trg = A [ 0 ] [ 0 ] = 1
rst = A . date = 1 <eos>
3156
src = C の 、 つまり先頭から D 番目までの部分列の逆順を A の B 番目に する
trg = A [ B ] = C [ : D ] [ : : - 1 ]
rst = A [ B ] = C [ : D ] [ : : - 1 ] <eos>
3157
src = calc _ max _ profit ( B ) を A とする
trg = A = calc_max_profit ( B )
rst = A = <unk> ( B ) <eos>
3158
src = B を 16 で割った値を A とする
trg = A = B / 16
rst = A = B / 16 <eos>
3159
src = 1 . を A とする
trg = A = 1.
rst = A = 1 <eos>
3160
src = A の B の先頭番目を 削 除 する
trg = del A [ B [ 0 ] ]
rst = del A [ B [ 0 ] ] <eos>
3161
src = A の末尾に rotate ( B , C ) を追加する
trg = A . append ( rotate ( B , C ) )
rst = A . append ( <unk> ( B , C ) ) <eos>
3162
src = partition ( A ,0, len ( A )-1) を円周率 とする
trg = pi = partition ( A , 0 , len ( A ) - 1 )
rst = pi = partition ( A , 0 , len ( A ) - 1 ) <eos>
3163
src = 13 を B とする
trg = B = 13
rst = B = 13 <eos>
3164
src = A 、 B の末尾の C 番目に D を加えた値の最小値を A とする
trg = A = min ( A , B [ - 1 ] [ C ] + D )
rst = A = min ( A , B [ - 1 ] [ C ] + D ) <eos>
3165
src = A の末尾に (1、0、0) の組 を追加する
trg = A . append ( ( 1 , 0 , 0 ) )
rst = A . append ( ( 0 , - 2 ) ) <eos>
3166
src = shellSort ( D ) を展開し 、 それぞれ A 、 B 、 C とする
trg = A , B , C = shellSort ( D )
rst = A , B , C = shellSort ( D ) <eos>
3167
src = D の graph の D の pos の E 番目の先頭番目の D の pos の E 番目の 1 番目番目を展開し 、 それぞれ A 、 B 、 C とする
trg = A , B , C = D . graph [ D . pos [ E ] [ 0 ] ] [ D . pos [ E ] [ 1 ] ]
rst = A , B , C = D . graph [ D . pos [ E ] [ 0 ] ] [ D . pos [ E ] [ 1 ] ] <eos>
3168
src = os . path を返す
trg = return path
rst = return path <eos>
3169
src = 1 を B に C を加えた値に D を掛けた値に E を加えた値に F を加えた値 だけ左シフトした値を A とする
trg = A = 1 << ( ( B + C ) * D + E + F )
rst = A = ( 1 << ( B + C ) * D + E + F ) <eos>
3170
src = x 、 y をパラメータとして x に y を掛けた値 を返す関数を A とする
trg = A = lambda B , C : B * C
rst = A = lambda B , C : C * C <eos>
3171
src = A が 2001 と等しいとき 、
trg = if A == 2001 :
rst = if A == sum : <eos>
3172
src = A の - B 番目を出力する
trg = print ( A [ - B ] )
rst = print ( A [ - B ] ) <eos>
3173
src = A の末尾に C を追加する
trg = A . append ( C )
rst = A . append ( C ) <eos>
3174
src = (0、 6000 、4000、3000、2000) からなる列を A とする
trg = A = [ 0 , 6000 , 4000 , 3000 , 2000 ]
rst = A = [ 0 , 4000 , 4000 , 2000 , 0 , 0 , 0 ] <eos>
3175
src = A が B の C 番目以上の 間 、 次 を 繰り返 す
trg = while A >= B [ C ] :
rst = while A >= B [ C ] : <eos>
3176
src = A に B を加えた値が C 以下かつ D の A に B を加えた値番目の E 番目が F に G を加えた値より小さいとき 、
trg = if A + B <= C and D [ A + B ] [ E ] < F + G :
rst = if A + B <= C and D [ A + B ] [ E ] < F + G : <eos>
3177
src = A の 、 つまり先頭から B から C を引いた値までの部分列が D の C 番目から B 番目までの部分列 と等しくないとき 、
trg = if A [ : B - C ] != D [ C : B ] :
rst = if A [ : B - C ] != D [ C : B ] : <eos>
3178
src = solve ( B +1, C - D [ B ] ) を A とする
trg = A = solve ( B + 1 , C - D [ B ] )
rst = A = solve ( B + 1 , C - D [ B ] ) <eos>
3179
src = ( B の 0 番目に C の D 番目の先頭を加えた値 ) からなる列を A とする
trg = A = [ B [ 0 ] + C [ D ] [ 0 ] ]
rst = A = [ B [ 0 ] + C [ D ] [ 0 ] ] <eos>
3180
src = A の flow を B だけ 減 少 させ る
trg = A . flow -= B
rst = A . flow -= B <eos>
3181
src = A の B の先頭番目の B の 1 番目番目の 1 番目が 0 と等しいとき 、
trg = if A [ B [ 0 ] ] [ B [ 1 ] ] [ 1 ] == 0 :
rst = if A [ B [ 0 ] ] [ B [ 1 ] ] [ 1 ] == 0 : <eos>
3182
src = 真
trg = True
rst = True <eos>
3183
src = A の最大値が 0 より小さいとき 、
trg = if max ( A ) < 0 :
rst = if max ( A ) < 0 : <eos>
3184
src = C の各要素に B を適用した列の集合 を A とする
trg = A = set ( map ( B , C ) )
rst = A = list ( map ( B , C ) ) <eos>
3185
src = A の先頭を取り出した値
trg = A . pop ( )
rst = A . pop ( ) <eos>
3186
src = B から 1 を引いた値から B に 3 を加えた値未満までの数列を順に A として 、 繰り返 す
trg = for A in range ( B - 1 , B + 3 ) :
rst = for A in range ( B - 1 , B + 3 ) : <eos>
3187
src = 1 から B に 1 を加えた値未満までの数列を 1 を 初 期 値として A で集約した列 を出力する
trg = print ( reduce ( A , range ( 1 , B + 1 ) , 1 ) )
rst = print ( format ( A , A ) + 1 , ( B + 1 ) ) ) <eos>
3188
src = B の C 番目の C に D を加えた値番目を A とする
trg = A = B [ C ] [ C + D ]
rst = A = B [ C ] [ C + D ] <eos>
3189
src = 空列を A のキーと値の集まり に する
trg = A . items = [ ]
rst = A . items = [ ] <eos>
3190
src = D に A の C の B から 1 を引いた値番目の C から E を引いた値番目を加えた値を A の C の B 番目の C 番目に する
trg = A . C [ B ] [ C ] = D + A . C [ B - 1 ] [ C - E ]
rst = A [ C [ B ] [ C ] = D + A [ C [ B - 1 ] [ C - E ] <eos>
3191
src = 0 から C の長さ未満までの数列の各要素を B とし 、 1 の列を A とする
trg = A = [ 1 for B in range ( len ( C ) ) ]
rst = A = [ 1 for B in range ( len ( C ) ) ] <eos>
3192
src = 現在の日時を A から 、 つまり現在の日時を引いた値 だけ 増 加 させ る
trg = now += ( A - now )
rst = now += A - now <eos>
3193
src = A が 200 と等しいとき 、
trg = if A == 200 :
rst = if A == 200 : <eos>
3194
src = C のリスト 、 C のリストを A 、 B とする
trg = A , B = list ( C ) , list ( C )
rst = A , B = list ( C ) , list ( C ) <eos>
3195
src = chs ( B + C -1, B , D ) を A とする
trg = A = chs ( B + C - 1 , B , D )
rst = A = chs ( B + C - 1 , B , D ) <eos>
3196
src = A を ( 3 、 7 ) からなる列の B の A 番目が C と等しいかどうか 番目だけ 増 加 させ る
trg = A += [ 3 , 7 ] [ B [ A ] == C ]
rst = A += [ 3 , 7 ] [ B [ A ] == C ] <eos>
3197
src = D の各要素を B 、 C とし 、 C の列の最小値を E とする
trg = E = min ( [ C for B , C in D ] )
rst = E = [ ( C for B , C in D ] ) <eos>
3198
src = A の末尾に gen ( B ,1) を追加する
trg = A . append ( gen ( B , 1 ) )
rst = A . append ( gen ( B , 1 ) ) <eos>
3199
src = A は 、 つまり整数 型 のとき 、
trg = if isinstance ( A , str ) :
rst = if isinstance ( A , int ) : <eos>
3200
src = A の B 番目に 1 を加えた値を返す
trg = return A [ B ] + 1
rst = return A [ B ] + 1 <eos>
3201
src = lcs ( C [ : sep ] , C [ sep : ] , A , B ) を展開し 、 それぞれ A 、 B とする
trg = A , B = lcs ( C [ : sep ] , C [ sep : ] , A , B )
rst = A , B = lcs ( C [ : sep ] , C [ sep : ] , A , B ) <eos>
3202
src = commands [ q ] ( int ( C )) を A の B 番目に する
trg = A [ B ] = commands[q] ( int ( C ) )
rst = A [ B ] = commands[q] ( int ( C ) ) <eos>
3203
src = A の最大値に 1 を加えた値を返す
trg = return max ( A ) + 1
rst = return max ( A ) + 1 <eos>
3204
src = A かつ D 、 C 、 E 、 F でない に お いて正規表現 B に C を加えた値が 5 より小さいとき B に C を加えた値 、 そうでなければ 、 つまり未定値 が最初にマッチする位置を A とする
trg = A = A and search ( B + C if B + C < 5 else None , D , C , E , not F )
rst = A = A and search ( B + C if B + C if B < C < 5 else None , None , None , None ) <eos>
3205
src = ( B ) からなる列に (0) からなる列の C の長さ回分の列 を加えた値を A とする
trg = A = [ B ] + [ 0 ] * len ( C )
rst = A = [ B ] + [ 0 ] * len ( C ) <eos>
3206
src = line _ cross _ point ( B [2], sub ( B [1], B [0]), C [2], sub ( C [1], C [0])) を A とする
trg = A = line_cross_point ( B [ 2 ] , sub ( B [ 1 ] , B [ 0 ] ) , C [ 2 ] , sub ( C [ 1 ] , C [ 0 ] ) )
rst = A = line_cross_point ( B [ 2 ] , sub ( B [ 1 ] , B [ 0 ] ) , sub ( C [ 1 ] , sub ( C [ 1 ] , C [ 0 ] ) ) <eos>
3207
src = A . dice _ move ([ B ] )
trg = A . dice_move ( [ B ] )
rst = A . <unk> ( [ B ] ) <eos>
3208
src = 100 を A の Max に する
trg = A . Max = 100
rst = A . <unk> = 100 <eos>
3209
src = B 、 C の最大値を A の height に する
trg = A . height = max ( B , C )
rst = A . height = max ( B , C ) <eos>
3210
src = 真を A の loop に する
trg = A . loop = True
rst = A . loop = True <eos>
3211
src = A の 8 番目から 、 つまり末尾までの部分列を A とする
trg = A = A [ 8 : ]
rst = A = A [ 8 : ] <eos>
3212
src = A の先頭を除いた部分列の各要素を ネイピア数とし 、 、 つまりネイピア数 を出力するの列
trg = [ print ( e ) for e in A [ 1 : ] ]
rst = [ print ( e ) for e in A [ 1 : ] ] <eos>
3213
src = 0 を開いたファイルストリーム から読み込んだ デ ータを空白で分割した字句列を A とする
trg = A = open ( 0 ) . read ( ) . split ( )
rst = A = list ( open ( ) . read ( ) . split ( ) ) <eos>
3214
src = 1 を A の 1 を B だけ左シフトした値 番目に する
trg = A [ 1 << B ] = 1
rst = A [ 1 << B ] = 1 <eos>
3215
src = A から B を引いた値が 2 と等しいかどうかを返す
trg = return A - B == 2
rst = return A - B == 2 <eos>
3216
src = A に B を掛けた値を A とする
trg = A = A * B
rst = A = A * B <eos>
3217
src = B を C で割った商を D で割った余りを A とする
trg = A = ( B // C ) % D
rst = A = ( B // C ) % D <eos>
3218
src = ( x をパラメータとして E [1] の浮動小数点数 を返す関数をキーとして range ( 2 ,4) の各要素を D とし 、 range (3) の列の各要素を C とし 、 B [ C ] の D 番目 の列をソートした列の 、 つまり先頭から 2 番目までの部分列 ) からなる列を A とする
trg = A = [ sorted ( ( [ B [ C ] [ D ] for C in [ range ( 3 ) for D in range ( 2 , 4 ) ] ] ) , key = lambda E : float ( E [ 1 ] ) ) [ : 2 ] ]
rst = A = [ [ B [ [ ] [ D [ D ] [ D ] for C , E ) ) ] = [ range ( 1 ) , D in range ( 2 , 4 ) ] ] ] <eos>
3219
src = A . left . flip _ color ()
trg = A . left . flip_color ( )
rst = A . left . <unk> ( ) <eos>
3220
src = B に ( C + D - B ) を掛けた値に E を掛けた値に C に ( D + B - C ) を掛けた値に F を掛けた値を加えた値に D に B + C から D を引いた値を掛けた値に G を掛けた値を加えた値を 16 に H の 2 乗を掛けた値で割った値を A とする
trg = A = ( B * ( C + D - B ) * E + C * ( D + B - C ) * F + D * ( B + C - D ) * G ) / ( 16 * H ** 2 )
rst = A = B * ( C + D - B ) * E + C * ( ( D * B + ( C * ( B + D ) * ( ) + ( D * ( D + D ) ) * ( H * H ) <eos>
3221
src = C の root に番号付した組の列の各要素を A 、 B とし 、 B が 0 より小さいとき の A の列を返す
trg = return [ A for A , B in enumerate ( C . root ) if B < 0 ]
rst = return [ A for A , B in enumerate ( C . root ) if B < 0 ] <eos>
3222
src = 無限の整数列の A に 1 を加えた値番目に 無限の整数列の B から A を引いた値から 1 を引いた値番目 を加えた値を出力する
trg = print ( count [ A + 1 ] + count [ B - A - 1 ] )
rst = print ( count [ A + 1 ] + B [ A - 1 ] ) <eos>
3223
src = B と C の最小公倍数を A とする
trg = A = lcm ( B , C )
rst = A = lcm ( B , C ) <eos>
3224
src = A の 4 番目が B と等しくないとき 、
trg = if A [ 4 ] != B :
rst = if A [ 4 ] != B : <eos>
3225
src = dijkstra 2( B ,0) を A とする
trg = A = dijkstra2 ( B , 0 )
rst = A = dijkstra ( B , 0 ) <eos>
3226
src = least _ multiplication ( B ) を A とする
trg = A = least_multiplication ( B )
rst = A = <unk> ( B ) <eos>
3227
src = 空白文字を間に入れて ( C 、 D 、 E ) からなる列の各要素を B とし 、 A を書式として B で整形した文字列の列 を連結した文字列を出力する
trg = print ( ' ' . join ( [ A . format ( B ) for B in [ C , D , E ] ] ) )
rst = print ( ' ' . join ( [ A . format ( B ) for B in [ C , D , E ) ] ) ) <eos>
3228
src = B の C から 1 を引いた値番目の D から 1 を引いた値番目の E 番目を A とする
trg = A = B [ C - 1 ] [ D - 1 ] [ E ]
rst = A = B [ C - 1 ] [ D - 1 ] [ E ] <eos>
3229
src = A の left が B の NIL と等しくないとき 、
trg = if A . left != B . NIL :
rst = if A . left != B . NIL : <eos>
3230
src = A の B から 1 を引いた値番目に 1 を加えた値を A の B から 1 を引いた値番目に する
trg = A [ B - 1 ] = A [ B - 1 ] + 1
rst = A [ B - 1 ] = A [ B - 1 ] + 1 <eos>
3231
src = A の B 番目の 2 番目を出力する
trg = print ( A [ B ] [ 2 ] )
rst = print ( A [ B ] [ 2 ] ) <eos>
3232
src = (1、1) の組が A に含まれるとき 、
trg = if ( 1 , 1 ) in A :
rst = if ( 1 , 1 ) in A : <eos>
3233
src = 0 から 600 未満までの B 間隔の数列を順に A として 、 繰り返 す
trg = for A in range ( 0 , 600 , B ) :
rst = for A in range ( 600 , 600 ) : <eos>
3234
src = A の B 番目でなくかつ dfs ( B ) のとき 、
trg = if not A [ B ] and dfs ( B ) :
rst = if not A [ B ] and dfs ( B ) : <eos>
3235
src = B の C の D の E から 1 を引いた値番目 と等しい要素の最初の位置番目を A とする
trg = A = B [ C . index ( D [ E - 1 ] ) ]
rst = A = B [ C . index ( D [ E - 1 ] ) ) <eos>
3236
src = ( A 、 7 から B を引いた値 、 C ) の組を返す
trg = return ( A , 7 - B , C )
rst = return ( A , 7 - B , C ) <eos>
3237
src = A の x 座標の 2 乗に A の y 座標の 2 乗を加えた値の平方根を返す
trg = return math . sqrt ( A . x ** 2 + A . y ** 2 )
rst = return math . sqrt ( A . x ** 2 + A . y ** 2 ) <eos>
3238
src = 整数 、 A の B 番目が全て数字かどうか が 、 つまり真と等しいとき 、
trg = if str . isnumeric ( A [ B ] ) == True :
rst = if str ( isdecimal ( A [ B ] ) == True : <eos>
3239
src = A の right が 、 つまり未定値と等しく なければ な らな い
trg = assert A . right is not None
rst = assert A . right is not None <eos>
3240
src = 改行文字を間に入れて A を連結した文字列を返す
trg = return '\n' . join ( A )
rst = return '\n' . join ( A ) <eos>
3241
src = A が B より小さくかつ C が D 以下の 間 、 次 を 繰り返 す
trg = while A < B and C <= D :
rst = while A < B and C <= D : <eos>
3242
src = 入力された文字列 を空白で分割した字句列の各要素に 整数を適用した列を展開し 、 それぞれ A 、 B 、 C 、 D 、 ネイピア数とする
trg = A , B , C , D , e = map ( int , input ( ) . split ( ) )
rst = A , B , C , D , e = map ( int , input ( ) . split ( ) ) <eos>
3243
src = A のコピーされた列を 返す
trg = return A [ : ]
rst = return A [ : ] <eos>
3244
src = 0 を A の d の 0 番目に する
trg = A . d [ 0 ] = 0
rst = A . d [ 0 ] = 0 <eos>
3245
src = A の B に 1 を加えた値番目の C 番目 、 ネイピア数から 1 を引いた値の最大値を A の B に 1 を加えた値番目の C 番目に する
trg = A [ B + 1 ] [ C ] = max ( A [ B + 1 ] [ C ] , e - 1 )
rst = A [ B + 1 ] [ C ] = max ( A [ B + 1 ] [ C ] , e - 1 ) <eos>
3246
src = f 2( A +1, B )
trg = f2 ( A + 1 , B )
rst = f2 ( A + 1 , B ) <eos>
3247
src = ( 90、 180 、 270 ) からなる列 を順に A として 、 繰り返 す
trg = for A in [ 90 , 180 , 270 ] :
rst = for A in [ <unk> ** 2 , 3.0 , 3.0 ] : <eos>
3248
src = 0 が A に B の 1 番目 を加えた値以下かどうかが C 以下のとき 、
trg = if 0 <= A + B [ 1 ] <= C :
rst = if 0 <= A + B [ 1 ] <= C : <eos>
3249
src = A の末尾に B に C を加えた値 の整数値を追加する
trg = A . append ( int ( B + C ) )
rst = A . append ( int ( B + C ) ) <eos>
3250
src = B の末尾に C の整数値を追加する を A とする
trg = A = B . append ( int ( C ) )
rst = A = B . index ( int ( C ) ) <eos>
3251
src = A の末尾に ( B 、 C 、 D ) の組 を追加する
trg = A . append ( ( B , C , D ) )
rst = A . append ( ( B , C , D ) ) <eos>
3252
src = A 内の B の出現回数が C 内の B の出現回数と等しいとき D 、 そうでなければ E を出力する
trg = print ( D if A . count ( B ) == C . count ( B ) else E )
rst = print ( D . count ( B . count ( B ) . count ( B ) else C ) else E ) <eos>
3253
src = A が 1 と等しいかどうか
trg = A == 1
rst = recursive ( 1 == 1 ) <eos>
3254
src = 99999 を A の B 番目に する
trg = A [ B ] = 99999
rst = A [ B ] = <unk> <eos>
3255
src = ネイピア数 、 B を A 、 ネイピア数とする
trg = A , e = e , B
rst = A , e = e , B <eos>
3256
src = A が B より小さいとき A 、 そうでなければ C を出力する
trg = print ( A if A < B else C )
rst = print ( A if A < B else C ) <eos>
3257
src = (500、100、50、10 、5、1) からなる列を A とする
trg = A = [ 500 , 100 , 50 , 10 , 5 , 1 ]
rst = A = [ 0 , 100 , 100 , 5 , 5 , 5 ] <eos>
3258
src = A が B の queen _ pos に含まれないとき 、
trg = if A not in B . queen_pos :
rst = if A not in B . queen_pos : <eos>
3259
src = B . dot ( Vector ( B . pt 1 , C )) を B . abs () の 2 乗で割った値を A とする
trg = A = B . dot ( Vector ( B . pt1 , C ) ) / pow ( B . abs ( ) , 2 )
rst = A = B . dot ( Vector ( B . pt1 , C ) ) / B . abs ( ) ) <eos>
3260
src = A の B から 1 を引いた値番目を C だけ 減 少 させ る
trg = A [ B - 1 ] -= C
rst = A [ B - 1 ] -= C <eos>
3261
src = B の C 乗を 10 の D 乗で割った商を 10000 で割った余りを A とする
trg = A = B ** C // ( 10 ** D ) % 10000
rst = A = B ** C // 10 ** D % 10000 <eos>
3262
src = A の末尾に ( B 、 C 、 D から E の F 番目の先頭を引いた値 ) の組 を追加する
trg = A . append ( ( B , C , D - E [ F ] [ 0 ] ) )
rst = A . append ( ( B , C , D - E [ F ] [ 0 ] ) ) <eos>
3263
src = ( ( B , C . GetNodes () の各要素を B とし 、 、 つまり偽の列 )) からなる辞書を A とする
trg = A = { node : [ False for B in C . GetNodes ( ) ] }
rst = A = { name : [ None for B in C . GetNodes ( ) ] } <eos>
3264
src = write ( A % max ( greedy ()))
trg = write ( A % max ( greedy ( ) ) )
rst = write ( A % max ( gen ( ) ) ) <eos>
3265
src = I に J から K に D に 1 を加えた値 を掛けた値を引いた値を掛けた値を H とする
trg = H = I * ( J - K * ( D + 1 ) )
rst = H = I * ( J - K * ( D + 1 ) ) <eos>
3266
src = A が 、 つまり空列 と等しいとき 、
trg = if A == [ ] :
rst = if A == [ ] : <eos>
3267
src = A の B 番目の末尾に time を追加する
trg = A [ B ] . append ( time )
rst = A [ B ] . append ( time ) <eos>
3268
src = A から B を引いた値が 0 以上かつ C から B を引いた値が 0 以上の 間 、 次 を 繰り返 す
trg = while A - B >= 0 and C - B >= 0 :
rst = while A - B >= 0 and C - B >= 0 : <eos>
3269
src = A の長さが 1 より大きくかつ cross 3( A [-1], A [-2], B ) が 0 以上の 間 、 次 を 繰り返 す
trg = while len ( A ) > 1 and cross3 ( A [ - 1 ] , A [ - 2 ] , B ) >= 0 :
rst = while len ( A ) > 1 and cross3 ( A [ - 1 ] , A [ - 2 ] , B ) >= 0 : <eos>
3270
src = C の distance に番号付した組の列を順に A 、 B として 、 繰り返 す
trg = for A , B in enumerate ( C . distance ) :
rst = for A , B in enumerate ( C . distance ) : <eos>
3271
src = A の先頭が B で 始 まるとき 、
trg = if A . startswith ( B ) :
rst = if A . startswith ( B ) : <eos>
3272
src = A の B 番目の C 番目が D より小さいとき A の B 番目の C 番目に 1 を加えた値 、 そうでなければ E を出力する
trg = print ( A [ B ] [ C ] + 1 if A [ B ] [ C ] < D else E )
rst = print ( A [ B ] [ C ] + 1 if A [ B ] [ C ] < D else E ) <eos>
3273
src = - B の C 番目 、 D の C 番目の最大値を A とする
trg = A = max ( - B [ C ] , D [ C ] )
rst = A = max ( - B [ C ] , D [ C ] ) <eos>
3274
src = readline () を空白で分割した字句列の各要素に 整数を適用した列を展開し 、 それぞれ A 、 B 、 ネイピア数とする
trg = A , B , e = map ( int , readline ( ) . split ( ) )
rst = A , B , e = map ( int , readline ( ) . split ( ) ) <eos>
3275
src = A の整数値を 1111 で割った余りが 0 と等しいとき 、
trg = if int ( A ) % 1111 == 0 :
rst = if int ( A ) % 10 == 0 : <eos>
3276
src = A の末尾に B に 1 を加えた値に C を掛けた値に D を加えた値 を追加する
trg = A . append ( ( B + 1 ) * C + D )
rst = A . append ( ( B + 1 ) * C + D ) <eos>
3277
src = 入力された文字列を E で分割した字句列の各要素を D とし 、 D の浮動小数点数の列 を展開し 、 それぞれ A 、 B 、 C とする
trg = A , B , C = [ float ( D ) for D in input ( ) . split ( E ) ]
rst = A , B , C = [ float ( D ) for D in input ( ) . split ( E ) ] <eos>
3278
src = aizu _ chicken ( A , B , C , D , E )
trg = aizu_chicken ( A , B , C , D , E )
rst = <unk> ( A , B , C , D , E ) <eos>
3279
src = A を 10 で割った値の切り 捨 て整数値を A とする
trg = A = math . floor ( A / 10 )
rst = A = math . floor ( A / 10 ) <eos>
3280
src = A の末尾に ( B から C の .5 乗を引いた値 、 D から E を引いた値 ) の組 を追加する
trg = A . append ( ( B - C ** .5 , D - E ) )
rst = A . append ( ( B - C ** .5 , D - E ) ) <eos>
3281
src = 無限の整数列の総和 を返す
trg = return sum ( count )
rst = return 44 <eos>
3282
src = A が B と等しいかどうかが 0 と等しいとき 、
trg = if A == B == 0 :
rst = if A == B == 0 : <eos>
3283
src = E から F に G を加えた値未満までの G 間隔の数列の各要素を D とし 、 C の D 番目の列の最小値を A の B 番目に する
trg = A [ B ] = min ( [ C [ D ] for D in range ( E , F + G , G ) ] )
rst = A [ B ] = min ( [ C [ D ] for D in range ( E , F + G , G ) ] <eos>
3284
src = A の B から 1 を引いた値番目の C から 1 を引いた値番目が -1 と等しくかつ D の長さが 0 より大きい 間 、 次 を 繰り返 す
trg = while A [ B - 1 ] [ C - 1 ] == - 1 and len ( D ) > 0 :
rst = while A [ B - 1 ] [ C - 1 ] == - 1 and len ( D ) > 0 : <eos>
3285
src = paint ( A , B )
trg = paint ( A , B )
rst = paint ( A , B ) <eos>
3286
src = A が 2 1 より大きいとき 、
trg = if A > 21 :
rst = if A > 21 : <eos>
3287
src = check _ puzzle ( B ) を A とする
trg = A = check_puzzle ( B )
rst = A = <unk> ( B ) <eos>
3288
src = 1 を開 始 番号として C 、 D 、 D の先頭を除いた部分列 の要素をそれぞれ組にした列 に番号付した組の列を順に A 、 B として 、 繰り返 す
trg = for A , B in enumerate ( zip ( C , D , D [ 1 : ] ) , start = 1 ) :
rst = for A , B in enumerate ( zip ( C , D , D [ 1 : ] ) , start = 1 ) : <eos>
3289
src = 3 から 0 未満までの -1 間隔の数列を順に A として 、 繰り返 す
trg = for A in range ( 3 , 0 , - 1 ) :
rst = for A in range ( 3 , 0 , - 1 ) : <eos>
3290
src = ネイピア数の 1 番目が 0 より大きくかつ A の level の 、 つまりネイピア数の先頭番目が 0 より小さいとき 、
trg = if e [ 1 ] > 0 and A . level [ e [ 0 ] ] < 0 :
rst = if e [ 1 ] > 0 and A . level [ 0 : 0 ] < 0 : <eos>
3291
src = A の先頭 の組が B に含まれるとき 、
trg = if tuple ( A [ 0 ] ) in B :
rst = if A [ 0 ] in B : <eos>
3292
src = ネイピア数の 2 番目のとき 、
trg = if e [ 2 ] :
rst = if e [ 2 ] : <eos>
3293
src = num _ from _ card ( B [ C ] ) を A とする
trg = A = num_from_card ( B [ C ] )
rst = A = <unk> ( B [ C ] ) <eos>
3294
src = B の 4 番目を 実 部 、 B の 5 番目を 虚 部 とし た 複 素数を A とする
trg = A = complex ( B [ 4 ] , B [ 5 ] )
rst = A = complex ( B [ 4 ] , B [ 5 ] ) <eos>
3295
src = calc ( B , C ) を A の B 番目から 、 つまり末尾までの部分列に する
trg = A [ B : ] = calc ( B , C )
rst = A [ B : ] = calc ( B , C ) <eos>
3296
src = C の各要素に tstr ( A [0]) + B + str ( A [1]) . zfill (2) を返す関数を適用した列のリスト を展開してを出力する
trg = print ( * list ( map ( lambda A : str ( A [ 0 ] ) + B + str ( A [ 1 ] ) . zfill ( 2 ) , C ) ) )
rst = print ( * list ( list ( list ( A [ 0 ] + list ( B [ 1 ] ) , + ) + list ( C ) [ 1 ] ) ) <eos>
3297
src = writelines ([ A %( B , C [ B ] , D [ B ] , E [ B ] , F [ B ] , G [ B ] , HifC [ B ] == -1 elseIifE [ B ] == 0 elseJ ) forBinrange ( K )])
trg = writelines ( [ A % ( B , C [ B ] , D [ B ] , E [ B ] , F [ B ] , G [ B ] , H if C [ B ] == - 1 else I if E [ B ] == 0 else J ) for B in range ( K ) ] )
rst = [ ( ( ( A ) % B B , C [ B ] , D [ B ] , E [ B ] , F [ B ] , G [ B ] , G [ B ] , ] [ 1 ] ] ) ] [ B ]
3298
src = A の B 番目が 、 つまり偽と等しくかつ C が -1 と等しくまたは D の B 番目が D の C 番目より小さいとき 、
trg = if A [ B ] == False and ( C == - 1 or D [ B ] < D [ C ] ) :
rst = if A [ B ] == None or ( C == - 1 or D [ B ] < D [ C ] ) : <eos>
3299
src = A が B と等しくまたは C のとき 、
trg = if A == B or C :
rst = if A == B or C : <eos>
3300
src = ( ( B の先頭の最小値 、0) からなる列 、 ( B の先頭の最大値 、0) からなる列 ) からなる列を A とする
trg = A = [ [ min ( B [ 0 ] ) , 0 ] , [ max ( B [ 0 ] ) , 0 ] ]
rst = A = [ [ B B ] , 0 , 0 ] , [ B B , 0 , 0 ] ] <eos>
3301
src = A の先頭の先頭 、 B に 1 を加えた値を出力する
trg = print ( A [ 0 ] [ 0 ] , B + 1 )
rst = print ( A [ 0 ] [ 0 ] , B + 1 ) <eos>
3302
src = A に対応する値 、 もし存在しなければ B の先頭のとき 、
trg = if A . get ( B [ 0 ] ) :
rst = if A . get ( B [ 0 ] ) : <eos>
3303
src = 無限の整数列の長さが 0 と等しいとき 、
trg = if len ( count ) == 0 :
rst = if <unk> == 0 : <eos>
3304
src = A を B の 2 番目だけ 増 加 させ る
trg = A += B [ 2 ]
rst = A += B [ 2 ] <eos>
3305
src = A から A に 5 を加えた値未満までの数列のリスト が B と等しいとき 、
trg = if list ( range ( A , A + 5 ) ) == B :
rst = if int ( A A A A 5 5 ) ) == B : <eos>
3306
src = f ( X ( A , B , C ) [0]) が f ( X ( A , B , C ) [1]) より小さいとき 、
trg = if f ( X ( A , B , C ) [ 0 ] ) < f ( X ( A , B , C ) [ 1 ] ) :
rst = if set ( f ( A , B , C ) ) < 0 ) < f ( A , A , B , C ) ] : <eos>
3307
src = B 、 C 、 D 、 A の C 番目の D 番目に お いて正規表現 A が最初にマッチする位置
trg = search ( A , B , C , D , A [ C ] [ D ] )
rst = search ( A , B , C , D , A [ C ] [ D ] ) <eos>
3308
src = inorder ( A , B )
trg = inorder ( A , B )
rst = inorder ( A , B ) <eos>
3309
src = A の B の先頭に [ MASK ] を挿入する
trg = A . insert ( B [ 0 ] )
rst = A . insert ( B [ 0 ] ) <eos>
3310
src = term () を展開し 、 それぞれ A 、 B とする
trg = A , B = term ( )
rst = A , B = input ( ) <eos>
3311
src = A の B 番目が C の D 番目と等しくない 間 、 次 を 繰り返 す
trg = while A [ B ] != C [ D ] :
rst = while A [ B ] != C [ D ] : <eos>
3312
src = A の B の C に 1 を加えた値番目から 1 を引いた値番目を 2 だけ 増 加 させ る
trg = A [ B [ C + 1 ] - 1 ] += 2
rst = A [ B [ C + 1 ] - 1 ] += 2 <eos>
3313
src = A でなくかつ B でなくかつ C でなくかつ D でなくかつ E でないとき 、
trg = if not A and not B and not C and not D and not E :
rst = if not A and not B and not C and not D and not E : <eos>
3314
src = 空白文字を間に入れて A の B 番目をソートした列 の各要素に整数を適用した列 を連結した文字列を出力する
trg = print ( ' ' . join ( map ( str , sorted ( A [ B ] ) ) ) )
rst = print ( ' ' . join ( map ( str , sorted ( A [ B ] ) ) ) ) <eos>
3315
src = rdfs ( A , B )
trg = rdfs ( A , B )
rst = rdfs ( A , B ) <eos>
3316
src = A に 1 を加えた値が B に含まれまたは A が 2019 と等しいとき 、
trg = if ( A + 1 in B or A == 2019 ) :
rst = if ( A + 1 ) B ) or A == == : <eos>
3317
src = A から B を引いた値が C の table に含まれるとき 、
trg = if A - B in C . table :
rst = if A - B in C . table : <eos>
3318
src = read ( A ) が B に含まれないとき 、
trg = if read ( A ) not in B :
rst = if read ( A ) in B : <eos>
3319
src = in _ the _ grid ( A , B ) でないとき 、
trg = if not in_the_grid ( A , B ) :
rst = if not <unk> ( A , B ) : <eos>
3320
src = f 1 ([ list ( input ()) forAinrange (8) ] )
trg = f1 ( [ list ( input ( ) ) for A in range ( 8 ) ] )
rst = [ ( [ list ( input ( ) ) for in [ ] for A in input ( ) ) ) ) <eos>
3321
src = C を A の B の C 番目から 1 を引いた値番目に する
trg = A [ B [ C ] - 1 ] = C
rst = A [ B [ C ] - 1 ] = C <eos>
3322
src = A の末尾に 10 e 9 に 1 を加えた値 を追加する
trg = A . append ( 10e9 + 1 )
rst = A . append ( <unk> ( 9 + 1 ) <eos>
3323
src = A 、 minimum _ cost ( B , C +1, tuple ( ( 1 ifD == Belse [ 0 forDinrange ( E )])) , min ( F + G -1, H ) , I , J , E , H ) に K を加えた値の最小値を A とする
trg = A = min ( A , minimum_cost ( B , C + 1 , tuple ( ( 1 if D == B else [ 0 for D in range ( E ) ] ) ) , min ( F + G - 1 , H ) , I , J , E , H ) + K )
rst = A = min ( A , minimum_cost ( B , C + 1 ) , ( ) + min ( ( D [ 1 ) ) ) ) ) ) , min ( ( E ) - 1 ) , min ( E ) - 1 ) , E )
3324
src = A でなくかつ B が C と等しいとき 、
trg = if not A and B == C :
rst = if not A and B == C : <eos>
3325
src = (0、0) からなる列に (1) からなる列の 9999 回分の列を加えた値を A とする
trg = A = [ 0 , 0 ] + [ 1 ] * 9999
rst = A = [ 0 , 0 ] + [ 1 ] * 999999 <eos>
3326
src = A が 100 と等しくまたは B が 100 と等しくまたは C が 100 と等しくまたは A に B を加えた値が 180 以上または A に B を加えた値に C を加えた値が 240 以上のとき 、
trg = if A == 100 or B == 100 or C == 100 or A + B >= 180 or A + B + C >= 240 :
rst = if A == 100 or B == 100 or C == 100 or A + B >= C or A >= B + C >= C : <eos>
3327
src = A の 2 に B を掛けた値から 2 に B を掛けた値に 2 を加えた値までの部分列が C と等しくなくかつ B を 2 で割った余りのとき 、
trg = if A [ 2 * B : 2 * B + 2 ] != C and B % 2 :
rst = if A [ 2 * B : 2 * B + 2 ] != C and B % 2 : <eos>
3328
src = A が 、 つまり未定値と等しくかつ B が 、 つまり未定値と等しいとき 、
trg = if A == None and B == None :
rst = if A is not None and B is not None : <eos>
3329
src = 2 の B から 1 を引いた値のビット長 乗を A の size に する
trg = A . size = 2 ** ( ( B - 1 ) . bit_length ( ) )
rst = A . size = 2 ** ( B - 1 ) . bit_length ( ) <eos>
3330
src = A の値の集まりの最大値が 1000000 より小さいとき 、
trg = if max ( A . values ( ) ) < 1000000 :
rst = if min ( A . values ( ) ) : <eos>
3331
src = F に G から H を引いた値を加えた値を E とする
trg = E = F + ( G - H )
rst = E = F * ( G - H ) <eos>
3332
src = B の C の 1 番目から C の 2 番目までの部分列を順に A として 、 繰り返 す
trg = for A in B [ C [ 1 ] : C [ 2 ] ] :
rst = for A in B [ C [ 1 ] : C [ 2 ] : <eos>
3333
src = A を isOddPrime (2* int ( input ()) +1) だけ 増 加 させ る
trg = A += isOddPrime ( 2 * int ( input ( ) ) + 1 )
rst = A += <unk> ( 2 * int ( input ( ) ) + 1 <eos>
3334
src = F の各要素を D とし 、 D 、 A の要素をそれぞれ組にした列 の各要素を B 、 C とし 、 B に C を掛けた値の列の総和を E で割った余りの列を A とする
trg = A = [ sum ( [ B * C for B , C in zip ( D , A ) ] ) % E for D in F ]
rst = A = [ [ ( B * C ) * E for B , C in zip ( D , A ) ] <eos>
3335
src = A に円周率を掛けた値を 180.0 で割った値を A とする
trg = A = A * math . pi / 180.0
rst = A = A * math . pi <eos>
3336
src = B に A の B から 1 を引いた値番目を掛けた値を A の B 番目に する
trg = A [ B ] = B * A [ B - 1 ]
rst = A [ B ] = B * A [ B - 1 ] <eos>
3337
src = B を書式として C 、 D 、 E 、 F 、 G 、 H 、 I で整形した文字列を A とする
trg = A = B . format ( C , D , E , F , G , H , I )
rst = A = B . format ( C , D , E , F , G , H , I ) <eos>
3338
src = A が 7 1 より小さいとき 、
trg = if A < 71 :
rst = if A < 7 : <eos>
3339
src = A の 1 番目に A の 2 番目を加えた値に A の 3 番目を加えた値に B の 1 番目 を加えた値を出力する
trg = print ( A [ 1 ] + A [ 2 ] + A [ 3 ] + B [ 1 ] )
rst = print ( A [ 1 ] + A [ 2 ] + A [ 3 ] + B [ 1 ] ) <eos>
3340
src = B の 3 番目から C の 3 番目を引いた値の 2 乗に B の 4 番目から C の 4 番目を引いた値の 2 乗を加えた値の平方根を A とする
trg = A = math . sqrt ( ( B [ 3 ] - C [ 3 ] ) ** 2 + ( B [ 4 ] - C [ 4 ] ) ** 2 )
rst = A = math . sqrt ( ( B [ 3 ] - C [ 3 ] ) ** 2 + ( B [ 4 ] - C [ 4 ] ) ** 2 ) <eos>
3341
src = A の B に C を挿入する
trg = A . insert ( B , C )
rst = A . insert ( B , C ) <eos>
3342
src = A を B から C を引いた値に D を加えた値だけ 増 加 させ る
trg = A += B - C + D
rst = A += B - C + D <eos>
3343
src = accel _ time _ end ()
trg = accel_time_end ( )
rst = <unk> ( ) <eos>
3344
src = A の B から C を引いた値から 1 を引いた値番目が 0 より大きいとき 、
trg = if A [ B - C - 1 ] > 0 :
rst = if A [ B - C - 1 ] > 0 : <eos>
3345
src = ネイピア数 、 A の B 番目に 1 を加えた値の最大値を ネイピア数とする
trg = e = max ( e , A [ B ] + 1 )
rst = e = max ( e , A [ B ] + 1 ) <eos>
3346
src = 改行文字を間に入れて ( A ) からなる列の 1000 回分の列 を連結した文字列を出力する
trg = print ( '\n' . join ( [ A ] * 1000 ) )
rst = print ( '\n' . join ( [ A ] * 1000 ) ) <eos>
3347
src = A を 360 で割った余りを出力する
trg = print ( A % 360 )
rst = print ( A % 360 ) <eos>
3348
src = B を 2 で割った余りを B とする
trg = B = B % 2
rst = B = B % 2 <eos>
3349
src = len ( set ( e [:4] )) が len ( set ( e [ 4 : 8 ])) と等しいかどうかが set ( e [8: ] ) の長さと等しいかどうかが 1 と等しいとき A 、 そうでなければ B を出力する
trg = print ( A if len ( set ( e [ : 4 ] ) ) == len ( set ( e [ 4 : 8 ] ) ) == len ( set ( e [ 8 : ] ) ) == 1 else B )
rst = print ( A if len ( jarvis ( jarvis ( jarvis ( jarvis ( jarvis ( A ) , if len ( <unk> ) if len ( bin ( 1 ) if len ( A ) if 2 ) if len ( ) ) if len ( A ) if
3350
src = A が B より小さくかつ C の A 番目が D と等しくない 間 、 次 を 繰り返 す
trg = while A < B and C [ A ] != D :
rst = while A < B and C [ A ] != D : <eos>
3351
src = 2002 を A とする
trg = A = 2002
rst = A = <unk> <eos>
3352
src = C 、 D 、 A 、 B を A 、 B 、 C 、 D とする
trg = A , B , C , D = C , D , A , B
rst = A , B , C , D = C , D , A , B , A <eos>
3353
src = - A の B 番目の先頭 を出力する
trg = print ( - A [ B ] [ 0 ] )
rst = print ( - A [ B ] [ 0 ] ) <eos>
3354
src = parse ( B , C , D +1, E ) を A とする
trg = A = parse ( B , C , D + 1 , E )
rst = A = parse ( B , C , D + 1 , E ) <eos>
3355
src = C の各要素を B とし 、 B の 0 番目 の列を順に A として 、 繰り返 す
trg = for A in [ B [ 0 ] for B in C ] :
rst = for A in [ B [ 0 ] for B in C ] ) : <eos>
3356
src = A の 0 番目が A の 1 番目と等しいとき 、
trg = if A [ 0 ] == A [ 1 ] :
rst = if A [ 0 ] == A [ 1 ] : <eos>
3357
src = B に C を加えた値に 1 を加えた値を A の 3 番目に する
trg = A [ 3 ] = B + C + 1
rst = A [ 3 ] = B + C + 1 <eos>
3358
src = merge ( B , C , D , E ) を A とする
trg = A = merge ( B , C , D , E )
rst = A = merge ( B , C , D , E ) <eos>
3359
src = 0 から B を 2 で割った商 未満までの数列を順に A として 、 繰り返 す
trg = for A in range ( B // 2 ) :
rst = for A in range ( B // 2 ) : <eos>
3360
src = A が 1 e -10 より小さいとき 、
trg = if A < 1e-10 :
rst = if A < 1e-10 : <eos>
3361
src = A の end を返す
trg = return A . end
rst = return A . end <eos>
3362
src = B に 1 を加えた値が C と等しいかどうかを A の B 番目の C 番目の D 番目の E 番目に する
trg = A [ B ] [ C ] [ D ] [ E ] = ( B + 1 == C )
rst = A [ B ] [ C ] [ D ] [ E ] = ( B + 1 ) == C <eos>
3363
src = 0 から C の 2 乗未満までの数列の各要素を B とし 、 、 つまり空列の列を A とする
trg = A = [ [ ] for B in range ( C ** 2 ) ]
rst = A = [ [ ] for B in range ( C ** 2 ) ] <eos>
3364
src = A かつ B が C に含まれるとき 、
trg = if A and B in C :
rst = if A and B in C : <eos>
3365
src = A の 2 番目から 、 つまり末尾までの部分列を A とする
trg = A = A [ 2 : ]
rst = A = A [ 2 : ] <eos>
3366
src = A の先頭から B の 5 番目から 、 つまり末尾までの部分列の整数値 を探して見つかった位置
trg = A . find ( int ( B [ 5 : ] ) )
rst = A . find ( int ( B [ 5 : ] ) ) <eos>
3367
src = update ( A [0], A [1]+1, A [2])
trg = update ( A [ 0 ] , A [ 1 ] + 1 , A [ 2 ] )
rst = update ( A [ 0 ] , A [ 1 ] ) , A [ 2 ] ) <eos>
3368
src = B の f _ val _ to _ key の A 番目を A とする
trg = A = B . f_val_to_key [ A ]
rst = A = B . <unk> [ A ] <eos>
3369
src = A の B の 1 番目番目の先頭 に A の B の 2 番目番目の先頭 を追加する
trg = A [ B [ 1 ] ] . appendleft ( A [ B [ 2 ] ] [ 0 ] )
rst = A [ B [ 1 ] ] . appendleft ( A [ B [ 2 ] ] [ 0 ] ) <eos>
3370
src = B の 1 番目の浮動小数点数を A とする
trg = A = float ( B [ 1 ] )
rst = A = float ( B [ 1 ] ) <eos>
3371
src = B が C より小さいとき D 、 そうでなければ E を A とする
trg = A = D if B < C else E
rst = A = D if B < C else E <eos>
3372
src = A の 1 番目 を辞書の A の先頭番目に する
trg = dict [ A [ 0 ] ] = A [ 1 ]
rst = dict [ A [ 0 ] ] = A [ 1 ] <eos>
3373
src = sort ( A , B , C , D )
trg = sort ( A , B , C , D )
rst = walk ( A , B , C , D ) <eos>
3374
src = A を書式として B の総和を B の長さで割った商 で整形した文字列を出力する
trg = print ( A . format ( sum ( B ) // len ( B ) ) )
rst = print ( A . format ( sum ( B ) . sum ( B ) ) ) <eos>
3375
src = A の B 番目を C の先頭だけ 増 加 させ る
trg = A [ B ] += C [ 0 ]
rst = A [ B ] += C [ 0 ] <eos>
3376
src = ( C 、 B ) の組を A の B に 1 を加えた値番目に する
trg = A [ B + 1 ] = ( C , B )
rst = A [ B + 1 ] = ( C , B ) <eos>
3377
src = A の B から C を引いた値番目の D 番目を A の B に C を加えた値に 1 を加えた値番目の D 番目だけ 増 加 させ る
trg = A [ B - C ] [ D ] += A [ B + C + 1 ] [ D ]
rst = A [ B - C ] [ D ] += A [ B + C + 1 ] [ D ] <eos>
3378
src = C に 10 を掛けた値を D で割った余りを C とする を A の B 番目に する
trg = A [ B ] = C = C * 10 % D
rst = A [ B ] = C = C * 10 10 % D <eos>
3379
src = ネイピア数に 1 から B の C 乗を引いた値を掛けた値を 1 から B を引いた値で割った値に B の C 乗に A を掛けた値を加えた値を A とする
trg = A = e * ( 1 - B ** C ) / ( 1 - B ) + B ** C * A
rst = A = e + ( 1 - B ** C ) + ( 1 ) B ) * ( B ** C * C ) <eos>
3380
src = ( (1) からなる列の 0 から D に 4 を加えた値未満までの数列の各要素 を C とし 、 B に 4 を加えた値の列回分の列 ) からなる列を A とする
trg = A = [ [ 1 ] * [ ( B + 4 ) for C in range ( D + 4 ) ] ]
rst = A = [ [ 1 ] * [ ( B + 4 ) for C in range ( D + 4 ) ] ] <eos>
3381
src = checkQueen ( A , B ) のとき 、
trg = if checkQueen ( A , B ) :
rst = if <unk> ( A , B ) : <eos>
3382
src = B に C に D に 1 を加えた値から E を引いた値を掛けた値を F で割った商を加えた値を A とする
trg = A = B + C * ( ( D + 1 ) - E ) // F
rst = A = B + C * ( D + 1 - E ) // F <eos>
3383
src = A を 2 で割った値を A とする
trg = A = A / 2
rst = A = A / 2 <eos>
3384
src = (0) からなる列の 4 回分の列 を展開し 、 それぞれ A 、 B 、 C 、 D とする
trg = A , B , C , D = [ 0 ] , 4
rst = A , B , C , D = [ 0 ] * 4 <eos>
3385
src = 空白文字を間に入れて A の B 番目の C 番目の各要素に整数を適用した列 を連結した文字列を出力する
trg = print ( ' ' . join ( map ( str , A [ B ] [ C ] ) ) )
rst = print ( ' ' . join ( map ( str , A [ B ] [ C ] ) ) ) <eos>
3386
src = B 、 6、8 、0 に お いて正規表現 A が最初にマッチする位置 のとき 、
trg = if search ( A , B , 6 , 8 , 0 ) :
rst = if search ( A , B , <unk> , 0 ) : <eos>
3387
src = ( (2, 1 )) からなる辞書を A とする
trg = A = { 2 : 1 }
rst = A = { <unk> : 1 } <eos>
3388
src = A の 2 乗に B の 2 乗を加えた値の .5 乗を ネイピア数とする
trg = e = ( A ** 2 + B ** 2 ) ** .5
rst = e = ( A ** 2 + B ** 2 ) ** .5 <eos>
3389
src = A . deletelast ()
trg = A . deletelast ( )
rst = A . <unk> ( ) <eos>
3390
src = B を A の w に する
trg = A . w = B
rst = A . w = B <eos>
3391
src = A が sys の maxsize と等しいとき 、
trg = if A == sys . maxsize :
rst = if A == sys . maxsize : <eos>
3392
src = ( B ) からなる列 の両端キューを A とする
trg = A = deque ( [ B ] )
rst = A = deque ( [ B ] ) <eos>
3393
src = A の stime に A の valuelist の先頭の 1 番目を加えた値を A の stime に する
trg = A . stime = A . stime + A . valuelist [ 0 ] [ 1 ]
rst = A . stime = A . stime + A . valuelist [ 0 ] [ 1 ] <eos>
3394
src = B が C より小さくかつ D の E 番目が D の B 番目より小さいかどうかを A とする
trg = A = B < C and D [ E ] < D [ B ]
rst = A = B < C and D [ E ] < D [ B ] <eos>
3395
src = 0 から C から D を引いた値 未満までの数列の各要素を B とし 、 、 つまり入力された文字列の整数値 の列を A とする
trg = A = [ int ( input ( ) ) for B in range ( C - D ) ]
rst = A = [ int ( input ( ) ) for B in range ( C - D ) ] <eos>
3396
src = A . root ( A . data [ B ] ) を A の data の B 番目に する
trg = A . data [ B ] = A . root ( A . data [ B ] )
rst = A . data [ B ] = A . root ( A . data [ B ] ) <eos>
3397
src = A の B の 1 番目番目の末尾に B の 2 番目を追加する
trg = A [ B [ 1 ] ] . append ( B [ 2 ] )
rst = A [ B [ 1 ] ] . append ( B [ 2 ] ) <eos>
3398
src = ((-1、0) の組 、(1、0) の組 、(0、-1) の組 、(0、1) の組 、(1、-1) の組 、(1、1) の組 ) の組を A とする
trg = A = ( ( - 1 , 0 ) , ( 1 , 0 ) , ( 0 , - 1 ) , ( 0 , 1 ) , ( 1 , - 1 ) , ( 1 , 1 ) )
rst = A = ( ( - 1 , 0 ) , ( 0 , 0 ) , ( 0 , - 1 ) , ( 1 , 0 ) , ( 1 , 1 ) ) <eos>
3399
src = - B 、 A を A 、 B とする
trg = A , B = - B , A
rst = A , B = - B , A <eos>
3400
src = 65535 をネイピア数とする
trg = e = 65535
rst = e = 65535 <eos>
