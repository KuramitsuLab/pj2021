# Cを1だけ増加させる
A = [ [ 1 , 2 , 4 , 8 ] , [ 4 , 8 , 1 , 2 ] , [ 8 , 1 , 2 , 4 ] , [ 2 , 4 , 8 , 1 ] ]
A , B , C = int ( 100 * A ) , int ( 100 * B ) , int ( 100 * C )
A = list ( B . split ( '|' ) )
while A < B :
A //= - B
A = B + C / D
return A . real ** 2 + A . imag ** 2
A = 104729
print ( 1 if A >= 1000 else 0 )
A , B = A // C , B // C
rec ( A + 1 , B - C , C )
A = ( 1440 * B + C * 60 + D ) % 10080
A . ws [ B ] = C
A . items = [ ]
if A >= 2 :
A , B , C = '' , 0 , len ( D )
print ( A [ B ] [ C // 3 ] [ C % 3 ] )
return A <= B and B <= C and D <= E and E <= F
A [ B ] [ C ] = 0
print ( bisect_left ( A , B ) )
A . items . append ( B )
A = B * C - ( C * ( C + 1 ) ) // 2
for A in range ( 1 , 1001 ) :
if A [ B ] == A [ B - 1 ] :
A , B , C , D , E , F = list ( map ( int , input ( ) . split ( ) ) )
A , B = A + C , B + 1
A = [ [ B for B in range ( 7 ) ] for C in range ( 2 ) ]
A -= B
A [ B ] [ 1 ] [ C ] [ C ] = A [ 1 ] [ D ] [ E ] [ E ] = 0
while A > 1 :
A = sum ( B )
# Dを1だけ増加させる
A = list ( B . split ( ) )
for A in range ( 24 ) :
if A + 1 < B and C [ A : A + 2 ] == 'IO' :
A = B . id [ A ]
A . append ( B )
A [ 1 ] = 0
if A [ B ] [ C ] + D >= A [ B ] [ E ] :
A = int ( '' . join ( input ( ) . split ( ) ) , 2 )
A <<= 1
if A [ B + 2 ] [ C ] == '#' or A [ B + 1 ] [ C ] == '#' or A [ B + 1 ] [ C - 1 ] == '#' :
import heapq
A . add ( B )
# 0を返す
for A in range ( B , 10 ) :
A [ B [ C ] ] += 1
print ( 'YES' if A ** 2 + B ** 2 == C ** 2 else 'NO' )
A [ B + C ] [ D + 1 ] = max ( A [ B + C ] [ D + 1 ] , A [ B ] [ D ] + E )
A = [ [ ' ' for B in range ( C + 5 ) ] for B in range ( C + 5 ) ]
A = [ 1 ] * 300
A = min ( A , B [ C + D ] )
A [ B ] += math . sin ( C * D ) * math . cos ( C * D )
if 2 * sum ( A ) <= B :
# 1をCの先頭のBに1を加えた値を1だけ右シフトした値番目にする
A = 10 * A + ( B % 10 )
# 関数処理を中断する
A = B . replace ( 'X' , str ( C ) )
# (A、0)からなる列を返す
A = UnionSet ( B )
A [ B ] [ C + 1 ] |= 8
if A <= B and ( A & 1 ) and C [ A ] == 0 :
# 1をCのB番目にする
A = [ ]
A = 223
A , B = calc ( C , D , E , F , 0 ) [ 0 ] , 0
print ( A [ int ( input ( ) ) ] )
A , B = 0 , [ ]
print ( A [ B ] [ int ( input ( ) ) ] )
A += B // C [ D ]
A = 2
# CをBのA番目にする
A = '' . join ( B )
print ( bisect_left ( A , B ) , bisect_right ( A , B ) )
A . sort ( )
A , B = [ 0 ] * C , [ 0 ] * C
print ( 196666 - A - B )
if A [ B ] < C and C <= A [ B + 1 ] :
A = B [ C ] [ D ]
A , B = 0 , C * 2
del A [ B [ 1 ] [ 0 ] ]
A , B = C , D
B = A . readline
# 偽をAとする
A = [ [ '' ] for B in range ( 1002 ) ]
print ( 'No\n' )
A [ B ] %= C
A = 2 if B > C else - 2
A = [ [ [ 0 for B in range ( 10 ) ] for C in range ( 10 ) ] for D in range ( 10 ) ]
A , B = 1 , [ 0 ] * C
A = list ( input ( ) )
A [ B + C ] [ 0 ] = D
A , B = [ 0 ] * 200 , 0
A , B = list ( map ( float , input ( ) . split ( ) ) )
A *= 10
rec ( 0 , A , A )
if A [ B ] [ C ] == '1' :
for A in range ( B - 1 , 0 , - 1 ) :
# BをDとする
A = [ [ [ B for C in range ( 31 ) ] for D in range ( E ) ] for F in range ( E ) ]
A , B , C = D . heappop ( E )
A . power = [ 0 ] * B
print ( sum ( [ A * B ** 2 for B in range ( A , 600 , A ) ] ) )
A = [ 'lunch' , 'dinner' , 'midnight' ]
A >>= 1
A = [ 'AAA' , 'AA' , 'A' , 'B' , 'C' , 'D' , 'E' , 'NA' ]
A [ B ] [ C ] [ D ] [ E ] += A [ B - 1 ] [ C ] [ D ] [ D ]
if A + 1 < len ( B ) and C [ B [ A ] ] < C [ B [ A + 1 ] ] :
# B、CのB番目を出力する
A += B [ 2 ]
print ( A )
print ( A [ B - 1 ] )
A = [ [ [ B for C in range ( D + 1 ) ] for E in range ( D + 1 ) ] for F in range ( G + 1 ) ]
A [ B ] = C + 1
A = input ( )
A = B + 6
print ( ( A - B - C ) // ( D - 2 ) )
# Aを展開してを出力する
if A [ B ] and C [ B ] == 0 :
# EのB番目を1だけ増加させる
A , B = map ( int , input ( ) . split ( ) )
print ( 'YES' if isOrthogonalLL ( [ A , B ] , [ C , D ] ) else 'NO' )
for A in range ( 2 ) :
print ( 'no' if A * B & 1 else 'yes' )
if A < B [ C ] [ D ] [ E ] :
A [ B ] -= 1
if A [ 0 ] > 0 :
A . heappop ( B )
A [ B ] [ C ] = min ( A [ B ] [ C ] , A [ B ] [ D ] + A [ D ] [ C ] )
A += B [ C ] // 3
# Dを1をCだけ左シフトした値だけ増加させる
A ^= B
A [ B * C + D - 1 ] . append ( ( E , F ) )
A += [ B ] * C [ B ]
print ( dijkstra ( A , B , C ) )
A = B [ C ] - B [ D ]
A = sum ( list ( map ( int , input ( ) . split ( ) ) ) )
A . append ( 1 )
A [ B ] = list ( map ( int , input ( ) . split ( ) ) )
# 繰り返しを中断する
# -1をCとする
A , B = C [ D ] , 1
A = ( ( 1 , 4 ) , ( 0 , 2 , 5 ) , ( 1 , 3 , 6 ) , ( 2 , 7 ) , ( 0 , 5 ) , ( 1 , 4 , 6 ) , ( 2 , 5 , 7 ) , ( 3 , 6 ) )
A , B = [ 0 ] * 3 , [ 0 ] * 3
A . level = [ - 1 ] * A . V
A [ B ] [ C ^ D ] += E
A [ 0 ] = list ( map ( int , input ( ) . split ( ) ) )
# 真をCとする
for A in range ( - 1 , 2 ) :
A . append ( complex ( B [ 2 ] , B [ 3 ] ) )
A , B = [ 0 ] * C , 0
A [ B ] [ C + 1 ] += 1
A += ')'
A = dijkstra ( B , C , D )
A -= B [ 0 ]
print ( A [ B ] , C // 10000 - D [ B - 1 ] // 10000 + 1 , E , F )
A = [ [ 0 for B in range ( 105 ) ] for C in range ( 105 ) ]
A += B + C + D + 1
A , B = C . heappop ( D )
for A in range ( 1 , 11 ) :
A . extend ( list ( map ( int , input ( ) . split ( ) ) ) )
# 1をBのAの7番目から末尾までの部分列番目にする
# 1をCのD番目のA番目のB番目にする
A = bisect_left ( B , C , 0 ) - 1
A , B = list ( C . split ( '+' ) )
A , B = C [ D - 1 ] , C [ D - 2 ]
if A == 2 :
# 'Impossible'を出力する
# 偽をCとする
A [ B ] = ( C , D [ 2 : ] )
for A , B , C in D . edge [ E ] :
A = [ list ( input ( ) ) for B in range ( C ) ]
if A > 20 :
A [ B ] = - getInt ( )
A -= B [ C ] * D
A [ 1 ] = True
if A <= B and A <= C :
A , B = int ( A ) - 1 , int ( B ) - 1
A = B = 0
A . edge = [ [ ] for B in range ( C ) ]
# BをCだけ増加させる
A [ B [ C + 1 ] ] = C + 1
print ( A if A > 0 else 'NA' )
A = 0
A = math . sqrt ( 4 * B * B + C * C ) + C
print ( ( comb ( A + B , min ( A , B ) ) << C ) % 100000007 )
A = bisect_left ( B , C , 0 , D )
while True :
A = B [ C ] + B [ D ]
# 0を出力する
A [ B - 1 ] = 1
A [ B ] [ C ] , A [ C ] [ B ] = D , D
A += 100
dijkstra ( A , B , C , D )
A = [ 0 ] * 2000
A = [ 18680908 , 19120730 , 19261225 , 19890108 , 99999999 ]
A [ B ] [ C ] = min ( A [ B ] [ C ] , A [ B ] [ D ] + E [ B ] [ 0 ] * E [ D ] [ 1 ] * E [ D + 1 ] [ 0 ] * E [ C ] [ 1 ] + A [ D + 1 ] [ C ] )
for A , B , C , D , E in F :
A . heappush ( B , ( ( - C << D ) | E , E , C ) )
print ( 'yes' if A else 'no' )
A , B = C // 100 , C % 100
print ( A - B + 1 )
A , B = C [ D ]
A = - 1
# EをBのC番目のD番目だけ増加させる
A = [ [ 660 , 899 ] , [ 1080 , 1259 ] , [ 1260 , 1559 ] ]
print ( )
for A in range ( B + 1 ) :
for A in B [ 1 : ] :
# 0をDとする
for A in range ( B - 1 , C - 1 , - 1 ) :
A = int ( input ( ) )
for A in range ( 4 ) :
# E.unite(F+A,F+A+1)
A = 720 - B
A [ B ] [ C - 1 ] += 1
if ( 'the' in A ) or ( 'this' in A ) or ( 'that' in A ) :
# E、AにBを加えた値をD、Cとする
import math
A . ws [ B ] += A . ws [ A . par [ B ] ]
for A in range ( B - 2 , - 1 , - 1 ) :
print ( '{:02d}:{:02d}:{:02d}' . format ( A // 3600 , ( A % 3600 ) // 60 , A % 60 ) )
A = { 0 : 'IDENTICAL' , 1 : 'CLOSE' , 2 : 'DIFFERENT' }
print ( calc ( 0 , 0 ) [ 0 ] )
if A [ B ] + C [ D ] < E :
# EをFのD番目だけ増加させる
A , B = C + D [ E << 1 ] , F + D [ ( E << 1 ) + 1 ]
# 繰り返しを中断する
A , B [ 0 ] = 0 , 1
is_atSameSide ( A , B , [ C , D ] )
A += '1' if B else '0'
A = { 'I' : 1 , 'V' : 5 , 'X' : 10 , 'L' : 50 , 'C' : 100 , 'D' : 500 , 'M' : 1000 }
print ( A [ B ] * math . cos ( C [ B ] ) , A [ B ] * math . sin ( C [ B ] ) , sep = '\n' )
# 繰り返しを中断する
if float ( A ) / float ( B ) ** 2 >= 25 :
print ( A [ 0 ] [ B - 1 ] )
A = dijkstra ( B , C , D , E , F )
A = [ '' ] * 100
for A in range ( 0 , 51 - B , C [ D ] ) :
A [ B + C ] [ 1 ] = 17 * ( D & 1 ) + 3 * ( D % 3 ) + 19
A = B = int ( input ( ) )
A = 17
for A in sys . stdin :
# 'C'を返す
A += B - C
if A [ 2 ] == 2 :
A , B = map ( float , input ( ) . split ( ',' ) )
# 9をAとする
A , B = list ( C ) , list ( C )
A , B , C = input ( ) . split ( )
A = min ( A , B + C [ D - E ] )
A [ B ] = int ( input ( ) )
A = [ 1 , 3 , 5 , 7 , 9 , 11 , 15 , 17 , 19 , 21 , 23 , 25 ]
print ( sum ( A [ B : C + 1 ] ) )
# 関数処理を中断する
A = B . Counter ( C )
A = [ 0 ] * 65
A = [ [ [ [ 0 for B in range ( 5 ) ] for C in range ( 5 ) ] for D in range ( 5 ) ] for E in range ( 2 ) ]
A [ B ] = A [ B - 1 ] + C [ B ]
if A < B and A not in C :
A %= B
A = B * C + D * E + F * G - H * I
# 繰り返しを中断する
# 繰り返しを中断する
A [ B ] = A [ C ] = A [ D ] = False
A = sorted ( list ( map ( int , input ( ) . split ( ) ) ) )
A [ B ] . append ( sum ( A [ B ] ) )
A = B - 1
A += 1720994 + B * 365 + ( C + 1 ) * 30 + ( C + 1 ) * 3 // 5 + D
# Aを1だけ増加させる
A = 0.00872664625997164788461845384244
print ( 'OK' if ( 2 * A ) ** 2 > B else 'NA' )
insort_left ( A , B )
# 繰り返しを中断する
A = 100000
A , B = list ( map ( float , input ( ) . split ( ',' ) ) )
print ( A + 1 , ':' , '*' * B [ A ] , sep = '' )
A = [ 'light fly' , 'fly' , 'bantam' , 'feather' , 'light' , 'light welter' , 'welter' , 'light middle' , 'middle' , 'light heavy' , 'heavy' ]
A = [ B for B in range ( C + 1 ) ]
# Bを1だけ減少させる
A = [ [ 0 for B in range ( 201 ) ] for C in range ( 201 ) ]
for A in range ( 1 , len ( B ) ) :
A = ( B + C ) / 2
print ( 1 )
A = 1e-8
A = int ( B [ 1 ] )
# BをAから20を引いた値に140を掛けた値だけ増加させる
A -= 5 * B
print ( A [ B & 1 ] [ C ] )
A . heappush ( B , ( 0 , C , - 1 , 0 ) )
while A < B and C [ A ] == ' ' :
A , B = '' , ''
A = list ( sorted ( A ) )
# 0を返す
A = 37
print ( A [ 1 ] )
print ( 'Yes' )
A [ B + 1 ] = A [ B ] + C [ B ]
A = Decimal ( 1 )
A = cross ( B [ 1 ] - B [ 0 ] , C [ 1 ] - C [ 0 ] )
return [ A , dist ( A , B ) ]
print ( 'no guest' if A [ B ] == 0 else C [ B ] * 100 // A [ B ] )
A = [ 10 , 12 , 15 ]
A , B = C . split ( '.' )
A = B
# 最初からもう一度、繰り返す
# AのB番目のCから1を引いた値番目をDとする
A . append ( ( B // 100 - 1 , C , D ) )
A = A . replace ( 'peach' , 'apple' )
A = 10000
A = 1
A = math . cos ( B * C ) * math . cos ( D * C ) * math . cos ( ( E - F ) * C ) + math . sin ( B * C ) * math . sin ( D * C )
A [ B ] = math . sqrt ( A [ B - 1 ] ** 2 + 1 )
A = [ 600 , 800 , 1000 , 1200 , 1400 , 1600 ]
D = A + ( B - 1 ) * C
A [ B ] %= 3
A = B ^ C [ D ] [ E ] [ F ] [ G ]
A = [ 500 , 100 , 50 , 10 , 5 , 1 ]
A , B = C [ D ] [ 0 ] , C [ D ] [ 1 ]
if A > B or ( C <= D and E [ C ] == 0 ) :
A = A ** 0.5
# DをCとする
A = [ [ - 1 , 0 ] , [ 0 , 1 ] , [ 1 , 0 ] , [ 0 , - 1 ] ]
A = list ( map ( int , input ( ) ) )
# Cを返す
A = [ False ] * B
# 0を返す
for A in range ( B , C + 1 , D ) :
A [ re ] = 1
if A > 0 and B . level [ C ] < B . level [ D ] :
A = [ 0 ] * 2
for A in range ( B + 1 , C ) :
print ( sum ( [ int ( input ( ) ) for A in range ( B >> 2 ) ] ) )
A = [ 0 , 4 , 13 , 27 , 45 , 67 , 94 , 126 , 162 , 202 , 247 ]
A , B = [ 0 ] * 31 , [ ]
A , B = - 1 , C [ 1 ]
# 最初からもう一度、繰り返す
A , B , C , D = list ( input ( ) . split ( ) )
A *= 2
A = B [ C ] - 1
A , B = 0 , 0
A , B = C , - 1
A , B = A - 1 , B + 1
A , B = int ( input ( ) ) - 1 , int ( input ( ) ) - 1
# 繰り返しを中断する
return min ( A , B [ C ] [ 0 ] )
print ( 'YES' if isParallelLL ( [ A , B ] , [ C , D ] ) else 'NO' )
# 最初からもう一度、繰り返す
for A in range ( B - 1 , - 1 , - 1 ) :
A [ 2 * B - 1 - C - D ] [ D ] = E
# EをCのDにBを加えた値番目だけ増加させる
A [ B ] [ C - 2 ] += 1
if A [ 0 ] != ')' :
A = [ [ 0 , - 1 ] , [ - 1 , 0 ] , [ 0 , 1 ] , [ 1 , 0 ] ]
A += B . pop ( 0 ) . upper ( )
A = [ [ 0.0 for B in range ( C ) ] for D in range ( E ) ]
if A [ B - C - 1 ] > 0 :
print ( A - len ( convex_hull ( B ) ) )
# Dを1だけ増加させる
A = [ [ 0 for B in range ( 1001 ) ] for C in range ( 11 ) ]
A = [ [ 0 for B in range ( 1002 ) ] for C in range ( 1002 ) ]
A [ B ] = False
A //= - 10
A = max ( A , B [ C ] - B [ D ] )
A , B = term ( )
A = math . sqrt ( B * B + C * C - 2 * B * C * math . cos ( D - math . fabs ( E ) ) )
def PPeQ ( a , b ) return EQ ( A . real , B . real ) and EQ ( A . imag , B . imag )
print ( 1 if A . issubset ( B ) else 0 )
def vabs ( a ) return math . hypot ( A . real , A . imag )
A = list ( map ( int , input ( ) . split ( ) ) ) + [ - 1 ]
A , B = ( C . real + D . real ) / 2 , ( C . imag + D . imag ) / 2
A [ B + 1 ] = A [ B ] [ 0 : C + 1 ]
A = B [ input ( ) . strip ( ) ]
A . unite ( B , C )
A . heappush ( B , ( 0 , 0 , 0 , 1 ) )
A = - A
# Cを1だけ増加させる
A = B + ( C << 9 )
# 1、CをAのB番目、DのB番目とする
A = len ( B ) - 1
A = A // gcd ( A , B ) * B
print ( min ( A , B ) )
# Bを返す
for A in range ( 28 ) :
# 1をCのB番目にする
if A [ B - 2 ] [ C ] == '#' or A [ B - 1 ] [ C ] == '#' or A [ B - 1 ] [ C + 1 ] == '#' :
# Bを返す
A = 5 if ( B % 5 ) == 1 else 2
A = B [ : C ]
A [ 4 ] = 1
for A in range ( int ( B ) ) :
return A + calc ( B >> 1 , C >> 1 )
# 偽を返す
# (0、未定値)からなる列を返す
A [ B : ] = 1
A [ B ] [ C ] [ D ] [ E ] %= 100000
print ( A if A >= 0 else 'unreachable' )
A . heappush ( B , ( C , D , E ) )
A , B = 0 , [ 0 ] * 1002
for A in range ( B [ C ] [ 1 ] , - 1 , - 1 ) :
A [ B ] , C [ B ] , D [ B ] , E [ B ] = map ( int , input ( ) . split ( ) )
A = B | ( 1 << C )
A , B = 0 , C
if A <= B and B <= C and D <= E and E <= F :
# Aを'0'にBに2を加えた値からAの長さを引いた値を掛けた値だけ増加させる
A += B // C
A [ F ( 't' ) + F ( 'h' ) + F ( 'a' ) + F ( 't' ) ] = ( B , C )
A = [ 0 ] * 60
# CをAのB番目だけ増加させる
A , B = C [ 0 ] , D
A = 1001
print ( A // 3600 , ':' , ( A % 3600 ) // 60 , ':' , A % 60 , sep = '' )
print ( A * B , 2 * ( A + B ) )
A [ B ] [ 0 ] [ 0 ] = 0
while len ( A ) :
A = B = C = 0
C = ( A / 100 + 1 ) ** B
A += [ B + C for C in range ( D ) ]
return chr ( ( A * B + C ) % D + E )
# Bを19にCから1を引いた値を掛けた値にCを2で割った商を加えた値だけ増加させる
# 繰り返しを中断する
A = format ( B , 'o' )
A = B [ C ] + D
# B、C、-DをC、B、Dとする
A += 15 * B + ( 15 - 2 ) * 3 * B
check ( A , B [ C ] [ 1 ] )
if not A . connected ( B [ 0 ] , B [ 1 ] ) :
A = B = C = D = E = 0
# Cを出力する
A , B = C . find ( A ) , C . find ( B )
# '13'を出力する
A = B + C + ( B * D ) // 100 + ( C * D ) // 100
A = defaultdict ( B )
A [ B + 1 ] [ C + 1 ] = min ( A [ B + 1 ] [ C + 1 ] , A [ B ] [ C ] + D [ B ] * E [ C ] )
A [ B ] [ C & D ] += E
return A . items == [ ]
if A <= B and B < C [ D ] :
# AのB番目にAのCから1を引いた値番目を加えた値をDとする
A [ B - 1 - C ] [ C ] = D
A = [ 0 ] * 101
A = B . real - C . real
A . add_edge ( B , C , 1 )
A . sort ( key = lambda x : ( - B [ 1 ] , B [ 0 ] ) )
for A in range ( 5 ) :
A , B , C , D , E = map ( int , input ( ) . split ( ) )
print ( 31 )
# BをAだけ減少させる
A = { 's' : 1 , 'w' : 2 , 'e' : 3 , 'n' : 4 }
# Bを(CのDを2だけ右シフトした値番目、A)からなる列だけ増加させる
A [ B + 2 ] [ C ] += 1
A [ ( 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 ) ] = 0
A = B * B
# 繰り返しを中断する
A = [ B for B in C if B < D ]
A . remove ( B )
A = [ [ 0 for B in range ( C + 2 ) ] for D in range ( C + 2 ) ]
# AのB番目のC番目の整数値、1をD、Eとする
A [ B : ] = A [ : B - 1 : - 1 ]
if A [ 0 ] == 'back' :
A = B [ : C // 2 ]
A = B [ : 2 ]
return 'd'
A = [ 'pre-meiji' , 'meiji' , 'taisho' , 'showa' , 'heisei' ]
if A [ 0 ] != ',' :
# AにBを加えた値にCを加えた値をDとする
for A in range ( 2 , B , 2 ) :
A . append ( str ( B & 3 ) )
# calc(D,E,F,G,B+2)を展開し順にC、Bとする
rec ( 0 , 0 , 0 )
# 繰り返しを中断する
A , B = A - 1 , C - 1
A . append ( complex ( B [ 0 ] , B [ 1 ] ) )
for A in range ( 1 , 13 ) :
A , B = C - 1 , 1
A [ B + 1 ] [ C ] += 1
A += B [ C ] - B [ D + 1 ]
# Dを1だけ増加させる
A , B = C + 1 , 2
parse ( list ( A ) , 0 )
print ( A [ 0 ] [ 0 ] , A [ 0 ] [ 1 ] )
print ( 1 if A == 0 else A )
A [ B ] = 'L' if ( ( C >> ( D - B ) ) & 1 ) == E [ B - 1 ] else 'R'
A , B , C , D , E = input ( ) . split ( )
print ( sum ( A ) )
A , B = list ( map ( int , C . split ( ) ) )
A . append ( ( B + C ) * D )
A = B . find ( B . par [ C ] )
# 最初からもう一度、繰り返す
print ( 0 )
A [ B + 1 ] [ C ] = max ( A [ B + 1 ] [ C ] , A [ B ] [ C ] )
A += B
while A and len ( B ) :
A = [ int ( input ( ) ) for B in range ( C ) ] [ : : - 1 ]
# 1をBのAの先頭の整数値番目にする
print ( (int) ( A ** 2 / 19.6 ) // 5 + 2 )
for A , B in C [ D ] :
A = crossPointLL ( B , C )
A [ 0 ] = B [ 0 ] = C = D = E = F = 200
A . unite ( id ( B , C ) , id ( D , E ) )
for A in range ( 1 , B ) :
A [ B ] , A [ C ] = A [ C ] , A [ B ]
A = counting_sort ( 100000 , A )
# 1000000をAとする
# CのB番目の0番目を1だけ増加させる
A = B = C - D + 1
A += 12
# DのB番目をCとする
print ( 'YES' if judge ( A , B , C , D , E , F , G , H ) else 'NO' )
# AのB番目を返す
A = 'A'
while A >= B :
A += B << 2
A , B = [ 0 ] * 7 , [ 0 ] * 7
A = 3
A [ B ] = C if A [ B - 1 ] + C < C else A [ B - 1 ] + C
print ( max ( A , key = A . count ) , max ( A , key = B ) )
print ( 'impossible' if A < 0 else A )
for A in range ( 3 , 1 + ( B >> 1 ) , 2 ) :
A , B , C = D [ 0 ]
if A [ B ] [ 2 ] and A [ C ] [ 2 ] :
if A [ B ] == '[' :
A = [ - 1 , 0 , 1 , 0 ]
print ( format ( A , '.2f' ) )
A = max ( - B [ C - D ] , E [ C - D ] )
return A
# Bを5にAから1を引いた値を3で割った商を掛けた値だけ増加させる
if A < B - 1 :
# CのD番目を1だけ増加させる
if A == '>' :
# 繰り返しを中断する
A , B = 0 , C - 1
# AをBとする
A = B * C - D * E + F * G + H * I
A , B = map ( int , C . split ( ':' ) )
A = [ 0 ] * 7
while A > 0 :
A , B , C = sorted ( list ( map ( int , input ( ) . split ( ) ) ) )
A = symmetric_Point ( B , C )
print ( 'Open' if A == 1 or A == 6 else 'Close' )
A *= 5
# Bを'_'にAの0を取り出した値を英小文字に変換した文字列を加えた値だけ増加させる
A [ B ] -= 1
A = [ 2 ]
if A [ B ] < C [ B ] :
print ( A - sum ( [ int ( input ( ) ) for B in range ( 9 ) ] ) )
A , B , C , D , E , F = list ( map ( float , input ( ) . split ( ) ) )
A = [ 'Sunday' , 'Monday' , 'Tuesday' , 'Wednesday' , 'Thursday' , 'Friday' , 'Saturday' ]
# B.appendleft(A[4:])
# 繰り返しを中断する
print ( A if A < B else 'Impossible' )
for A in range ( 5 , B - 1 , - 1 ) :
A , B = [ 0 ] * 120 , 0
A [ B ] = 1
A = dijkstra ( B , C , 0 )
A , B , C = list ( map ( int , input ( ) . split ( ) ) )
A [ B ] = max ( A [ B ] , C )
A = A . replace ( 'apple' , '_____' )
A = pay ( B )
A [ B ] [ 2 ] += 1
A [ B ] [ C ] = '#'
print ( B if A else 'NA' )
B [ A ] = [ ]
A = float ( input ( ) )
A [ chr ( ord ( 'A' ) + B ) ] = C
# DのC番目をEとする
# Cから1を引いた値をDとする
A , B , C , D = E . heappop ( F )
if A == 'HIT' :
print ( max ( A ) - min ( A ) )
A = [ 1 , 2 , 1 , 0 ]
if A :
while A != '6174' :
A , B , C , D = [ 0 ] * E , [ 0 ] * E , [ 0 ] * E , [ 0 ] * E
A . ws = [ 0 ] * B
A = { 0 : '.' , 1 : 'E' }
if A [ B ] > A [ B + 1 ] :
if A . size [ B ] < A . size [ C ] :
A = [ 0 ] * 3
A = ( - 1 , 0 , 1 , 0 )
print ( A + 1 , B + 1 )
A , B = Counter ( C ) . most_common ( ) [ 0 ]
A = [ A [ B ] + C [ B ] for B in range ( D ) ]
A , B = C , 0
A = [ [ 0 for B in range ( 12 ) ] for C in range ( 12 ) ]
print ( '' . join ( A [ 1 : B + 1 ] ) )
print ( 1 + A . index ( max ( A ) ) )
A = 1000000010
A = 10 * A + int ( B [ C ] )
if A > 10 :
A = 1.0e-8
A = UnionSet ( B * C )
A = [ 380 , 550 , 850 ]
import bisect
print ( dijkstra ( A , B , C , D ) )
A [ B ] [ C ] = '0'
A = B = 1
B = ( A - 61 ) // 20 + 1
A [ B + 1 ] [ C + D ] += A [ B ] [ C ]
A . level [ B ] = 0
print ( 'OK' if A <= B else 'NA' )
# Aを1だけ減少させる
# DをAからBに4にCを掛けた値を加えた値を引いた値だけ減少させる
A = B [ 0 ] [ C ]
A , B , C , D = [ 0 ] * 1002 , [ 0 ] * 1002 , [ 0 ] * 1002 , [ 0 ] * 1002
# 3にBのAから1を引いた値番目を掛けた値をBのA番目にする
A [ B [ C ] [ 0 ] ] = D
A = 250000
A = set ( list ( map ( int , input ( ) . split ( ) ) ) )
init ( 12 * 12 )
# pr(D,C)
A = math . acos ( ( B * B + C * C - D * D ) / ( 2 * B * C ) )
A = max ( - B [ C ] , D [ C ] )
A . append ( [ 0 , B , C ] )
# Cを1だけ減少させる
print ( * A [ 1 ] )
# rec(C+1,D*10+A[B])
A , B , C , D = list ( map ( float , input ( ) . split ( ) ) )
# C.heappush(D,(A[B],E,F+B))
for A in range ( 3 , 11 ) :
A [ F ( 't' ) + F ( 'h' ) + F ( 'i' ) + F ( 's' ) ] = ( B , C )
A [ B ] [ C + 2 ] += 1
A = 1000 - int ( input ( ) )
A = [ 2 ] * ( B + 1 )
A [ B ] [ C - 1 ] += D [ B ] * E
if EQ ( A [ B ] . real , 0 ) :
A . unite ( B , C , D )
return - A <= B and B <= A
A = max ( [ B [ C ] [ D ] for C in range ( E ) ] )
A [ B + 1 ] [ 0 ] = A [ B ] [ 0 ] + C [ 0 ]
print ( A // B )
if A . isalpha ( ) :
A . edge [ B ] [ C ] [ 1 ] -= D
A = complex ( B [ 6 ] , B [ 7 ] )
A = [ 0 ] * B
A = 50025
while A * A < B :
A = B [ C [ D ] ] [ 1 ]
print ( min ( A , ( ( B * C + D * E ) * 4 ) // 5 ) )
# A、AをBのC番目のD番目、BのD番目のC番目とする
# 繰り返しを中断する
A , B , C , D = map ( int , input ( ) . split ( ) )
A , B = [ 0 ] * 128 , [ 0 ] * 128
print ( max ( A - B , max ( C >> 1 , D [ 0 ] - 1 ) ) )
C = A ^ B
print ( A * B / 3.305785 )
A . append ( ( int ( B ) , int ( C ) , int ( D ) , int ( E ) , F ) )
A = [ ( 0 , 0 , 0 , 0 ) ]
A [ B * C ] = 1
A = 1e-5
A = sorted ( B , key = lambda x : ( C . imag , C . real ) )
A [ B + C ] . append ( ( B + D , E [ C - D - 1 ] ) )
A = [ - 1 ] * ( 1 << 25 )
A , B = C . popleft ( )
if A [ B ] >= 1000000 :
A = str ( input ( ) )
A [ B ] [ C | D ] += E
print ( A [ 0 ] [ 0 ] , A [ 1 ] [ 0 ] , A [ B - 2 ] [ 0 ] , sep = '\n' )
A = 1000000
A += B * C + D
A [ 51 ] , A [ 52 ] , A [ 53 ] , A [ 54 ] , A [ 55 ] = 'u' , 'v' , 'w' , 'x' , 'y'
A = B [ 0 ]
for A in range ( 9 , 0 , - 1 ) :
A = min ( len ( B ) , 5 )
A = B - C
A = [ 0 ] * ( B + 5 )
A [ B ] = ( int ( C ) , [ ] )
A = convex_cut ( B , A )
A [ B [ C ] - 1 ] += D
A = min ( A , B * C + D * E + F * G )
A , B = C - D , C + D
A = int ( sum ( B ) // C )
A += 'R'
print ( A , Decimal ( str ( calc_area ( B ) ) ) . quantize ( Decimal ( '0.1' ) , rounding = C ) )
print ( A [ B ] )
# 2をAとする
# E.unite(F+D,F+G+D)
if A [ B ] [ C + 2 ] == '#' or A [ B ] [ C + 1 ] == '#' or A [ B + 1 ] [ C + 1 ] == '#' :
print ( min ( A ) , max ( A ) )
for A in range ( B * C ) :
# CをA倍にする
return True
# 繰り返しを中断する
A , B , C = True , D , E
A = B = C >> 1
# DをCとする
print ( A [ B ] [ 0 ] )
A = [ B ] * ( C + 1 )
A , B = C + D [ E ] [ 0 ] , F + D [ E ] [ 1 ]
def cross ( a , b ) return A . real * B . imag - A . imag * B . real
A [ B ] [ C ] = '2'
A = ( 0 , 1 , 0 , - 1 )
A = [ [ ] for B in range ( C + 1 ) ]
print ( A [ 0 ] , A [ 1 ] )
return False
print ( 'Data ' , A + 1 , ':' , sep = '' )
combi ( 2 , A , B [ C ] [ 2 ] )
A = 26
A . iter = [ 0 ] * B
# 入力された文字列をAとする
A += B * C
# (Cを実部、Dを虚部とした複素数、Cを実部、DにB.realからA.realを引いた値に100を掛けた値を加えた値を虚部とした複素数)からなる列を返す
A = [ 0 for B in range ( 30001 ) ]
while A < B or C < D :
if leap_year ( A ) :
A = gcd ( A , B [ C ] )
A = [ [ B for C in range ( D + 1 ) ] for E in range ( F + 1 ) ]
# DをBのCに2を加えた値番目だけ増加させる
# 繰り返しを中断する
# 繰り返しを中断する
if A % B > ( B - 1 ) // 2 :
A = 22.0
A . par [ B ] += A . par [ C ]
A = [ 0 ] * 53
B = ( A - 1 ) // 5 + 1
# D、Bの最大値をDとする
A = B [ : : - 1 ]
return ( A > 0 and B > 0 ) or ( A < 0 and B < 0 )
+ ( A [ 1 ] . imag - A [ 0 ] . imag ) * ( A [ 0 ] . real - B . real )
# Eを1だけ増加させる
print ( A - B )
A = B + C + D
A [ B ] = A [ B - 1 ] + C
# Cを1だけ増加させる
A = [ 0 ] * 105
print ( 'OK' if A >= B else B - A )
if A [ B ] == 'O' :
A [ B ] = C [ D ]
# 40をAとする
A . append ( ( B , C , D , E ) )
A [ B ] [ C ] [ D ] [ D ] %= 100000
if A % 5 == 0 and B <= 99 :
return A [ 0 ] + B * C
while A < B and C [ A ] . isdigit ( ) :
while len ( A ) or len ( B ) :
A = B [ C ] [ 1 ]
# 1をCのB番目とするをCのA番目にする
A = complex ( B [ 2 ] , B [ 3 ] )
A , B [ C ] [ 0 ] , D , B [ C ] [ 1 ] = map ( int , input ( ) . split ( ) )
A , B = 0 , 31
A += B . power [ C ] + B . weight ( C )
print ( A , '{:d}.{:02d}' . format ( B // 100 , B % 100 ) )
A [ 1 ] , A [ 2 ] = 1 , 2
A = list ( A )
A . append ( B [ 0 ] )
A = re . split ( '[., ]' , input ( ) )
A [ B ] , C [ B ] = D , E
A = [ 0 ] * 100
A , B = min ( C ) , max ( C )
A = B . dfs ( C , D , E )
# BのA番目を1だけ増加させる
A = { }
A , B = C * D , E
# 繰り返しを中断する
print ( A . maxFlow ( B - 1 , C - 1 ) )
# Aを1だけ減少させる
A = 2 - ( B & 1 )
A = B * C - D
A , B = '' , 0
A [ 'A' ] , A [ 'B' ] , A [ 'C' ] = 'X' , 'Y' , 'Z'
# AのB番目を出力する
A [ B - 2 ] [ C ] += 1
input ( )
return A . items [ len ( A . items ) - 1 ]
A += B [ C - 1 ]
if A [ B ] == False :
A = [ len ( input ( ) ) for B in range ( C ) ]
A , B = 0 , 1
A = [ [ B for C in range ( 1 << D ) ] for E in range ( F ) ]
A , B = C // D , - E // D
print ( dijkstra ( A , B , 0 , A - 1 , C ) )
A = 2761
# Cの[MASK]番目のAにBを加えた値番目をCの1から[MASK]を引いた値番目のA番目だけ増加させる
for A in range ( 0 , B , 2 ) :
A += 60 * B [ C ] + B [ C + 1 ]
A = [ [ ] for B in range ( 50 ) ]
if A [ B ] [ C ] == 0 :
# Bを1だけ増加させる
A , B , C = 0 , 1001 , - 1
# 最初からもう一度、繰り返す
for A in list ( B . keys ( ) ) :
A . append ( tuple ( map ( int , input ( ) . split ( ) ) ) )
A , B = C / D , D
A = len ( B [ 2 ] )
print ( A , B , sep = '\n' )
print ( 7.81481481481481 * float ( A ) )
A . append ( B + C )
A , B = C + D [ E ] , F + G [ E ]
A = 1e-7
for A , B in C :
if A == 0 or B [ A ] >= 0 :
print ( ( A [ B ] - 1 ) // 3650 + 1 )
if A [ B ] == '"' :
A += B [ C ]
A [ B ] [ 0 ] = C
if len ( A [ B ] [ 1 ] ) > 0 :
print ( A if abs ( A - B ) <= C or A <= B else 'impossible' )
A = [ 0.0 , 48.0 , 51.0 , 54.0 , 57.0 , 60.0 , 64.0 , 69.0 , 75.0 , 81.0 , 91.0 , 1000.0 ]
print ( A , B )
for A in range ( 3 , B + 1 , 2 ) :
A = [ [ 0 for B in range ( 4 ) ] for C in range ( 2 ) ]
if A > 0 and B . level [ C ] < 0 :
A , B = len ( C ) , len ( D )
topological_sort ( A , B )
A . sort ( key = lambda x : ( B [ 1 ] , B [ 0 ] ) )
A = bisect_left ( B , C )
print ( A , int ( B ) + int ( C ) , 200 * int ( B ) + 300 * int ( C ) )
# Dを1だけ増加させる
A = [ 0 ] * 5
# CをAとする
# CをDとする
A , B = '' , True
# 0をBのCの先頭番目にする
# DをEにFのC番目からFのCから1を引いた値番目を引いた値を掛けた値だけ増加させる
if A + 1 >= len ( B ) :
# Aを1だけ増加させる
# BをCとする
A , B = int ( input ( ) ) , int ( input ( ) )
# 偽をDとする
# 'Impossible'を出力する
A = [ 5 , 7 , 5 , 7 , 7 ]
print ( 1 if topological_sort ( A , B ) else 0 )
for A in B [ C ] :
# CをAからBを引いた値から3を引いた値だけ減少させる
A = [ 0 ] * 5001
for A in range ( 5 - len ( B ) ) :
A [ 21 ] , A [ 22 ] , A [ 23 ] , A [ 24 ] , A [ 25 ] = 'f' , 'g' , 'h' , 'i' , 'j'
# BからAを引いた値をAとする
A = 0 if B == '+' else 1
A , B , C , D = 0 , True , 0 , 0
A -= 3 * B
# 'A'を出力する
# 関数処理を中断する
if A [ B ] [ C ] >= '0' and A [ B ] [ C ] <= '9' :
A [ B - 1 ] += A [ B ] + 1
A = 2 * int ( input ( ) )
A = { 'U' : 0 , 'R' : 1 , 'D' : 2 , 'L' : 3 }
return A [ B - 1 ] [ C - 1 ] [ D ]
A [ 31 ] , A [ 32 ] , A [ 33 ] , A [ 34 ] , A [ 35 ] = 'k' , 'l' , 'm' , 'n' , 'o'
A = [ [ 0 for B in range ( 3 ) ] for C in range ( 210 ) ]
if A >= B :
# BのC番目、Aを出力する
A = prime_factor ( B )
A = max ( - 3 , min ( 3 , B [ 1 ] - B [ 2 ] ) )
A [ B ] = complex ( C , D )
A [ B ] [ C ] = D = 1
A , B , C , D = map ( int , list ( E ) )
print ( A [ B ] - 2 , A [ B ] )
A = B * ( B - 1 ) >> 1
A = 899
print ( 1 + A * ( A + 1 ) // 2 )
A [ 2 ] = False
print ( * A [ 0 ] )
A = bisector ( B [ C ] , B [ D ] )
A . extend ( B )
A += 'U'
# '0'をAとする
A = 15
print ( B if A == 0 else A )
if not A . connected ( B , C ) :
A = circumscribed_circle ( B , C , D )
A . sort ( key = lambda x : ( B [ 0 ] , B [ 1 ] ) )
for A in range ( len ( B ) ) :
A = [ '' ] * B
A = [ - 1 ] * 4001
A = B [ C [ D ] ]
# 繰り返しを中断する
A = [ B ] * C
A . size [ B ] += A . size [ C ]
print ( sum ( list ( map ( int , input ( ) . split ( ) ) ) ) // ( A - 1 ) )
return root ( A ) == root ( B )
A , B , C , D = E - F , G - F , E + F , G + F
A , B = factor ( B + 1 )
A [ B [ 0 ] ] , A [ B [ 1 ] ] = A [ B [ 1 ] ] , A [ B [ 0 ] ]
A [ 11 ] , A [ 12 ] , A [ 13 ] , A [ 14 ] , A [ 15 ] = 'a' , 'b' , 'c' , 'd' , 'e'
A , B , C = 0 , 0 , 0
# 繰り返しを中断する
print ( gcd ( A [ 0 ] , A [ 1 ] ) , lcm ( A [ 0 ] , A [ 1 ] ) )
A = B + C [ B ]
# Cを1だけ減少させる
A , B , C = 3 , 3 , D - 2
combi ( A + 1 )
A = ( A * A // 100 ) % 10000
A [ B ] [ C ] = D
if A [ B ] < 0 :
A = 100
A = B [ C ] - D
for A in range ( B - 1 , len ( C ) ) :
A , B , C , D , E , F , G , H = map ( int , input ( ) . split ( ) )
if A [ B ] != '0' :
A , B = [ 0 ] * 100003 , [ 0 ] * 100003
A , B , C = int ( input ( ) ) , int ( input ( ) ) , int ( input ( ) )
import collections
A = B [ 0 ] // C * B [ 1 ]
if A [ B ] > C [ B ] :
A . find ( B )
A = max ( A , B )
A = sorted ( B , key = lambda x : ( C [ 2 ] ) )
re = A [ B ]
A , B = B , B + 1
# 繰り返しを中断する
# BをCのA番目からDのA番目を引いた値の絶対値だけ増加させる
A = B . replace ( '2' , '0' )
A = 3 + B // 4 - B // 100 + B // 400
# 繰り返しを中断する
A , B = A + 1 , True
A = palindrome ( B , C )
A [ 0 ] , A [ 1 ] = B , C
A [ B ] = C [ B ] = 0
A , B = int ( C [ 1 ] ) , int ( C [ 2 ] )
print ( A [ 0 ] )
for A in range ( 3 , B , 2 ) :
print ( math . factorial ( int ( input ( ) ) ) )
C = A [ B ]
A += 3
A = [ 0 ] * 12
print ( input ( ) . upper ( ) )
# BのC番目の0番目をDからEのA番目を引いた値に1を加えた値だけ増加させる
A . sort ( key = lambda x : ( len ( B [ 0 ] ) , B [ 0 ] ) )
A , B = 1 , C [ 0 ]
# Bを1だけ増加させる
# BをAとする
print ( int ( A ) )
for A in range ( 2 , 18 ) :
print ( min ( A [ : 3 ] ) + min ( A [ 3 : ] ) - 50 )
A = B + int ( C [ 1 ] ) * D [ E ] [ 1 ]
print ( ( A [ B ] [ C ] [ D ] [ D ] + A [ B ] [ C ] [ E ] [ E ] ) % 100000 )
A = [ 1 , 2 , 4 , 8 , 16 , 32 , 64 , 128 , 256 , 512 ]
# 繰り返しを中断する
for A in re . findall ( B , input ( ) ) :
A = [ [ B - 1 ] if B > 0 else [ [ ] for B in range ( C ) ] ]
A -= C [ B ]
A = int ( input ( ) ) - 1
for A in range ( B ) :
# 1を出力する
A , B [ C ] = A + 1 , B [ C ] + 1
# Bを1だけ増加させる
for A in range ( 0 , len ( B ) , 4 ) :
A = 1000
A = list ( B )
A [ 0 ] [ 0 ] [ 1 ] = 0
A = B % 10
A = int ( '9' * B ) + 1
# Dを返す
A = B [ C ] - B [ C + 1 ]
print ( A - B + 1 , C - D + 1 )
F = A * ( - B ) + C + D * E
A [ B + 1 ] = A [ B ] + ( C [ B ] == 'J' )
A = 'U'
A , B , C = 1 , 0 , D
A . append ( ( int ( B [ 0 ] ) , int ( B [ 1 ] ) , B [ 2 ] , int ( B [ 3 ] ) , B [ 4 ] ) )
A += B * C [ D - E - 1 ]
A = [ 0 , 1 , 2 , 4 , 6 , 16 , 12 , 64 , 24 , 36 , 48 , 1024 , 60 ]
A = 1000004
A = [ 0 ] + [ int ( input ( ) ) for B in range ( C - 1 ) ] + [ D ]
A = (int) ( B * C )
if A >= 0 :
A = ( ( - 1 , 0 ) , ( 0 , 1 ) , ( 1 , 0 ) , ( 0 , - 1 ) )
# 繰り返しを中断する
A = 240 * B
A . par [ B ] = C
def EQ ( a , b ) return abs ( B - C ) < A
A [ B [ 0 ] [ 0 ] ] = C = 1
A . append ( [ B , C ] )
A , B = ( 30 * C + ( D // 2 ) ) * 2 , ( 6 * D ) * 2
A [ 0 ] = B [ 0 ] = B [ 0 ] + C [ D ]
A = [ 1520 , 1870 , 2244 ]
A = 500
# term(B+1)を展開し順にC、Bとする
# EのB番目のC番目をDとする
A . update ( B )
A = [ ord ( B ) - C for B in A ]
A = [ 0 ] * 31
A = [ [ - 1 for B in range ( C ) ] for D in range ( C ) ]
A , B = [ ] , '>'
# DをCのBのAに1を加えた値番目から1を引いた値番目にする
if A == '~' :
if A == 9 :
A , B , C = 0 , - 1 , 0
print ( A >> 1 )
A , B = [ 0 ] * 27 , [ 0 ] * 27
A = { PLUS : 2 , MINUS : 2 , MUL : 3 , DIV : 3 , LEFT : 1 , RIGHT : 1 }
# 最初からもう一度、繰り返す
A . heappush ( B , ( C , D , E , F ) )
[ A . append ( B ) for B in range ( 5 , 0 , - 1 ) ]
A = max ( B - C [ D ] , E - F [ D ] )
A , B = d2t ( C [ D ] ) , d2t ( C [ D + 1 ] )
A = ( ( 1 , 2 ) , ( - 1 , 3 ) , ( 1 , - 3 ) , ( 4 , 5 ) , ( 5 , 2 ) , ( 2 , 1 ) )
sieve ( )
A = complex ( B [ 0 ] , B [ 1 ] )
A = 0.01745329251994329576923690768489
A , B = 0 , C + 1
A , B = C [ 0 ] [ 0 ] , C [ 0 ] [ 1 ]
A = complex ( B [ 8 ] , B [ 9 ] )
if A [ 0 ] == '0' :
A = [ 0.0 ] * 2
A = max ( A , B [ C ] [ D ] )
combi ( A + 1 , B , C + D [ E ] [ 2 ] )
print ( A + ( 31 - B ) * 50 )
A [ B [ 0 ] - 1 ] += C
A = B [ 0 ] [ 1 ]
A //= 100
A [ B [ 0 ] ] . append ( B )
A = 3 * 0xff ** 2
A [ B ] [ C ] = max ( D , E , F )
print ( - 1 if A < 0 else A + B * C )
# 最初からもう一度、繰り返す
A = B << 1
A = 0x7ffffff
if A [ B ] >= 'a' and A [ B ] <= 'z' :
print ( A [ Zeller ( 2004 , B , C ) ] )
A . append ( 0 )
A = [ [ 0 for B in range ( 3 ) ] for C in range ( D ) ]
for A , B in C [ : : - 1 ] :
# CをBを1だけ右シフトした値だけ増加させる
if int ( A ) + int ( B ) == int ( C ) :
A = ( B . imag - C . imag ) / 2
if re :
A = swap ( B , C , D )
print ( format ( A [ B ] [ C ] , '4d' ) , end = '' )
A [ B ] [ C ] |= 2
A = str ( A ) [ : B + 2 ]
A . id [ B ] = A . id [ A . id [ B ] ]
A = 'R'
A = B . dfs ( C , D , min ( E , F ) )
return A // gcd ( A , B ) * B
A [ B ] [ C + 1 ] [ D + 1 ] = min ( A [ B ] [ C + 1 ] [ D + 1 ] , max ( E [ D + 1 ] - E [ C ] , A [ B - 1 ] [ F ] [ C ] ) )
A = B . bisect_left ( C , D - C [ E ] )
A = [ [ [ [ 0 for B in range ( 2 ) ] for C in range ( 2 ) ] for D in range ( E + 1 ) ] for F in range ( G + 1 ) ]
A . append ( float ( input ( ) ) )
A = B * B + C * C
A , B = 100000 , 1000000000
A = [ [ ] for B in range ( C ) ]
return max ( abs ( A - B ) , abs ( C - D ) )
A -= B . power [ C ] + B . weight ( C )
# Eの末尾にFのC番目のD番目を追加する
A , B = [ [ 0 , 0 , 0 ] ] , [ 0 ]
A , B = 1 , 2
A += B // 3
print ( A // B + 1 )
A = [ [ 0 , 1 ] , [ 1 , 0 ] , [ 0 , - 1 ] , [ - 1 , 0 ] ]
setcontext ( Context ( prec = A , rounding = B ) )
if A [ B ] [ C ] == 1 :
A = 10 ** len ( B )
A = B - 2 * A
return 1
A , B = C
# Aを'0'に5からAの長さを5で割った余りを引いた値を掛けた値だけ増加させる
A = ( B >> ( C * 3 ) ) & 7
if A [ B ] != A [ B - 1 ] + 1 :
# Cの末尾に(D、E、Aに1を加えた値)からなる列を追加する
print ( B + A + 1 if A > 0 else 'NA' )
A = tuple ( map ( int , input ( ) . split ( ) ) )
# Bを3だけ左シフトした値とCのA番目の論理和をBとする
for A in range ( 1 , 32 ) :
A = ( B * C + D * E ) / ( F * G )
if math . fabs ( A ) < B or math . fabs ( C ) < B :
A = [ [ 0 for B in range ( 100 ) ] for C in range ( 100 ) ]
A , B , C = list ( map ( int , input ( ) . split ( ',' ) ) )
A = B ** 2 - 4 * C * D
A = [ 0 ] * 128
B = list ( A [ 1 ] )
print ( * sorted ( map ( int , A [ B ] ) ) )
A = ord ( B ) - C
A , B , C = - D + E , - D - E , F << 1
A . append ( A [ 0 ] )
# 偽を返す
A , B = input ( ) . split ( )
if A [ B ] + C [ B ] == C [ 0 ] :
A = A [ : B ] + A [ C : D ] + A [ E : C ] + A [ B : E ] + A [ D : ]
A = len ( B )
A = deque ( )
A [ B ] [ C ] = - 1 if D < 0 else C - D
A . heappush ( B , ( C , D ) )
A = B + 2
return [ A , B + 1 ]
A , B , C = map ( float , input ( ) . split ( ) )
A = int ( input ( ) ) * 2
A , B = C [ D << 1 ] , C [ ( D << 1 ) + 1 ]
A [ B ] = A [ B - 1 ] - 1
# Bの0番目を1だけ増加させる
A += [ B + ( C << 18 ) for C in range ( D ) ]
A . sort ( key = lambda x : ( B [ 0 ] , B [ 2 ] ) )
A = ( B + C [ D ] ) / ( E + F )
A = dcmp ( cross ( B [ 1 ] - B [ 0 ] , C [ D ] - B [ 0 ] ) )
A = ( 1 - B * B ) ** 0.5
A = B / ( C / 100 ) ** 2
act ( 0 , 2 if A == 'i' else 1 )
print ( 'overflow' )
return [ complex ( A , B ) , complex ( C , ( A - C ) * ( D . real - E . real ) / ( D . imag - E . imag ) + B ) ]
A = B
print ( A , len ( set ( B ) & set ( C ) ) - A )
A -= B [ C ]
# Bの[MASK]番目のDのE番目のA番目番目をBの1から[MASK]を引いた値番目のA番目にする
A = B / 2
A , B , C = int ( D [ 1 ] ) , int ( D [ 2 ] ) , int ( D [ 3 ] )
A , B = C [ 0 ] , B - C [ 0 ]
A [ 1 ] = 1.0
return A [ 0 ]
A = [ 2 , 3 , 5 ]
A . append ( ( B , - C ) )
pushBack ( A , B )
# 0をBとする
A = 1 - A
A = ( B * C ) % ( C + D )
# Bを返す
A = B + C [ D ]
A [ B ] = getInt ( )
A , B , C = 1 , 1 , 1
A = B [ C ] [ 1 ] - 10080 if B [ C ] [ 1 ] >= 10080 else 0
print ( C if A > ( B >> 1 ) else 'NO COLOR' )
print ( A * B )
A = [ [ 0 for B in range ( 13 ) ] for C in range ( 13 ) ]
A [ B ] [ C - 1 - B ] = D
A [ B ] [ C ] = max ( A [ B ] [ C ] , A [ B - 1 ] [ D ] * E [ D ] [ C ] )
print ( A [ B : C ] . count ( D ) )
if ( A >= B and C <= D ) or ( A <= B and C >= D ) :
# 繰り返しを中断する
A = 2002
# AのBに1を加えた値番目、AのB番目をAのB番目、AのBに1を加えた値番目とする
# 区切りなしでAの先頭、','、Aの2番目を出力する
for A in range ( 1000 ) :
A = [ B for B in range ( 7 ) ]
A , B = C . pop ( ) , C . pop ( )
A , B = C - D [ 0 ] [ 0 ] , E - D [ 0 ] [ 1 ]
A , B = 0 , - 1
A = B - ( C . imag - D . imag ) * 100
# Cの末尾に(D、E)の組を追加する
print ( 'LOOP' )
A , B , C , D = list ( map ( int , input ( ) . split ( ) ) )
A = [ 0 , '.,!? ' , 'abc' , 'def' , 'ghi' , 'jkl' , 'mno' , 'pqrs' , 'tuv' , 'wxyz' ]
A , B , C = map ( int , input ( ) . split ( ',' ) )
if A >= 0 and A < 5 and B >= 0 and B < 5 and C >= 0 and C < 5 :
# Cの補数をCとする
A , B = ( C - 1 ) // D + 1 , ( E - 1 ) // F + 1
if A > 255 :
A = ( B * B + C * C ) - D * D
# (偽、0)からなる列を返す
A = False
if 3 <= len ( A ) <= 6 :
A . push ( B )
A = input ( ) [ 0 ]
print ( kruskal ( A , B ) )
# 最初からもう一度、繰り返す
A [ B ] += A [ C ]
A = B * ( B + 1 ) * ( B + 2 ) // 6
A . power [ B ] += C
A , B = C // 2 + 1 , C // 2
A [ B ] [ 1 ] += 1
A = [ True for B in range ( C ) ]
# 繰り返しを中断する
print ( calc ( input ( ) ) )
A [ B ] , C = D , B
A , B = B , A
# 最初からもう一度、繰り返す
while A < B and C < D :
for A in range ( 101 ) :
rec ( A + 1 , B + C , D + E )
A . pop ( B . index ( C ) )
A = B * C - D * E - F * G - H * I
A = [ '' ] * 7
A [ B - 1 ] [ C - 1 ] += 1
A = 0.0001
A , B , C , D , E = [ int ( input ( ) ) for F in range ( 5 ) ]
A . append ( B [ C ] )
A [ B ] [ C ] = A [ D ] [ E ] + F
A += ( B + C - 1 ) // C
for A in range ( 1001 - B ) :
A = B + int ( C [ 1 ] ) * D [ E ] [ 0 ]
A = [ 0 ] * 126
A = 'abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz'
A = MaxFlow ( B )
A = sorted ( A [ B : C ] , reverse = True )
A = [ list ( map ( int , input ( ) . split ( ) ) ) for B in range ( C ) ]
return A [ 0 ] + B * ( cross ( C , D [ 0 ] - A [ 0 ] ) / cross ( C , B ) )
A = [ 0 ] * ( B + max ( C , D ) + 1 )
del A [ B [ 0 ] [ 0 ] ]
A = [ [ 0 for B in range ( 5 ) ] for C in range ( 5 ) ]
C = A [ B : ] + A [ : B ]
print ( A if A >= B else B )
if clause ( A [ 1 : - 1 ] ) :
A [ B - 1 ] [ C ] += 1
# Bの6番目を1だけ増加させる
A , B , C = 1 , D , D
A = int ( B )
A = [ [ [ 0.0 for B in range ( 3 ) ] for C in range ( 3 ) ] for D in range ( 17 ) ]
# 最初からもう一度、繰り返す
A , B = len ( C . edge [ D ] ) , len ( C . edge [ E ] )
# DのB番目のC番目をDのB番目のCから1を引いた値番目だけ増加させる
A = sum ( [ int ( input ( ) ) for B in range ( 4 ) ] )
A . append ( B [ 1 ] )
A . unite ( B [ 0 ] , B [ 1 ] )
if A >= 0 and A < 12 and B >= 0 and B < 12 :
A = 20
print ( A + B + C , A , B , C )
A , B = [ [ 0 for C in range ( 16 ) ] for D in range ( 20 ) ] , 0
[ A . append ( B ) for B in range ( C , 10 ) ]
for A in range ( B - 1 , B + 2 ) :
if A [ B ] < A [ C ] :
A [ 0 ] , A [ 1 ] = 2 , 3
A = { "North" : 1 , "East" : 2 , "West" : 3 , "South" : 4 , "Right" : 5 , "Left" : 6 }
A , B = list ( map ( int , input ( ) . split ( ',' ) ) )
A [ B - 1 ] . append ( C - 1 )
A += ( B [ C ] - B [ D + 1 ] ) * E [ D ]
print ( calc ( A ) )
A , B = map ( int , input ( ) . split ( ',' ) )
A , B = [ C ] * D , [ 0 ] * D
if A [ B + C ] [ 0 ] >= 0 :
A [ B + 1 ] [ C + 1 ] += 1
A += min ( B , C )
A , B = [ 0 ] * 62 , [ 0 ] * 62
if A [ B ] >= '0' and A [ B ] <= '9' :
A , B = len ( C ) , D
# 繰り返しを中断する
return A % 4 == 0 and ( A % 100 != 0 or A % 400 == 0 )
A , B = C [ ord ( D [ E ] ) - F ] , G [ ord ( D [ E ] ) - F ]
A = [ 1 , 5 , 25 , 125 , 625 , 3125 , 15625 , 78125 ]
print ( A if A <= B else - 1 )
parse ( A , B [ C ] [ 0 ] )
C = A [ B ]
A = [ 0 ] * 26
A = [ int ( input ( ) ) for B in range ( C ) ]
A . bfs ( B )
A += B
A . heappush ( B , ( C [ 1 ] , C [ 0 ] ) )
A = ord ( B ) - ord ( 'A' )
if A - B [ C ] - B [ D ] >= E :
A = [ 4 , 1 , 4 , 1 , 2 , 1 , 2 , 1 , 4 , 1 , 4 , 1 , 2 , 1 , 2 , 1 ]
# 0をCとする
print ( calc ( A , B ) )
A = int ( B [ C ] [ D ] )
A = A + ( A * 5 ) // 100
A , B , C = 1 , 1 , 0
A = B [ C - 1 ] [ 2 ] * D / E + B [ C - 1 ] [ 0 ]
A . append ( [ B , C , 3 * int ( D ) + int ( E ) ] )
return A // B [ C ] [ 0 ] + A // B [ C ] [ 1 ]
A = A - B / ( 3 * C )
for A , B , C , D in E :
A = [ [ 0 for B in range ( 4 ) ] for C in range ( 4 ) ]
A *= B
return A [ B ]
print ( 'win' if A else 'lose' )
A = 182
A [ B + C + D + E ] += 1
A = B . pop ( )
if ( A & 1 ) or B >= ( 1 << ( A >> 1 ) ) :
A = dict ( sorted ( A . items ( ) ) )
A , B [ 0 ] , C [ 0 ] = 0 , 1 , int ( input ( ) )
# 偽をDのA番目にする
if A >= B + C :
A = [ B ] * 2
if A [ B ] == '1' :
A [ int ( B [ 0 ] ) ] += 1
print ( * A [ : : - 1 ] )
# Cを1だけ増加させる
A , B = root ( C ) , root ( D )
A = ( ( A - 1 ) // 1000 + 1 ) * 1000
# 0をDのB番目のC番目にする
A = [ '0' , '90' , '180' , '270' ]
A = dcmp ( cross ( B [ 1 ] - B [ 0 ] , C - B [ 0 ] ) )
A = bisect_right ( B , int ( C [ 2 ] ) , D )
for A in range ( 1 , 126 ) :
A , B = B , C
A = B [ C ] - B [ C - 1 ]
A = [ [ 0 for B in range ( 51 ) ] for C in range ( 51 ) ]
A [ B ] [ 1 ] = C
A [ B . index ( C ) ] += 1
A [ 0 ] = 0
# Cを1だけ増加させる
A = [ 35.5 , 37.5 , 40.0 , 43.0 , 50.0 , 55.0 , 70.0 , 1000.0 ]
print ( int ( '' . join ( sorted ( A , reverse = True ) ) ) - int ( '' . join ( sorted ( A ) ) ) )
A = [ A [ B [ C [ D ] ] [ E ] ] for E in range ( 7 ) ]
# gcd(C,B[A])をCとする
for A in list ( input ( ) . split ( ) ) :
if A <= B and C [ A ] == 0 :
A , B , C , D = set ( ) , True , [ 0 ] , 1
print ( A [ B // 100 ] )
A = 1005
A = gcd ( B [ 0 ] , B [ 1 ] )
print ( len ( A & B ) )
A = list ( map ( int , B ) )
print ( A [ 1 - ( B & 1 ) ] )
A = B [ C ]
A , B , C = [ ] , [ ] , { }
A , B = list ( input ( ) . split ( ',' ) )
A , B = list ( input ( ) . split ( ) )
# BからAを引いた値をAとする
for A in range ( 3 , 1 + int ( B ** 0.5 ) , 2 ) :
A = abs ( B - C )
A , B = gcd ( C , D ) , gcd ( E , D )
A = B + 5
A = [ [ 0 for B in range ( 15 ) ] for C in range ( 2 ) ]
return A . items . pop ( )
( A [ B ] , A [ C ] ) = ( A [ C ] , A [ B ] )
return [ A , B ]
for A in range ( 1 , B + 1 , 1 + ( B & 1 ) ) :
while A < B and C [ A ] . isalpha ( ) :
A , B = B , - 1
A = B . bisect_left ( C , D >> 1 , 0 , E )
A = list ( map ( int , input ( ) . split ( ) ) )
A , B = [ ] , 0
A [ B ] [ C ] [ D ] [ D ] += A [ B - 1 ] [ C ] [ D ] [ D ] + A [ B - 1 ] [ C ] [ E ] [ D ]
if A <= 5 :
# Aの0を取り出した値をBとする
A = [ True ] * B
B = A + 1
if A [ B ] [ C ] <= 40 and ( ( 1730 <= D and D <= 1930 ) or ( 1730 <= E and E <= 1930 ) ) :
A = [ 1 ] * ( 2 * B + 1 )
A = B = C [ D ]
A , B , C = [ ] , set ( ) , set ( )
A = [ B for B in range ( 1 , C + 1 ) ]
A . V = B
# 'alert'を出力する
return A + 2 * ( project ( B , A ) - A )
A = B + int ( input ( ) )
A [ B ] . append ( ( C , D , E ) )
A [ B ] = C
return A * B + C
A . append ( complex ( B - C * D , E + C * F ) )
print ( A [ 0 : 8 ] , sep = '' )
A = 50000
# Dを1だけ増加させる
A = [ [ ] for B in range ( 8 ) ]
A = [ [ 0.0 for B in range ( C ) ] for D in range ( C ) ]
A = [ B for B in range ( 1 , 31 ) ]
A //= 10
# Cの末尾にcrossPointS2P(D,E[F],G)を追加する
A , B = [ 0.0 ] * C , [ 0.0 ] * C
A = [ [ 0 for B in range ( B + 1 ) ] for C in range ( C + 1 ) ]
print ( * sorted ( list ( set ( A ) ) ) )
A [ 0 ] = input ( ) . strip ( )
A = B [ C ] [ 0 ] * D [ C ]
A = { 1 : 6000 , 2 : 4000 , 3 : 3000 , 4 : 2000 }
A [ B ] [ 2 * C - 1 - D - B ] = E
A = '' . join ( B [ C ] )
print ( judge ( sorted ( A ) , sorted ( B . items ( ) , key = lambda x : - C [ 1 ] ) ) )
A >>= 2
A = ''
A . level = [ 0 ] * B
A = 1 + min ( B [ C - 1 ] [ D - 1 ] , B [ C ] [ D - 1 ] , B [ C - 1 ] [ D ] )
A = [ 0 , 1 , 0 , - 1 ]
print ( 2 )
A = B [ C ] [ 2 ] * D / E + B [ C ] [ 0 ]
# EのB番目のC番目を1との論理和にする
# 1をAとする
A = A [ : B ] + A [ B : C ] [ : : - 1 ] + A [ C : ]
break
A , B = '' , list ( B )
A = [ 0 ] * 32
B = int ( A )
A = [ True ] * 11
print ( A [ : : - 1 ] )
A , B , C = 0 , 90 * D , 0
A . append ( B - C )
A , B = [ 0 ] * 12 , [ 0 ] * 12
for A in range ( B , 5 ) :
F = A
# 辞書のA番目を1だけ増加させる
A = calc ( )
print ( A + 2 )
A . append ( B [ C ] [ D % len ( B [ C ] ) ] )
A = ( 3600 * B + 60 * C + D ) - ( 3600 * E + 60 * F + G )
print ( int ( 6378.1 * math . acos ( A ) + 0.5 ) )
A = bisect_left ( B , C , A ) - 1
# AのB番目のC番目のD番目をEとする
return factorial ( A ) // factorial ( A - B ) // factorial ( B )
if ( ( A [ B ] - C [ D ] ) << 1 ) == E :
unite ( A * 12 + B , C * 12 + D )
print ( 'yes' if A . connected ( B , C ) else 'no' )
A = B . pop ( 0 )
A = bisect_right ( B , C [ 2 ] , D )
A += 'L'
A , B = ord ( 'a' ) , ord ( 'z' ) + 1
A [ B ] = max ( - C [ D ] , A [ B ] ) + E [ F ]
# 偽をDとする
A , B = dijkstra ( C , D , 0 )
A -= B [ 0 ] [ 1 ]
A = A + A
A = int ( B [ C ] + B [ C + 1 ] )
# 関数処理を中断する
# Dを1だけ増加させる
A = B [ C - 1 ]
A [ 0 ] [ B // 3 ] [ B % 3 ] = 1
A = B [ 0 : ]
if A == 1 or A == 2 :
# AからBのCから1を引いた値番目を引いた値をEとする
A [ B ] [ C ] [ 7 - D ] = A [ B - 1 ] [ D ] [ C ]
A = B [ 0 ] * B [ 4 ] - B [ 3 ] * B [ 1 ]
if A [ B ] :
A [ 0 ] , A [ B ] , A [ C ] = 1 , 1 , 1
# 最初からもう一度、繰り返す
A += B [ C & 1 ] [ D ] [ E ] [ F ] & 1
# BのAから1を引いた値番目にBのAから2を引いた値番目を加えた値を1001で割った余りをBのA番目にする
A = set ( )
while len ( A ) > 0 :
print ( A , B , C , D )
dijkstra ( A , B )
A . sort ( key = lambda x : ( - B [ 0 ] , B [ 1 ] ) )
A = format ( B , '08b' )
print ( calc ( ) [ 15 ] )
for A in range ( 2 , B ) :
# 0をBとする
A = B = C = D = 0
print ( '3C' , format ( A , '02d' ) , sep = '' )
A , B , C = list ( input ( ) . split ( ) )
A += B [ 1 - ( C & 1 ) ] [ 1 ]
while A < B * B :
A = B * 60 + C
A += B [ C ] - B [ D - 1 ] - 1
A = list ( B . items ( ) )
A = [ [ B for C in range ( 1 << D ) ] for E in range ( D ) ]
A [ B ] = min ( - C [ D ] , A [ B ] ) + E [ F ]
A , B = C [ 0 ] - 1 , C [ 1 ]
A , B , C = D
A . append ( [ B , C , 0 ] )
# Cを返す
A = [ [ 0 , 1 , 2 , 3 , 4 , 5 , 6 ] , [ 0 , 2 , 6 , 3 , 4 , 1 , 5 ] , [ 0 , 4 , 2 , 1 , 6 , 5 , 3 ] , [ 0 , 3 , 2 , 6 , 1 , 5 , 4 ] , [ 0 , 5 , 1 , 3 , 4 , 6 , 2 ] ]
if A == 'xy' :
# Aを1だけ減少させる
A , B = [ 0 ] * ( C + 1 ) , 0
A [ B ] [ C ] [ D ] [ D ] += A [ B ] [ C - 1 ] [ D ] [ D ] + A [ B ] [ C - 1 ] [ E ] [ D ]
A , B = [ 0 ] * C , [ ]
A [ B ] = C - D [ 0 ] [ 2 ]
A = [ [ - 1 , - 1 ] , [ - 1 , 0 ] , [ - 1 , 1 ] , [ 0 , - 1 ] , [ 0 , 1 ] , [ 1 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] ]
A , B , C = D / E , ( F . real + G . real ) / 2 , ( F . imag + G . imag ) / 2
A . level [ B ] = A . level [ C ] + 1
# 1をFのA番目にする
if len ( A ) == 4 and A in B :
A = [ 0 ] * 1500
A [ B ] , A [ B + 1 ] = A [ B + 1 ] , A [ B ]
A = max ( A , B * ( C - 1 - D ) )
A = list ( map ( int , A . split ( ) ) )
A //= B
B [ A ] = 0
A += 1
A [ B ] [ C ] = 1
# act(A[B][0],C)
A = B = - 1
# Dをcalc(A)だけ増加させる
move ( A [ B ] [ C ] )
# 繰り返しを中断する
# AのCからBを引いた値番目にDを加えた値をAのB番目にする
A . par = [ - 1 ] * B
A . sort ( key = lambda x : ( - B [ 2 ] , B [ 3 ] , B [ 0 ] ) )
if A * A + B * B == C * C :
A = len ( B [ 0 ] )
# DをCとする
A = [ [ 0 for B in range ( 3 ) ] for C in range ( 101 ) ]
print ( 'OK' if A + B <= 150 else 'NG' )
A |= len ( B ) > 1
# DをAからCを引いた値だけ増加させる
# Cに(BのA番目、BのAに1を加えた値番目)の組を追加した集まり
A [ B ] [ C | ( 1 << B ) ] = min ( A [ B ] [ C | ( 1 << B ) ] , A [ D ] [ C ] + E [ F [ B ] ] [ F [ D ] ] )
A = int ( A )
# Aを展開してを出力する
# 最初からもう一度、繰り返す
A . iter = [ 0 ] * A . V
if A > 0 :
A = [ [ B for C in range ( D + 2 ) ] for E in range ( 3 ) ]
# 1をDの1番目のCに1を加えた値を1だけ右シフトした値番目にする
A = len ( B [ 1 ] )
A = '>'(=+)#(=+)~$'
# BのA番目をCとする
A , B = [ 1 ] * 16 , [ 0 ] * 16
print ( calc_area ( A ) )
# Cに1を加えた値をBとする
A = B [ C ] [ 1 ] * D [ C ] + B [ C ] [ 2 ]
print ( 'Hello World' )
A = sum ( B ) - sum ( C )
C [ A ] = int ( B [ 2 ] )
B = A
# AのC番目にDを加えた値をAのBからCを引いた値番目にする
A = cross ( B - C , D [ 1 ] - C )
A [ 1 - ( B & 1 ) ] += str ( C ) + A [ B & 1 ] [ D - 1 ]
# CのAから1を引いた値番目に入力された文字列の整数値を加えた値をCのA番目にする
# DをAからBのCに1を加えた値番目を引いた値だけ増加させる
A = 3 - A
A [ B % 3 ] [ C + 1 ] = min ( A [ B % 3 ] [ C + 1 ] , A [ B // 3 ] [ C ] + D [ B // 3 ] [ B % 3 ] [ E [ 0 ] [ C ] ] [ E [ 1 ] [ C ] ] + 1 )
A = [ B , B + ( C - D ) * complex ( 0 , 1 ) ]
A , B , C = D . pop ( )
import sys
A , B = A + 1 , 2 * ( C * D )
for A in range ( 9 ) :
print ( format ( A [ 0 ] . real + B , '.3f' ) , format ( A [ 0 ] . imag + B , '.3f' ) , format ( A [ 1 ] + B , '.3f' ) )
print ( LIS ( A ) )
while 1 :
A , B = list ( map ( int , input ( ) . split ( ':' ) ) )
print ( 1 if A [ B ] == C else 0 )
A = 10e8
A = B . root ( C )
A = [ 0 ] * 6
if A >= 1 :
A = B [ C ] - B [ D - 1 ]
# 繰り返しを中断する
# 最初からもう一度、繰り返す
for A in range ( 20 ) :
A += '('
A = A + ( ( A + 1 ) >> 1 )
return 0
A [ 0 ] [ 0 ] = 0
# Aを1だけ減少させる
A = B [ C ] - D - 1
A [ B + 1 ] = A [ B ] + ( C [ B ] == 'I' )
if ( A [ 1 ] & 1 ) and ( A [ 2 ] & 1 ) :
A [ B ] += 1
for A in range ( 47 ) :
A [ B ] [ C ] += 1
A = B [ 0 ] = int ( input ( ) )
if A >= 0 and B >= 0 and A <= 9 and B <= 9 and C [ D ] [ A ] [ B ] :
# Aを1だけ増加させる
A [ B ] . append ( C )
[ A . append ( B ) for B in range ( 0 , C + 1 ) ]
# 文字コードAに'A'の順序数を加えた値の文字をBの文字コードAに3を加えた値に'A'の順序数を加えた値の文字番目にする
for A in range ( 997 , B , 2 ) :
A [ 1 ] = False
while A [ 99 ] == 0 :
A = [ [ 0 for B in range ( C ) ] for D in range ( E ) ]
A = 0.00001 * B
for A in range ( 8 ) :
for A in range ( B - 1 , C - 2 , - 1 ) :
return - 1
A += int ( input ( ) )
A [ B ] = [ C for C in range ( D ) ]
A [ B + 1 ] = A [ B ] = C
return 'null'
A , B = 0 , 3
A . heappush ( B , ( 0 , C , 0 ) )
while A != [ ] :
A = B [ C // 2 : ]
# BをAの0を取り出した値だけ増加させる
A = sum ( B [ C : D ] )
A , B = list ( input ( ) . split ( '=' ) )
# -1を出力する
A = get ( B )
# Aに1を加えた値、Dに1を加えた値をA、Dとする
A = [ 0 ] * 10
A [ B ] [ C ] = A [ C ] [ B ] = int ( 2 * D * E ** 0.5 )
A *= 1 + B
A = False
A [ B + 1 ] [ C - 1 ] += 1
A , B = factor ( B )
print ( abs ( A - B ) )
A , B = factor ( )
A = B + C
A = B * C + D * E
A . heappush ( B , ( 0 , C ) )
for A in range ( B - 3 , B + 4 ) :
A = [ 1 ] * 5
# Cを1だけ減少させる
A = 360 - B [ C ]
A , B = [ 0 ] * ( C + 1 ) , [ 0 ] * ( C + 1 )
A = B [ 1 ] - B [ 0 ]
for A in range ( 225 , B + 1 , 2 ) :
# Dを1だけ増加させる
A = int ( input ( ) ) + int ( input ( ) )
A [ B ] += C [ D ]
A = 1
A = ( ( A // 2 - 1 ) // 50 + 1 ) * 50
A = [ [ '' for B in range ( 7 ) ] for C in range ( D ) ]
# 真を返す
A , B = C [ D ] , E [ F ]
A = ( B ** 2 + C ** 2 ) ** 0.5
for A in range ( B - 1 ) :
A , B = [ ] , { }
for A in range ( 1 , B + 1 ) :
A = B + ( C << 18 )
# Dの末尾にAの文字列を追加する
# Cを1だけ減少させる
A , B , C , D = E . split ( )
if A < B [ C ] and D < E [ C ] :
print ( A [ B ] - C )
A . append ( [ B , C , 0 , D ] )
A = min ( A , calc ( B ) + 1 )
A = B // C
A . heappush ( B , ( - C , D ) )
for A in range ( B , B + 1001 ) :
if A == B [ C ] :
A = max ( B - C [ D ] , E [ D ] - F )
A = [ [ 0 for B in range ( 6 ) ] for C in range ( 6 ) ]
A [ int ( input ( ) ) ] += 1
return A . real * B . imag - A . imag * B . real
A = D [ 0 ] if B + 1 == C else D [ B + 1 ]
A += str ( B // C )
A [ B ] = 2
while A [ B ] >= '0' and A [ B ] <= '9' :
A = B [ 3 ]
# 偽をCのA番目にする
# Cを1だけ増加させる
print ( A [ 1 ] , A [ 0 ] , sep = '\n' )
# 最初からもう一度、繰り返す
print ( 'YES' if A >= 4 else 'NO' )
A = [ [ '' for B in range ( 5 ) ] for C in range ( 8 ) ]
for A in range ( B . iter [ C ] , len ( B . edge [ C ] ) ) :
A += C [ B ] if B in C else B
A , B = [ 0 ] * 100005 , [ 0 ] * 100005
A . append ( 1000000001 )
# D、BをA、Cとする
A , B , C , D = map ( float , input ( ) . split ( ) )
print ( * list ( str ( A [ B ] ) ) )
for A in range ( B , C + 1 ) :
A [ 0 ] [ B ] = list ( input ( ) )
# 繰り返しを中断する
print ( A // 5 )
A = B [ 2 ] * B [ 4 ] - B [ 5 ] * B [ 1 ]
A = gcd ( B , C )
A = ( 31 << 9 ) + ( 5 << 5 ) + 1
for A in range ( 0 , len ( B ) , 2 ) :
A = max ( A , B [ C ] + B [ D ] )
A = [ - 1 ] * B
A = min ( A , B )
combi ( A , 20 )
# Aを1だけ増加させる
for A in range ( 7 ) :
if A [ 0 ] == 1 :
A , B = [ C ] * ( D + 1 ) , [ 0 ] * ( D + 1 )
A , B = int ( A ) , int ( B )
if A [ B - 1 ] [ C ] [ D ] < E :
A -= 1
A = max ( B )
A = B [ C + 1 ]
A , B = [ ] , [ ]
print ( A [ B ] [ C ] + 1 if A [ B ] [ C ] < D else 'NA' )
if A != B [ C ] [ 0 ] :
A , B = A + 2 , B - 2
A , B = [ 0 ] * 8 , [ 0 ] * 8
if A [ B ] >= C :
A += 2 * B
A = B = C = 1
print ( A , B , C )
A = 1 << B
if A in [ '+' , '-' , '*' , '/' ] :
# 'A'を出力する
return - 1 if A <= 0 else 1
A = B [ C ] [ D ] + E + B [ F ] [ G ]
A = calc ( B [ C ] [ 2 ] ) if B [ C ] [ 2 ] > 0 else 1
print ( 'YES' if A else 'NO' )
print ( * A [ : B ] )
A += ','
A , B = d2t ( A ) , d2t ( B )
while A :
A [ B ] = - 1
A , B = int ( input ( ) ) - 1 , int ( input ( ) )
check ( A , B [ C ] [ 0 ] )
print ( 'OK' if A ^ B else 'NG' )
if A < 0 or A >= 3 or B < 0 or B >= 3 or 3 * A + B == C :
A = B [ 1 ]
# CをAの整数値だけ増加させる
A = bisect_left ( B , int ( C [ 1 ] ) )
while A != 0 :
A = 'D'
if A [ B ] > C :
A = int ( ( B * C ) ** 0.5 )
# C、DのA番目の最小値をCとする
# B、D、A、CをA、C、B、Dとする
A = input ( ) . strip ( )
for A in range ( B + 1 , C + 1 ) :
# act(A[B][1],C)
print ( ut2jd ( A , B , C ) - ut2jd ( D , E , F ) )
pushBack ( A + B , A + C )
print ( int ( input ( ) ) ** 3 )
A = B * 10000 + C * 100 + D
A = 3.1415926535897932384626433832795
A . id [ B ] = C
A [ 0 ] = B [ 0 ] = int ( input ( ) )
A [ 0 ] [ 2 ] = 1
A = 0x7fffffff
if A == 'R' :
A = 10
for A in range ( B - 1 , 1 , - 1 ) :
A = calc ( B [ C ] [ 3 ] ) if B [ C ] [ 3 ] > 0 else 1
A , B = C [ 1 ] , C [ 2 ]
# Gを1だけ増加させる
for A , B , C in D [ E ] :
# AのBに1を加えた値番目をCだけ減少させる
return len ( A . items )
A [ B & 1 ] = 1
A = [ 'A' , 'B' , 'AB' , 'O' ]
A , B = 0 , B + 1
A = [ [ 0 for B in range ( 102 ) ] for C in range ( 102 ) ]
A = ( '0' , '1' , '2' , '3' , '5' , '7' , '8' , '9' )
A = list ( sorted ( B . items ( ) , key = lambda x : A [ 1 ] ) )
print ( ( A + B ) << 3 )
print ( '{0:.3f} {1:.3f}' . format ( A / B + C , D / B + C ) )
A , B , C = B , C , 1
A , B = C [ D ] , E [ D ]
A = [ 0 , 1 , 2 , 0 , 1 , 2 , 0 , 1 , 2 ]
A = '' . join ( sorted ( B ) )
A = [ B ** 3 for B in range ( 1111 ) ]
A [ B ] = A [ B - 1 ] - C [ B - 1 ]
A = [ input ( ) . strip ( ) for B in range ( C ) ]
A = [ [ 0 for B in range ( C + 2 ) ] for D in range ( 2 ) ]
return [ True , A ]
print ( len ( A ) )
for A in range ( B - C ) :
A = 0
A , B = map ( int , C . split ( ) )
A , B = get ( C ) , get ( D )
A [ B ] [ C ] [ D ] [ E ] |= ( 1 << ( F * 5 + G ) )
# Bの1番目の1番目が2と等しいとき'full house'、そうでなければ'three card'を返す
A = [ 0 ] * ( B + 1 )
print ( A [ 0 ] [ B ] , A [ 1 ] [ B ] )
if A [ 0 ] == 'FORWARD' :
if A [ B ] > C [ D ] :
parse ( A , B [ C ] [ 1 ] )
A = [ 0 , 0 , 1 , 4 , 10 , 20 , 35 , 56 , 84 , 120 , 165 ]
A . push ( int ( B ) )
A = B | ( C << ( D * 3 ) ) | ( E << ( F - 1 ) * 3 )
A = 50
# AのB番目からAのBから1を引いた値番目を引いた値をCとする
B [ A ] = 1
A = 32770
for A in range ( int ( input ( ) ) ) :
A = A [ : B ] + C [ D - B : ] + C [ : D - B ] + A [ E : ]
# '#'をCのD番目のA番目にする
A = [ [ 0 for B in range ( C ) ] for D in range ( C ) ]
while A < len ( B ) :
# BをAから10を引いた値に125を掛けた値だけ増加させる
A = A * 2 - B * B
# Cを1だけ増加させる
A = [ True for B in range ( C + 2 ) ]
A += ( B [ C ] . real - B [ C + 1 ] . real ) * ( B [ C ] . imag + B [ C + 1 ] . imag )
print ( judge ( A , B , C ) )
A , B = [ 0 ] * 202 , [ 0 ] * 202
while A < len ( B [ C ] ) and A < D :
return ( A + A // 4 - A // 100 + A // 400 + ( 13 * B + 8 ) // 5 + C ) % 7
A = ( B + C ) % 4
print ( A . replace ( '_____' , 'peach' ) )
A = 195 * B
if A [ 0 ] == '(' :
A = B * C
A , B , C = 3 , 4 , 1
A , B , C , D = ord ( '0' ) , ord ( '9' ) + 1 , ord ( 'a' ) , ord ( 'z' ) + 1
print ( 'myon' * calc ( A ) )
rec ( 0 , 0 )
if A [ B ] [ C - 2 ] == '#' or A [ B ] [ C - 1 ] == '#' or A [ B - 1 ] [ C - 1 ] == '#' :
# AのBから1を引いた値番目の2番目をAのB番目の2番目にする
print ( A . replace ( 'Hoshino' , 'Hoshina' ) )
A = min ( B )
if A [ 0 ] == 'IN' :
A = re . match ( B , C )
# 最初からもう一度、繰り返す
for A in range ( 1 , 100 ) :
print ( A * B [ C ] )
A = B + C - D
print ( A [ B ] [ C ] )
while A <= B :
A [ B ] = C [ ord ( D [ B ] ) - ord ( 'a' ) + E ]
# 繰り返しを中断する
A , B , C = D [ 0 ] , D [ 1 ] , E [ 0 ]
if abs ( A - B ) < C :
print ( A + 1 )
print ( A [ 5 * B ] [ C ] )
print ( get ( A ) )
A = B // C [ D ] * E [ D ] + ( B % C [ D ] ) // F [ D ] * G [ D ]
A = sorted ( B . items ( ) , key = lambda x : C [ 1 ] , reverse = True )
A [ B ] [ B ] = 0
A , B , C = list ( input ( ) . split ( ',' ) )
A = ( B == 0 or B == 2 )
# Dの補数をDとする
A = [ '' ] * 2
# 2をEとする
# BをAの整数値だけ増加させる
for A in range ( 0 , 10 ) :
print ( A - 2 * B )
A += shortpath ( B , C , D , E )
if A <= 160 and B <= 25 :
