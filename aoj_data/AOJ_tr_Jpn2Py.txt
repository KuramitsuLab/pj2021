BLEU score = 90.58
epoch = 91
image = 4

| Train Loss: 0.037 | Train PPL:   1.038 |
| Val. Loss: 0.100 | Val. PPL:   1.106 |
| Test Loss: 0.100 | Test PPL:   1.106 |

0
src = read _ list ( int ) を 展開 し 、 それぞれ A 、 B とする
trg = A , B = read_list ( int )
rst = A , B = <unk> ( int ( A ) ) <eos>
1
src = D の 各要素 を C とし 、 C の 整数値 の 列 を A の B の 整数値 番 目 にする
trg = A [ int ( B ) ] = [ int ( C ) for C in D ]
rst = A [ int ( B ) ] = [ int ( C ) for C in D ] <eos>
2
src = fibonacci ( 3 + 2 * B , C ) に fibonacci ( D + 1 -2 * B , C ) を 掛 け た 値を C で 割 った 余 り を A とする
trg = A = fibonacci ( 3 + 2 * B , C ) * fibonacci ( D + 1 - 2 * B , C ) % C
rst = A = fibonacci ( 3 + 2 * B , C ) * fibonacci ( D + 1 - 2 * B , C ) % C <eos>
3
src = 1 から 6 未 満 までの 数 列 を 順に A として 、 繰り返す
trg = for A in range ( 1 , 6 ) :
rst = for A in range ( 1 , 6 ) : <eos>
4
src = A 内の B の 1 番目の 出現 回数 の とき 、
trg = if A . count ( B [ 1 ] ) :
rst = if A . count ( B [ 1 ] ) : <eos>
5
src = B を 100 で 割 った 商 に C を 30 で 割 った 商 に 5 を 掛 け た 値 を加えた 値を A とする
trg = A = B // 100 + C // 30 * 5
rst = A = B // 100 + C // 30 * 5 <eos>
6
src = A の 、 つまり 先頭 から B に 1 を加えた 値 までの 部分 列 に A の B に 2 を加えた 値 から 、 つまり 末 尾 までの 部分 列 を加えた 値を A とする
trg = A = A [ : B + 1 ] + A [ B + 2 : ]
rst = A = A [ : B + 1 ] + A [ B + 2 : ] <eos>
7
src = A の B の 1 番 目 番 目 が 、 つまり 空 列 と 等 しい とき 、
trg = if A [ B [ 1 ] ] == [ ] :
rst = if A [ B [ 1 ] ] == [ ] : <eos>
8
src = ネ イ ピ ア 数の 1 番 目 が 0 より 大きい とき 、
trg = if e [ 1 ] > 0 :
rst = if e [ 1 ] > 0 : <eos>
9
src = B から 30 を 引 いた 値を 2 で 割 った 商 を A とする
trg = A = ( B - 30 ) // 2
rst = A = ( B - 30 ) // 2 <eos>
10
src = jump _ candidate ( B ) を A とする
trg = A = jump_candidate ( B )
rst = A = <unk> ( B ) <eos>
11
src = A に 1 に B / 100 を加えた 値を 掛 け た 値に 0 . 0000 1 を加えた 値の 切り 捨 て 整数値 が C と 等 しく ない とき 、
trg = if floor ( A * ( 1 + B / 100 ) + 0.00001 ) != C :
rst = if floor ( A * ( 1 + B / 100 ) + 0.00001 ) != ( C ) : <eos>
12
src = 100 、 0.0 を出力する
trg = print ( 100 , 0.0 )
rst = print ( 100 , 0.0 ) <eos>
13
src = A 、 B 、 C を出力する
trg = print ( A , B , C )
rst = print ( A , B , C ) <eos>
14
src = 0 から D の長さ 未 満 までの 数 列 の 各要素 を B とし 、 0 から C の長さ 未 満 までの 数 列 の 各要素 を B とし 、 0 の 列 の 列 を A とする
trg = A = [ [ 0 for B in range ( len ( C ) ) ] for B in range ( len ( D ) ) ]
rst = A = [ [ 0 for B in range ( len ( C ) ) ] for B in range ( len ( D ) ) ] <eos>
15
src = ( ( B ) からなる 列 の 0 から C の n 未 満 までの 数 列 の 各要素 を D とし 、 C の n の 列 回 分 の 列 ) からなる 列 を A とする
trg = A = [ [ B ] * [ C . n for D in range ( C . n ) ] ]
rst = A = [ [ B ] * [ C . n for D in range ( C . n ) ] ] <eos>
16
src = intersection 01 ( 0 , 0 , B , C , D , E , F ) を A とする
trg = A = intersection01 ( 0 , 0 , B , C , D , E , F )
rst = A = circle_intersection ( 0 , 0 , B , C , D , E , F ) <eos>
17
src = A の 2 番 目 を 2 だけ 減少 させる
trg = A [ 2 ] -= 2
rst = A [ 2 ] -= 2 <eos>
18
src = A が 1 と 等 しい 間 、 次 を 繰り返す
trg = while A == 1 :
rst = while A == 1 : <eos>
19
src = ( A の B の 1 番 目 番 目 、 B の先頭 ) の 組 が ( A の C の 1 番 目 番 目 、 C の先頭 ) の 組 より 小さい とき 、
trg = if ( A [ B [ 1 ] ] , B [ 0 ] ) < ( A [ C [ 1 ] ] , C [ 0 ] ) :
rst = if ( A [ B [ 1 ] ] , B [ 0 ] ) < ( A [ C [ 1 ] ] , C [ 0 ] ) : <eos>
20
src = A の B 番目の c の先頭 が -1 と 等 しく ない とき 、
trg = if A [ B ] . c [ 0 ] != - 1 :
rst = if A [ B ] . c [ 0 ] != - 1 : <eos>
21
src = f ( A , B )
trg = f ( A , B )
rst = f ( A , B ) <eos>
22
src = ( -1 ) からなる 列 の 100 1 回 分 の 列 を A とする
trg = A = [ - 1 ] * 1001
rst = A = [ - 1 ] * 1001 <eos>
23
src = calc ( A - 1, B - C , D , E ) に [MASK] を加えた 値
trg = + calc ( A - 1 , B - C , D , E )
rst = + calc ( A - 1 , B - C , D , E ) <eos>
24
src = A . _ is _ red ( B . left ) の とき 、
trg = if A . _is_red ( B . left ) :
rst = if A . _is_red ( B . left ) : <eos>
25
src = D が E と 等 しい かどうか を A の B 番目の C 番 目 にする
trg = A [ B ] [ C ] = ( D == E )
rst = A [ B ] [ C ] = ( D == E ) <eos>
26
src = A の A の長さ に 0 から D 未 満 までの 数 列 の 各要素 を C とし 、 B の 列 を挿入する
trg = A . insert ( len ( A ) , [ B for C in range ( D ) ] )
rst = A . insert ( len ( A ) , [ B for C in range ( D ) ] ) <eos>
27
src = heappush ( A , [ B + C , 1, D , [ E , F ]])
trg = heappush ( A , [ B + C , 1 , D , [ E , F ] ] )
rst = heappush ( A , [ B + C , 1 , D , [ E , F ] ] ) <eos>
28
src = SPFA ( B , C , D ) を A とする
trg = A = SPFA ( B , C , D )
rst = A = <unk> ( B , C , D ) <eos>
29
src = rotate _ dice ( A , e ) を A とする
trg = A = rotate_dice ( A , e )
rst = A = rotate_dice ( A , e ) <eos>
30
src = B を A の r にする
trg = A . r = B
rst = A . r = B <eos>
31
src = root ( D ) を C とする を A の B 番 目 にする
trg = A [ B ] = C = root ( D )
rst = A [ B ] = C = root ( D ) <eos>
32
src = 空白 文字 を 間 に 入れ て sorted ( B [ max ( B . keys () ) ] ) の先頭 の 文字列 の 各要素 を A とし 、 A の 列 を 連結 した 文字列 を出力する
trg = print ( ' ' . join ( [ A for A in str ( sorted ( B [ max ( B . keys ( ) ) ] ) [ 0 ] ) ] ) )
rst = print ( ' ' . join ( [ str ( A ) for A in sorted ( B . f_keys [ 0 ] ) for B in sorted ( B . keys ( ) ) ] ) ) <eos>
33
src = B の集合 と C の集合 の 排 他 論理 和 の リストを A とする
trg = A = list ( set ( B ) ^ set ( C ) )
rst = A = list ( set ( B ) ^ set ( C ) ) <eos>
34
src = A が B の C 番 目 より 小さく かつ A が B の D 番 目 より 小さい とき 、
trg = if A < B [ C ] and A < B [ D ] :
rst = if A < B [ C ] and A < B [ D ] : <eos>
35
src = A が B に C を加えた 値 以下の とき 、
trg = if A <= B + C :
rst = if A <= B + C : <eos>
36
src = dfs ( A [ 1 ] , B + 1 )
trg = dfs ( A [ 1 ] , B + 1 )
rst = dfs ( A [ 1 ] , B + 1 ) <eos>
37
src = B に C を 掛 け た 値に 2 を 掛 け た 値に C の 2 乗 を加えた 値を A とする
trg = A = B * C * 2 + C ** 2
rst = A = B * C * 2 + C ** 2 <eos>
38
src = matmul ( A , B , C , D )
trg = matmul ( A , B , C , D )
rst = matmul ( A , B , C , D ) <eos>
39
src = dfs ( B , C , D , E , float ( F ) ) を A とする
trg = A = dfs ( B , C , D , E , float ( F ) )
rst = A = dfs ( B , C , D , E , float ( F ) ) <eos>
40
src = A を 5 で 割 った 商 を A とする
trg = A = A // 5
rst = A = A // 5 <eos>
41
src = A を B が C と 等 しい とき D 、 そうでなければ E から D を 引 いた 値 だけ 増加 させる
trg = A += D if B == C else E - D
rst = A += D if B == C else E - D <eos>
42
src = A の B に 1 を加えた 値 番目の C から D の B 番 目 を 引 いた 値 番 目 を A の B 番目の C 番 目 だけ 増加 させる
trg = A [ B + 1 ] [ C - D [ B ] ] += A [ B ] [ C ]
rst = A [ B + 1 ] [ C - D [ B ] ] += A [ B ] [ C ] <eos>
43
src = A を 書式 として B の C 番目の 先頭 で 整 形 した 文字列 を出力する
trg = print ( A . format ( B [ C ] [ 0 ] ) )
rst = print ( A . format ( B [ C ] [ 0 ] ) ) <eos>
44
src = A が B の id の A 番 目 と 等 しく ない 間 、 次 を 繰り返す
trg = while A != B . id [ A ] :
rst = while A != B . id [ A ] : <eos>
45
src = cross ( B , ( C - D , E - F ) ) の 絶対 値を length ( B ) で 割 った 値を A とする
trg = A = abs ( cross ( B , ( C - D , E - F ) ) ) / length ( B )
rst = A = abs ( cross ( B , ( C - D , E - F ) ) ) / length ( B ) <eos>
46
src = A の B 番 目 が C 以上 かつ D が 0 より 大きい とき 、
trg = if ( A [ B ] >= C ) and ( D > 0 ) :
rst = if A [ B ] >= C and D > 0 : <eos>
47
src = A を A を 10 で 割 った 商 に 10 を 掛 け た 値 だけ 減少 させる
trg = A -= A // 10 * 10
rst = A -= ( A // 10 ) * 10 <eos>
48
src = C を A の hldid の B 番 目 にする
trg = A . hldid [ B ] = C
rst = A . hldid [ B ] = C <eos>
49
src = 6 5 から 6 5 に 26 を加えた 値 未 満 までの 数 列 の 各要素 を B とし 、 、 つまり 文字コード B の 文字 の 列 を A とする
trg = A = [ chr ( B ) for B in range ( 65 , 65 + 26 ) ]
rst = A = [ chr ( B ) for B in range ( 65 , 65 + 26 ) ] <eos>
50
src = A の先頭 から B を 探 して 見つかった 位置 の とき 、
trg = if A . find ( B ) :
rst = if A . find ( B ) : <eos>
51
src = ( A 、 B ) からなる 列 の f ( C , D ) または f ( C [ 1 : ] , D ) 番 目 を出力する
trg = print ( [ A , B ] [ f ( C , D ) or f ( C [ 1 : ] , D ) ] )
rst = print ( [ A , B ] [ f ( C , D ) or f ( C [ 1 : ] , D ) ] ) <eos>
52
src = ( -1 ) からなる 列 の 50 に 50 を 掛 け た 値 回 分 の 列 を A とする
trg = A = [ - 1 ] * ( 50 * 50 )
rst = A = [ - 1 ] * 50 <eos>
53
src = A から B を 引 いた 値 から C を 引 いた 値を D から 2 を 引 いた 値 で 割 った 商 を出力する
trg = print ( ( A - B - C ) // ( D - 2 ) )
rst = print ( ( A - B - C ) // ( D - 2 ) ) <eos>
54
src = A の B 番 目 が C の WHITE と 等 しい とき 、
trg = if A [ B ] == C . WHITE :
rst = if A [ B ] == C . WHITE : <eos>
55
src = B を A の size にする
trg = A . size = B
rst = A . size = B <eos>
56
src = os . path の A 番 目 を B だけ 増加 させる
trg = path [ A ] += B
rst = path [ A ] += B <eos>
57
src = readline () の 両 端 から 空白 改行 を取り 除 いた 文字列を 空白 で 分割 した 字句 列 を 展開 し 、 それぞれ A 、 B 、 C 、 D とする
trg = A , B , C , D = readline ( ) . strip ( ) . split ( )
rst = A , B , C , D = readline ( ) . strip ( ) . split ( ) <eos>
58
src = A の B の 1 番 目 番 目 を 1 だけ 増加 させる
trg = A [ B [ 1 ] ] += 1
rst = A [ B [ 1 ] ] += 1 <eos>
59
src = [MASK] の 辞書 カウンタ を B とする を A とする
trg = A = B = Counter ( )
rst = A = B = Counter ( ) <eos>
60
src = A 、 B から 19 25 を 引 いた 値 、 C 、 D を出力する
trg = print ( A , B - 1925 , C , D )
rst = print ( A , B - 1925 , C , D ) <eos>
61
src = A を 2 と の 論理 和 にする
trg = A |= 2
rst = A |= 2 <eos>
62
src = sys . setrecursionlimit ( 400 0 )
trg = sys . setrecursionlimit ( 4000 )
rst = sys . setrecursionlimit ( 4000 ) <eos>
63
src = equal _ range ( C , D ) を 展開 し 、 それぞれ A 、 B とする
trg = A , B = equal_range ( C , D )
rst = A , B = extended_gcd ( C , D ) <eos>
64
src = A の 0 番 目 を A の 1 番 目 で 割 った 余 り が 0 と 等 しい とき 、
trg = if A [ 0 ] % A [ 1 ] == 0 :
rst = if A [ 0 ] % A [ 1 ] == 0 : <eos>
65
src = 0 から 2 未 満 までの 数 列 の 各要素 を B とし 、 d [ i ] ( A [ B ] , C ) の 列 を A とする
trg = A = [ d[i] ( A [ B ] , C ) for B in range ( 2 ) ]
rst = A = [ <unk> ( A [ B ] , C ) for B in range ( 2 ) ] <eos>
66
src = statistics モジュール を用いる
trg = import statistics
rst = import <unk> <eos>
67
src = A の 2 に B を 掛 け た 値に 1 を加えた 値 番 目 を C だけ 増加 させる
trg = A [ 2 * B + 1 ] += C
rst = A [ 2 * B + 1 ] += C <eos>
68
src = C の D から 1 を 引 いた 値 番目の 末 尾 を 展開 し 、 それぞれ A 、 B とする
trg = A , B = C [ D - 1 ] [ - 1 ]
rst = A , B = C [ D - 1 ] [ - 1 ] <eos>
69
src = B に 12 から A の長さ を 引 いた 値に A を加えた 値を 掛 け た 値を A とする
trg = A = B * ( 12 - len ( A ) ) + A
rst = A = B * ( 12 - len ( A ) ) + A <eos>
70
src = 0 から D 未 満 までの 数 列 の 各要素 を C とし 、 B の C 番目の 総 和 の 列 を A とする
trg = A = [ sum ( B [ C ] ) for C in range ( D ) ]
rst = A = sum ( [ B [ C ] for C in range ( D ) ] ) <eos>
71
src = check ( A , B ) でない とき 、
trg = if not check ( A , B ) :
rst = if not check ( A , B ) : <eos>
72
src = B の 各要素 を A とし 、 A が C 以上の とき の A の 列 の長さ が C 以上の とき 、
trg = if len ( [ A for A in B if A >= C ] ) >= C :
rst = if len ( [ A for A in B if A >= C ] ) >= C : <eos>
73
src = B の C に 1 を加えた 値を D で 割 った 余 り 番 目 から E を 引 いた 値を A とする
trg = A = B [ ( C + 1 ) % D ] - E
rst = A = B [ ( C + 1 ) % D ] - E <eos>
74
src = B の長さ に 1 を加えた 値を A とする
trg = A = len ( B ) + 1
rst = A = len ( B ) + 1 <eos>
75
src = A が 0 と 等 しく かつ B の C 番 目 が 、 つまり 偽 と 等 しい とき 、
trg = if A == 0 and B [ C ] == False :
rst = if A == 0 and B [ C ] == False : <eos>
76
src = A の B の 組 番 目 を 1 だけ 増加 させる
trg = A [ tuple ( B ) ] += 1
rst = A [ tuple ( B ) ] += 1 <eos>
77
src = A の 末 尾 に B の prev の val を追加する
trg = A . append ( B . prev . val )
rst = A . append ( B . val . prev ) <eos>
78
src = A が B の tail と 等 しく ない とき 、
trg = if A != B . tail :
rst = if A != B . tail : <eos>
79
src = C の 各要素 を B とし 、 B の 3 乗 の 列 の 総 和 の 1 を 3 で 割 った 値 乗 を A とする
trg = A = sum ( [ B ** 3 for B in C ] ) ** ( 1 / 3 )
rst = A = sum ( [ B ** 3 for B in C ] ) ** ( 1 / 3 ) <eos>
80
src = A の B から 8 を 引 いた 値 番 目 かつ A の B から 6 を 引 いた 値 番 目 かつ A の B から 2 を 引 いた 値 番 目 かつ A の B 番目の とき 、
trg = if A [ B - 8 ] and A [ B - 6 ] and A [ B - 2 ] and A [ B ] :
rst = if A [ B - 8 ] and A [ B - 6 ] and A [ B - 2 ] : <eos>
81
src = A の B から 3 を 引 いた 値 番 目 を A の B から 1 を 引 いた 値 番 目 にする
trg = A [ B - 1 ] = A [ B - 3 ]
rst = A [ B - 1 ] = A [ B - 3 ] <eos>
82
src = A の 各要素 を B とし 、 、 つまり 空白 文字 を 間 に 入れ て B の 各要素 に 整数 を適用した 列 を 連結 した 文字列 の 列 を A とする
trg = A = ( [ ' ' . join ( map ( str , B ) ) for B in A ] )
rst = A = ( [ ' ' . join ( map ( str , B ) ) for B in A ] ) <eos>
83
src = A の D の C 番 目 に 1 を加えた 値を A の D の B 番 目 にする
trg = A . D [ B ] = A . D [ C ] + 1
rst = A . D [ B ] = A . D [ C ] + 1 <eos>
84
src = 0 を A の ms の B 番 目 にする
trg = A . ms [ B ] = 0
rst = A . ms [ B ] = 0 <eos>
85
src = A に 1988 を加えた 値 を出力する
trg = print ( A + 1988 )
rst = print ( A + 1988 ) <eos>
86
src = _ solve ( A . board , 0 , 0 ) を A の board にする
trg = A . board = _solve ( A . board , 0 , 0 )
rst = A . board = _solve ( A . board , 0 , 0 ) <eos>
87
src = ( B の 2 番 目 から 、 つまり 末 尾 までの 部分 列 、 未 定 値 、 未 定 値 ) からなる 列 を A の B の先頭 番 目 にする
trg = A [ B [ 0 ] ] = [ B [ 2 : ] , None , None ]
rst = A [ B [ 0 ] ] = [ B [ 2 : ] , None , None ] <eos>
88
src = 0 から B の graph の長さ 未 満 までの 数 列 を 順に A として 、 繰り返す
trg = for A in range ( len ( B . graph ) ) :
rst = for A in range ( len ( B . graph ) ) : <eos>
89
src = B 、 C の D 番目の 要素を それぞれ 組 にした 列 を 順に A 、 ネ イ ピ ア 数 として 、 繰り返す
trg = for A , e in zip ( B , C [ D ] ) :
rst = for A , e in zip ( B , C [ D ] ) : <eos>
90
src = 入力された 文字列を ネ イ ピ ア 数 とする
trg = e = input ( )
rst = e = input ( ) <eos>
91
src = cs ( A , 0 , B ) を出力する
trg = print ( cs ( A , 0 , B ) )
rst = print ( cs ( A , 0 , B ) ) <eos>
92
src = A が 8 より 小さい とき 、
trg = if A < 8 :
rst = if A < 8 : <eos>
93
src = A を 90 に 2 の B から 1 を 引 いた 値 乗 を 掛 け た 値 だけ 増加 させる
trg = A += 90 * 2 ** ( B - 1 )
rst = A += 90 * 2 ** ( B - 1 ) <eos>
94
src = 整数 のリスト の 各要素 を B とし 、 B の 整数値 の 列 を A とする
trg = A = [ int ( B ) for B in list ( str ) ]
rst = A = [ int ( B ) for B in list ( str ) ] <eos>
95
src = query _ add ( A , B )
trg = query_add ( A , B )
rst = <unk> ( A , B ) <eos>
96
src = A から 読み 込 んだ 一行 でない とき 、
trg = if not A . readline ( ) :
rst = if not A . readline ( ) : <eos>
97
src = A の B 番目の 先頭 を 除 いた 部分 列 を A の B 番 目 にする
trg = A [ B ] = A [ B ] [ 1 : ]
rst = A [ B ] = A [ B ] [ 1 : ] <eos>
98
src = A が B より 大きく または A が 0 以下の とき 、
trg = if A > B or A <= 0 :
rst = if A > B or A <= 0 : <eos>
99
src = ( 0 ) からなる 列 の B と 1 の 排 他 論理 和 に ( C ) からなる 列 を加えた 値に ( 0 ) からなる 列 を加えた 値に (1) からなる 列 の D 回 分 の 列 を加えた 値 回 分 の 列 を A とする
trg = A = [ 0 ] * ( B ^ 1 ) + [ C ] + [ 0 ] + [ 1 ] * D
rst = A = [ 0 ] * ( B ^ 1 ) + [ C ] + [ 0 ] * D + [ 1 ] * D <eos>
100
src = ( -1 ) からなる 列 の B に C を加えた 値に 2 を加えた 値 回 分 の 列 を A とする
trg = A = [ - 1 ] * ( B + C + 2 )
rst = A = [ - 1 ] * ( B + C + 2 ) <eos>
101
src = A を 書式 として bit ( B ) 、 空白 文字 を 間 に 入れ て B の 各要素 を C とし 、 C の 文字列 の 列 を 連結 した 文字列 で 整 形 した 文字列 を出力する
trg = print ( A . format ( bit ( B ) , ' ' . join ( [ str ( C ) for C in B ] ) ) )
rst = print ( A . format ( B ) , ' ' . join ( [ str ( C ) for C in B ] ) ) <eos>
102
src = A から 1 を 引 いた 値の 間 、 次 を 繰り返す
trg = while A - 1 :
rst = while A - 1 : <eos>
103
src = sugoroku ( A , B ) の とき C 、 そうでなければ D を出力する
trg = print ( C if sugoroku ( A , B ) else D )
rst = print ( C if <unk> ( A , B ) else D ) <eos>
104
src = D を C を B とする とする を A とする
trg = A = B = C = D
rst = A = B = C = D <eos>
105
src = le ( A , B ) かつ le ( C , B ) の とき 、
trg = if le ( A , B ) and le ( C , B ) :
rst = if <unk> ( A , B ) and <unk> ( C , B ) : <eos>
106
src = ( calc ( A , B , C ) 、 D ) の 組 を返す
trg = return ( calc ( A , B , C ) , D )
rst = return ( calc ( A , B , C ) , D ) <eos>
107
src = 改行 文字 を 間 に 入れ て C . roots () の 各要素 を B とし 、 A を 書式 として B 、 C . members ( B ) で 整 形 した 文字列 の 列 を 連結 した 文字列 を返す
trg = return '\n' . join ( [ A . format ( B , C . members ( B ) ) for B in C . roots ( ) ] )
rst = return '\n' . join ( [ str ( A . format ( B . format ( C . <unk> ( B ) , C . <unk> ( B ) ) ) for B in C . roots ( ) ] ) <eos>
108
src = B から C を 引 いた 値を 2 で 割 った 商 に 1 を加えた 値を A とする
trg = A = ( B - C ) // 2 + 1
rst = A = ( B - C ) // 2 + 1 <eos>
109
src = A の B 番目の C 番 目 が -1 と 等 しく なく かつ A の D 番目の E 番 目 が -1 と 等 しく なく なければならない
trg = assert A [ B ] [ C ] != - 1 and A [ D ] [ E ] != - 1
rst = assert A [ B ] [ C ] != - 1 and A [ D ] [ E ] != - 1 <eos>
110
src = A の 3 番 目 から 、 つまり 末 尾 までの 部分 列 に A の 、 つまり 先頭 から 3 番 目 までの 部分 列 を加えた 値を A とする
trg = A = A [ 3 : ] + A [ 0 : 3 ]
rst = A = A [ 3 : ] + A [ : 3 ] <eos>
111
src = sys . setrecursionlimit ( 2 * 10 * * 5 )
trg = sys . setrecursionlimit ( 2 * 10 ** 5 )
rst = sys . setrecursionlimit ( 2 ** 10 ) <eos>
112
src = 0 が A 以下 かどうか が 7 以下 かつ 0 が B 以下 かどうか が 7 以下 かつ C の B 番目の A 番 目 が D と 等 しい とき 、
trg = if 0 <= A <= 7 and 0 <= B <= 7 and C [ B ] [ A ] == D :
rst = if 0 <= A <= 7 and 0 <= B <= 7 and C [ B ] [ A ] == D : <eos>
113
src = A を 90 だけ 増加 させる
trg = A += 90
rst = A += 90 <eos>
114
src = A が B 以下 でない とき 、
trg = if not A <= B :
rst = if not A <= B : <eos>
115
src = A の x 座標 が 0 と 等 しい とき 、
trg = if A . x == 0 :
rst = if A . x == 0 : <eos>
116
src = B 、 0 の 最大 値 から C 、 D の 最小 値に 1 を加えた 値 未 満 までの 数 列 を 順に A として 、 繰り返す
trg = for A in range ( max ( B , 0 ) , min ( C , D ) + 1 ) :
rst = for A in range ( max ( B , 0 ) , min ( C , D ) + 1 ) : <eos>
117
src = A に B を加えた 値に C 内の A の 出現 回数 の 文字列 を加えた 値 を出力する
trg = print ( A + B + str ( C . count ( A ) ) )
rst = print ( A + B + str ( C . count ( A ) ) ) <eos>
118
src = A の 末 尾 に get _ distance _ sp ( B , C , D ) を追加する
trg = A . append ( get_distance_sp ( B , C , D ) )
rst = A . append ( <unk> ( B , C , D ) ) <eos>
119
src = B . get _ lf ( C ) を A とする
trg = A = B . get_lf ( C )
rst = A = B . <unk> ( C ) <eos>
120
src = D の B に 1 を加えた 値 から C 番 目 までの 部分 列 を A の B から 1 を 引 いた 値 から C から 2 を 引 いた 値 までの 部分 列 にする
trg = A [ B - 1 : C - 2 ] = D [ B + 1 : C ]
rst = A [ B - 1 : C - 2 ] = D [ B + 1 : C ] <eos>
121
src = 2 から D に 1 を加えた 値 未 満 までの 数 列 、 E 、 F の 要素を それぞれ 組 にした 列 を 順に A 、 B 、 C として 、 繰り返す
trg = for A , B , C in zip ( range ( 2 , D + 1 ) , E , F ) :
rst = for A , B , C in zip ( range ( 2 , D + 1 ) , E , F ) : <eos>
122
src = B の prev 、 B を A の prev 、 A の next とする
trg = A . prev , A . next = B . prev , B
rst = A . prev , A . next = B . prev , B <eos>
123
src = B の _ nodes の C 番目の A に 1 を加えた 値 から の範囲 内で の 1 と 等 しい 要素 の最初の 位置 を A とする
trg = A = B . _nodes [ C ] . index ( 1 , A + 1 )
rst = A = B . _nodes [ C ] [ A + 1 ] . index ( 1 ) <eos>
124
src = F の D に 1 を加えた 値 番 目 を E とする
trg = E = F [ D + 1 ]
rst = E = F [ D + 1 ] <eos>
125
src = A に 1 を加えた 値の 3 乗 が B 以下の 間 、 次 を 繰り返す
trg = while ( A + 1 ) ** 3 <= B :
rst = while ( A + 1 ) ** 3 <= B : <eos>
126
src = F . heappop ( G ) を 展開 し 、 それぞれ A 、 B 、 C 、 D 、 E とする
trg = A , B , C , D , E = F . heappop ( G )
rst = A , B , C , D , E = F . heappop ( G ) <eos>
127
src = A の 3 番 目 かつ prop ( A )
trg = A [ 3 ] and prop ( A )
rst = A [ 3 ] and prop ( A ) <eos>
128
src = A の 0 番 目 が 1 と 等 しく ない とき 、
trg = if A [ 0 ] != 1 :
rst = if A [ 0 ] != 1 : <eos>
129
src = dot ( B [ 1 ]- B [ 0 ] , C [ 1 ]- C [ 0 ] ) を A とする
trg = A = dot ( B [ 1 ] - B [ 0 ] , C [ 1 ] - C [ 0 ] )
rst = A = dot ( B [ 1 ] - B [ 0 ] , C [ 1 ] - C [ 0 ] ) <eos>
130
src = A の 末 尾 を 除 いた 部分 列 を A とする
trg = A = A [ : - 1 ]
rst = A = A [ : - 1 ] <eos>
131
src = 1 を A の B から 1 を 引 いた 値 番目の C の D に 2 を加えた 値 番 目 から 1 を 引 いた 値 番 目 にする
trg = A [ B - 1 ] [ C [ D + 2 ] - 1 ] = 1
rst = A [ B - 1 ] [ C [ D + 2 ] - 1 ] = 1 <eos>
132
src = A の 末 尾 に 空白 文字 を 間 に 入れ て B が C より 小さい とき B の 文字列 、 そうでなければ E の F 番目の 各要素 を B とし 、 D の 列 を 連結 した 文字列 を追加する
trg = A . append ( ' ' . join ( str ( B ) if B < C else [ D for B in E [ F ] ] ) )
rst = A . append ( ' ' . join ( B if B < C else [ D for B in E ] ) ) <eos>
133
src = 0 から 5 、 B に 1 を加えた 値の 最小 値 未 満 までの 数 列 を 順に A として 、 繰り返す
trg = for A in range ( min ( 5 , B + 1 ) ) :
rst = for A in range ( min ( 5 , B + 1 ) ) : <eos>
134
src = A を B . get _ weight ( C ) だけ 増加 させる
trg = A += B . get_weight ( C )
rst = A += B . get_weight ( C ) <eos>
135
src = readline () を 空白 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 を 展開 し 、 それぞれ A 、 B 、 C 、 D とする
trg = A , B , C , D = map ( int , readline ( ) . split ( ) )
rst = A , B , C , D = map ( int , readline ( ) . split ( ) ) <eos>
136
src = A 、 minimum _ cost ( B + 1, C , D , E - 1, F , G , H , I ) の 最小 値を A とする
trg = A = min ( A , minimum_cost ( B + 1 , C , D , E - 1 , F , G , H , I ) )
rst = A = min ( A , minimum_cost ( B + 1 , C , D , E - 1 , F , G , H , I ) ) <eos>
137
src = A を B の 1 番 目 だけ 増加 させる
trg = A += B [ 1 ]
rst = A += B [ 1 ] <eos>
138
src = A に B の C 番 目 を 掛 け た 値 から D に B の C 番 目 に E を加えた 値を 掛 け た 値を 引 いた 値を返す
trg = return A * B [ C ] - D * ( B [ C ] + E )
rst = return A * B [ C ] - D * ( B [ C ] + E ) <eos>
139
src = insert ( A [ 1 ] , A [ 2 ] )
trg = insert ( A [ 1 ] , A [ 2 ] )
rst = insert ( A [ 1 ] , A [ 2 ] ) <eos>
140
src = B を 空白 文字 で 分割 した 字句 列 を 順に A として 、 繰り返す
trg = for A in B . split ( ' ' ) :
rst = for A in B . split ( ' ' ) : <eos>
141
src = B に対応する 値 、 も し 存在 し なければ C 、 空 列 を A とする
trg = A = B . get ( C , [ ] )
rst = A = B . get ( C , ] ) <eos>
142
src = 1 を A の B 番目の C の 整数値 から 1 を 引 いた 値 番 目 にする
trg = A [ B ] [ int ( C ) - 1 ] = 1
rst = A [ B ] [ int ( C ) - 1 ] = 1 <eos>
143
src = update ( A , B [ C ] [ D ] , D , C )
trg = update ( A , B [ C ] [ D ] , D , C )
rst = update ( A , B [ C ] [ D ] , D , C ) <eos>
144
src = A を 書式 として B を C で 割 った 値に D を加えた 値 、 E を C で 割 った 値に D を加えた 値 で 整 形 した 文字列 を出力する
trg = print ( A . format ( B / C + D , E / C + D ) )
rst = print ( A . format ( B / C + D , E / C + D ) ) <eos>
145
src = A の B から 1 を 引 いた 値 番 目 を 1 だけ 減少 させる
trg = A [ B - 1 ] -= 1
rst = A [ B - 1 ] -= 1 <eos>
146
src = B に C を 掛 け た 値に D を加えた 値を A とする
trg = A = B * C + D
rst = A = B * C + D <eos>
147
src = divide ( [ A , B ] + C + [ D ] ) を返す
trg = return divide ( [ A , B ] + C + [ D ] )
rst = return divide ( [ A , B ] + C [ D ] ) <eos>
148
src = B の長さ を A の - 4 番 目 にする
trg = A [ - 4 ] = len ( B )
rst = A [ - 4 ] = len ( B ) <eos>
149
src = 0 から 17 未 満 までの 数 列 を 順に A として 、 繰り返す
trg = for A in range ( 17 ) :
rst = for A in range ( 17 ) : <eos>
150
src = A 内の B から 3 を 引 いた 値の 出現 回数 を出力する
trg = print ( A . count ( B - 3 ) )
rst = print ( A . count ( B - 3 ) ) <eos>
151
src = C の先頭 から D の先頭 を 引 いた 値 、 C の 1 番 目 から D の 1 番 目 を 引 いた 値を A 、 B とする
trg = A , B = C [ 0 ] - D [ 0 ] , C [ 1 ] - D [ 1 ]
rst = A , B = C [ 0 ] - D [ 0 ] , C [ 1 ] - D [ 1 ] <eos>
152
src = ( ( 、 つまり 未 定 値 ) からなる 列 の 0 から D に 2 を加えた 値 未 満 までの 数 列 の 各要素 を C とし 、 B に 2 を加えた 値の 列 回 分 の 列 ) からなる 列 を A とする
trg = A = [ [ None ] * [ ( B + 2 ) for C in range ( D + 2 ) ] ]
rst = A = [ [ None ] * [ ( B + 2 ) for C in range ( D + 2 ) ] ] <eos>
153
src = A の B 乗 に対する 1 _ 00 0 _ 00 0 _ 00 7 の 剰 余 を出力する
trg = print ( pow ( A , B , 1_000_000_007 ) )
rst = print ( pow ( A , B , <unk> ) % <unk> ) <eos>
154
src = _ cost ( 0 , 0 , 0 ) を 展開 し 、 それぞれ A 、 B とする
trg = A , B = _cost ( 0 , 0 , 0 )
rst = A , B = <unk> ( 0 , 0 , 0 ) <eos>
155
src = time の A 番 目 から B 番 目 までの 部分 列 の 総 和 が 0 と 等 しい とき 、
trg = if sum ( time [ A : B ] ) == 0 :
rst = if sum ( time [ A : B ] ) == 0 : <eos>
156
src = A と B の C 番目の 論理 積 が A と 等 しい とき 、
trg = if A & B [ C ] == A :
rst = if A & B [ C ] == A : <eos>
157
src = append ( A [ -1 ] + int ( input () ) )
trg = append ( A [ - 1 ] + int ( input ( ) ) )
rst = append ( A [ - 1 ] + int ( input ( ) ) ) <eos>
158
src = A から B を 引 いた 値の 絶対 値が C より 大きい とき 、
trg = if abs ( A - B ) > C :
rst = if abs ( A - B ) > C : <eos>
159
src = 0 から B 未 満 までの 数 列 の 各要素 を D とし 、 C と 1 を D だけ 左 シフト した 値の 論理 積 が 0 と 等 しい とき の D の 列 を A の B 番目の C 番 目 にする
trg = A [ B ] [ C ] = [ D for D in range ( B ) if ( C & ( 1 << D ) ) == 0 ]
rst = A [ B ] [ C ] = [ D for D in range ( B ) if C & ( 1 << D ) == 0 ] <eos>
160
src = 空文字列 を 間 に 入れ て B を ソート した 列 の 逆 順 を 連結 した 文字列 の 整数値 を A とする
trg = A = int ( '' . join ( sorted ( B ) [ : : - 1 ] ) )
rst = A = int ( '' . join ( sorted ( B ) ) [ : : - 1 ] ) <eos>
161
src = 無限 の 整数 列 を A を 10 で 割 った 値の 整数値 だけ 増加 させる
trg = count += int ( A / 10 )
rst = count += int ( A / 10 ) <eos>
162
src = A の B 番 目 から 2 を 引 いた 値が A の B に 1 を加えた 値 番 目 と 等 しい とき 、
trg = if A [ B ] - 2 == A [ B + 1 ] :
rst = if A [ B ] - 2 == A [ B + 1 ] : <eos>
163
src = B 、 C から 1 を 引 いた 値 、 D において 正規表現 A が 最初 にマッチする 位置
trg = search ( A , B , C - 1 , D )
rst = search ( A , B , C - 1 , D ) <eos>
164
src = conv _ avacus ( B ) を A とする
trg = A = conv_avacus ( B )
rst = A = <unk> ( B ) <eos>
165
src = E の C 番目の D 番 目 を A の B の C 番目の D 番 目 番目の D 番 目 にする
trg = A [ B [ C ] [ D ] ] [ D ] = E [ C ] [ D ]
rst = A [ B [ C ] [ D ] ] = E [ C ] [ D ] <eos>
166
src = under ( A , B ) 、 over ( A , B ) を出力する
trg = print ( under ( A , B ) , over ( A , B ) )
rst = print ( under ( A , B ) , <unk> ( A , B ) ) <eos>
167
src = B の C 番 目 に 2 を 掛 け た 値 から 10 を 引 いた 値に D を加えた 値を A とする
trg = A = B [ C ] * 2 - 10 + D
rst = A = B [ C ] * 2 - 10 + D <eos>
168
src = B 、 C から 1 を 引 いた 値の 総 和 を A とする
trg = A = B . sum ( C - 1 )
rst = A = B . sum ( C - 1 ) <eos>
169
src = dfs 0 ( B , C , D ) を A とする
trg = A = dfs0 ( B , C , D )
rst = A = dfs0 ( B , C , D ) <eos>
170
src = C のリスト の 各要素 を B とし 、 B の 整数値 から 1 を 引 いた 値の 列 を A とする
trg = A = [ int ( B ) - 1 for B in list ( C ) ]
rst = A = [ int ( B ) - 1 for B in list ( C ) ] <eos>
171
src = A の B に 1 を加えた 値 番 目 から A の B 番 目 を 引 いた 値が C より 大きい とき 、
trg = if A [ B + 1 ] - A [ B ] > C :
rst = if A [ B + 1 ] - A [ B ] > C : <eos>
172
src = A の -2 番 目 を出力する
trg = print ( A [ - 2 ] )
rst = print ( A [ - 2 ] ) <eos>
173
src = solve 1 ( B , C . primes ) を A とする
trg = A = solve1 ( B , C . primes )
rst = A = solve1 ( B , C . primes ) <eos>
174
src = solve ( A , B , C + 1, D )
trg = solve ( A , B , C + 1 , D )
rst = solve ( A , B , C + 1 , D ) <eos>
175
src = 現在の 日 時 が A と 等 しく ない 間 、 次 を 繰り返す
trg = while now != A :
rst = while now != A : <eos>
176
src = A の B 番目の C 番 目 が 0 より 小さい とき 、
trg = if A [ B ] [ C ] < 0 :
rst = if A [ B ] [ C ] < 0 : <eos>
177
src = A の B に 1 を加えた 値を A の長さ で 割 った 余 り 番 目 から A の B 番 目 を 引 いた 値を返す
trg = return A [ ( B + 1 ) % len ( A ) ] - A [ B ]
rst = return A [ ( B + 1 ) % len ( A ) ] - A [ B ] <eos>
178
src = ( < __ main __ . Cammaobjectat 0 x 10 9 e 5 fc 70 > ) の集合 を A とする
trg = A = { [ B ** 2 % C for B in range ( 1 , C ) ] }
rst = A = { [ B for B in range ( 1 , C + 1 ) ] } <eos>
179
src = B の N から 1 を B の N から 1 を 引 いた 値の ビット 長 だけ 左 シフト した 値 未 満 までの 数 列 を 順に A として 、 繰り返す
trg = for A in range ( B . N , 1 << ( B . N - 1 ) . bit_length ( ) ) :
rst = for A in range ( B . N , 1 << ( B . N - 1 ) . bit_length ( ) ) : <eos>
180
src = B を _ pow ( 10 , 28 ) で 割 った 商 を A とする
trg = A = B // _pow ( 10 , 28 )
rst = A = B // _pow ( 10 , 28 ) <eos>
181
src = C から D を 引 いた 値 から E を 引 いた 値に 1 を加えた 値を B とする
trg = B = C - D - E + 1
rst = B = C - D - E + 1 <eos>
182
src = ( 0 、 0 ) の 組
trg = ( 0 , 0 )
rst = ( 0 , 0 ) <eos>
183
src = ( 1 、 5 、 3 、 6 、 2 、 4 ) の 組 を A とする
trg = A = ( 1 , 5 , 3 , 6 , 2 , 4 )
rst = A = ( 1 , 5 , 3 , 6 , 2 , 4 ) <eos>
184
src = A の B から 1 を 引 いた 値 、 C から B を 引 いた 値の 最小 値 番目の D から 1 を 引 いた 値 番 目 を 1 と の 排 他 的 論理 和 にする
trg = A [ min ( B - 1 , C - B ) ] [ D - 1 ] ^= 1
rst = A [ B - 1 , min ( C - B ) ] [ D - 1 ] ^= 1 <eos>
185
src = A の death _ list の 末 尾 に ( B 、 C 、 D ) の 組 を追加する
trg = A . death_list . append ( ( B , C , D ) )
rst = A . death_list . append ( ( B , C , D ) ) <eos>
186
src = E の 各要素 を B とし 、 A の [ ( note & B ) < < CforC , einD ] の 総 和 番目の 列 の集合 が F と 等 しい とき 、
trg = if set ( [ A [ sum ( [ ( not e & B ) << C for C , e in D ] ) ] for B in E ] ) == F :
rst = if sum ( [ A [ ( ( B & C ) for B in D if E & F ] , [ A ] ) == F : <eos>
187
src = A . dice _ w ()
trg = A . dice_w ( )
rst = A . <unk> ( ) <eos>
188
src = is _ parallel ( A , B ) の とき 、
trg = if is_parallel ( A , B ) :
rst = if is_parallel ( A , B ) : <eos>
189
src = 1 を C とする を A の B の先頭 の先頭 番 目 にする
trg = A [ B [ 0 ] [ 0 ] ] = C = 1
rst = A [ B [ 0 ] [ 0 ] ] = C = 1 <eos>
190
src = A が 2 に B を 掛 け た 値 と 等 しい とき 、
trg = if A == 2 * B :
rst = if A == 2 * B : <eos>
191
src = 改行 せずに A の -1 に B を 掛 け た 値 番目の 文字列 に 空白 文字 を加えた 値 を出力する
trg = print ( str ( A [ - 1 * B ] ) + ' ' , end = '' )
rst = print ( str ( A [ - 1 * B ] ) + ' ' , end = '' ) <eos>
192
src = ( ( -2 、 1 ) の 組 、 ( -1 、 1 ) の 組 、 ( -1 、 2 ) の 組 、 ( 0 、 1 ) の 組 、 ( 0 、 2 ) の 組 、 ( 0 、 3 ) の 組 、 ( 1 、 1 ) の 組 、 ( 1 、 2 ) の 組 、 ( 2 、 1 ) の 組 ) からなる 列 を A とする
trg = A = [ ( - 2 , 1 ) , ( - 1 , 1 ) , ( - 1 , 2 ) , ( 0 , 1 ) , ( 0 , 2 ) , ( 0 , 3 ) , ( 1 , 1 ) , ( 1 , 2 ) , ( 2 , 1 ) ]
rst = A = [ ( - 2 , 1 ) , ( - 1 , - 1 ) , ( 2 , - 1 ) , ( 0 , 1 ) , ( 0 , 2 ) , ( 0 , 1 ) , ( 2 , 1 ) , (
193
src = 3 60 から A を 引 いた 値を返す
trg = return 360 - A
rst = return 360 - A <eos>
194
src = A の INITIAL _ VALUE を A の data の 0 番 目 にする
trg = A . data [ 0 ] = A . INITIAL_VALUE
rst = A . data [ 0 ] = A . INITIAL_VALUE <eos>
195
src = dfs ( A )
trg = dfs ( A )
rst = dfs ( A ) <eos>
196
src = B から C の 逆 順 の D と 等 しい 要素 の最初の 位置 を 引 いた 値 から 1 を 引 いた 値を A とする
trg = A = B - C [ : : - 1 ] . index ( D ) - 1
rst = A = B - C [ : : - 1 ] . index ( D ) - 1 <eos>
197
src = 0 が A 以下 かどうか が B より 小さく なく または 0 が C 以下 かどうか が D より 小さく なく または E の A 番目の C 番 目 が - F と 等 しく ない とき 、
trg = if not 0 <= A < B or not 0 <= C < D or E [ A ] [ C ] != - F :
rst = if not 0 <= A < B or not 0 <= C < D or E [ A ] [ C ] != - F : <eos>
198
src = A に B を加えた 値 、 C に B を加えた 値の 最小 値を A とする
trg = A = min ( A + B , C + B )
rst = A = min ( A + B , C + B ) <eos>
199
src = A の day が 13 と 等 しく かつ A の 週 が 4 と 等 しい とき 、
trg = if A . day == 13 and A . weekday ( ) == 4 :
rst = if A . .5 == 13 and A . weekday ( ) == 4 : <eos>
200
src = A の dp の 末 尾 に C の 各要素 を B とし 、 B が 0 と 等 しい かどうか の 整数値 の 列 を追加する
trg = A . dp . append ( [ int ( ( B == 0 ) ) for B in C ] )
rst = A . dp . append ( [ int ( B == 0 ) for B in C . dp ] ) <eos>
201
src = A . warshall _ floyd ( B )
trg = A . warshall_floyd ( B )
rst = A . warshall_floyd ( B ) <eos>
202
src = C の 1 番 目 を 順に A 、 B 、 B として 、 繰り返す
trg = for A , B , B in C [ 1 ] :
rst = for A , B in C [ 1 ] : <eos>
203
src = B を A の stack の A の tail 番 目 にする
trg = A . stack [ A . tail ] = B
rst = A . stack [ A . tail ] = B <eos>
204
src = ( 3 5 . 5 、 3 7 . 5 、 40 、 4 3 、 50 、 5 5 、 70 ) からなる 列 を A とする
trg = A = [ 35.5 , 37.5 , 40 , 43 , 50 , 55 , 70 ]
rst = A = [ 35.5 , <unk> , <unk> , 50.0 , <unk> , <unk> , 50.0 , <unk> , <unk> , <unk> ] <eos>
205
src = compare _ cards ( A [ B ] , A [ C ] ) の とき 、
trg = if compare_cards ( A [ B ] , A [ C ] ) :
rst = if <unk> ( A [ B ] , A [ C ] ) : <eos>
206
src = B の 1 番 目 から 3 番 目 までの 部分 列 を A とする
trg = A = B [ 1 : 3 ]
rst = A = B [ 1 : 3 ] <eos>
207
src = C . popleft () を B とする を A とする
trg = A = B = C . popleft ( )
rst = A = B = C . popleft ( ) <eos>
208
src = A から B の長さ を 引 いた 値が C から D を 引 いた 値 より 小さい とき 、
trg = if A - len ( B ) < C - D :
rst = if A - len ( B ) < C - D : <eos>
209
src = B に C を 掛 け た 値 から D に E を 掛 け た 値を 引 いた 値を B から E を 引 いた 値 で 割 った 値を A とする
trg = A = ( B * C - D * E ) / ( B - E )
rst = A = ( B * C - D * E ) / ( B - E ) <eos>
210
src = 入力された 文字列を H で 分割 した 字句 列 の 各要素 を G とし 、 D ( G ) の 列 を 展開 し 、 それぞれ A 、 B 、 C 、 D 、 E 、 F とする
trg = A , B , C , D , E , F = [ D ( G ) for G in input ( ) . split ( H ) ]
rst = A , B , C , D , E , F = [ ( D ) for G in input ( ) . split ( H ) ] <eos>
211
src = A 内の A の 最小 値 と 等 しい 要素を 取り除く
trg = A . remove ( min ( A ) )
rst = A . remove ( min ( A ) ) <eos>
212
src = A が B の tree に含まれる かどうか を返す
trg = return A in B . tree
rst = return A in B . tree <eos>
213
src = A の q の 末 尾 に B を追加する
trg = A . q . append ( B )
rst = A . q . append ( B ) <eos>
214
src = A を 2 で 割 った 余 り が 0 より 大きい とき 、
trg = if A % 2 > 0 :
rst = if A % 2 > 0 : <eos>
215
src = A 、 B から C を 引 いた 値に D に 1 を加えた 値を 掛 け た 値に E から F を 引 いた 値 を加えた 値の 絶対 値の 最小 値を A とする
trg = A = min ( A , abs ( ( B - C ) * ( D + 1 ) + ( E - F ) ) )
rst = A = min ( A , abs ( B - C ) * ( D + 1 ) + abs ( E - F ) ) <eos>
216
src = A の parent の depth に 1 を加えた 値を A の depth にする
trg = A . depth = A . parent . depth + 1
rst = A . depth = A . parent . depth + 1 <eos>
217
src = A の par の B 番 目 が A の par の C 番 目 より 小さい とき 、
trg = if A . par [ B ] < A . par [ C ] :
rst = if A . par [ B ] < A . par [ C ] : <eos>
218
src = B の 末 尾 を 除 いた 部分 列 を追加し て A を拡張する
trg = A . extend ( B [ : - 1 ] )
rst = A . extend ( B [ : - 1 ] ) <eos>
219
src = A . set _ root ( B )
trg = A . set_root ( B )
rst = A . <unk> ( B ) <eos>
220
src = QueueNode ( B ) を A とする
trg = A = QueueNode ( B )
rst = A = <unk> ( B ) <eos>
221
src = B 、 C 、 D 、 0 において 正規表現 A が 最初 にマッチする 位置 を返す
trg = return search ( A , B , C , D , 0 )
rst = return search ( A , B , C , D , 0 ) <eos>
222
src = write ( ' ' . join ( A ) )
trg = write ( '' . join ( A ) )
rst = write ( '' . join ( A ) ) <eos>
223
src = input () を 空白 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 のリスト の集合 を ソート した 列 を A とする
trg = A = sorted ( set ( list ( map ( int , input ( ) . split ( ) ) ) ) )
rst = A = sorted ( list ( set ( map ( int , input ( ) . split ( ) ) ) ) ) <eos>
224
src = ( B 、 C 、 B 、 C 、 B ) からなる 列 を A とする
trg = A = [ B , C , B , C , B ]
rst = A = [ B , C , B , C , B ] <eos>
225
src = C の D 番 目 を A の B の C の D 番 目 番 目 から 1 を 引 いた 値 番 目 にする
trg = A [ B [ C [ D ] ] - 1 ] = C [ D ]
rst = A [ B [ C [ D ] ] - 1 ] = C [ D ] <eos>
226
src = B に 1 を加えた 値 から B に C を加えた 値 未 満 までの 数 列 を 順に A として 、 繰り返す
trg = for A in range ( B + 1 , B + C ) :
rst = for A in range ( B + 1 , B + C ) : <eos>
227
src = heappush ( A , ( B + C , D ) )
trg = heappush ( A , ( B + C , D ) )
rst = heappush ( A , ( B + C , D ) ) <eos>
228
src = 0 を A の B 番目の C から D を 引 いた 値 番 目 にする
trg = A [ B ] [ C - D ] = 0
rst = A [ B ] [ C - D ] = 0 <eos>
229
src = A を 書式 として B に 0.0 を加えた 値 で 整 形 した 文字列 を出力する
trg = print ( A . format ( B + 0.0 ) )
rst = print ( A . format ( B + 0.0 ) ) <eos>
230
src = dt ( B , C , D ) を A とする
trg = A = dt ( B , C , D )
rst = A = <unk> ( B , C , D ) <eos>
231
src = B に B から C を 引 いた 値を 掛 け た 値に B から D を 引 いた 値を 掛 け た 値に B から D を 引 いた 値を 掛 け た 値の 0.5 乗 を A とする
trg = A = ( B * ( B - C ) * ( B - D ) * ( B - D ) ) ** 0.5
rst = A = ( B * ( B - C ) * ( B - D ) * ( B - D ) ) ** 0.5 <eos>
232
src = A の weights の B 番 目 から A の weights の C 番 目 を 引 いた 値を返す
trg = return A . weights [ B ] - A . weights [ C ]
rst = return A . weights [ B ] - A . weights [ C ] <eos>
233
src = A と 0 b 00 11 の 論理 積 が 0 と 等 しい とき 、
trg = if A & 0b0011 == 0 :
rst = if A & <unk> == 0 : <eos>
234
src = 1 から B に 1 を加えた 値を 2 で 割 った 値の 整数値 に 1 を加えた 値 未 満 までの 数 列 を 順に A として 、 繰り返す
trg = for A in range ( 1 , int ( ( B + 1 ) / 2 ) + 1 ) :
rst = for A in range ( 1 , int ( ( B + 1 ) / 2 ) + 1 ) : <eos>
235
src = A の B と 等 しい 要素 の最初の 位置 を出力する
trg = print ( A . index ( B ) )
rst = print ( A . index ( B ) ) <eos>
236
src = C から D を 引 いた 値に 1 を加えた 値を A の B 番 目 にする
trg = A [ B ] = C - D + 1
rst = A [ B ] = C - D + 1 <eos>
237
src = A の B 番目の C 番 目 に 1 を加えた 値を A の B 番目の C 番 目 にする
trg = A [ B ] [ C ] = A [ B ] [ C ] + 1
rst = A [ B ] [ C ] = A [ B ] [ C ] + 1 <eos>
238
src = A または C 、 D 、 E に B を加えた 値が 5 より 小さい とき E に B を加えた 値 、 そうでなければ 、 つまり 未 定 値 、 F でない において 正規表現 B が 最初 にマッチする 位置 を A とする
trg = A = A or search ( B , C , D , E + B if E + B < 5 else None , not F )
rst = A = A or search ( B , C , D , E + B if E + B < 5 else None , not F ) <eos>
239
src = 3.1 4 15 9 26 5 3 5 89 79 32 38 を 円 周 率 とする
trg = pi = 3.141592653589793238
rst = pi = <unk> <eos>
240
src = 未 定 値を A の lt の B 番目の par にする
trg = A . lt [ B ] . par = None
rst = A . lt [ B ] . par = None <eos>
241
src = A で なく かつ B が C 以上の とき 、
trg = if not A and B >= C :
rst = if not A and B >= C : <eos>
242
src = prime _ factor ( int ( readline () ) ) の 辞書 カウンタ の キー と 値 の集まり の 各要素 を B 、 C とし 、 B の C 乗 から B の C -1 乗 を 引 いた 値の 列 を A で 集約 した 列 を出力する
trg = print ( reduce ( A , ( [ pow ( B , C ) - pow ( B , C - 1 ) for B , C in Counter ( prime_factor ( int ( readline ( ) ) ) ) . items ( ) ] ) ) )
rst = print ( functools . join ( [ str ( B - C ) ** A . values ( ) for B , C in reversed ( int ( readline ( ) ) ) ] ) ) <eos>
243
src = C の primeFactorization の キー と 値 の集まり を 順に A 、 B として 、 繰り返す
trg = for A , B in C . primeFactorization . items ( ) :
rst = for A , B in C . primeFactorization . items ( ) : <eos>
244
src = A の B 番 目 に C を加えた 値が A の D 番 目 より 小さい とき 、
trg = if A [ B ] + C < A [ D ] :
rst = if A [ B ] + C < A [ D ] : <eos>
245
src = Rummy ( A , B )
trg = Rummy ( A , B )
rst = <unk> ( A , B ) <eos>
246
src = A の 2 番 目 から 、 つまり 末 尾 までの 部分 列 を 順に ネ イ ピ ア 数 として 、 繰り返す
trg = for e in A [ 2 : ] :
rst = for e in A [ 2 : ] : <eos>
247
src = A を 10 で 割 った 余 り が B を 10 で 割 った 余 り と 等 しい とき 、
trg = if A % 10 == B % 10 :
rst = if A % 10 == B % 10 : <eos>
248
src = A の 末 尾 に B に 空白 文字 を加えた 値に C の 文字列 を加えた 値 を追加する
trg = A . append ( B + ' ' + str ( C ) )
rst = A . append ( B + ' ' + str ( C ) ) <eos>
249
src = B の 、 つまり 先頭 から C に 1 を加えた 値 までの 部分 列 、 B の 1 番 目 から C に 2 を加えた 値 までの 部分 列 の 要素を それぞれ 組 にした 列 を A とする
trg = A = zip ( B [ 0 : C + 1 ] , B [ 1 : C + 2 ] )
rst = A = zip ( B [ : C + 1 ] , B [ 1 : C + 2 ] ) <eos>
250
src = distance _ ss ( B , C , D , E ) を A とする
trg = A = distance_ss ( B , C , D , E )
rst = A = <unk> ( B , C , D , E ) <eos>
251
src = A の B 番目の 0 番 目 が A の C 番目の 0 番 目 より 小さく かつ A の B 番目の 1 番 目 が A の C 番目の 1 番 目 より 小さく かつ D の C 番 目 が E より 大きい とき 、
trg = if A [ B ] [ 0 ] < A [ C ] [ 0 ] and A [ B ] [ 1 ] < A [ C ] [ 1 ] and D [ C ] > E :
rst = if A [ B ] [ 0 ] < A [ C ] [ 0 ] and A [ B ] [ 1 ] < A [ C ] [ 1 ] and D [ C ] [ E ] > D : <eos>
252
src = 1 から 11 未 満 までの 数 列 の 各要素 を B とし 、 B の 列 を A とする
trg = A = [ B for B in range ( 1 , 11 ) ]
rst = A = [ B for B in range ( 1 , 11 ) ] <eos>
253
src = A に 2 を 掛 け た 値 から 、 つまり 円 周 率 を 引 いた 値を A とする
trg = A = A * 2 - pi
rst = A = A * 2 - pi <eos>
254
src = D の B 番 目 から C に 1 を加えた 値 までの 部分 列 を 反 転 した 列 を A の B 番 目 から C に 1 を加えた 値 までの 部分 列 にする
trg = A [ B : C + 1 ] = reversed ( D [ B : C + 1 ] )
rst = A [ B : C + 1 ] = reversed ( D [ B : C + 1 ] ) <eos>
255
src = A の 末 尾 に ( B の先頭 、 B の 1 番 目 に 1 を加えた 値 ) の 組 を追加する
trg = A . append ( ( B [ 0 ] , B [ 1 ] + 1 ) )
rst = A . append ( ( B [ 0 ] , B [ 1 ] + 1 ) ) <eos>
256
src = A の B 番目の C 番 目 から D の B 番目の C 番 目 を 引 いた 値が E の C 番 目 、 0 の 最大 値 より 大きい とき 、
trg = if A [ B ] [ C ] - D [ B ] [ C ] > max ( E [ C ] , 0 ) :
rst = if A [ B ] [ C ] - D [ B ] [ C ] > max ( E [ C ] , 0 ) : <eos>
257
src = A の B から 2 を 引 いた 値 番目の 先頭 を出力する
trg = print ( A [ B - 2 ] [ 0 ] )
rst = print ( A [ B - 2 ] [ 0 ] ) <eos>
258
src = 0 から A の n 未 満 までの 数 列 の 各要素 を B とし 、 、 つまり 未 定 値の 列 を A の distance にする
trg = A . distance = [ None for B in range ( A . n ) ]
rst = A . distance = [ None for B in range ( A . n ) ] <eos>
259
src = A が -1 と 等 しく または B が A より 小さい とき 、
trg = if A == - 1 or B < A :
rst = if A == - 1 or B < A : <eos>
260
src = A . solve ( B , C , 0 , 0 , 1, 0 ) を出力する
trg = print ( A . solve ( B , C , 0 , 0 , 1 , 0 ) )
rst = print ( A . solve ( B , C , 0 , 0 , 1 , 0 ) ) <eos>
261
src = A を B から 2 を 引 いた 値 で 割 った 値の 整数値 を出力する
trg = print ( int ( A / ( B - 2 ) ) )
rst = print ( int ( A / ( B - 2 ) ) ) <eos>
262
src = A の top を 1 だけ 減少 させる
trg = A . top -= 1
rst = A . top -= 1 <eos>
263
src = B の 24 番 目 を A とする
trg = A = B [ 24 ]
rst = A = B [ 24 ] <eos>
264
src = time を ソート する
trg = time . sort ( )
rst = time . sort ( ) <eos>
265
src = 入力された 文字列を 空白 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 を 展開 し 、 それぞれ A の B 番 目 、 C の B 番 目 、 D の B 番 目 とする
trg = A [ B ] , C [ B ] , D [ B ] = map ( int , input ( ) . split ( ) )
rst = A [ B ] , C [ B ] , D [ B ] = map ( int , input ( ) . split ( ) ) <eos>
266
src = B を 12 で 割 った 余 り を A とする
trg = A = B % 12
rst = A = B % 12 <eos>
267
src = B の集合 を A とする
trg = A = set ( B )
rst = A = set ( B ) <eos>
268
src = A かつ D の 各要素 を C とし 、 C が E と 等 しく ない とき の C の 列 、 F 、 E に 1 を加えた 値 、 0 において 正規表現 B が 最初 にマッチする 位置 を A とする
trg = A = A and search ( B , [ C for C in D if C != E ] , F , E + 1 , 0 )
rst = A = A and search ( B , C if C != E , F ] , [ E + 1 , 0 for C in D ] ) <eos>
269
src = A が B と 等 しく なく かつ C の A 番 目 が D の B 番 目 と 等 しい とき 、
trg = if A != B and C [ A ] == D [ B ] :
rst = if A != B and C [ A ] == D [ B ] : <eos>
270
src = time の tosec ( A ) 番 目 を 1 だけ 増加 させる
trg = time [ tosec ( A ) ] += 1
rst = time [ <unk> ( A ) ] += 1 <eos>
271
src = A を B の lazy の C 番 目 だけ 増加 させる
trg = A += B . lazy [ C ]
rst = A += B . lazy [ C ] <eos>
272
src = C と D と 1 の 論理 積 の 排 他 論理 和 を ネ イ ピ ア 数 とする を A の B 番 目 にする
trg = A [ B ] = e = C ^ ( D & 1 )
rst = A [ B ] = e = C ^ ( D & 1 ) <eos>
273
src = ( 、 つまり 未 定 値 ) からなる 列 の 2020 回 分 の 列 を A とする
trg = A = [ None ] * 2020
rst = A = [ None ] * 2020 <eos>
274
src = 0 から C 未 満 までの 数 列 の 各要素 を B とし 、 0 から C 未 満 までの 数 列 の 各要素 を B とし 、 、 つまり 無限大 の 列 の 列 を A とする
trg = A = [ [ inf for B in range ( C ) ] for B in range ( C ) ]
rst = A = [ [ inf for B in range ( C ) ] for B in range ( C ) ] <eos>
275
src = ( 1 、 ( A の先頭 、 B の先頭 、 C の先頭 、 D の先頭 ) の 組 ) からなる 列 を返す
trg = return [ 1 , ( A [ 0 ] , B [ 0 ] , C [ 0 ] , D [ 0 ] ) ]
rst = return [ 1 , ( A [ 0 ] , B [ 0 ] , C [ 0 ] , D [ 0 ] ) ] <eos>
276
src = Node ( val = B , prev = None , next = None ) を A の start にする
trg = A . start = Node ( val = B , prev = None , next = None )
rst = A . start = Node ( val = B , prev , next = None , next = None ) <eos>
277
src = A が 36 より 大きい とき 、
trg = if A > 36 :
rst = if A > 36 : <eos>
278
src = 0 から B 未 満 までの 数 列 の集合 を A の zeros にする
trg = A . zeros = set ( range ( B ) )
rst = A . zeros = set ( range ( B ) ) <eos>
279
src = B の y 座標 に C の y 座標 を加えた 値を A とする
trg = A = B . y + C . y
rst = A = B . y + C . y <eos>
280
src = A を 2 から 3 を 引 いた 値に B を 掛 け た 値 だけ 増加 させる
trg = A += ( 2 - 3 ) * B
rst = A += ( 2 - 3 ) * B <eos>
281
src = A の B 番目の C 番 目 を A の B から 1 を 引 いた 値 番目の C から 1 を 引 いた 値 番 目 だけ 増加 させる
trg = A [ B ] [ C ] += A [ B - 1 ] [ C - 1 ]
rst = A [ B ] [ C ] += A [ B - 1 ] [ C - 1 ] <eos>
282
src = A の 末 尾 に 入力された 文字列を 空白 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 の 総 和 を追加する
trg = A . append ( sum ( map ( int , input ( ) . split ( ) ) ) )
rst = A . append ( sum ( map ( int , input ( ) . split ( ) ) ) ) <eos>
283
src = A の B 番目の C に D を挿入する
trg = A [ B ] . insert ( C , D )
rst = A [ B ] . insert ( C , D ) <eos>
284
src = A の -1 番 目 を B の 、 つまり 現在の 日 時 番 目 だけ 減少 させる
trg = A [ - 1 ] -= B [ now ]
rst = A [ - 1 ] -= B [ now ] <eos>
285
src = B の C 番 目 を 10 に 36 5 を 掛 け た 値 で 割 った 値に 1 を加えた 値の 整数値 を A とする
trg = A = int ( B [ C ] / ( 10 * 365 ) + 1 )
rst = A = int ( B [ C ] / ( 10 * 365 ) + 1 ) <eos>
286
src = 改行 せずに A の B 番目の name を出力する
trg = print ( A [ B ] . name , end = '' )
rst = print ( A [ B ] . name , end = '' ) <eos>
287
src = 0 から 2 の A . height に 1 を加えた 値 乗 から 1 を 引 いた 値 未 満 までの 数 列 の 各要素 を B とし 、 0 の 列 を A の nodes にする
trg = A . nodes = [ 0 for B in range ( pow ( 2 , A . height + 1 ) - 1 ) ]
rst = A . nodes = [ 0 for B in range ( 2 ** A . height + 1 ) ] <eos>
288
src = A が 1 と 等 しく または A を 2 で 割 った 余 り が 0 と 等 しい とき 、
trg = if A == 1 or A % 2 == 0 :
rst = if A == 1 or A % 2 == 0 : <eos>
289
src = B の 、 つまり ネ イ ピ ア 数 番 目 、 C から D を 引 いた 値の 最小 値を A とする
trg = A = min ( B [ e ] , C - D )
rst = A = min ( B [ e ] , C - D ) <eos>
290
src = A の先頭 の 全て が 英 小文字 の とき 、
trg = if A [ 0 ] . islower ( ) :
rst = if A [ 0 ] . islower ( ) : <eos>
291
src = term () を 展開 し 、 それぞれ A 、 B とする
trg = A , B = term ( )
rst = A , B = term ( ) <eos>
292
src = A が 5 以上 または A が -1 以下の とき 、
trg = if A >= 5 or A <= - 1 :
rst = if A >= 5 or A <= - 1 : <eos>
293
src = sys の stdin の 各要素 を ネ イ ピ ア 数 とし 、 float ( e ) * * 2 を 98 で 割 った 値の 切り 上げ 整数値 に 1 を加えた 値 を出力する の 列
trg = [ print ( math . ceil ( float ( e ) ** 2 / 98 ) + 1 ) for e in sys . stdin ]
rst = [ print ( math . ceil ( ( ( float ( e ) ** 2 / 98 ) ) + 1 ) for e in sys . stdin ] <eos>
294
src = readline () を 空白 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 を 展開 し 、 それぞれ A の B 番 目 、 C の B 番 目 、 D の B 番 目 とする
trg = A [ B ] , C [ B ] , D [ B ] = map ( int , readline ( ) . split ( ) )
rst = A [ B ] , C [ B ] , D [ B ] = map ( int , readline ( ) . split ( ) ) <eos>
295
src = cross 2 ( A , B ) の 2 乗 を dist 1 ( A ) で 割 った 値を返す
trg = return cross2 ( A , B ) ** 2 / dist1 ( A )
rst = return cross2 ( A , B ) ** 2 / dist1 ( A ) <eos>
296
src = 2000 に B を 掛 け た 値を A とする
trg = A = 2000 * B
rst = A = 2000 * B <eos>
297
src = B の 4 番 目 を A とする
trg = A = B [ 4 ]
rst = A = B [ 4 ] <eos>
298
src = B に C から D を 引 いた 値を 掛 け た 値 から D に E から B を 引 いた 値を 掛 け た 値を 引 いた 値を A とする
trg = A = B * ( C - D ) - D * ( E - B )
rst = A = B * ( C - D ) - D * ( E - B ) <eos>
299
src = A に B を加えた 値が C と 等 しい とき 、
trg = if A + B == C :
rst = if A + B == C : <eos>
300
src = A の B 番目の C 番 目 を A の B から 1 を 引 いた 値 番目の C から D の B 番 目 を 引 いた 値 番 目 だけ 増加 させる
trg = A [ B ] [ C ] += A [ B - 1 ] [ C - D [ B ] ]
rst = A [ B ] [ C ] += A [ B - 1 ] [ C - D [ B ] ] <eos>
301
src = A を B と の 論理 和 にする
trg = A |= B
rst = A |= B <eos>
302
src = B の 末 尾 の 1 番 目 を A とする
trg = A = B [ - 1 ] [ 1 ]
rst = A = B [ - 1 ] [ 1 ] <eos>
303
src = bubble _ sort ( A ) を 展開 し 、 それぞれ A 、 B とする
trg = A , B = bubble_sort ( A )
rst = A , B = bubble_sort ( A ) <eos>
304
src = A == 0 かつ B == 0 かつ C が 0 と 等 しく かつ D が 0 と 等 しく かつ E が 0 と 等 しく かつ F が 0 と 等 しい とき 、
trg = if A == 0 and B == 0 and C == 0 and D == 0 and E == 0 and F == 0 :
rst = if A == 0 and B == 0 and C == 0 and D == 0 and E == 0 and F == 0 : <eos>
305
src = 0 から C 未 満 までの 数 列 の 各要素 を B とし 、 MaxPQ () の 列 を A とする
trg = A = [ MaxPQ ( ) for B in range ( C ) ]
rst = A = [ <unk> ( ) for B in range ( C ) ] <eos>
306
src = B の集合 を ソート した 列 を 順に A として 、 繰り返す
trg = for A in sorted ( set ( B ) ) :
rst = for A in sorted ( set ( B ) ) : <eos>
307
src = 0 を os . path の 、 つまり ネ イ ピ ア 数 番 目 にする
trg = path [ e ] = 0
rst = path [ e ] = 0 <eos>
308
src = 改行 せずに A の B 番目の 7 から C を 引 いた 値 番 目 を出力する
trg = print ( A [ B ] [ 7 - C ] , end = '' )
rst = print ( A [ B ] [ 7 - C ] , end = '' ) <eos>
309
src = C の parents に 番号 付 した 組 の 列 の 各要素 を A 、 B とし 、 B が 0 より 小さい とき の A の 列 を返す
trg = return [ A for A , B in enumerate ( C . parents ) if B < 0 ]
rst = return [ A for A , B in enumerate ( C . parents ) if B < 0 ] <eos>
310
src = traversal ( B ) を A とする
trg = A = traversal ( B )
rst = A = <unk> ( B ) <eos>
311
src = A は collections の Iterable 型 かつ A は ( 、 つまり 整数 、 B ) の 組 型 でない とき 、
trg = if isinstance ( A , collections . Iterable ) and not isinstance ( A , ( str , B ) ) :
rst = if isinstance ( A . collections . <unk> and not <unk> ( A , B ) , <unk> ) : <eos>
312
src = A の 末 尾 に B の 2 番目の 文字列 に B の 1 番目の 文字列 を加えた 値の 整数値 を追加する
trg = A . append ( int ( str ( B [ 2 ] ) + str ( B [ 1 ] ) ) )
rst = A . append ( int ( str ( B [ 2 ] ) + str ( B [ 1 ] ) ) ) <eos>
313
src = 改行 せずに str ( A ) . rjust ( 4 ) を出力する
trg = print ( str ( A ) . rjust ( 4 ) , end = '' )
rst = print ( str ( A ) . rjust ( 4 ) , end = '' ) <eos>
314
src = B の 、 つまり 先頭 から C から 3 を 引 いた 値 までの 部分 列 を A とする
trg = A = B [ 0 : C - 3 ]
rst = A = B [ : C - 3 ] <eos>
315
src = A に 2 を 掛 け た 値を 3 の 平 方 根 で 割 った 値を A とする
trg = A = A * 2 / sqrt ( 3 )
rst = A = A * 2 / sqrt ( 3 ) <eos>
316
src = 1 、 D 、 D を A 、 B 、 C とする
trg = A , B , C = 1 , D , D
rst = A , B , C = 1 , D , D <eos>
317
src = 19 11 に A を加えた 値 を出力する
trg = print ( 1911 + A )
rst = print ( 1911 + A ) <eos>
318
src = A の B 番目の C 番 目 、 D の 最小 値を A の B 番目の C 番 目 にする
trg = A [ B ] [ C ] = min ( A [ B ] [ C ] , D )
rst = A [ B ] [ C ] = min ( A [ B ] [ C ] , D ) <eos>
319
src = A に B を 掛 け た 値が C 以下の 間 、 次 を 繰り返す
trg = while A * B <= C :
rst = while A * B <= C : <eos>
320
src = A に B を 掛 け た 値を 2 で 割 った 余 り の とき 、
trg = if A * B % 2 :
rst = if ( A * B ) % 2 : <eos>
321
src = B から C を 引 いた 値 と D から E を 引 いた 値の ノ ル ム を A とする
trg = A = hypot ( B - C , D - E )
rst = A = hypot ( B - C , D - E ) <eos>
322
src = A . add _ edge ( 2 * B , 2 * B + 1, 1, 0 )
trg = A . add_edge ( 2 * B , 2 * B + 1 , 1 , 0 )
rst = A . add_edge ( 2 * B , 2 * B + 1 , 1 , 0 ) <eos>
323
src = A から B の C から 1 を 引 いた 値 番 目 を 引 いた 値が D より 小さい とき 、
trg = if A - B [ C - 1 ] < D :
rst = if A - B [ C - 1 ] < D : <eos>
324
src = 0 から D 未 満 までの 数 列 の 各要素 を C とし 、 C が E と 等 しく なく かつ F の G の C 番 目 番目の とき の B の C 番目の 0 番目の 列 の 総 和 を A とする
trg = A = sum ( [ B [ C ] [ 0 ] for C in range ( D ) if C != E and F [ G [ C ] ] ] )
rst = A = sum ( [ B [ C ] [ 0 ] for C in range ( D ) if E != F and G [ C ] [ 0 ] ] ) <eos>
325
src = A . update _ depth ()
trg = A . update_depth ( )
rst = A . update_nodetype ( ) <eos>
326
src = A に B を加えた 値が 300 以下の 間 、 次 を 繰り返す
trg = while A + B <= 300 :
rst = while A + B <= 300 : <eos>
327
src = ( 99 0000 1 ) からなる 列 の B 回 分 の 列 を A とする
trg = A = [ 9900001 ] * B
rst = A = [ <unk> ] * B <eos>
328
src = A の 整数値 、 B の 整数値 、 C の 整数値 を A 、 B 、 C とする
trg = A , B , C = int ( A ) , int ( B ) , int ( C )
rst = A , B , C = int ( A ) , int ( B ) , int ( C ) <eos>
329
src = B に B を 掛 け た 値 から 1000 1 未 満 までの B 間隔 の 数 列 を 順に A として 、 繰り返す
trg = for A in range ( B * B , 10001 , B ) :
rst = for A in range ( B * B , 10001 , B ) : <eos>
330
src = ( ( 0 、 0 ) の 組 、 ( -1 、 1 ) の 組 、 ( 0 、 1 ) の 組 、 ( 1 、 1 ) の 組 、 ( -2 、 2 ) の 組 、 ( -1 、 2 ) の 組 、 ( 0 、 2 ) の 組 、 ( 1 、 2 ) の 組 、 ( 2 、 2 ) の 組 、 ( -1 、 3 ) の 組
trg = A = [ ( 0 , 0 ) , ( - 1 , 1 ) , ( 0 , 1 ) , ( 1 , 1 ) , ( - 2 , 2 ) , ( - 1 , 2 ) , ( 0 , 2 ) , ( 1 , 2 ) , ( 2 , 2 ) , ( - 1 , 3 ) , ( 0 , 3 ) , ( 1 , 3 ) , (
rst = for A , B in ( ( 0 , 0 ) , ( - 1 , 1 ) , ( 0 , 1 ) , ( 1 , 2 ) , ( - 2 , 1 ) , ( - 1 , 2 ) , ( 2 , 1 )
331
src = ネ イ ピ ア 数が 4 と 等 しい とき 、
trg = if e == 4 :
rst = if e == 4 : <eos>
332
src = ( 0 ) からなる 列 の A の offset に 2 を 掛 け た 値 回 分 の 列 を A の table にする
trg = A . table = [ 0 ] * A . offset * 2
rst = A . table = [ 0 ] * ( A . offset * 2 ) <eos>
333
src = ( A の face の 2 番 目 、 A の face の 1 番 目 、 A の face の 5 番 目 、 A の face の先頭 、 A の face の 4 番 目 、 A の face の 3 番 目 ) からなる 列 を A の face にする
trg = A . face = [ A . face [ 2 ] , A . face [ 1 ] , A . face [ 5 ] , A . face [ 0 ] , A . face [ 4 ] , A . face [ 3 ] ]
rst = A . face = [ A . face [ 2 ] , A . face [ 1 ] , A . face [ 5 ] , A . face [ 0 ] , A . face [ 4 ] , A . face [ 3 ] ] <eos>
334
src = B に ( C + D - B ) を 掛 け た 値に E を 掛 け た 値に C に ( D + B - C ) を 掛 け た 値に F を 掛 け た 値 を加えた 値に D に B + C から D を 引 いた 値を 掛 け た 値に G を 掛 け た 値 を加えた 値を 16 に H の 2 乗 を 掛 け た 値 で 割 った 値を
trg = A = ( B * ( C + D - B ) * E + C * ( D + B - C ) * F + D * ( B + C - D ) * G ) / ( 16 * H ** 2 )
rst = A = ( B * ( C + D - B ) + E * C * ( D - B ) + F * ( D - B ) * C + ( D - B ) * ( D - C ) ) / H <eos>
335
src = 入力された 文字列を 空白 文字 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 の リストを 展開 し 、 それぞれ A 、 B 、 ネ イ ピ ア 数 とする
trg = A , B , e = list ( map ( int , input ( ) . split ( ' ' ) ) )
rst = A , B , e = list ( map ( int , input ( ) . split ( ' ' ) ) ) <eos>
336
src = B の長さ を 2 で 割 った 商 の 階乗 を A とする
trg = A = factorial ( len ( B ) // 2 )
rst = A = factorial ( len ( B ) // 2 ) <eos>
337
src = Dfs ( B ) を A とする
trg = A = Dfs ( B )
rst = A = <unk> ( B ) <eos>
338
src = B の 逆 順 の 整数値 を A とする
trg = A = int ( B [ : : - 1 ] )
rst = A = int ( B [ : : - 1 ] ) <eos>
339
src = minkowsuki ( A , B , 2 ) を出力する
trg = print ( minkowsuki ( A , B , 2 ) )
rst = print ( minkowsuki ( A , B , 2 ) ) <eos>
340
src = A を 3 で 割 った 余 り が 0 と 等 しく または A の 文字列 内の B の 出現 回数 が 0 と 等 しく ない とき 、
trg = if A % 3 == 0 or str ( A ) . count ( B ) != 0 :
rst = if A % 3 == 0 or A . count ( B ) != 0 : <eos>
341
src = A の root が 、 つまり 未 定 値 と 等 しく なければならない
trg = assert A . root is not None
rst = assert A . root is not None <eos>
342
src = 0 を A 内の [MASK] の 出現 回数 にする
trg = A . count = 0
rst = A . count = 0 <eos>
343
src = - B に C を 掛 け た 値 から D に E を 掛 け た 値を 引 いた 値 から 2 に F を 掛 け た 値を 引 いた 値を A とする
trg = A = - B * C - D * E - 2 * F
rst = A = - ( B * C - D * E - 2 * F ) <eos>
344
src = A の pip の 4 番 目 、 A の pip の先頭 、 A の pip の 5 番 目 、 A の pip の 1 番 目 を A の pip の先頭 、 A の pip の 1 番 目 、 A の pip の 4 番 目 、 A の pip の 5 番 目 とする
trg = A . pip [ 0 ] , A . pip [ 1 ] , A . pip [ 4 ] , A . pip [ 5 ] = A . pip [ 4 ] , A . pip [ 0 ] , A . pip [ 5 ] , A . pip [ 1 ]
rst = A . pip [ 0 ] , A . pip [ 1 ] , A . pip [ 4 ] , A . pip [ 5 ] = A . pip [ 4 ] , A . pip [ 0 ] , A . pip [ 5 ] , A
345
src = expr () を A とする
trg = A = expr ( )
rst = A = expr ( ) <eos>
346
src = i を パラメータ として i の 1 番 目 を i の 2 番目の 2 乗 で 割 った 値を返す 関数を A とする
trg = A = lambda B : B [ 1 ] / ( B [ 2 ] ** 2 )
rst = A = lambda D : E [ 1 ] ** 2 / D [ 2 ] ** 2 <eos>
347
src = A を B を 1 だけ 右 シフト した 値 だけ 増加 させる
trg = A += B >> 1
rst = A += B >> 1 <eos>
348
src = A が 0 より 小さく または 1 0000 が A より 小さい とき 、
trg = if ( A < 0 or 10000 < A ) :
rst = if A < 0 or 10000 < A : <eos>
349
src = remove _ team ( A )
trg = remove_team ( A )
rst = remove_node ( A ) <eos>
350
src = solve ( B - 1, C - D ) を A とする
trg = A = solve ( B - 1 , C - D )
rst = A = solve ( B - 1 , C - D ) <eos>
351
src = A の 、 つまり 円 周 率 番 目 が A の 、 つまり 円 周 率 から B を 引 いた 値 番 目 に 1 を加えた 値 より 大きい とき 、
trg = if A [ pi ] > A [ pi - B ] + 1 :
rst = if A [ pi ] > A [ pi - B ] + 1 : <eos>
352
src = tree _ walk ( tree _ walk ( 0 ) , 1 )
trg = tree_walk ( tree_walk ( 0 ) , 1 )
rst = <unk> ( 0 , 1 ) <eos>
353
src = A が B より 小さく かつ C の A 番 目 が 全て アルファベット の 間 、 次 を 繰り返す
trg = while A < B and C [ A ] . isalpha ( ) :
rst = while A < B and C [ A ] . isalpha ( ) : <eos>
354
src = ( ( -1 、 -1 ) の 組 、 ( -1 、 1 ) の 組 、 ( 1 、 -1 ) の 組 、 ( 1 、 1 ) の 組 ) からなる 列 を 順に A 、 B として 、 繰り返す
trg = for A , B in [ ( - 1 , - 1 ) , ( - 1 , 1 ) , ( 1 , - 1 ) , ( 1 , 1 ) ] :
rst = for A , B in [ ( - 1 , - 1 ) , ( - 1 , 1 ) , ( 1 , - 1 ) , ( 1 , 1 ) ] : <eos>
355
src = A の 4 番 目 、 A の先頭 、 A の 1 番 目 、 A の 5 番 目 を A の先頭 、 A の 1 番 目 、 A の 5 番 目 、 A の 4 番 目 とする
trg = A [ 0 ] , A [ 1 ] , A [ 5 ] , A [ 4 ] = A [ 4 ] , A [ 0 ] , A [ 1 ] , A [ 5 ]
rst = A [ 0 ] , A [ 1 ] , A [ 5 ] , A [ 4 ] = A [ 4 ] , A [ 0 ] , A [ 1 ] , A [ 5 ] <eos>
356
src = ( 4 、 2 、 1 、 19 、 9 ) からなる 列
trg = [ 4 , 2 , 1 , 19 , 9 ]
rst = [ 4 , 2 , 1 , 19 , 9 ] <eos>
357
src = C 、 D 、 E 、 F の 要素を それぞれ 組 にした 列 に 番号 付 した 組 の 列 を 順に A 、 B として 、 繰り返す
trg = for A , B in enumerate ( zip ( C , D , E , F ) ) :
rst = for A , B in enumerate ( zip ( C , D , E , F ) ) : <eos>
358
src = A の B 番 目 に C の B 番目の D 番 目 を加えた 値が A の D 番 目 より 小さい とき 、
trg = if A [ B ] + C [ B ] [ D ] < A [ D ] :
rst = if A [ B ] + C [ B ] [ D ] < A [ D ] : <eos>
359
src = C の 2 番 目 から 5 番 目 までの 部分 列 の 各要素 に 整数 を適用した 列 の 総 和 、 C の 5 番 目 から 7 番 目 までの 部分 列 の 各要素 に 整数 を適用した 列 の 総 和 を A 、 B とする
trg = A , B = sum ( map ( int , C [ 2 : 5 ] ) ) , sum ( map ( int , C [ 5 : 7 ] ) )
rst = A , B = sum ( map ( int , C [ 2 : 5 ] ) , sum ( map ( int , C [ 5 : 7 ] ) ) ) <eos>
360
src = distance ( B [ C ] , D [ E ] ) を A とする
trg = A = distance ( B [ C ] , D [ E ] )
rst = A = distance ( B [ C ] , D [ E ] ) <eos>
361
src = run ( A ) を A とする
trg = A = run ( A )
rst = A = run ( A ) <eos>
362
src = Vector ( B - C , D - E ) を A とする
trg = A = Vector ( B - C , D - E )
rst = A = Vector ( B - C , D - E ) <eos>
363
src = A 、 B の C 番目の 先頭 、 B の C 番目の 末 尾 の 最小 値を A とする
trg = A = min ( A , B [ C ] [ 0 ] , B [ C ] [ - 1 ] )
rst = A = min ( A , B [ C ] [ 0 ] , B [ C ] [ - 1 ] ) <eos>
364
src = A を B から C の D 番 目 を 引 いた 値に E の D 番 目 を 掛 け た 値 だけ 増加 させる
trg = A += ( B - C [ D ] ) * E [ D ]
rst = A += ( B - C [ D ] ) * E [ D ] <eos>
365
src = ( < __ main __ . Cammaobjectat 0 x 10 a 20 32 b 0 > ) の集合 を A とする
trg = A = { 0 }
rst = A = { [ B for B in range ( C , 14 ) ] } <eos>
366
src = A の 各要素 を C 、 D とし 、 B を 書式 として C 、 D で 整 形 した 文字列 の 列 を A とする
trg = A = [ B . format ( C , D ) for C , D in A ]
rst = A = [ B . format ( C , D ) for C , D in A ] <eos>
367
src = B の長さ から 2 を 引 いた 値 から -1 未 満 までの -2 間隔 の 数 列 の 各要素 を C とし 、 B の C 番 目 から C に 2 を加えた 値 までの 部分 列 の 列 を A とする
trg = A = [ B [ C : C + 2 ] for C in range ( len ( B ) - 2 , - 1 , - 2 ) ]
rst = A = [ B [ C : C + 2 ] for C in range ( len ( B ) - 2 , - 1 , - 2 ) ] <eos>
368
src = A の 末 尾 に B の C 番 目 が B の D 番 目 と 等 しい とき E 、 そうでなければ F を追加する
trg = A . append ( E if B [ C ] == B [ D ] else F )
rst = A . append ( E if B [ C ] == B [ D ] else F ) <eos>
369
src = [MASK] の 両 端 キュー を A の B の先頭 番 目 にする
trg = A [ B [ 0 ] ] = deque ( )
rst = A [ B [ 0 ] ] = deque ( ) <eos>
370
src = x を パラメータ として x の 2 乗 に B を加えた 値を C で 割 った 余 り を返す関数 を A とする
trg = A = lambda D : ( D ** 2 + B ) % C
rst = A = lambda B : ( B ** 2 + B ) % C <eos>
371
src = 5 を B とする
trg = B = 5
rst = B = 5 <eos>
372
src = 2 に B の N 0 を加えた 値に C を加えた 値を A とする
trg = A = 2 + B . N0 + C
rst = A = 2 + B . N + 0 + C <eos>
373
src = A を B の C の D に 1 を加えた 値 番 目 番 目 から B の C の D 番 目 番 目 を 引 いた 値 だけ 増加 させる
trg = A += B [ C [ D + 1 ] ] - B [ C [ D ] ]
rst = A += B [ C [ D + 1 ] ] - B [ C [ D ] ] <eos>
374
src = ( B の 整数値 ) からなる 列 を追加し て A を拡張する
trg = A . extend ( [ int ( B ) ] )
rst = A . extend ( [ int ( B ) ] ) <eos>
375
src = B を A の rightChild にする
trg = A . rightChild = B
rst = A . <unk> = B <eos>
376
src = A を _ search ( B , C + 1, D , E ) だけ 増加 させる
trg = A += _search ( B , C + 1 , D , E )
rst = A += _search ( B , C + 1 , D , E ) <eos>
377
src = A の 末 尾 に ( ( 0 、 1 、 2 、 3 、 4 、 5 、 6 、 7 ) の 組 、 0 ) の 組 を追加する
trg = A . append ( ( ( 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 ) , 0 ) )
rst = A . append ( ( 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 0 ) ) <eos>
378
src = 入力された 文字列を 空白 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 を 展開 し 、 それぞれ A 、 B 、 C 、 D 、 ネ イ ピ ア 数 、 E とする
trg = A , B , C , D , e , E = map ( int , input ( ) . split ( ) )
rst = A , B , C , D , e , E = map ( int , input ( ) . split ( ) ) <eos>
379
src = ( ( -1 、 0 ) からなる 列 、 ( 1 、 0 ) からなる 列 、 ( 0 、 0 ) からなる 列 、 ( 0 、 -1 ) からなる 列 、 ( 0 、 1 ) からなる 列 ) からなる 列 を A とする
trg = A = [ [ - 1 , 0 ] , [ 1 , 0 ] , [ 0 , 0 ] , [ 0 , - 1 ] , [ 0 , 1 ] ]
rst = A = [ [ - 1 , 0 ] , [ 1 , 0 ] , [ 0 , 0 ] , [ 0 , - 1 ] , [ 0 , 1 ] ] <eos>
380
src = LIS ( A ) を出力する
trg = print ( LIS ( A ) )
rst = print ( <unk> ( A ) ) <eos>
381
src = B を 1 0000 で 割 った 余 り の 文字列 に C の D 番 目 を加えた 値に A を加えた 値を A とする
trg = A = str ( B % 10000 ) + C [ D ] + A
rst = A = str ( B % 10000 ) + C [ D ] + A <eos>
382
src = Node ( val = B , prev = None , next = None ) を A の end にする
trg = A . end = Node ( val = B , prev = None , next = None )
rst = A . end = Node ( val = B , prev , next = None ) <eos>
383
src = 6 を B とする
trg = B = 6
rst = B = 6 <eos>
384
src = A の先頭 が B と 等 しい 間 、 次 を 繰り返す
trg = while A [ 0 ] == B :
rst = while A [ 0 ] == B : <eos>
385
src = D に E を F で 割 った 値 を加えた 値を C とする を A の B 番 目 にする
trg = A [ B ] = C = D + E / F
rst = A [ B ] = C = D + E / F <eos>
386
src = 未 定 値を C を B とする とする を A とする
trg = A = B = C = None
rst = A = B = C = None <eos>
387
src = 3 に B を 掛 け た 値 から 100 0000 未 満 までの 2 に B を 掛 け た 値 間隔 の 数 列 を 順に A として 、 繰り返す
trg = for A in range ( 3 * B , 1000000 , 2 * B ) :
rst = for A in range ( 3 * B , 1000000 , 2 * B ) : <eos>
388
src = ( ( -1 、 0 ) の 組 、 ( -1 、 -1 ) の 組 、 ( 0 、 -1 ) の 組 、 ( 1 、 -1 ) の 組 、 ( 1 、 0 ) の 組 、 ( 1 、 1 ) の 組 、 ( 0 、 1 ) の 組 、 ( -1 、 1 ) の 組 ) の 組 を A とする
trg = A = ( ( - 1 , 0 ) , ( - 1 , - 1 ) , ( 0 , - 1 ) , ( 1 , - 1 ) , ( 1 , 0 ) , ( 1 , 1 ) , ( 0 , 1 ) , ( - 1 , 1 ) )
rst = A = ( ( - 1 , 0 ) , ( - 1 , - 1 ) , ( 0 , - 1 ) , ( 1 , - 1 ) , ( 1 , 0 ) , ( 0 , 1 ) , ( 1 , 1 ) ,
389
src = B の C の 末 尾 番目の 1 番 目 を A とする
trg = A = B [ C [ - 1 ] ] [ 1 ]
rst = A = B [ C [ - 1 ] ] [ 1 ] <eos>
390
src = w を パラメータ として B の 1 番 目 に 100 を 掛 け た 値に w の 3 番 目 を加えた 値を返す 関数を キー として 逆 順に A を ソート した 列 を A とする
trg = A = sorted ( A , key = lambda B : B [ 1 ] * 100 + B [ 3 ] , reverse = True )
rst = A = sorted ( A , key = lambda B : B [ 1 ] * 100 + B . w , reverse = True ) <eos>
391
src = atan 2 ( - B , - C ) を A とする
trg = A = atan2 ( - B , - C )
rst = A = atan2 ( - B , - C ) <eos>
392
src = A の B 番目の 1 番 目 が A の B から 1 を 引 いた 値 番目の 1 番 目 より 小さい とき 、
trg = if A [ B ] [ 1 ] < A [ B - 1 ] [ 1 ] :
rst = if A [ B ] [ 1 ] < A [ B - 1 ] [ 1 ] : <eos>
393
src = LinkList () を A とする
trg = A = LinkList ( )
rst = A = <unk> ( ) <eos>
394
src = D の 各要素 を B とし 、 B から C を 引 いた 値の 2 乗 の 列 を A とする
trg = A = [ ( B - C ) ** 2 for B in D ]
rst = A = [ ( B - C ) ** 2 for B in D ] <eos>
395
src = 未 定 値を A の 3 番 目 にする
trg = A [ 3 ] = None
rst = A [ 3 ] = None <eos>
396
src = A の B から 1 を 引 いた 値 番目の C から 1 を 引 いた 値 番 目 が -1 と 等 しい とき -1 、 そうでなければ 1 を A の B から 1 を 引 いた 値 番目の C から 1 を 引 いた 値 番 目 にする
trg = A [ B - 1 ] [ C - 1 ] = - 1 if A [ B - 1 ] [ C - 1 ] == - 1 else 1
rst = A [ B - 1 ] [ C - 1 ] = - 1 if A [ B - 1 ] [ C - 1 ] == - 1 else 1 <eos>
397
src = A の 各要素 に B を適用した 列 の 両 端 キュー を A とする
trg = A = deque ( map ( B , A ) )
rst = A = deque ( map ( B , A ) ) <eos>
398
src = B の 、 つまり ネ イ ピ ア 数 と 等 しい 要素 の最初の 位置 を A とする
trg = A = B . index ( e )
rst = A = B . index ( e ) <eos>
399
src = B の C 番 目 に D の E - C から 2 を 引 いた 値 番目の C に 1 を加えた 値 番 目 を加えた 値 、 D の E - C から 2 を 引 いた 値 番目の C 番 目 に B の E 番 目 を加えた 値の 最小 値を A とする
trg = A = min ( B [ C ] + D [ E - C - 2 ] [ C + 1 ] , D [ E - C - 2 ] [ C ] + B [ E ] )
rst = A = B [ C ] + min ( D [ E - C - 2 ] [ C + 1 ] , D [ E - C - 2 ] [ E - C ] + E [ B ] ) <eos>
400
src = ( ( B , ( 3 、 1 、 0 、 5 、 4 、 2 ) の 組 ) 、 ( C , ( 1 、 5 、 2 、 3 、 0 、 4 ) の 組 ) 、 ( D , ( 4 、 0 、 2 、 3 、 5 、 1 ) の 組 ) 、 ( E , ( 2 、 1 、 5 、 0 、 4 、 3 ) の 組 )
trg = A = { 'E' : ( 3 , 1 , 0 , 5 , 4 , 2 ) , 'N' : ( 1 , 5 , 2 , 3 , 0 , 4 ) , 'S' : ( 4 , 0 , 2 , 3 , 5 , 1 ) , 'W' : ( 2 , 1 , 5 , 0 , 4 , 3 ) }
rst = A = { 'N' : ( 3 , 1 , 0 , 5 , 4 , 2 , 5 , 4 ) , 'S' : ( 4 , 0 , 2 , 3 , 5 , 5 , 4 ) , 'E' : ( 4 , 0 , 3 ,
401
src = A の B 番 目 を C の B を 12 で 割 った 余 り 番 目 だけ 増加 させる
trg = A [ B ] += C [ B % 12 ]
rst = A [ B ] += C [ B % 12 ] <eos>
402
src = 0 から C に 2 を 掛 け た 値 未 満 までの 数 列 の 各要素 を D とし 、 0 から C に 2 を 掛 け た 値 未 満 までの 数 列 の 各要素 を B とし 、 -1 の 列 の 列 を A とする
trg = A = [ [ - 1 for B in range ( C * 2 ) ] for D in range ( C * 2 ) ]
rst = A = [ [ - 1 for B in range ( C * 2 ) ] for D in range ( C * 2 ) ] <eos>
403
src = A を 書式 として B に cos ( C ) を 掛 け た 値 から D に sin ( C ) を 掛 け た 値を 引 いた 値に E を加えた 値 、 D に cos ( C ) を 掛 け た 値に B に sin ( C ) を 掛 け た 値 を加えた 値に F を加えた 値 で 整 形 した 文字列 を出力する
trg = print ( A . format ( B * cos ( C ) - D * sin ( C ) + E , D * cos ( C ) + B * sin ( C ) + F ) )
rst = print ( A . format ( B * cos ( C ) - D * sin ( C ) + E * sin ( D ) , sin ( C ) + F * sin ( B ) * sin ( C ) ) + F ) <eos>
404
src = 0 から C に D を 掛 け た 値 未 満 までの 数 列 の 各要素 を B とし 、 、 つまり 空 列 の 列 を A とする
trg = A = [ [ ] for B in range ( C * D ) ]
rst = A = [ [ ] for B in range ( C * D ) ] <eos>
405
src = 0 、 C の先頭 を A 、 B とする
trg = A , B = 0 , C [ 0 ]
rst = A , B = 0 , C [ 0 ] <eos>
406
src = A の B の 1 番 目 番目の B の先頭 番 目 が 0 と 等 しく ない とき 、
trg = if A [ B [ 1 ] ] [ B [ 0 ] ] != 0 :
rst = if A [ B [ 1 ] ] [ B [ 0 ] ] != 0 : <eos>
407
src = isstable ( A . split () , B , C ) を出力する
trg = print ( isstable ( A . split ( ) , B , C ) )
rst = print ( <unk> ( A . split ( ) , B , C ) ) <eos>
408
src = B を 20 で 割 った 商 に 20 を 掛 け た 値を A とする
trg = A = B // 20 * 20
rst = A = B // 20 * 20 <eos>
409
src = 0 から C 未 満 までの 数 列 の 各要素 を B とし 、 event ( B + 1, int ( input () ) ) の 列 を A とする
trg = A = [ event ( B + 1 , int ( input ( ) ) ) for B in range ( C ) ]
rst = A = [ <unk> ( B + 1 , int ( input ( ) ) ) for B in range ( C ) ] <eos>
410
src = A が B に 2 を 掛 け た 値 に含まれる とき 、
trg = if A in B * 2 :
rst = if A in B * 2 : <eos>
411
src = A を B の 0 を取り 出した 値を 英 小文字 に変換し た 文字列 だけ 増加 させる
trg = A += B . pop ( 0 ) . lower ( )
rst = A += B . pop ( 0 ) . lower ( ) <eos>
412
src = B の C 番目の 辞書 カウンタ を A とする
trg = A = Counter ( B [ C ] )
rst = A = Counter ( B [ C ] ) <eos>
413
src = Vector ( A . x - B . x , A . y - B . y ) を返す
trg = return Vector ( A . x - B . x , A . y - B . y )
rst = return Vector ( A . x - B . x , A . y - B . y ) <eos>
414
src = A 、 B を 書式 として C を 100 で 割 った 商 、 C を 100 で 割 った 余 り で 整 形 した 文字列 を出力する
trg = print ( A , B . format ( C // 100 , C % 100 ) )
rst = print ( A , B . format ( C // 100 , C % 100 ) ) <eos>
415
src = A の val の B 番 目 を返す
trg = return A . val [ B ]
rst = return A . val [ B ] <eos>
416
src = A を 空白 文字 で 分割 した 字句 列 の 各要素 に x を パラメータ として B の長さ の 文字列 を返す関数 を適用した 列 の リストを A とする
trg = A = list ( map ( lambda B : str ( len ( B ) ) , A . split ( ' ' ) ) )
rst = A = list ( map ( lambda B : len ( B ) , A . split ( ' ' ) ) ) <eos>
417
src = conv ( B [ C ] ) を A とする
trg = A = conv ( B [ C ] )
rst = A = conv ( B [ C ] ) <eos>
418
src = A に B の 3 乗 を加えた 値を A とする
trg = A = A + pow ( B , 3 )
rst = A = A + ( B ** 3 ) <eos>
419
src = height ( A ) を A の B の HEIGHT 番 目 にする
trg = A [ B . HEIGHT ] = height ( A )
rst = A [ B . HEIGHT ] = height ( A ) <eos>
420
src = A の 末 尾 に 入力された 文字列 の 整数値 を 10 で 割 った 商 を追加する
trg = A . append ( int ( input ( ) ) // 10 )
rst = A . append ( int ( input ( ) ) // 10 ) <eos>
421
src = 0 から 16 未 満 までの 数 列 を 順に A として 、 繰り返す
trg = for A in range ( 16 ) :
rst = for A in range ( 16 ) : <eos>
422
src = A の 末 尾 に 無限 の 整数 列 を追加する
trg = A . append ( count )
rst = A . append ( count ) <eos>
423
src = A と 3 を 割 った とき の ( 商 を 展開 し 、 それぞれ A 、 B とする
trg = A , B = divmod ( A , 3 )
rst = A , B = divmod ( A , 3 ) <eos>
424
src = A を B の C 番 目 から D の C に E を加えた 値を 8 で 割 った 余 り 番 目 を 引 いた 値 、 0 の 最大 値 だけ 増加 させる
trg = A += max ( B [ C ] - D [ ( C + E ) % 8 ] , 0 )
rst = A += max ( B [ C ] - ( D [ C + E ) % 8 ] , 0 ) <eos>
425
src = time が A より 小さい とき 、
trg = if time < A :
rst = if time < A : <eos>
426
src = 0 が A から B を 引 いた 値 以下 かつ A から B を 引 いた 値が C より 小さい かどうか が A より 小さく ない とき 、
trg = if 0 <= A - B and ( not ( A - B < C < A ) ) :
rst = if not 0 <= A - B and not A - B < C < A : <eos>
427
src = A の 末 尾 に ( B 、 C に ネ イ ピ ア 数の weight を加えた 値 ) の 組 を追加する
trg = A . append ( ( B , C + e . weight ) )
rst = A . append ( ( B , C + e . weight ) ) <eos>
428
src = A の B 番目の C 番 目 、 A の B に D [ C ] [ 1 ] を加えた 値 番目の C に 1 を加えた 値 番 目 に D の C 番目の 先頭 を加えた 値の 最大 値を A の B 番目の C 番 目 にする
trg = A [ B ] [ C ] = max ( A [ B ] [ C ] , A [ B + D [ C ] [ 1 ] ] [ C + 1 ] + D [ C ] [ 0 ] )
rst = A [ B ] [ C ] [ 0 ] = max ( A [ B ] [ C ] , A [ B + D [ C ] [ 1 ] [ C + 1 ] [ D [ C ] ] + E [ C ] [ 0
429
src = A の 末 尾 に ( 1 に B を加えた 値 、 C ) の 組 を追加する
trg = A . append ( ( 1 + B , C ) )
rst = A . append ( ( 1 + B , C ) ) <eos>
430
src = 無限 の 整数 列 を A の B 番目の C 番 目 だけ 増加 させる
trg = count += A [ B ] [ C ]
rst = count += A [ B ] [ C ] <eos>
431
src = B の C 番目の D から 2 を 引 いた 値 番 目 を A とする
trg = A = B [ C ] [ D - 2 ]
rst = A = B [ C ] [ D - 2 ] <eos>
432
src = B を 正規表現 に コンパイル した結果 を A とする
trg = A = re . compile ( B )
rst = A = re . <unk> ( B ) <eos>
433
src = check ( A , B + 1, C )
trg = check ( A , B + 1 , C )
rst = check ( A , B + 1 , C ) <eos>
434
src = A 、 B に C を加えた 値を D に E に 1 を加えた 値に F を 掛 け た 値 を加えた 値 で 割 った 商 の 最大 値を A とする
trg = A = max ( A , ( B + C ) // ( D + ( E + 1 ) * F ) )
rst = A = max ( A , ( B + C ) // ( D + E + 1 ) * F ) <eos>
435
src = sys . setrecursionlimit ( 200 0000 )
trg = sys . setrecursionlimit ( 2000000 )
rst = sys . setrecursionlimit ( 1000000 ) <eos>
436
src = E を F で 分割 した 字句 列 の 各要素 を D とし 、 D の 整数値 の 列 を 展開 し 、 それぞれ A 、 B 、 C とする
trg = A , B , C = [ int ( D ) for D in E . split ( F ) ]
rst = A , B , C = [ int ( D ) for D in E . split ( F ) ] <eos>
437
src = 0 を A の 0 番 目 にする
trg = A [ 0 ] = 0
rst = A [ 0 ] = 0 <eos>
438
src = 0 から D に 1 を加えた 値 未 満 までの 数 列 の 各要素 を C とし 、 B に C を 掛 け た 値の 列 を A とする
trg = A = [ B * C for C in range ( D + 1 ) ]
rst = A = [ B * C for C in range ( D + 1 ) ] <eos>
439
src = prime ( 1 0000 ) を A とする
trg = A = prime ( 10000 )
rst = A = prime ( 10000 ) <eos>
440
src = A から B に C を 掛 け た 値を 引 いた 値が 0 以上の とき 、
trg = if A - B * C >= 0 :
rst = if A - B * C >= 0 : <eos>
441
src = A . query ( A . table [ 2 * B ] , A . table [ 2 * B + 1 ] ) を A の table の B 番 目 にする
trg = A . table [ B ] = A . query ( A . table [ 2 * B ] , A . table [ 2 * B + 1 ] )
rst = A . table [ B ] = A . query ( A . table [ 2 * B ] , A . table [ 2 * B + 1 ] ) <eos>
442
src = A . add _ edge ( B + C , B + D + 1, 1, 0 )
trg = A . add_edge ( B + C , B + D + 1 , 1 , 0 )
rst = A . add_edge ( B + C , B + D + 1 , 1 , 0 ) <eos>
443
src = readline () を C で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 を 展開 し 、 それぞれ A 、 B とする
trg = A , B = map ( int , readline ( ) . split ( C ) )
rst = A , B = map ( int , readline ( ) . split ( C ) ) <eos>
444
src = A の先頭 が 0 と 等 しく かつ A の 1 番 目 が 0 と 等 しく かつ A の 2 番 目 が 0 と 等 しい とき 、
trg = if A [ 0 ] == 0 and A [ 1 ] == 0 and A [ 2 ] == 0 :
rst = if A [ 0 ] == 0 and A [ 1 ] == 0 and A [ 2 ] == 0 : <eos>
445
src = 19 、 B の 最小 値を A とする
trg = A = min ( 19 , B )
rst = A = min ( 19 , B ) <eos>
446
src = os . path の 末 尾 に ( ( 0 、 1 、 2 、 3 、 4 、 5 、 6 、 7 、 8 、 9 ) からなる 列 、 空 列 ) からなる 列 を追加する
trg = path . append ( [ [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] , [ ] ] )
rst = path . append ( [ [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , ] , [ ] ] ) <eos>
447
src = A が 1 より 小さい とき 、
trg = if A < 1 :
rst = if A < 1 : <eos>
448
src = A の B 番目の 先頭 の 整数値 を A の B 番目の 0 番 目 にする
trg = A [ B ] [ 0 ] = int ( A [ B ] [ 0 ] )
rst = A [ B ] [ 0 ] = int ( A [ B ] [ 0 ] ) <eos>
449
src = 0 が A 以下 かどうか が B より 小さく なく または 0 が C 以下 かどうか が B より 小さく ない とき 、
trg = if not 0 <= A < B or not 0 <= C < B :
rst = if not 0 <= A < B or not 0 <= C < B : <eos>
450
src = heappush ( A , ( B , time , C , D , E ) )
trg = heappush ( A , ( B , time , C , D , E ) )
rst = heappush ( A , ( B , time , C , D , E ) ) <eos>
451
src = find ( C ) を A の find ( B ) 番 目 にする
trg = A [ find ( B ) ] = find ( C )
rst = A [ find ( B ) ] = find ( C ) <eos>
452
src = A の とき " { } : { } " 、 そうでなければ B を出力する
trg = print ( {v}: {combi} if A else B )
rst = print ( <unk> if A else B ) <eos>
453
src = E の 、 つまり ネ イ ピ ア 数 番目の 各要素 を C とし 、 A [ B -1 ] の C 番 目 が D と 等 しい かどうか の 列 が 少なくとも ひとつ は 真 かつ E の H 番目の 各要素 を G とし 、 A [ F -1 ] の G 番 目 が D と 等 しい かどうか の 列 が 少なくとも ひとつ は 真 の とき 、
trg = if any ( [ A [ B - 1 ] [ C ] == D for C in E [ e ] ] ) and any ( [ A [ F - 1 ] [ G ] == D for G in E [ H ] ] ) :
rst = if any ( [ A [ B ] [ C ] == D and any ( [ E ] [ A [ F - 1 ] == G for C in D ] ) : <eos>
454
src = B から C を 引 いた 値の 2 乗 に D から E を 引 いた 値の 2 乗 を加えた 値の . 5 乗 を F で 割 った 値を A とする
trg = A = ( ( B - C ) ** 2 + ( D - E ) ** 2 ) ** .5 / F
rst = A = ( ( B - C ) ** 2 + ( D - E ) ** 2 ) ** .5 / F <eos>
455
src = A から B を 引 いた 値が 1 より 大きい 間 、 次 を 繰り返す
trg = while A - B > 1 :
rst = while A - B > 1 : <eos>
456
src = scaler ( 2 , B ) を A とする
trg = A = scaler ( 2 , B )
rst = A = scaler ( 2 , B ) <eos>
457
src = vc ( B , C ) を A とする
trg = A = vc ( B , C )
rst = A = vc ( B , C ) <eos>
458
src = C に I に F を 掛 け た 値を G で 割 った 値 を加えた 値を H とする
trg = H = C + I * F / G
rst = H = C + I * F / G <eos>
459
src = B . compute () を A とする
trg = A = B . compute ( )
rst = A = B . compute ( ) <eos>
460
src = _ miny ( B . right , C , D + 1 ) を A とする
trg = A = _miny ( B . right , C , D + 1 )
rst = A = _miny ( B . right , C , D + 1 ) <eos>
461
src = A が B と 等 しく または C の B 番 目 が D より 小さい とき 、
trg = if A == B or C [ B ] < D :
rst = if A == B or C [ B ] < D : <eos>
462
src = B と C の 論理 積 を ソート した 列 を 順に A として 、 繰り返す
trg = for A in sorted ( B & C ) :
rst = for A in sorted ( B & C ) : <eos>
463
src = A が B より 小さく かつ A が C と 等 しく ない とき 、
trg = if A < B and A != C :
rst = if A < B and A != C : <eos>
464
src = 空 列 を A の status にする
trg = A . status = [ ]
rst = A . status = [ ] <eos>
465
src = D を 空白 文字 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 の リストを 展開 し 、 それぞれ A 、 B 、 C とする
trg = A , B , C = list ( map ( int , D . split ( ' ' ) ) )
rst = A , B , C = list ( map ( int , D . split ( ' ' ) ) ) <eos>
466
src = A の B から C を 引 いた 値 番目の D から E を 引 いた 値 番 目 が F と 等 しく ない とき 、
trg = if A [ B - C ] [ D - E ] != F :
rst = if A [ B - C ] [ D - E ] != F : <eos>
467
src = A が B に B を 掛 け た 値 より 小さい とき 、
trg = if A < B * B :
rst = if A < B * B : <eos>
468
src = C の D 番 目 を A の faces の B 番 目 にする
trg = A . faces [ B ] = C [ D ]
rst = A . faces [ B ] = C [ D ] <eos>
469
src = ( D 、 E ) の 組 を A の ( B 、 C ) の 組 から 、 つまり 末 尾 までの 部分 列 にする
trg = A [ ( B , C ) : ] = ( D , E )
rst = A [ ( B , C ) : ] = ( D , E ) <eos>
470
src = bfs ( A , B ) を返す
trg = return bfs ( A , B )
rst = return bfs ( A , B ) <eos>
471
src = 0 から D 未 満 までの 数 列 の 各要素 を C とし 、 B の 浮動小数点数 の 列 を A とする
trg = A = [ float ( B ) for C in range ( D ) ]
rst = A = [ float ( B ) for C in range ( D ) ] <eos>
472
src = A の B から 1 を 引 いた 値 番目の C 番 目 、 A の B から 1 を 引 いた 値 番目の C から 1 を 引 いた 値 番目の 最大 値に A の B 番目の C 番 目 を加えた 値を A の B 番目の C 番 目 にする
trg = A [ B ] [ C ] = max ( A [ B - 1 ] [ C ] , A [ B - 1 ] [ C - 1 ] ) + A [ B ] [ C ]
rst = A [ B ] [ C ] = max ( A [ B - 1 ] [ C ] , A [ B - 1 ] [ C - 1 ] ) + A [ B ] [ C ] <eos>
473
src = I の J 番 目 を 展開 し 、 それぞれ A 、 B 、 C 、 D 、 E 、 F 、 G 、 H とする
trg = A , B , C , D , E , F , G , H = I [ J ]
rst = A , B , C , D , E , F , G , H = I [ J ] <eos>
474
src = A から B を 引 いた 値を D とする
trg = D = A - B
rst = D = A - B <eos>
475
src = 1 から 2 に B を 掛 け た 値 未 満 までの 数 列 を 順に A として 、 繰り返す
trg = for A in range ( 1 , 2 * B ) :
rst = for A in range ( 1 , 2 * B ) : <eos>
476
src = A に B の node の 組 を追加した 集 ま り
trg = A . add ( tuple ( B . node ) )
rst = A . add ( tuple ( B . node ) ) <eos>
477
src = parse ( 1, 0 , E [ F ] , ( E + E ) [ F + 1 : F + G ] ) を 展開 し 、 それぞれ A 、 B 、 C 、 D とする
trg = A , B , C , D = parse ( 1 , 0 , E [ F ] , ( E + E ) [ F + 1 : F + G ] )
rst = A , B , C , D = parse ( 1 , 0 , E [ F ] , ( E + F ) [ 1 : F + G + 1 ] ) <eos>
478
src = B に C を 掛 け た 値に D の ラ ジ アン の 正 弦 を 掛 け た 値を 2 で 割 った 値を A とする
trg = A = B * C * math . sin ( math . radians ( D ) ) / 2
rst = A = B * C * sin ( radians ( D ) ) / 2 <eos>
479
src = ( ( B の C 番目の D 番 目 、 C 、 D ) の 組 ) からなる 列 を A とする
trg = A = [ ( B [ C ] [ D ] , C , D ) ]
rst = A = [ ( B [ C ] [ D ] , C , D ) ] <eos>
480
src = A . put ( [ 0 , 0 , 0 ] )
trg = A . put ( [ 0 , 0 , 0 ] )
rst = A . put ( [ 0 , 0 , 0 ] ) <eos>
481
src = A の B 番目の 順序 数が 4 8 以上 かつ A の B 番目の 順序 数が 5 7 以下の とき 、
trg = if ord ( A [ B ] ) >= 48 and ord ( A [ B ] ) <= 57 :
rst = if ord ( A [ B ] ) >= <unk> and ord ( A [ B ] ) <= 5 : <eos>
482
src = ( 0 ) からなる 列 の 6 回 分 の 列 を A とする
trg = A = [ 0 ] * 6
rst = A = [ 0 ] * 6 <eos>
483
src = A に B を加えた 値が C に D を加えた 値を 2 で 割 った 値 より 小さい とき 、
trg = if A + B < ( C + D ) / 2 :
rst = if A + B < ( C + D ) / 2 : <eos>
484
src = 32 から A を 引 いた 値を A とする
trg = A = 32 - A
rst = A = 32 - A <eos>
485
src = ( -1 、 0 、 1 、 2 ) からなる 列 を A とする
trg = A = [ - 1 , 0 , 1 , 2 ]
rst = A = [ - 1 , 0 , 1 , 2 ] <eos>
486
src = A を B の C 番 目 に B の C 番 目 から 1 を 引 いた 値を 掛 け た 値を 2 で 割 った 商 だけ 増加 させる
trg = A += B [ C ] * ( B [ C ] - 1 ) // 2
rst = A += B [ C ] * ( B [ C ] - 1 ) // 2 <eos>
487
src = B に C を加えた 値に 2 を加えた 値を A とする
trg = A = B + C + 2
rst = A = B + C + 2 <eos>
488
src = A の 絶対 値を返す
trg = return abs ( A )
rst = return abs ( A ) <eos>
489
src = B に C に 3 を 掛 け た 値 を加えた 値に 1 を加えた 値を A とする
trg = A = B + C * 3 + 1
rst = A = B + C * 3 + 1 <eos>
490
src = A . push ( int ( B ) )
trg = A . push ( int ( B ) )
rst = A . push ( int ( B ) ) <eos>
491
src = B に 1 を加えた 値 から C を 引 いた 値 から B 未 満 までの 数 列 を 順に A として 、 繰り返す
trg = for A in range ( B + 1 - C , B ) :
rst = for A in range ( B + 1 - C , B ) : <eos>
492
src = A の 末 尾 に 入力された 文字列を 空白 で 分割 した 字句 列 のリスト を追加する
trg = A . append ( list ( input ( ) . split ( ) ) )
rst = A . append ( list ( input ( ) . split ( ) ) ) <eos>
493
src = A の 末 尾 に ( 0 ) からなる 列 の B に 2 を加えた 値 回 分 の 列 を追加する
trg = A . append ( [ 0 ] * ( B + 2 ) )
rst = A . append ( [ 0 ] * ( B + 2 ) ) <eos>
494
src = 7 を そうでなければ 、 とする
trg = else = 7
rst = else = 7 <eos>
495
src = A の B の C と 等 しい 要素 の最初の 位置 番 目 を返す
trg = return A [ B . index ( C ) ]
rst = return A [ B . index ( C ) ] <eos>
496
src = A の B 番 目 が C 以下 または D の 1 番 目 が 0 と 等 しい とき 、
trg = if A [ B ] <= C or D [ 1 ] == 0 :
rst = if A [ B ] <= C or D [ 1 ] == 0 : <eos>
497
src = -10 0000 0000 を A とする
trg = A = - 1000000000
rst = A = - 1000000000 <eos>
498
src = B から C に 1000 を 掛 け た 値を 引 いた 値を 500 で 割 った 商 を A とする
trg = A = ( B - C * 1000 ) // 500
rst = A = ( B - C * 1000 ) // 500 <eos>
499
src = E の B から 1 を 引 いた 値 番目の 各要素 を D とし 、 D が C 以下の とき の A の B から 1 を 引 いた 値 番目の C から D を 引 いた 値 番目の 列 の 総 和 を A の B 番目の C 番 目 にする
trg = A [ B ] [ C ] = sum ( [ A [ B - 1 ] [ C - D ] for D in E [ B - 1 ] if D <= C ] )
rst = A [ B ] [ C ] = sum ( [ C - 1 - D [ C - 1 ] for D in E [ B - 1 ] ] ) <eos>
500
src = A に 2 を 掛 け た 値が 7 より 大きい とき 、
trg = if A * 2 > 7 :
rst = if A * 2 > 7 : <eos>
501
src = A の 各要素 を B 、 C 、 D とし 、 ( B 、 C に D を加えた 値 ) の 組 の 列 を A とする
trg = A = [ ( B , C + D ) for B , C , D in A ]
rst = A = [ ( B , C + D ) for B , C , D in A ] <eos>
502
src = convert ( B ) を B とする
trg = B = convert ( B )
rst = B = convert ( B ) <eos>
503
src = A の fct の B 番 目 に A の inv の C 番 目 を 掛 け た 値に A の inv の B から C を 引 いた 値 番 目 を 掛 け た 値を A の mod で 割 った 余 り を返す
trg = return A . fct [ B ] * A . inv [ C ] * A . inv [ B - C ] % A . mod
rst = return A . fct [ B ] * A . inv [ C ] * A . inv [ B - C ] % A . mod <eos>
504
src = A を 空白 文字 に B . official _ house の C 番目の D 番目の E 番目の 文字列 を加えた 値 だけ 増加 させる
trg = A += ' ' + str ( B . official_house [ C ] [ D ] [ E ] )
rst = A += ' ' + B . official_house ( C [ D ] [ E ] ) <eos>
505
src = A が time の 1 番 目 より 小さく かつ B が time の 2 番 目 より 小さい とき 、
trg = if A < time [ 1 ] and B < time [ 2 ] :
rst = if A < time [ 1 ] and B < time [ 2 ] : <eos>
506
src = A 、 B の A 番 目 に C の A 番 目 を加えた 値 を出力する
trg = print ( A , B [ A ] + C [ A ] )
rst = print ( A , B [ A ] + C [ A ] ) <eos>
507
src = B の 0.5 乗 の 整数値 に 1 を加えた 値を A とする
trg = A = int ( B ** 0.5 ) + 1
rst = A = int ( B ** 0.5 ) + 1 <eos>
508
src = A 、 B に C の D から 1 を 引 いた 値 から B を 引 いた 値 番 目 を加えた 値の 最大 値を A とする
trg = A = max ( A , B + C [ D - 1 - B ] )
rst = A = max ( A , B + C [ D - 1 - B ] ) <eos>
509
src = B の F 番目の D 番 目 から B の C 番目の D 番 目 を 引 いた 値を E とする
trg = E = B [ F ] [ D ] - B [ C ] [ D ]
rst = E = B [ F ] [ D ] - B [ C ] [ D ] <eos>
510
src = B の x 座標 に C の x 座標 を 掛 け た 値に B の y 座標 に C の y 座標 を 掛 け た 値 を加えた 値を A とする
trg = A = B . x * C . x + B . y * C . y
rst = A = B . x * C . x + B . y * C . y <eos>
511
src = 0 を A の renew の B 番 目 にする
trg = A . renew [ B ] = 0
rst = A . renew [ B ] = 0 <eos>
512
src = B . dequeue () を A とする
trg = A = B . dequeue ( )
rst = A = B . dequeue ( ) <eos>
513
src = 0 から 16 未 満 までの 数 列 の 各要素 を B とし 、 2 の B 乗 の 列 の 組 を A とする
trg = A = tuple ( [ 2 ** B for B in range ( 16 ) ] )
rst = A = tuple ( [ 2 ** B for B in range ( 16 ) ] ) <eos>
514
src = 0 から 20 1 未 満 までの 数 列 を 順に A として 、 繰り返す
trg = for A in range ( 201 ) :
rst = for A in range ( 201 ) : <eos>
515
src = c ( A . value + B . value ) を返す
trg = return c ( A . value + B . value )
rst = return c ( A . value + B . value ) <eos>
516
src = pp () を 展開 し 、 それぞれ A 、 B とする
trg = A , B = pp ( )
rst = A , B = <unk> ( ) <eos>
517
src = C の 文字列 において 正規表現 A が 最初 にマッチする 位置 を 展開 し 、 それぞれ A 、 B とする
trg = A , B = search ( A , str ( C ) )
rst = A , B = search ( A , C ) <eos>
518
src = A を B の C 番 目 に B の D から C を 引 いた 値 番 目 を 掛 け た 値 だけ 増加 させる
trg = A += B [ C ] * B [ D - C ]
rst = A += B [ C ] * B [ D - C ] <eos>
519
src = A を 1000 で 割 った 余 り を 100 で 割 った 商 が B を 1000 で 割 った 商 と 等 しく または A を 1000 で 割 った 余 り を 100 で 割 った 商 が B を 100 で 割 った 余 り を 10 で 割 った 商 と 等 しく または A を 1000 で 割 った 余 り を 100 で 割 った 商 が B を 10 で 割 った
trg = if ( A % 1000 ) // 100 == B // 1000 or ( A % 1000 ) // 100 == ( B % 100 ) // 10 or ( A % 1000 ) // 100 == B % 10 :
rst = if ( A % 1000 ) // 100 == B // 1000 or ( A % 1000 ) // 100 == B % 1000 or ( A % 100 ) // 10 == B % 1000 or ( A % 100 ) // 10 == B % 1000 ) //
520
src = A の ( B 、 C ) の 組 番 目 を 展開 して を出力する
trg = print ( * A [ ( B , C ) ] )
rst = print ( * A [ ( B , C ) ] ) <eos>
521
src = C の D 番 目 、 C の E 番 目 を A 、 B とする
trg = A , B = C [ D ] , C [ E ]
rst = A , B = C [ D ] , C [ E ] <eos>
522
src = C の B 番 目 に 1 を加えた 値を A の B 番 目 にする
trg = A [ B ] = C [ B ] + 1
rst = A [ B ] = C [ B ] + 1 <eos>
523
src = B の node の C 番 目 を A とする
trg = A = B . node [ C ]
rst = A = B . node [ C ] <eos>
524
src = ( ( 0 、 -3 ) からなる 列 、 ( 0 、 -2 ) からなる 列 、 ( 0 、 -1 ) からなる 列 、 ( 3 、 0 ) からなる 列 、 ( 2 、 0 ) からなる 列 、 ( 1 、 0 ) からなる 列 、 ( 0 、 3 ) からなる 列 、 ( 0 、 2 ) からなる 列 、 ( 0 、 1 ) からなる 列 、 ( -3 、 0 ) からなる 列
trg = for A , B in [ [ 0 , - 3 ] , [ 0 , - 2 ] , [ 0 , - 1 ] , [ 3 , 0 ] , [ 2 , 0 ] , [ 1 , 0 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 0 , 1 ] , [ - 3 , 0 ] , [ - 2 , 0 ] , [ - 1
rst = [ 0 , - 3 ] , [ 0 , - 2 ] , [ 0 , - 1 , 3 ] , [ 0 , 1 ] , [ 0 , 2 ] , [ 0 , 1 ] , [ 0 , 3 ] , [ 0 ,
525
src = A の 末 尾 に 入力された 文字列 の 文字列 を追加する
trg = A . append ( str ( input ( ) ) )
rst = A . append ( input ( ) ) <eos>
526
src = A の先頭 、 A の 1 番 目 、 A の 3 番 目 、 A の 5 番 目 を A の 1 番 目 、 A の 5 番 目 、 A の先頭 、 A の 3 番 目 とする
trg = A [ 1 ] , A [ 5 ] , A [ 0 ] , A [ 3 ] = A [ 0 ] , A [ 1 ] , A [ 3 ] , A [ 5 ]
rst = A [ 0 ] , A [ 1 ] , A [ 5 ] , A [ 0 ] , A [ 3 ] = A [ 0 ] , A [ 1 ] , A [ 3 ] , A [ 5 ] <eos>
527
src = 改行 せずに A を ( B 、 C の B 番目の p ) の 組 で 割 った 余 り を出力する
trg = print ( A % ( B , C [ B ] . p ) , end = '' )
rst = print ( A % ( B , C [ B ] . p ) , end = '' ) <eos>
528
src = B を A の G にする
trg = A . G = B
rst = A . G = B <eos>
529
src = dequeue ( A [ 1 ] )
trg = dequeue ( A [ 1 ] )
rst = dequeue ( A [ 1 ] ) <eos>
530
src = ( B 、 C 、 D 、 E 、 F 、 G ) からなる 列 を A とする
trg = A = [ B , C , D , E , F , G ]
rst = A = [ B , C , D , E , F , G ] <eos>
531
src = ( C 、 D ) の 組 を A の value の B 番 目 にする
trg = A . value [ B ] = ( C , D )
rst = A . value [ B ] = ( C , D ) <eos>
532
src = ネ イ ピ ア 数 を A の B から C を 引 いた 値 番 目 にする
trg = A [ B - C ] = e
rst = A [ B - C ] = e <eos>
533
src = A の長さ が 0 と 等 しく ない とき B を 書式 として C 、 空白 文字 を 間 に 入れ て A の 各要素 に str を適用した 列 を 連結 した 文字列 で 整 形 した 文字列 を出力する 、 そうでなければ " { } : " を出力する
trg = print ( B . format ( C , ' ' . join ( map ( str , A ) ) ) ) if len ( A ) != 0 else print ( {i}: )
rst = print ( B . format ( C , ' ' . join ( map ( str , A ) ) ) ) if len ( A ) != 0 else print ( <unk> ) <eos>
534
src = 関数 d 2 t を d を パラメータ として 定義 する
trg = def d2t ( A ) : return ( A // 100 ) * 60 + ( A % 100 )
rst = def f2 ( B ) : return 2 * A + 100 <eos>
535
src = 0 から C 未 満 までの 数 列 の 各要素 を B とし 、 、 つまり 入力された 文字列 の 整数値 の 列 の 両 端 キュー を A とする
trg = A = deque ( [ int ( input ( ) ) for B in range ( C ) ] )
rst = A = deque ( [ int ( input ( ) ) for B in range ( C ) ] ) <eos>
536
src = 入力された 文字列 の 両 端 から 空白 改行 を取り 除 いた 文字列を 空白 文字 で 分割 した 字句 列 を 展開 し 、 それぞれ A 、 B とする
trg = A , B = input ( ) . strip ( ) . split ( ' ' )
rst = A , B = input ( ) . strip ( ) . split ( ' ' ) <eos>
537
src = 2 、 1 、 0 を A 、 B 、 C とする
trg = A , B , C = 2 , 1 , 0
rst = A , B , C = 2 , 1 , 0 <eos>
538
src = A を 書式 として B から 19 11 を 引 いた 値 で 整 形 した 文字列 を出力する
trg = print ( A . format ( B - 1911 ) )
rst = print ( A . format ( B - 1911 ) ) <eos>
539
src = A の 3 番 目 を A の 1 番 目 にする
trg = A [ 1 ] = A [ 3 ]
rst = A [ 1 ] = A [ 3 ] <eos>
540
src = 0 から 3 未 満 までの 数 列 の 各要素 を E とし 、 D から 読み 込 んだ 一行 の 整数値 の 列 を 展開 し 、 それぞれ A 、 B 、 C とする
trg = A , B , C = [ int ( D . readline ( ) ) for E in range ( 3 ) ]
rst = A , B , C = [ int ( D . readline ( ) ) for E in range ( 3 ) ] <eos>
541
src = -1 を B で 割 った 値を A とする
trg = A = - 1 / B
rst = A = - 1 / B <eos>
542
src = C . cross _ points ( D ) を 展開 し 、 それぞれ A 、 B とする
trg = A , B = C . cross_points ( D )
rst = A , B = C . <unk> ( D ) <eos>
543
src = A の 末 尾 に B の C 番 目 に B の D 番 目 を加えた 値 を追加する
trg = A . append ( B [ C ] + B [ D ] )
rst = A . append ( B [ C ] + B [ D ] ) <eos>
544
src = Node ( None , None , 1, sys . maxsize ) を A とする
trg = A = Node ( None , None , 1 , sys . maxsize )
rst = A = Node ( None , None , 1 , sys . maxsize ) <eos>
545
src = B に C を 掛 け た 値に D を加えた 値を E で 割 った 余 り を A の B 番 目 にする
trg = A [ B ] = ( B * C + D ) % E
rst = A [ B ] = ( B * C + D ) % E <eos>
546
src = A に 100 を 掛 け た 値 を出力する
trg = print ( A * 100 )
rst = print ( A * 100 ) <eos>
547
src = A の 最小 値の 整数値 を出力する
trg = print ( int ( min ( A ) ) )
rst = print ( int ( min ( A ) ) ) <eos>
548
src = A が B の _ parent の C 番 目 と 等 しく なく かつ A が D の C 番 目 と 等 しく ない とき 、
trg = if A != B . _parent [ C ] and A != D [ C ] :
rst = if A != B . _parent [ C ] and A != D [ C ] : <eos>
549
src = 0 から C 未 満 までの 数 列 の 各要素 を D とし 、 0 から C 未 満 までの 数 列 の 各要素 を B とし 、 -1 の 列 の 列 を A とする
trg = A = [ [ - 1 for B in range ( C ) ] for D in range ( C ) ]
rst = A = [ [ - 1 for B in range ( C ) ] for D in range ( C ) ] <eos>
550
src = E を A の ( B 、 C 、 D ) の 組 番 目 にする
trg = A [ ( B , C , D ) ] = E
rst = A [ ( B , C , D ) ] = E <eos>
551
src = A が B と 等 しい かどうか
trg = A == B
rst = A == B <eos>
552
src = countingSort ( A , B )
trg = countingSort ( A , B )
rst = <unk> ( A , B ) <eos>
553
src = date ( B , C , D ) を A とする
trg = A = date ( B , C , D )
rst = A = date ( B , C , D ) <eos>
554
src = A が B と 等 しく なく かつ ( A 、 B ) の 組 の 各要素 を C とし 、 C が ( 1 、 2 ) の 組 に含まれる かどうか の 列 が 全て が 真 の とき 、
trg = if A != B and all ( [ C in ( 1 , 2 ) for C in ( A , B ) ] ) :
rst = if A != B and all ( [ ( C , 1 ) in 2 for C in B ] ) : <eos>
555
src = A を 1 を ネ イ ピ ア 数 から 1 を 引 いた 値 だけ 左 シフト した 値 と の 論理 和 にする
trg = A |= 1 << ( e - 1 )
rst = A |= 1 << ( e - 1 ) <eos>
556
src = ( ( B , 0 ) 、 ( ( C から 1 を 引 いた 値 、 D から 1 を 引 いた 値 、 E から 1 を 引 いた 値 、 F から 1 を 引 いた 値 ) の 組 , 0 ) ) からなる 辞書 を A とする
trg = A = { key : 0 , (kx-1, ky-1, tx-1, ty-1) : 0 }
rst = A = { <unk> : 0 , <unk> : 1 , <unk> - 1 , <unk> : - 1 , <unk> : 0 } <eos>
557
src = _ lca ( A [ B ] [ C -1 ] , A [ D ] [ C -1 ] ) を返す
trg = return _lca ( A [ B ] [ C - 1 ] , A [ D ] [ C - 1 ] )
rst = return <unk> ( A [ B ] [ C - 1 ] , A [ D ] [ C - 1 ] ) <eos>
558
src = ( B から 1 を 引 いた 値 ) からなる 列 の 両 端 キュー を A とする
trg = A = deque ( [ B - 1 ] )
rst = A = deque ( [ B - 1 ] ) <eos>
559
src = A の B に C の B 番 目 を加えた 値を D で 割 った 余 り 番目の 末 尾 に B を追加する
trg = A [ ( B + C [ B ] ) % D ] . append ( B )
rst = A [ ( B + C [ B ] ) % D ] . append ( B ) <eos>
560
src = B の C の D 番目の E 番 目 番 目 を A とする
trg = A = B [ C [ D ] [ E ] ]
rst = A = B [ C [ D ] [ E ] ] <eos>
561
src = A の先頭 から B の先頭 を 探 して 見つかった 位置
trg = A . find ( B [ 0 ] )
rst = A . find ( B . find ( ) ) <eos>
562
src = E の F 番 目 を 空白 で 分割 した 字句 列 の 各要素 を D とし 、 D の 整数値 の 列 を 展開 し 、 それぞれ A 、 B 、 C とする
trg = A , B , C = [ int ( D ) for D in E [ F ] . split ( ) ]
rst = A , B , C = [ int ( D ) for D in E [ F ] . split ( ) ] <eos>
563
src = A の d の 4 番 目 、 A の d の 1 番 目 、 A の d の 3 番 目 、 A の d の 6 番 目 を A の d の 1 番 目 、 A の d の 3 番 目 、 A の d の 6 番 目 、 A の d の 4 番 目 とする
trg = A . d [ 1 ] , A . d [ 3 ] , A . d [ 6 ] , A . d [ 4 ] = A . d [ 4 ] , A . d [ 1 ] , A . d [ 3 ] , A . d [ 6 ]
rst = A . d [ 1 ] , A . d [ 3 ] , A . d [ 4 ] , A . d [ 6 ] = A . d [ 4 ] , A . d [ 1 ] , A . d [ 3 ] , A
564
src = A を ( B から C * D を 引 いた 値を E で 割 った 値 、 D ) の 組 で 割 った 余 り を出力する
trg = print ( A % ( ( B - C * D ) / E , D ) )
rst = print ( A % ( ( B - C * D ) / E , D ) ) <eos>
565
src = ( ( 0 、 0 ) の 組 、 ( 1 、 0 ) の 組 、 ( 0 、 1 ) の 組 、 ( -1 、 0 ) の 組 、 ( 0 、 -1 ) の 組 ) の 組 を A とする
trg = A = ( ( 0 , 0 ) , ( 1 , 0 ) , ( 0 , 1 ) , ( - 1 , 0 ) , ( 0 , - 1 ) )
rst = A = ( ( 0 , 0 ) , ( 1 , 0 ) , ( 0 , 1 ) , ( - 1 , 0 ) , ( 0 , - 1 ) ) <eos>
566
src = B を A の _ size にする
trg = A . _size = B
rst = A . _size_ = B <eos>
567
src = 1 を 開始 番号 として C の先頭 を 除 いた 部分 列 に 番号 付 した 組 の 列 を 順に A 、 B として 、 繰り返す
trg = for A , B in enumerate ( C [ 1 : ] , start = 1 ) :
rst = for A , B in enumerate ( C [ 1 : ] , start = 1 ) : <eos>
568
src = 0 、 空文字列 、 1 を A 、 B 、 C とする
trg = A , B , C = 0 , '' , 1
rst = A , B , C = 0 , '' , 1 <eos>
569
src = (1) からなる 列 の 500 21 回 分 の 列 を A とする
trg = A = [ 1 ] * 50021
rst = A = [ 1 ] * 50021 <eos>
570
src = ( ( 0 、 0 ) の 組 、 ( -1 、 0 ) の 組 、 ( 1 、 0 ) の 組 、 ( 0 、 -1 ) の 組 、 ( 0 、 1 ) の 組 ) からなる 列 を 順に A 、 B として 、 繰り返す
trg = for A , B in [ ( 0 , 0 ) , ( - 1 , 0 ) , ( 1 , 0 ) , ( 0 , - 1 ) , ( 0 , 1 ) ] :
rst = for A , B in [ ( 0 , 0 ) , ( - 1 , 0 ) , ( 1 , 0 ) , ( 0 , - 1 ) , ( 0 , 1 ) ] : <eos>
571
src = ( ( 、 つまり 空 列 、 空 列 、 空 列 ) からなる 列 、 ( 、 つまり 空 列 、 空 列 、 空 列 ) からなる 列 、 ( 、 つまり 空 列 、 空 列 、 空 列 ) からなる 列 、 ( 、 つまり 空 列 、 空 列 、 空 列 ) からなる 列 ) からなる 列 を A とする
trg = A = [ [ [ ] , [ ] , [ ] ] , [ [ ] , [ ] , [ ] ] , [ [ ] , [ ] , [ ] ] , [ [ ] , [ ] , [ ] ] ]
rst = A = [ [ ] , [ ] , [ [ ] , [ ] , [ ] , [ ] , [ ] , [ ] , [ ] ] , [ ] ] <eos>
572
src = 1 を 無限 の 整数 列 とする
trg = count = 1
rst = count = 1 <eos>
573
src = A . add _ edge ( 2 * B , 2 * C , 1, 0 )
trg = A . add_edge ( 2 * B , 2 * C , 1 , 0 )
rst = A . add_edge ( 2 * B , 2 * C , 1 , 0 ) <eos>
574
src = cross _ point ( B , C , D , E ) を A とする
trg = A = cross_point ( B , C , D , E )
rst = A = cross_point ( B , C , D , E ) <eos>
575
src = D から E を 引 いた 値の 絶対 値 、 F から G を 引 いた 値の 絶対 値 、 H から I を 引 いた 値の 絶対 値を A 、 B 、 C とする
trg = A , B , C = abs ( D - E ) , abs ( F - G ) , abs ( H - I )
rst = A , B , C = abs ( D - E ) , abs ( F - G ) , abs ( H - I ) <eos>
576
src = A . weight ( B , C ) を出力する
trg = print ( A . weight ( B , C ) )
rst = print ( A . weight ( B , C ) ) <eos>
577
src = 0 から 10 未 満 までの 数 列 の 各要素 を B とし 、 0 から 100 1 未 満 までの 数 列 の 各要素 を B とし 、 0 の 列 の 列 を A とする
trg = A = [ [ 0 for B in range ( 1001 ) ] for B in range ( 10 ) ]
rst = A = [ [ 0 for B in range ( 1001 ) ] for B in range ( 10 ) ] <eos>
578
src = A を 書式 として B と C の 論理 積 で 整 形 した 文字列 を出力する
trg = print ( A . format ( B & C ) )
rst = print ( A . format ( B & C ) ) <eos>
579
src = B から 1 を 引 いた 値 から 0 未 満 までの -1 間隔 の 数 列 を 順に A として 、 繰り返す
trg = for A in range ( B - 1 , 0 , - 1 ) :
rst = for A in range ( B - 1 , 0 , - 1 ) : <eos>
580
src = -1 に A の B 番 目 を 掛 け た 値を A の B 番 目 にする
trg = A [ B ] = - 1 * A [ B ]
rst = A [ B ] = - 1 * A [ B ] <eos>
581
src = 2 から B に 1 を加えた 値の 0.5 乗 を 四 捨 五 入 した 整数値 の 整数値 未 満 までの 数 列 を 順に A として 、 繰り返す
trg = for A in range ( 2 , int ( round ( pow ( B + 1 , 0.5 ) ) ) ) :
rst = for A in range ( round ( ( 2 , B + 1 ) ** 0.5 ) ) : <eos>
582
src = A の wait を出力する
trg = print ( A . wait )
rst = print ( A . wait ) <eos>
583
src = 入力された 文字列を 空白 で 分割 した 字句 列 の 各要素 に x を パラメータ として ( B の先頭 、 B [ 1 ] の 整数値 ) の 組 を返す関数 を適用した 列 の リストを A とする
trg = A = list ( map ( lambda B : ( B [ 0 ] , int ( B [ 1 ] ) ) , input ( ) . split ( ) ) )
rst = A = list ( map ( lambda B : ( B [ 0 ] , B [ 1 ] ) , input ( ) . split ( ) ) ) <eos>
584
src = B に C を 掛 け た 値 から D に E を 掛 け た 値を 引 いた 値を E に F を 掛 け た 値 から C に G を 掛 け た 値を 引 いた 値 で 割 った 値を A とする
trg = A = ( B * C - D * E ) / ( E * F - C * G )
rst = A = ( B * C - D * E ) / ( E * F - C * G ) <eos>
585
src = A の B から 1 を 引 いた 値 番 目 と A の B 番 目 を 入れ替え る
trg = A [ B - 1 ] , A [ B ] = A [ B ] , A [ B - 1 ]
rst = A [ B - 1 ] , A [ B - 1 ] = A [ B - 1 ] , A [ B - 1 ] <eos>
586
src = B を C に D を加えた 値 で 割 った 余 り を A とする
trg = A = B % ( C + D )
rst = A = B % ( C + D ) <eos>
587
src = ( A 、 B ) の 組 が ( C 、 D ) の 組 と 等 しい とき 、
trg = if ( A , B ) == ( C , D ) :
rst = if ( A , B ) == ( C , D ) : <eos>
588
src = B を _ pow ( 10 , 40 ) で 割 った 商 を A とする
trg = A = B // _pow ( 10 , 40 )
rst = A = B // _pow ( 10 , 40 ) <eos>
589
src = A を ( 5 、 4 、 3 、 2 、 1 、 0 、 1 、 2 、 3 、 4 、 5 ) からなる 列 だけ 増加 させる
trg = A += [ 5 , 4 , 3 , 2 , 1 , 0 , 1 , 2 , 3 , 4 , 5 ]
rst = A += [ 5 , 4 , 3 , 2 , 1 , 0 , 1 , 2 , 3 , 4 , 5 ] <eos>
590
src = C の先頭 の 2 番 目 を A の B 番 目 にする
trg = A [ B ] = C [ 0 ] [ 2 ]
rst = A [ B ] = C [ 0 ] [ 2 ] <eos>
591
src = 0 が A 以下 かどうか が B より 小さく かつ 0 が C 以下 かどうか が D より 小さく かつ E が 0 と 等 しく かつ F [ min ( A , A - G ) ] [ H ] が 0 と 等 しく または G が 0 と 等 しく かつ I [ J ] [ min ( C , C - E ) ] が 0 と 等 しく かつ K の A 番目の C 番
trg = if 0 <= A < B and 0 <= C < D and ( ( E == 0 and F [ min ( A , A - G ) ] [ H ] == 0 ) or ( G == 0 and I [ J ] [ min ( C , C - E ) ] == 0 ) ) and K [ A ] [ C ] == - 1 :
rst = if ( 0 <= A < B and 0 <= C < D ) and ( E == F and min ( G [ A ] [ 0 ] == H ) or ( A , C - 1 ) == 0 or ( A , E - 1 )
592
src = A の 末 尾 に B から C を 引 いた 値の 絶対 値 を追加する
trg = A . append ( abs ( B - C ) )
rst = A . append ( abs ( B - C ) ) <eos>
593
src = dfs ( A . index ( -1 ) )
trg = dfs ( A . index ( - 1 ) )
rst = dfs ( A . index ( - 1 ) ) <eos>
594
src = C を A の FaceValue の B 番 目 にする
trg = A . FaceValue [ B ] = C
rst = A . FaceValue [ B ] = C <eos>
595
src = 1 を C の B 番 目 とする を A の B 番 目 にする
trg = A [ B ] = C [ B ] = 1
rst = A [ B ] = C [ B ] = 1 <eos>
596
src = A の 末 尾 に pos ( B [ C * 2 ] , B [ C * 2 + 1 ] ) を追加する
trg = A . append ( pos ( B [ C * 2 ] , B [ C * 2 + 1 ] ) )
rst = A . append ( B . pos [ C * 2 ] , B [ C * 2 + 1 ] ) <eos>
597
src = 0 から B に B から 1 を 引 いた 値を 掛 け た 値を 2 で 割 った 商 未 満 までの 数 列 を 順に A として 、 繰り返す
trg = for A in range ( B * ( B - 1 ) // 2 ) :
rst = for A in range ( B * ( B - 1 ) // 2 ) : <eos>
598
src = B の C 番 目 から D の E 番 目 を 引 いた 値を A とする
trg = A = B [ C ] - D [ E ]
rst = A = B [ C ] - D [ E ] <eos>
599
src = 0 から C 未 満 までの 数 列 の 各要素 を D とし 、 0 から C 未 満 までの 数 列 の 各要素 を B とし 、 0 の 列 の 列 を A とする
trg = A = [ [ 0 for B in range ( C ) ] for D in range ( C ) ]
rst = A = [ [ 0 for B in range ( C ) ] for D in range ( C ) ] <eos>
600
src = A 、 B を 開 いた ファイル ストリーム を sys の stdin にする
trg = sys . stdin = open ( A , B )
rst = sys . stdin = A , B <eos>
601
src = A の B 番目の 間 、 次 を 繰り返す
trg = while A [ B ] :
rst = while A [ B ] : <eos>
602
src = A の 各要素 に x を パラメータ として x に B の先頭 を 掛 け た 値を返す 関数 を適用した 列 の リストを A とする
trg = A = list ( map ( lambda C : C * B [ 0 ] , A ) )
rst = A = list ( map ( lambda B : B * B [ 0 ] , A ) ) <eos>
603
src = A から B の 総 和 を 引 いた 値 を出力する
trg = print ( A - sum ( B ) )
rst = print ( A - sum ( B ) ) <eos>
604
src = ( 1 、 10 、 11 、 12 、 13 ) からなる 列 を A とする
trg = A = [ 1 , 10 , 11 , 12 , 13 ]
rst = A = [ 1 , 10 , 11 , 12 , 13 ] <eos>
605
src = cross ( A - B , C - D ) の 絶対 値が 1 e -10 より 小さい とき E 、 そうでなければ F を出力する
trg = print ( E if abs ( cross ( A - B , C - D ) ) < 1e-10 else F )
rst = print ( E if abs ( cross ( A - B , C - D ) ) < 1e-10 else F ) <eos>
606
src = 0 から B の ビット 長 から 1 を 引 いた 値 未 満 までの 数 列 を 順に A として 、 繰り返す
trg = for A in range ( B . bit_length ( ) - 1 ) :
rst = for A in range ( B . bit_length ( ) - 1 ) : <eos>
607
src = A が 0 と 等 しく なく かつ B が 0 と 等 しく ない とき 、
trg = if A != 0 and B != 0 :
rst = if A != 0 and B != 0 : <eos>
608
src = ( A 内の B の 出現 回数 、 A の 末 尾 ) の 組 を返す
trg = return ( A . count ( B ) , A [ - 1 ] )
rst = return ( A . count ( B ) , A [ - 1 ] ) <eos>
609
src = A の B 番目の C 番目の D 番 目 を 1 だけ 減少 させる
trg = A [ B ] [ C ] [ D ] -= 1
rst = A [ B ] [ C ] [ D ] -= 1 <eos>
610
src = A の cap を B だけ 減少 させる
trg = A . cap -= B
rst = A . cap -= B <eos>
611
src = A が 1 25 以下の とき 、
trg = if A <= 125 :
rst = if A <= 125 : <eos>
612
src = A . query ( ( B -1 ) / /2 , C , D ) を返す
trg = return A . query ( ( B - 1 ) // 2 , C , D )
rst = return A . query ( ( B - 1 ) // 2 , C , D ) <eos>
613
src = 入力された 文字列を 空白 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 を 展開 し 、 それぞれ A 、 B 、 C 、 D 、 E とする
trg = A , B , C , D , E = map ( int , input ( ) . split ( ) )
rst = A , B , C , D , E = map ( int , input ( ) . split ( ) ) <eos>
614
src = A が B と 等 しく または A が ( 1 、 10 、 11 、 12 、 13 ) からなる 列 と 等 しい とき 、
trg = if A == B or A == [ 1 , 10 , 11 , 12 , 13 ] :
rst = if A == B or A == [ 1 , 10 , 11 , 12 , 13 ] : <eos>
615
src = A に B を 掛 け た 値 から C を 引 いた 値が 0 以上の とき A * B から C を 引 いた 値を D で 割 った 値の 切り 上げ 整数値 、 そうでなければ 0 を出力する
trg = print ( math . ceil ( ( A * B - C ) / D ) if A * B - C >= 0 else 0 )
rst = print ( math . ceil ( ( A * B - C ) / math . ceil ( ( A * B - C ) / D ) ) if A * B - C >= 0 else 0 ) <eos>
616
src = A 、 B の C 番目の D に 1 を加えた 値 番 目 に B の D に 1 を加えた 値 番目の E に 1 を加えた 値 番 目 を加えた 値の 最小 値を A とする
trg = A = min ( A , B [ C ] [ D + 1 ] + B [ D + 1 ] [ E + 1 ] )
rst = A = min ( A , B [ C ] [ D + 1 ] + B [ D + 1 ] [ E + 1 ] ) <eos>
617
src = A の 、 つまり 先頭 から 2 番 目 までの 部分 列 が B と 等 しく かつ A の 、 つまり 末 尾 から 、 つまり 末 尾 までの 部分 列 が C と 等 しい とき 、
trg = if A [ 0 : 2 ] == B and A [ - 1 : ] == C :
rst = if A [ : 2 ] == B and A [ - 1 : ] == C : <eos>
618
src = D の B 番 目 を A の mp の B 番目の C 番 目 にする
trg = A . mp [ B ] [ C ] = D [ B ]
rst = A . mp [ B ] [ C ] = D [ B ] <eos>
619
src = 0 が - A 以下 かどうか が B 以下の とき 、
trg = if 0 <= - A <= B :
rst = if 0 <= - A <= B : <eos>
620
src = 空 辞書 を A の pages にする
trg = A . pages = { }
rst = A . pages = { } <eos>
621
src = 0 から 3 未 満 までの 数 列 の 各要素 を B とし 、 、 つまり 入力された 文字列を 空白 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 のリスト の 列 を A とする
trg = A = [ list ( map ( int , input ( ) . split ( ) ) ) for B in range ( 3 ) ]
rst = A = [ list ( map ( int , input ( ) . split ( ) ) ) for B in range ( 3 ) ] <eos>
622
src = solver ( A , B , C , D [ : E ] + [ F ] + D [ E + 1 : ] ) の とき 、
trg = if solver ( A , B , C , D [ : E ] + [ F ] + D [ E + 1 : ] ) :
rst = if <unk> ( A , B , C , D [ E : ] + F [ D + E : ] ) : <eos>
623
src = A が B の forest に 含まれ ない とき 、
trg = if A not in B . forest :
rst = if A not in B . forest : <eos>
624
src = 入力された 文字列を 空白 で 分割 した 字句 列 の 各要素 を C とし 、 C の 整数値 の 列 を 展開 し 、 それぞれ A 、 B とする
trg = A , B = [ int ( C ) for C in input ( ) . split ( ) ]
rst = A , B = [ int ( C ) for C in input ( ) . split ( ) ] <eos>
625
src = A と 1 を B だけ 左 シフト した 値の 論理 積 の とき 、
trg = if A & ( 1 << B ) :
rst = if A & ( 1 << B ) : <eos>
626
src = A . add _ edge ( B , C + D , 1, E )
trg = A . add_edge ( B , C + D , 1 , E )
rst = A . add_edge ( B , C + D , 1 , E ) <eos>
627
src = D を A の B に 2 を加えた 値 番目の C 番 目 にする
trg = A [ B + 2 ] [ C ] = D
rst = A [ B + 2 ] [ C ] = D <eos>
628
src = func ( A )
trg = func ( A )
rst = func ( A ) <eos>
629
src = df _ lower _ search ( A , 0 , B , C , None ) の とき 、
trg = if df_lower_search ( A , 0 , B , C , None ) :
rst = if df_lower_search ( A , 0 , B , C , None ) : <eos>
630
src = F を default として 0 から D 未 満 までの 数 列 の 各要素 を C とし 、 E が C と 等 しく ない とき の B の C 番目の 列 の 最大 値 、 F の 最大 値を A とする
trg = A = max ( max ( ( [ B [ C ] for C in range ( D ) if E != C ] ) , default = F ) , F )
rst = A = max ( min ( [ B [ C ] for C in range ( D ) if E != C ] ) , default = F ) , F ) <eos>
631
src = B に C を 掛 け た 値に D を 掛 け た 値を E で 割 った 値を A とする
trg = A = B * C * D / E
rst = A = B * C * D / E <eos>
632
src = A の 2 番 目 、 A の 1 番 目 を A の 1 番 目 、 A の 2 番 目 とする
trg = A [ 1 ] , A [ 2 ] = A [ 2 ] , A [ 1 ]
rst = A [ 1 ] , A [ 2 ] = A [ 2 ] , A [ 1 ] <eos>
633
src = 1000 から B を 引 いた 値 から 1 を 引 いた 値に 195 を 掛 け た 値を A とする
trg = A = ( 1000 - B - 1 ) * 195
rst = A = ( 1000 - B - 1 ) * 195 <eos>
634
src = A の B から 1 を 引 いた 値 番 目 、 A の B に 1 を加えた 値 番 目 を出力する
trg = print ( A [ B - 1 ] , A [ B + 1 ] )
rst = print ( A [ B - 1 ] , A [ B + 1 ] ) <eos>
635
src = A が B の C 番 目 に 含まれ かつ D が B の C 番 目 に含まれる とき 、
trg = if A in B [ C ] and D in B [ C ] :
rst = if A in B [ C ] and D in B [ C ] : <eos>
636
src = A の distance の B 番目の C 番 目 、 A の distance の B 番目の D 番 目 に A の distance の D 番目の C 番 目 を加えた 値の 最小 値を A の distance の B 番目の C 番 目 にする
trg = A . distance [ B ] [ C ] = min ( A . distance [ B ] [ C ] , A . distance [ B ] [ D ] + A . distance [ D ] [ C ] )
rst = A . distance [ B ] [ C ] = min ( A . distance [ B ] [ C ] , A . distance [ B ] [ D ] + A . distance [ D ] [ C ] ) <eos>
637
src = dfs ( B , C , 0 , 0 , 0 , D + 1 ) を A とする
trg = A = dfs ( B , C , 0 , 0 , 0 , D + 1 )
rst = A = dfs ( B , C , 0 , 0 , D + 1 ) <eos>
638
src = A に 1 を加えた 値の 文字列 に B を加えた 値に C の A 番 目 を加えた 値 を出力する
trg = print ( str ( A + 1 ) + B + C [ A ] )
rst = print ( str ( A + 1 ) + B + C [ A ] ) <eos>
639
src = A の長さ が 0 と 等 しく なく または B が 、 つまり 偽 と 等 しい とき 、
trg = if len ( A ) != 0 or B == False :
rst = if len ( A ) != 0 or B == False : <eos>
640
src = get _ cycle ( B , C , D ) を A とする
trg = A = get_cycle ( B , C , D )
rst = A = find_cycle ( B , C , D ) <eos>
641
src = ( B ) からなる 列 に 0 から 4 未 満 までの 数 列 の 各要素 を D とし 、 C . readline () を 空白 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 の 総 和 の 列 を加えた 値を A とする
trg = A = [ B ] + [ sum ( map ( int , C . readline ( ) . split ( ) ) ) for D in range ( 4 ) ]
rst = A = [ B ] + [ sum ( map ( int , C . readline ( ) . split ( ) ) ) for D in range ( 4 ) ] <eos>
642
src = A が B の C の先頭 番 目 に D を 掛 け た 値 より 小さい 間 、 次 を 繰り返す
trg = while A < B [ C [ 0 ] ] * D :
rst = while A < B [ C [ 0 ] ] * D : <eos>
643
src = A から 25 に B を 掛 け た 値を 引 いた 値を A とする
trg = A = A - 25 * B
rst = A = A - 25 * B <eos>
644
src = 0 から B 未 満 までの 数 列 の 各要素 を C とし 、 0 から B 未 満 までの 数 列 の集合 の 列 を A とする
trg = A = [ set ( range ( B ) ) for C in range ( B ) ]
rst = A = set ( [ range ( B ) for C in range ( B ) ] ) <eos>
645
src = -10 の 18 乗 を A とする
trg = A = - 10 ** 18
rst = A = - 10 ** 18 <eos>
646
src = 入力された 文字列 に 2 を 掛 け た 値 の先頭 から 、 つまり 入力された 文字列を 探 して 見つかった 位置 が -1 より 大きい とき A を出力する 、 そうでなければ B を出力する
trg = print ( A ) if ( input ( ) * 2 ) . find ( input ( ) ) > - 1 else print ( B )
rst = print ( A if input ( ) * 2 - re . find ( input ( ) ) > - 1 else B ) <eos>
647
src = ( ( B 、 未 定 値 、 0 ) の 組 ) からなる 列 を A とする
trg = A = [ ( B , None , 0 ) ]
rst = A = [ ( B , None , 0 ) ] <eos>
648
src = put _ queen _ in _ row ( A + 1 ) を返す
trg = return put_queen_in_row ( A + 1 )
rst = return put_queen_in_row ( A + 1 ) <eos>
649
src = 9 、 B の 最小 値を A とする
trg = A = min ( 9 , B )
rst = A = min ( 9 , B ) <eos>
650
src = A . _ is _ red ( B . left ) かつ A . _ is _ red ( B . left . left ) の とき 、
trg = if A . _is_red ( B . left ) and A . _is_red ( B . left . left ) :
rst = if A . _is_red ( B . left ) and A . _is_red ( B . left . left ) : <eos>
651
src = attack ( A , B , C )
trg = attack ( A , B , C )
rst = <unk> ( A , B , C ) <eos>
652
src = B の 2 個 までの コン ビ ネ ー ション を A とする
trg = A = combinations ( B , 2 )
rst = A = itertools . combinations ( B , 2 ) <eos>
653
src = A を B の C の 末 尾 番目の 末 尾 だけ 増加 させる
trg = A += B [ C [ - 1 ] ] [ - 1 ]
rst = A += B [ C [ - 1 ] ] [ - 1 ] <eos>
654
src = B に C を 掛 け た 値に D の 正 弦 を 掛 け た 値に 0.5 を 掛 け た 値を A とする
trg = A = B * C * sin ( D ) * 0.5
rst = A = B * C * math . sin ( D ) * 0.5 <eos>
655
src = D の FREE を A の B に C を加えた 値 番 目 にする
trg = A [ B + C ] = D . FREE
rst = A [ B + C ] = D . FREE <eos>
656
src = B の C 番目の D 番 目 に 2 を加えた 値が B の C に 1 を加えた 値 番目の D 番 目 と 等 しい かどうか を A とする
trg = A = ( B [ C ] [ D ] + 2 == B [ C + 1 ] [ D ] )
rst = A = ( B [ C ] [ D ] + 2 == B [ C + 1 ] [ D ] ) <eos>
657
src = A に B を 掛 け た 値に C に D を 掛 け た 値 を加えた 値に 0 . 8 を 掛 け た 値の 整数値 を出力する
trg = print ( int ( ( A * B + C * D ) * 0.8 ) )
rst = print ( int ( ( A * B + C * D ) * 0.8 ) ) <eos>
658
src = A から 1 を 引 いた 値が B より 小さい とき 、
trg = if A - 1 < B :
rst = if A - 1 < B : <eos>
659
src = A の 、 つまり 先頭 から 2 番 目 までの 部分 列 が B と 等 しく かつ A の -2 番 目 から 、 つまり 末 尾 までの 部分 列 が C と 等 しい とき 、
trg = if A [ 0 : 2 ] == B and A [ - 2 : ] == C :
rst = if A [ : 2 ] == B and A [ - 2 : ] == C : <eos>
660
src = H の 各要素 を C とし 、 ( B + 27 * ( C - e ) == D ) に ( E + 9 * ( C - e ) == D ) を加えた 値に F + 3 * ( C - e ) が D と 等 しい かどうか を加えた 値に G に ( C - e ) を加えた 値が D と 等 しい かどうか を加えた 値の 列 の 最大 値を A とする
trg = A = max ( [ ( B + 27 * ( C - e ) == D ) + ( E + 9 * ( C - e ) == D ) + ( F + 3 * ( C - e ) == D ) + ( G + ( C - e ) == D ) for C in H ] )
rst = A = max ( [ ( B + 27 * ( C - e ) + ( D ) * ( E - F ) + ( C + e ) * ( D - F ) + ( e - D ) * ( C - e ) +
661
src = A に B を 掛 け た 値が 100 に C を 掛 け た 値 より 小さい かどうか を返す
trg = return A * B < 100 * C
rst = return A * B < 100 * C <eos>
662
src = A の graph の B 番目の C 番目の 2 番 目 を D だけ 増加 させる
trg = A . graph [ B ] [ C ] [ 2 ] += D
rst = A . graph [ B ] [ C ] [ 2 ] += D <eos>
663
src = A の 1 番 目 が B の 1 番 目 と 等 しい かどうか が C の 1 番 目 と 等 しい とき 、
trg = if A [ 1 ] == B [ 1 ] == C [ 1 ] :
rst = if A [ 1 ] == B [ 1 ] == C [ 1 ] : <eos>
664
src = ( C 、 D ) の 組 を A の B から 3 を 引 いた 値 番 目 にする
trg = A [ B - 3 ] = ( C , D )
rst = A [ B - 3 ] = ( C , D ) <eos>
665
src = 0 を A の length にする
trg = A . length = 0
rst = A . length = 0 <eos>
666
src = get ( B , C , D , E , F , 2 ) の コピー された 列 を A とする
trg = A = get ( B , C , D , E , F , 2 ) [ : ]
rst = A = get ( B , C , D , E , F , 2 ) [ : ] <eos>
667
src = B の 末 尾 から B の先頭 を 引 いた 値を A とする
trg = A = B [ - 1 ] - B [ 0 ]
rst = A = B [ - 1 ] - B [ 0 ] <eos>
668
src = D に 1 を加えた 値を A の B 番目の C 番 目 にする
trg = A [ B ] [ C ] = D + 1
rst = A [ B ] [ C ] = D + 1 <eos>
669
src = 整数 、 A の B 番 目 が 全て 数字 かどうか が 、 つまり 真 と 等 しい とき 、
trg = if str . isnumeric ( A [ B ] ) == True :
rst = if str , A [ B ] . isdigit ( ) : <eos>
670
src = 区切り なしで 改行 せずに A に - B を 掛 け た 値 を出力する
trg = print ( A * ( - B ) , sep = '' , end = '' )
rst = print ( A * - B , sep = '' , end = '' ) <eos>
671
src = A の値 の集まり の 最大 値を返す
trg = return max ( A . values ( ) )
rst = return max ( A . values ( ) ) <eos>
672
src = 0 から C の長さ 未 満 までの 数 列 の 各要素 を B とし 、 、 つまり 空文字列 の 列 を A とする
trg = A = [ '' for B in range ( len ( C ) ) ]
rst = A = [ '' for B in range ( len ( C ) ) ] <eos>
673
src = ( ( B , 1 から 5 未 満 までの 数 列 の 各要素 を B とし 、 ( [ 0 ] の 10 回 分 の 列 、 [ 0 ] の 10 回 分 の 列 、 [ 0 ] の 10 回 分 の 列 ) からなる 列 の 列 ) ) からなる 辞書 を A とする
trg = A = { b : [ [ [ 0 ] * 10 , [ 0 ] * 10 , [ 0 ] * 10 ] for B in range ( 1 , 5 ) ] }
rst = A = { idx : [ [ 0 ] * [ 10 for B in range ( 10 ) ] ] * [ 0 for B in range ( 5 ) ] <eos>
674
src = B の 4 番 目 を A の 4 番 目 にする
trg = A [ 4 ] = B [ 4 ]
rst = A [ 4 ] = B [ 4 ] <eos>
675
src = B の pos の長さ を A とする
trg = A = len ( B . pos )
rst = A = len ( B . pos ) <eos>
676
src = C を A の B に 1 を加えた 値 番 目 にする
trg = A [ B + 1 ] = C
rst = A [ B + 1 ] = C <eos>
677
src = ( 7 から A を 引 いた 値 、 B 、 C ) の 組 を返す
trg = return ( 7 - A , B , C )
rst = return ( 7 - A , B , C ) <eos>
678
src = write ( A % sum ( B ) )
trg = write ( A % sum ( B ) )
rst = write ( A % sum ( B ) ) <eos>
679
src = segmentTree ( B , C , sentinel = 0 ) を A とする
trg = A = segmentTree ( B , C , sentinel = 0 )
rst = A = <unk> ( B , C , <unk> = 0 ) <eos>
680
src = A が 全て アルファベット かつ A が B に 含まれ ない とき 、
trg = if A . isalpha ( ) and A not in B :
rst = if A . isalpha ( ) and A not in B : <eos>
681
src = 0 から A 未 満 までの 数 列 の 各要素 を B とし 、 A - B から 1 を 引 いた 値に C の B 番 目 を 掛 け た 値の 列 の 総 和 を出力する
trg = print ( sum ( [ ( A - B - 1 ) * C [ B ] for B in range ( A ) ] ) )
rst = print ( sum ( [ ( A - B - 1 ) * C [ B ] for B in range ( A ) ] ) ) <eos>
682
src = A の B 番目の C 番目の D 番 目 を A の B から 1 を 引 いた 値 番目の E 番目の F 番 目 を 4 で 割 った 値 だけ 増加 させる
trg = A [ B ] [ C ] [ D ] += A [ B - 1 ] [ E ] [ F ] / 4
rst = A [ B ] [ C ] [ D ] += A [ B - 1 ] [ E ] [ F ] / 4 <eos>
683
src = A を A と B の 最大 公 約 数 で 割 った 商 に B を 掛 け た 値を返す
trg = return A // gcd ( A , B ) * B
rst = return A // gcd ( A , B ) * B <eos>
684
src = A を 間 に 入れ て C の 各要素 を B とし 、 、 つまり 改行 文字 を 間 に 入れ て B の 各要素 に str を適用した 列 を 連結 した 文字列 の 列 を 連結 した 文字列 を出力する
trg = print ( A . join ( [ '\n' . join ( map ( str , B ) ) for B in C ] ) )
rst = print ( A . join ( [ '\n' . join ( map ( str , B ) ) for B in C ] ) ) <eos>
685
src = A の bit の 末 尾 に 0 を追加する
trg = A . bit . append ( 0 )
rst = A . bit . append ( 0 ) <eos>
686
src = 入力された 文字列を D で 分割 した 字句 列 の 各要素 を C とし 、 C の 整数値 の 列 を 展開 し 、 それぞれ A 、 B とする
trg = A , B = [ int ( C ) for C in input ( ) . split ( D ) ]
rst = A , B = [ int ( C ) for C in input ( ) . split ( D ) ] <eos>
687
src = A が -1 より 大きい とき 、
trg = if A > - 1 :
rst = if A > - 1 : <eos>
688
src = A の B 番 目 、 A の B に 1 を加えた 値 番目の 最小 値を A の B に 1 を加えた 値 番 目 にする
trg = A [ B + 1 ] = min ( A [ B ] , A [ B + 1 ] )
rst = A [ B + 1 ] = min ( A [ B ] , A [ B + 1 ] ) <eos>
689
src = 空白 文字 を 間 に 入れ て B . postorder () の 各要素 を A とし 、 A の 文字列 の 列 を 連結 した 文字列 を出力する
trg = print ( ' ' . join ( [ str ( A ) for A in B . postorder ( ) ] ) )
rst = print ( ' ' . join ( [ str ( A ) for A in B . postorder ( ) ] ) ) <eos>
690
src = 入力された 文字列 の 両 端 から 空白 改行 を取り 除 いた 文字列を 順に A として 、 繰り返す
trg = for A in input ( ) . strip ( ) :
rst = for A in input ( ) . strip ( ) : <eos>
691
src = D の C 番 目 を 1 だけ 増加 させる
trg = D [ C ] += 1
rst = D [ C ] += 1 <eos>
692
src = A の B 番 目 が C の D 番 目 と 等 しく ない 間 、 次 を 繰り返す
trg = while A [ B ] != C [ D ] :
rst = while A [ B ] != C [ D ] : <eos>
693
src = A に B から 1 を 引 いた 値 、 C を追加した 集 ま り
trg = A . add ( B - 1 , C )
rst = A . add ( B - 1 , C ) <eos>
694
src = A の 切り 上げ 整数値 を A とする
trg = A = math . ceil ( A )
rst = A = math . ceil ( A ) <eos>
695
src = 1 から A の B 番目の C 番 目 を 引 いた 値を A の B 番目の C 番 目 にする
trg = A [ B ] [ C ] = 1 - A [ B ] [ C ]
rst = A [ B ] [ C ] = 1 - A [ B ] [ C ] <eos>
696
src = bridge _ finding ( C , D ) を 展開 し 、 それぞれ A 、 B とする
trg = A , B = bridge_finding ( C , D )
rst = A , B = <unk> ( C , D ) <eos>
697
src = traveling _ salesman ( A , B ) を出力する
trg = print ( traveling_salesman ( A , B ) )
rst = print ( <unk> ( A , B ) ) <eos>
698
src = A の B 番目の C から D の先頭 の 1 番 目 を 引 いた 値 番 目 に D の先頭 の先頭 を加えた 値を A の B 番目の C 番 目 にする
trg = A [ B ] [ C ] = A [ B ] [ C - D [ 0 ] [ 1 ] ] + D [ 0 ] [ 0 ]
rst = A [ B ] [ C ] = A [ B ] [ C - D [ 0 ] [ 1 ] + D [ 0 ] [ 0 ] <eos>
699
src = - 2000 0000 01 を A とする
trg = A = - 2000000001
rst = A = - 1000000001 <eos>
700
src = B の 正 弦 に C から D を 引 いた 値を 掛 け た 値に B の 余 弦 に E から F を 引 いた 値を 掛 け た 値 を加えた 値に F を加えた 値を A とする
trg = A = math . sin ( B ) * ( C - D ) + math . cos ( B ) * ( E - F ) + F
rst = A = sin ( B ) * ( C - D ) + math . cos ( B ) * ( E - F ) + F <eos>
701
src = B の size の B の root 番 目 を 2 で 割 った 商 を A とする
trg = A = B . size [ B . root ] // 2
rst = A = B . size [ B . root ] // 2 <eos>
702
src = ( -1 、 1 、 0 、 0 ) からなる 列 を A とする
trg = A = [ - 1 , 1 , 0 , 0 ]
rst = A = [ - 1 , 1 , 0 , 0 ] <eos>
703
src = E の -1 から C を 引 いた 値 番 目 を D とする
trg = D = E [ - 1 - C ]
rst = D = E [ - 1 - C ] <eos>
704
src = dimension ( B , C ) を A とする
trg = A = dimension ( B , C )
rst = A = <unk> ( B , C ) <eos>
705
src = _ find _ cycle ( B , C ) を A とする
trg = A = _find_cycle ( B , C )
rst = A = find_cycle ( B , C ) <eos>
706
src = -1 e 10 の 整数値 を A とする
trg = A = int ( - 1e10 )
rst = A = int ( - 1e10 ) <eos>
707
src = A 内の B を C の 文字列 で 置き換え た 文字列 の 整数 値を返す
trg = return int ( A . replace ( B , str ( C ) ) )
rst = return int ( A . replace ( B , str ( C ) ) ) <eos>
708
src = 空白 文字 を 間 に 入れ て A の count から 1 を 引 いた 値 番目の 各要素 に 整数 を適用した 列 を 連結 した 文字列 を出力する
trg = print ( ' ' . join ( map ( str , A [ count - 1 ] ) ) )
rst = print ( ' ' . join ( map ( str , A [ count - 1 ] ) ) ) <eos>
709
src = G の E 番 目 から G の C 番 目 を 引 いた 値を F とする
trg = F = G [ E ] - G [ C ]
rst = F = G [ E ] - G [ C ] <eos>
710
src = ( 1 、 2 、 4 、 8 、 16 、 32 、 64 、 1 28 、 25 6 、 5 12 ) からなる 列 を A とする
trg = A = [ 1 , 2 , 4 , 8 , 16 , 32 , 64 , 128 , 256 , 512 ]
rst = A = [ 1 , 2 , 4 , 8 , 16 , 12 , 64 , 32 , 16 , 256 , <unk> ] <eos>
711
src = cross ( A - B , C - B ) が 0 より 大きい とき 、
trg = if cross ( A - B , C - B ) > 0 :
rst = if cross ( A - B , C - B ) > 0 : <eos>
712
src = 0 から 8 未 満 までの 数 列 の 各要素 を C とし 、 B の C 番 目 、 D の C 番目の 最小 値の 列 の 総 和 を A とする
trg = A = sum ( [ min ( B [ C ] , D [ C ] ) for C in range ( 8 ) ] )
rst = A = sum ( [ B [ C ] , min ( D [ C ] , D [ C ] ) for C in range ( 8 ) ] ) <eos>
713
src = ( B 、 C 、 D 、 E ) の 組 を 順に A として 、 繰り返す
trg = for A in ( B , C , D , E ) :
rst = for A in ( B , C , D , E ) : <eos>
714
src = A . __ class __ ( A . x + B . x , A . y + B . y ) を返す
trg = return A . __class__ ( A . x + B . x , A . y + B . y )
rst = return A . __class__ ( A . x + B . x , A . y + B . y ) <eos>
715
src = A に B を加えた 値を 現在の 日 時 とする
trg = now = A + B
rst = now = A + B <eos>
716
src = D の graph の E 番 目 を 順に A 、 B 、 C として 、 繰り返す
trg = for A , B , C in D . graph [ E ] :
rst = for A , B , C in D . graph [ E ] : <eos>
717
src = ( B の C 番 目 から D の C 番 目 を 引 いた 値の 絶対 値 、 A ) からなる 列 の 最大 値を A とする
trg = A = max ( [ abs ( B [ C ] - D [ C ] ) , A ] )
rst = A = max ( [ B [ C ] - D [ C ] , abs ( A ) ] ) <eos>
718
src = A を B から C を 引 いた 値の D 乗 に combination ( B , C ) を 掛 け た 値 だけ 増加 させる
trg = A += ( B - C ) ** D * combination ( B , C )
rst = A += ( B - C ) ** D * combination ( B , C ) <eos>
719
src = B の 順 列 を 順に A として 、 繰り返す
trg = for A in itertools . permutations ( B ) :
rst = for A in permutations ( B ) : <eos>
720
src = C を E だけ 増加 させる
trg = C += E
rst = C += E <eos>
721
src = 0 から C 未 満 までの 数 列 の 各要素 を B とし 、 、 つまり 入力された 文字列を 空白 で 分割 した 字句 列 の 列 の 両 端 キュー を A とする
trg = A = deque ( [ input ( ) . split ( ) for B in range ( C ) ] )
rst = A = deque ( [ input ( ) . split ( ) for B in range ( C ) ] ) <eos>
722
src = A 内の 0 の 出現 回数 が 1 より 大きい とき 、
trg = if A . count ( 0 ) > 1 :
rst = if A . count ( 0 ) > 1 : <eos>
723
src = 1 0000 0000 を A とする
trg = A = 100000000
rst = A = <unk> <eos>
724
src = B の C から D を 引 いた 値 番目の E 番 目 に F を加えた 値を A とする
trg = A = B [ C - D ] [ E ] + F
rst = A = B [ C - D ] [ E ] + F <eos>
725
src = A に B を加えた 値に C を 掛 け た 値が 1 0000 より 小さい とき 、
trg = if ( A + B ) * C < 10000 :
rst = if ( A + B ) * C < 10000 : <eos>
726
src = s ( A , 0 , B )
trg = s ( A , 0 , B )
rst = s ( A , 0 , B ) <eos>
727
src = swap _ range ( A , B , e , C )
trg = swap_range ( A , B , e , C )
rst = swap ( A , B , e , C ) <eos>
728
src = B を 英 大文字 に変換し た 文字列を A とする
trg = A = B . upper ( )
rst = A = B . upper ( ) <eos>
729
src = ( 7 、 ( A の先頭 、 B の先頭 ) の 組 ) からなる 列 を返す
trg = return [ 7 , ( A [ 0 ] , B [ 0 ] ) ]
rst = return [ 7 , ( A [ 0 ] , B [ 0 ] ) ] <eos>
730
src = ( 0 ) からなる 列 の 30 回 分 の 列 を A とする
trg = A = [ 0 ] * 30
rst = A = [ 0 ] * 30 <eos>
731
src = B に B を 掛 け た 値 から 100 0000 未 満 までの B 間隔 の 数 列 を 順に A として 、 繰り返す
trg = for A in range ( B * B , 1000000 , B ) :
rst = for A in range ( B * B , 1000000 , B ) : <eos>
732
src = B の A 番 目 を A とする
trg = A = B [ A ]
rst = A = B [ A ] <eos>
733
src = A が B 以下 かどうか が C に 1 を加えた 値 より 小さく かつ D の B から 1 を 引 いた 値 番 目 から D の B 番 目 を 引 いた 値が E 以上の とき 、
trg = if A <= B < C + 1 and D [ B - 1 ] - D [ B ] >= E :
rst = if A <= B < C + 1 and D [ B - 1 ] - D [ B ] >= E : <eos>
734
src = " { } , { } , { } " を返す
trg = return {self.pt1},{self.pt2},{self.vector}
rst = return <unk> <unk> <unk> <unk> <eos>
735
src = A の B から 1 を 引 いた 値 番 目 に 1 を加えた 値が A に 含まれ または A の B から 1 を 引 いた 値 番 目 が 2019 と 等 しい とき 、
trg = if A [ B - 1 ] + 1 in A or A [ B - 1 ] == 2019 :
rst = if A [ B - 1 ] + 1 in A or A [ B - 1 ] == 2019 : <eos>
736
src = A を 2 で 割 った 余 り が 1 と 等 しい とき A に 1 を加えた 値 、 そうでなければ A を返す
trg = return A + 1 if A % 2 == 1 else A
rst = return A + 1 if A % 2 == 1 else A + 1 <eos>
737
src = A の 0 番 目 を 24 、 B から 1 を 引 いた 値を 14 6 1 で 割 った 商 の 最小 値に 4 を 掛 け た 値 だけ 増加 させる
trg = A [ 0 ] += min ( 24 , ( B - 1 ) // 1461 ) * 4
rst = A [ 0 ] += min ( B - 1 ) // 1461 * 4 <eos>
738
src = A の bel の B に 1 を加えた 値 番目の C に 1 を加えた 値 番 目 を A の mod で 割 った 余 り にする
trg = A . bel [ B + 1 ] [ C + 1 ] %= A . mod
rst = A . bel [ B + 1 ] [ C + 1 ] %= A . mod <eos>
739
src = dot ( A - B , C - D ) の 絶対 値が 1. e -10 より 小さい とき E 、 そうでなければ F を出力する
trg = print ( E if abs ( dot ( A - B , C - D ) ) < 1.e-10 else F )
rst = print ( E if abs ( dot ( A - B , C - D ) ) < 1e-10 else F ) <eos>
740
src = Cp ( B , C , D ) を A とする
trg = A = Cp ( B , C , D )
rst = A = <unk> ( B , C , D ) <eos>
741
src = A の B 番目の A の B 番目の 長さ から 1 を 引 いた 値 番 目 を出力する
trg = print ( A [ B ] [ len ( A [ B ] ) - 1 ] )
rst = print ( A [ B ] [ len ( A [ B ] ) - 1 ] ) <eos>
742
src = A の 1 を B で 割 った 値 乗 を返す
trg = return pow ( A , 1 / B )
rst = return A ** ( 1 / B ) <eos>
743
src = dfs ( 0 , - 1, None )
trg = dfs ( 0 , - 1 , None )
rst = dfs ( 0 , - 1 , None ) <eos>
744
src = bitDP ( 0 , 0 , B ) を A とする
trg = A = bitDP ( 0 , 0 , B )
rst = A = <unk> ( 0 , 0 , B ) <eos>
745
src = B の 5 番 目 を A の 3 番 目 にする
trg = A [ 3 ] = B [ 5 ]
rst = A [ 3 ] = B [ 5 ] <eos>
746
src = A を B を C で 割 った 商 に 7 を 掛 け た 値 だけ 増加 させる
trg = A += ( B // C ) * 7
rst = A += ( B // C ) * 7 <eos>
747
src = D の E から 1 を 引 いた 値 番 目 を 順に A 、 B 、 C として 、 繰り返す
trg = for A , B , C in D [ E - 1 ] :
rst = for A , B , C in D [ E - 1 ] : <eos>
748
src = A の 末 尾 に ( B の C に 2 を 掛 け た 値 番 目 、 B の C に 2 を 掛 け た 値に 1 を加えた 値 番 目 ) の 組 を追加する
trg = A . append ( ( B [ C * 2 ] , B [ C * 2 + 1 ] ) )
rst = A . append ( ( B [ C * 2 ] , B [ C * 2 + 1 ] ) ) <eos>
749
src = A が B に 1 を加えた 値 より 小さい とき C の A 番 目 、 そうでなければ C の A 番 目 から D から E を 引 いた 値を 引 いた 値が F から D を 引 いた 値 より 小さい とき 、
trg = if ( C [ A ] if A < B + 1 else C [ A ] - ( D - E ) ) < F - D :
rst = if A < B + 1 else C [ A ] - ( D - E ) < F - ( D - E ) : <eos>
750
src = A の k _ parent の先頭 の B 番 目 を返す
trg = return A . k_parent [ 0 ] [ B ]
rst = return A . k_parent [ 0 ] [ B ] <eos>
751
src = 空文字列 を 間 に 入れ て A の mp の B 番 目 を 連結 した 文字列 を出力する
trg = print ( '' . join ( A . mp [ B ] ) )
rst = print ( '' . join ( A . mp [ B ] ) ) <eos>
752
src = A の right を A の parent の left にする
trg = A . parent . left = A . right
rst = A . parent . left = A . right <eos>
753
src = A の 末 尾 に heapPop _ max ( B ) を追加する
trg = A . append ( heapPop_max ( B ) )
rst = A . append ( <unk> ( B ) ) <eos>
754
src = printComparison ( int ( A [ 0 ] ) , int ( A [ 1 ] ) )
trg = printComparison ( int ( A [ 0 ] ) , int ( A [ 1 ] ) )
rst = <unk> ( int ( A [ 0 ] ) , int ( A [ 1 ] ) ) <eos>
755
src = A の C 番目の 0 番 目 に A の D 番目の 1 番 目 を加えた 値に E の C 番 目 を加えた 値 、 A の C 番目の 1 番 目 に A の D 番目の 0 番 目 を加えた 値に E の D 番 目 を加えた 値 、 A の C 番目の 1 番 目 に A の D 番目の 1 番 目 を加えた 値の 最小 値を A の B 番目の 1 番 目 にする
trg = A [ B ] [ 1 ] = min ( A [ C ] [ 0 ] + A [ D ] [ 1 ] + E [ C ] , A [ C ] [ 1 ] + A [ D ] [ 0 ] + E [ D ] , A [ C ] [ 1 ] + A [ D ] [ 1 ] )
rst = A [ B ] [ C ] [ 1 ] = min ( A [ C ] [ 0 ] [ A [ D ] + A [ D ] [ 1 ] + E [ C ] [ 1 ] , A [ D ] [ 0 ] +
756
src = 真 を A の B に C を加えた 値 番目の D に E を加えた 値 番 目 にする
trg = A [ B + C ] [ D + E ] = True
rst = A [ B + C ] [ D + E ] = True <eos>
757
src = A の B 番 目 が A の C 番 目 より 小さい とき 、
trg = if A [ B ] < A [ C ] :
rst = if A [ B ] < A [ C ] : <eos>
758
src = B から 18 68 を 引 いた 値に 1 を加えた 値を A とする
trg = A = B - 1868 + 1
rst = A = B - 1868 + 1 <eos>
759
src = A から B に C を加えた 値を 引 いた 値が 1 e -10 より 大きい とき 、
trg = if A - ( B + C ) > 1e-10 :
rst = if A - ( B + C ) > 1e-10 : <eos>
760
src = insertionSort ( C , A , B ) を 展開 し 、 それぞれ A 、 B とする
trg = A , B = insertionSort ( C , A , B )
rst = A , B = insertionSort ( C , A , B ) <eos>
761
src = A . ok ( B , C ) の とき 、
trg = if A . ok ( B , C ) :
rst = if A . <unk> ( B , C ) : <eos>
762
src = 1 を A の B から 1 を 引 いた 値 番目の C 番 目 にする
trg = A [ B - 1 ] [ C ] = 1
rst = A [ B - 1 ] [ C ] = 1 <eos>
763
src = -1 e - 9 を A とする
trg = A = - 1e-9
rst = A = - 1e9 <eos>
764
src = ( 1 、 1 、 1 、 1 、 1 、 2 、 2 、 2 、 3 ) からなる 列 を A とする
trg = A = [ 1 , 1 , 1 , 1 , 1 , 2 , 2 , 2 , 3 ]
rst = A = [ 1 , 1 , 1 , 1 , 1 , 1 , 2 , 2 , 2 , 3 ] <eos>
765
src = 25 6 を A とする
trg = A = 256
rst = A = <unk> <eos>
766
src = 0 から C 未 満 までの 数 列 の 各要素 を B とし 、 、 つまり 空 辞書 の 列 を A とする
trg = A = [ { } for B in range ( C ) ]
rst = A = [ { } for B in range ( C ) ] <eos>
767
src = 0 から 5 未 満 までの 数 列 の 各要素 を B とし 、 calcDp ( B ) の 列 を A とする
trg = A = [ calcDp ( B ) for B in range ( 5 ) ]
rst = A = [ <unk> ( B ) for B in range ( 5 ) ] <eos>
768
src = A の 末 尾 に B に C の 最大 値 を加えた 値 を追加する
trg = A . append ( B + max ( C ) )
rst = A . append ( B + max ( C ) ) <eos>
769
src = repeating _ decimals ( C , D ) を 展開 し 、 それぞれ A 、 B とする
trg = A , B = repeating_decimals ( C , D )
rst = A , B = <unk> ( C , D ) <eos>
770
src = A を B 内の C の 出現 回数 だけ 増加 させる
trg = A += B . count ( C )
rst = A += B . count ( C ) <eos>
771
src = A の B から 1 を 引 いた 値 番 目 を C で 割 った 余 り が A の B 番 目 を C で 割 った 余 り より 大きい とき 、
trg = if A [ B - 1 ] % C > A [ B ] % C :
rst = if A [ B - 1 ] % C > A [ B ] % C : <eos>
772
src = 1 e 30 を A とする
trg = A = 1e30
rst = A = <unk> <eos>
773
src = A の 末 尾 に " rightkey = { } , " を追加する
trg = A . append ( right key = {a[i*2+1]}, )
rst = A . append ( right key = <unk> ) <eos>
774
src = A が B 以下 かどうか が C から A を 引 いた 値 以下 かつ A が D 以下 かどうか が E から A を 引 いた 値 以下の とき F 、 そうでなければ G を出力する
trg = print ( F if A <= B <= C - A and A <= D <= E - A else G )
rst = print ( F if A <= B <= C - A and A <= D <= E - A else G ) <eos>
775
src = MyList ( [ 0 ] * A . D ) を返す
trg = return MyList ( [ 0 ] * A . D )
rst = return MyList ( [ 0 ] * A . D ) <eos>
776
src = ( ( -2 、 0 ) からなる 列 、 ( -1 、 -1 ) からなる 列 、 ( -1 、 0 ) からなる 列 、 ( -1 、 1 ) からなる 列 、 ( 0 、 -2 ) からなる 列 、 ( 0 、 -1 ) からなる 列 、 ( 0 、 0 ) からなる 列 、 ( 0 、 1 ) からなる 列 、 ( 0 、 2 ) からなる 列 、 ( 1 、 -1 ) からなる 列
trg = A = [ [ - 2 , 0 ] , [ - 1 , - 1 ] , [ - 1 , 0 ] , [ - 1 , 1 ] , [ 0 , - 2 ] , [ 0 , - 1 ] , [ 0 , 0 ] , [ 0 , 1 ] , [ 0 , 2 ] , [ 1 , - 1 ] , [ 1 , 0 ] , [ 1 ,
rst = A = [ [ - 2 , 0 ] , [ - 1 , - 1 ] , [ - 1 , 0 ] , [ - 1 , 1 ] , [ 0 , - 1 ] , [ 0 , - 1 ] , [ 0 , 1
777
src = 100 1 を A とする
trg = A = 1001
rst = A = 1001 <eos>
778
src = A の長さ が 5 以上の とき 、
trg = if len ( A ) >= 5 :
rst = if len ( A ) >= 5 : <eos>
779
src = B を A の n _ にする
trg = A . n_ = B
rst = A . n = B <eos>
780
src = B に C を加えた 値に D を加えた 値を 3 で 割 った 商 を A とする
trg = A = ( B + C + D ) // 3
rst = A = ( B + C + D ) // 3 <eos>
781
src = 入力された 文字列 の 整数値 を B の 0 番 目 とする を A とする
trg = A = B [ 0 ] = int ( input ( ) )
rst = A = B [ 0 ] = int ( input ( ) ) <eos>
782
src = A が ( ( 0 、 0 ) の 組 、 ( 0 、 1 ) の 組 、 ( 1 、 1 ) の 組 、 ( 1 、 2 ) の 組 ) からなる 列 と 等 しい とき 、
trg = if A == [ ( 0 , 0 ) , ( 0 , 1 ) , ( 1 , 1 ) , ( 1 , 2 ) ] :
rst = if A == [ ( 0 , 0 ) , ( 0 , 1 ) , ( 1 , 1 ) , ( 1 , 2 ) ] : <eos>
783
src = A の B から 1 を 引 いた 値 番目の C 番 目 、 A の B 番目の C から D [ B ] の 1 番 目 を 引 いた 値 番 目 に D の B 番目の 先頭 を加えた 値の 最大 値を A の B 番目の C 番 目 にする
trg = A [ B ] [ C ] = max ( A [ B - 1 ] [ C ] , A [ B ] [ C - D [ B ] [ 1 ] ] + D [ B ] [ 0 ] )
rst = A [ B ] [ C ] = max ( A [ B - 1 ] [ C ] , A [ B ] [ C - D [ B ] [ 1 ] ] + D [ B ] [ 0 ] ) <eos>
784
src = 100 の 2 乗 を A とする
trg = A = 100 ** 2
rst = A = 100 ** 2 <eos>
785
src = A の長さ が B より 大きく かつ cross ( C [ A [ -2 ]] , C [ A [ -1 ]] , C [ D ] ) が 0 以上の 間 、 次 を 繰り返す
trg = while len ( A ) > B and cross ( C [ A [ - 2 ] ] , C [ A [ - 1 ] ] , C [ D ] ) >= 0 :
rst = while len ( A ) > B and cross ( C [ A [ - 2 ] ] , C [ A [ - 1 ] ] , C [ D ] ) >= 0 : <eos>
786
src = A [ B ] の 1 番 目 が A [ C ] の 0 番 目 以下 かつ A [ B ] の 2 番 目 が A [ C ] の 1 番 目 以下 かつ A の B 番目の 3 番 目 が A の C 番目の 2 番 目 以下 かつ A [ B ] [ 1 ] に 4 を 掛 け た 値に A [ B ] [ 2 ] に 9 を 掛
trg = if A [ B ] [ 1 ] <= A [ C ] [ 0 ] and A [ B ] [ 2 ] <= A [ C ] [ 1 ] and A [ B ] [ 3 ] <= A [ C ] [ 2 ] and A [ B ] [ 1 ] * 4 + A [ B ] [ 2 ] * 9 + A [ B ] [ 3 ] * 4 <= A
rst = if A [ B ] [ 1 ] <= A [ C ] [ 0 ] and A [ B ] [ 2 ] <= A [ C ] [ 1 ] and A [ B ] [ 3 ] <= A [ C ] [ 2 ] and A
787
src = D の B 番 目 に 2 を加えた 値を A の B と C の 論理 和 番 目 にする
trg = A [ B | C ] = D [ B ] + 2
rst = A [ B | C ] = D [ B ] + 2 <eos>
788
src = A の 文字列 が B の 0 番 目 と 等 しく または A が 10 以上 かつ B の 0 番 目 が C と 等 しい とき 、
trg = if str ( A ) == B [ 0 ] or ( A >= 10 and B [ 0 ] == C ) :
rst = if ( str ( A ) == B [ 0 ] or ( A >= 10 and B [ 0 ] == C ) ) : <eos>
789
src = B に C から B を 引 いた 値の 要素を 右 に 6 0.0 個 、 回 転 する を加えた 値を A とする
trg = A = B + ( C - B ) . rotate ( 60.0 )
rst = A = B + ( C - B ) * <unk> + 0.0 <eos>
790
src = test () でない 間 、 次 を 繰り返す
trg = while not test ( ) :
rst = while not test ( ) : <eos>
791
src = copy の先頭 を A の 2 番 目 にする
trg = A [ 2 ] = copy [ 0 ]
rst = A [ 2 ] = copy [ 0 ] <eos>
792
src = A の B 番目の C 番目の 先頭 でない とき 、
trg = if not A [ B ] [ C ] [ 0 ] :
rst = if not A [ B ] [ C ] [ 0 ] : <eos>
793
src = A が 、 つまり 辞書 に含まれる とき 、
trg = if A in dict :
rst = if A in dict : <eos>
794
src = B に 15 1 を 掛 け た 値を A とする
trg = A = B * 151
rst = A = B * <unk> <eos>
795
src = B . GetNodes () を A とする
trg = A = B . GetNodes ( )
rst = A = B . GetNodes ( ) <eos>
796
src = 0 から 、 つまり 入力された 文字列 の 整数値 未 満 までの 数 列 の 各要素 を B とし 、 、 つまり 入力された 文字列 の長さ の 列 を A とする
trg = A = [ len ( input ( ) ) for B in range ( int ( input ( ) ) ) ]
rst = A = [ len ( input ( ) ) for B in range ( int ( input ( ) ) ) ] <eos>
797
src = A に 1 を加えた 値が B より 小さく かつ C の A に 1 を加えた 値 番 目 が 0 より 大きい とき 、
trg = if A + 1 < B and C [ A + 1 ] > 0 :
rst = if A + 1 < B and C [ A + 1 ] > 0 : <eos>
798
src = calc _ kagen ( A ) を A とする
trg = A = calc_kagen ( A )
rst = A = <unk> ( A ) <eos>
799
src = A が 9 と 等 しい とき 、
trg = if A == 9 :
rst = if A == 9 : <eos>
800
src = euler _ phi ( A , B ) を出力する
trg = print ( euler_phi ( A , B ) )
rst = print ( <unk> ( A , B ) ) <eos>
801
src = B の vec の C を 2 で 割 った 余 り 番 目 を A とする
trg = A = B . vec [ C % 2 ]
rst = A = B . <unk> [ C % 2 ] <eos>
802
src = A を B に C を 掛 け た 値 から D に E を 掛 け た 値を 引 いた 値の 絶対 値を 2 で 割 った 値 だけ 増加 させる
trg = A += abs ( B * C - D * E ) / 2
rst = A += abs ( B * C - D * E ) / 2 <eos>
803
src = A を ( B 、 C ) の 組 で 割 った 余 り を出力する
trg = print ( A % ( B , C ) )
rst = print ( A % ( B , C ) ) <eos>
804
src = A 、 B 、 C 、 D から 、 つまり ネ イ ピ ア 数 を 引 いた 値 、 E から D を 引 いた 値の 最小 値の 最大 値を A とする
trg = A = max ( A , min ( B , C , D - e , E - D ) )
rst = A = max ( A , min ( B , C , D - e , E - D ) ) <eos>
805
src = A の cursor の prev を A の cursor にする
trg = A . cursor = A . cursor . prev
rst = A . cursor = A . cursor . prev <eos>
806
src = 1 を A の B に 1 を加えた 値 番目の C に 1 を加えた 値 番 目 にする
trg = A [ B + 1 ] [ C + 1 ] = 1
rst = A [ B + 1 ] [ C + 1 ] = 1 <eos>
807
src = A を 書式 として B に 1 を加えた 値 、 C の B 番 目 で 整 形 した 文字列 を出力する
trg = print ( A . format ( B + 1 , C [ B ] ) )
rst = print ( A . format ( B + 1 , C [ B ] ) ) <eos>
808
src = A を B から 1 を 引 いた 値 から C を 引 いた 値に D の C 番 目 を 掛 け た 値を B から 1 を 引 いた 値に E を 掛 け た 値 で 割 った 値 だけ 増加 させる
trg = A += ( ( B - 1 - C ) * D [ C ] ) / ( ( B - 1 ) * E )
rst = A += ( B - 1 ) * ( C - D [ C ] ) / ( B - 1 ) * E <eos>
809
src = __ createtable () を A とする
trg = A = __createtable ( )
rst = A = <unk> ( ) <eos>
810
src = 2 から 1000 0000 未 満 までの 数 列 を 順に A として 、 繰り返す
trg = for A in range ( 2 , 10000000 ) :
rst = for A in range ( 2 , 10000000 ) : <eos>
811
src = 2 の A 乗 に対する B の 剰 余 を出力する
trg = print ( pow ( 2 , A , B ) )
rst = print ( pow ( 2 , A , B ) ) <eos>
812
src = C の 各要素 に B を適用した 列 の集合 を A とする
trg = A = set ( map ( B , C ) )
rst = A = set ( map ( B , C ) ) <eos>
813
src = A の 4 番 目 、 A の先頭 、 A の 2 番 目 、 A の 3 番 目 、 A の 5 番 目 、 A の 1 番 目 を A の先頭 、 A の 1 番 目 、 A の 2 番 目 、 A の 3 番 目 、 A の 4 番 目 、 A の 5 番 目 とする
trg = A [ 0 ] , A [ 1 ] , A [ 2 ] , A [ 3 ] , A [ 4 ] , A [ 5 ] = A [ 4 ] , A [ 0 ] , A [ 2 ] , A [ 3 ] , A [ 5 ] , A [ 1 ]
rst = A [ 0 ] , A [ 1 ] , A [ 2 ] , A [ 3 ] , A [ 4 ] , A [ 5 ] = A [ 4 ] , A [ 0 ] , A [ 0 ] , A [ 2 ] ,
814
src = treewalk _ preorder ( A [ B ] [ C ] )
trg = treewalk_preorder ( A [ B ] [ C ] )
rst = treewalk_preorder ( A [ B ] [ C ] ) <eos>
815
src = A の B 番 目 、 C に 1 を加えた 値 を出力する
trg = print ( A [ B ] , C + 1 )
rst = print ( A [ B ] , C + 1 ) <eos>
816
src = l を パラメータ として B [ 0 ] * * 2 に B [ 1 ] * * 2 を加えた 値の 平 方 根 から C を 引 いた 値の 絶対 値を返す 関数を A とする
trg = A = lambda B : abs ( math . sqrt ( B [ 0 ] ** 2 + B [ 1 ] ** 2 ) - C )
rst = A = abs ( math . sqrt ( B [ 0 ] ** 2 + B [ 1 ] ** 2 - B [ 2 ] * C ) ) <eos>
817
src = B から C を 引 いた 値に D を E で 割 った 商 を加えた 値を A とする
trg = A = ( B - C ) + ( D // E )
rst = A = ( B - C ) + ( D // E ) <eos>
818
src = 15 を A とする
trg = A = 15
rst = A = 15 <eos>
819
src = 0 、 25 5 、 0 を A 、 B 、 C とする
trg = A , B , C = 0 , 255 , 0
rst = A , B , C = 0 , 255 , 0 <eos>
820
src = 0 から C 未 満 までの 数 列 の 各要素 を B とし 、 A から 読み 込 んだ 一行 を 空白 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 の 列 を pd とする
trg = pd = [ map ( int , A . readline ( ) . split ( ) ) for B in range ( C ) ]
rst = pd = ( [ map ( int , A . readline ( ) . split ( ) ) for B in range ( C ) ] ) <eos>
821
src = 区切り なしで A 、 B から 19 25 を 引 いた 値 を出力する
trg = print ( A , B - 1925 , sep = '' )
rst = print ( A , B - 1925 , sep = '' ) <eos>
822
src = A を Fraction ( 90 , 1 < < B ) だけ 減少 させる
trg = A -= Fraction ( 90 , 1 << B )
rst = A -= Fraction ( 90 , 1 << B ) <eos>
823
src = D 、 D の 1 番 目 から 、 つまり 末 尾 までの 部分 列 に ( 、 つまり 未 定 値 ) からなる 列 を加えた 値の 要素を それぞれ 組 にした 列 の 各要素 を B 、 C とし 、 B が C と 等 しく ない とき の B の 列 を A とする
trg = A = ( [ B for B , C in zip ( D , D [ 1 : ] + [ None ] ) if B != C ] )
rst = A = [ B for B , C in zip ( D , D [ 1 : ] + [ None ] , B , C ) if B != None ] <eos>
824
src = C を A の B 番目の parent _ id にする
trg = A [ B ] . parent_id = C
rst = A [ B ] . parent_id = C <eos>
825
src = 3 から B の 平 方 根 の 整数値 に 1 を加えた 値 未 満 までの 2 間隔 の 数 列 を 順に A として 、 繰り返す
trg = for A in range ( 3 , int ( math . sqrt ( B ) ) + 1 , 2 ) :
rst = for A in range ( 3 , int ( math . sqrt ( B ) ) + 1 , 2 ) : <eos>
826
src = A の B 番 目 から C を 引 いた 値 から D を 引 いた 値が E 以上の とき 、
trg = if A [ B ] - C - D >= E :
rst = if A [ B ] - C - D >= E : <eos>
827
src = solve ( B + 1, C ) または solve ( B + 1, C - D [ B ] ) を A とする
trg = A = solve ( B + 1 , C ) or solve ( B + 1 , C - D [ B ] )
rst = A = solve ( B + 1 , C ) or solve ( B + 1 , C - D [ B ] ) <eos>
828
src = A の FLAGS の 2 進 数 文字列 内の B の 出現 回数 を返す
trg = return bin ( A . FLAGS ) . count ( B )
rst = return bin ( A . FLAGS ) . count ( B ) <eos>
829
src = least _ multiplication ( B ) を A とする
trg = A = least_multiplication ( B )
rst = A = <unk> ( B ) <eos>
830
src = A が 0 と 等 しく かつ B が C に含まれる とき 、
trg = if A == 0 and B in C :
rst = if A == 0 and B in C : <eos>
831
src = A が 20 以上の とき 、
trg = if A >= 20 :
rst = if A >= 20 : <eos>
832
src = phi ( A ) の 整数値 を出力する
trg = print ( int ( phi ( A ) ) )
rst = print ( int ( <unk> ( A ) ) ) <eos>
833
src = ( 、 つまり 空文字列 、 B 、 C 、 D ) からなる 列 を A とする
trg = A = [ '' , B , C , D ]
rst = A = [ '' , B , C , D ] <eos>
834
src = WeightedUnionFindTree ( B -1 ) を A とする
trg = A = WeightedUnionFindTree ( B - 1 )
rst = A = <unk> ( B - 1 ) <eos>
835
src = isSolved ( A ) を出力する
trg = print ( isSolved ( A ) )
rst = print ( <unk> ( A ) ) <eos>
836
src = ( B 、 0 ) の 組 を A とする
trg = A = ( B , 0 )
rst = A = ( B , 0 ) <eos>
837
src = 1 を A の B に C を 掛 け た 値 番 目 にする
trg = A [ B * C ] = 1
rst = A [ B * C ] = 1 <eos>
838
src = A の集合 のリスト を返す
trg = return list ( set ( A ) )
rst = return list ( set ( A ) ) <eos>
839
src = ( B の先頭 を取り 出した 値 ) からなる 列 を A とする
trg = A = [ B . pop ( ) ]
rst = A = [ B . pop ( ) ] <eos>
840
src = dice () を A とする
trg = A = dice ( )
rst = A = dice ( ) <eos>
841
src = A に B に 1 を加えた 値 を加えた 値が C 以下の とき 、
trg = if A + ( B + 1 ) <= C :
rst = if A + B + 1 <= C : <eos>
842
src = par ( A ) が par ( B ) と 等 しい とき C 、 そうでなければ D を出力する
trg = print ( C if par ( A ) == par ( B ) else D )
rst = print ( C if par ( par ( A ) == par ( B ) else D ) ) <eos>
843
src = ( ( C 、 D ) の 組 ) からなる 列 を A の B 番 目 にする
trg = A [ B ] = [ ( C , D ) ]
rst = A [ B ] = [ ( C , D ) ] <eos>
844
src = ( 、 つまり 空文字列 、 B 、 C 、 B 、 C 、 B ) からなる 列 を A とする
trg = A = [ '' , B , C , B , C , B ]
rst = A = [ '' , B , C , B , C , B ] <eos>
845
src = 1 から C に 1 を加えた 値 未 満 までの 数 列 の 各要素 を B とし 、 B の 文字列 の 列 を A とする
trg = A = ( [ str ( B ) for B in range ( 1 , C + 1 ) ] )
rst = A = [ str ( B ) for B in range ( 1 , C + 1 ) ] <eos>
846
src = 0 から G 未 満 までの 数 列 の 各要素 を E とし 、 D [ B ] [ E ] と F [ E ] [ C ] の 論理 積 の 列 の 総 和 が 0 より 大きい かどうか に [MASK] を加えた 値を A の B 番目の C 番 目 にする
trg = A [ B ] [ C ] = + ( sum ( [ D [ B ] [ E ] & F [ E ] [ C ] for E in range ( G ) ] ) > 0 )
rst = A [ B ] [ C ] = + ( sum ( [ D [ B ] [ E ] & F [ E ] [ C ] > 0 for E in range ( G ) ] ) ) <eos>
847
src = min _ cost _ sort ( B ) を A とする
trg = A = min_cost_sort ( B )
rst = A = <unk> ( B ) <eos>
848
src = A . cost () を返す
trg = return A . cost ( )
rst = return A . cost ( ) <eos>
849
src = A の _ edges の 、 つまり ネ イ ピ ア 数の v 番目の 末 尾 に ネ イ ピ ア 数 を追加する
trg = A . _edges [ e . v ] . append ( e )
rst = A . _edges [ e . v ] . append ( e . <unk> ) <eos>
850
src = A の B 番目の C 番 目 かつ D の B 番目の C 番 目 が 0 と 等 しい とき 、
trg = if A [ B ] [ C ] and D [ B ] [ C ] == 0 :
rst = if A [ B ] [ C ] and D [ B ] [ C ] == 0 : <eos>
851
src = B の 先頭に C の先頭 を 掛 け た 値に B の 1 番 目 に C の 1 番 目 を 掛 け た 値 を加えた 値を B の先頭 の 2 乗 に B の 1 番目の 2 乗 を加えた 値 で 割 った 値を A とする
trg = A = ( B [ 0 ] * C [ 0 ] + B [ 1 ] * C [ 1 ] ) / ( B [ 0 ] ** 2 + B [ 1 ] ** 2 )
rst = A = ( B [ 0 ] * C [ 0 ] + B [ 1 ] * C [ 1 ] ) / ( B [ 0 ] ** 2 + B [ 1 ] ** 2 ) <eos>
852
src = " 0 : " を出力する
trg = print ( 0: )
rst = print ( {d}: ) <eos>
853
src = B に C に D から E を 引 いた 値を 掛 け た 値 を加えた 値 から F に G に H を 掛 け た 値 を加えた 値を 引 いた 値を A とする
trg = A = B + C * ( D - E ) - ( F + G * H )
rst = A = B + C * ( D - E ) - ( F + G * H ) <eos>
854
src = B に C を 掛 け た 値 から D に E を 掛 け た 値を 引 いた 値を A とする
trg = A = B * C - D * E
rst = A = B * C - D * E <eos>
855
src = ( get _ area () ) からなる 列 を A とする
trg = A = [ get_area ( ) ]
rst = A = [ <unk> ( ) ] <eos>
856
src = A の 、 つまり 先頭 から 2 番 目 までの 部分 列 の 総 和 が 1 79 より 大きく または B が 23 9 より 大きく または 100 が A に含まれる とき 、
trg = if sum ( A [ : 2 ] ) > 179 or B > 239 or 100 in A :
rst = if ( sum ( A [ 0 : 2 ] ) > 1 or B > 9 or A in B ) : <eos>
857
src = A の B から 1 を 引 いた 値 番目の C 番 目 に 1 を加えた 値を A の B 番目の C 番 目 にする
trg = A [ B ] [ C ] = A [ B - 1 ] [ C ] + 1
rst = A [ B ] [ C ] = A [ B - 1 ] [ C ] + 1 <eos>
858
src = A が B の find ( C ) 番 目 に 含まれ ない とき 、
trg = if A not in B [ find ( C ) ] :
rst = if A not in B [ find ( C ) ] : <eos>
859
src = listing ( C [ 0 ] , D ) 、 listing ( C [ 1 ] , D ) を A 、 B とする
trg = A , B = listing ( C [ 0 ] , D ) , listing ( C [ 1 ] , D )
rst = A , B = <unk> ( C [ 0 ] , D ) , <unk> ( C [ 1 ] , D ) <eos>
860
src = B の先頭 から A を 探 して 見つかった 位置 を A とする
trg = A = B . find ( A )
rst = A = B . find ( A ) <eos>
861
src = D の 各要素 を C 、 B とし 、 B から C を 引 いた 値が E より 小さい とき の B から C を 引 いた 値の 列 の 最大 値を A とする
trg = A = max ( [ B - C for C , B in D if B - C < E ] )
rst = A = max ( [ B - C for C , B in D if B - C < E ] ) <eos>
862
src = ( 0 、 1 、 0 、 0 ) からなる 列 を A の B 番目の 0 番 目 にする
trg = A [ B ] [ 0 ] = [ 0 , 1 , 0 , 0 ]
rst = A [ B ] [ 0 ] = [ 0 , 1 , 0 , 0 ] <eos>
863
src = sys の stdin から 読み 込 んだ 一行 を 空白 で 分割 した 字句 列 を 展開 し 、 それぞれ A 、 time とする
trg = A , time = sys . stdin . readline ( ) . split ( )
rst = A , time = sys . stdin . readline ( ) . split ( ) <eos>
864
src = ( 0 ) からなる 列 の 8 回 分 の 列 を追加し て A を拡張する
trg = A . extend ( [ 0 ] * 8 )
rst = A . extend ( [ 0 ] * 8 ) <eos>
865
src = A を _ pow ( 10 , 68 ) で 割 った 余 り を A とする
trg = A = A % _pow ( 10 , 68 )
rst = A = A % _pow ( 10 , 68 ) <eos>
866
src = swaping ( A , B , C , e , D )
trg = swaping ( A , B , C , e , D )
rst = <unk> ( A , B , C , e , D ) <eos>
867
src = A の 先頭に 2 を 掛 け た 値を返す
trg = return A [ 0 ] * 2
rst = return A [ 0 ] * 2 <eos>
868
src = buildMaxHeap ( A , B )
trg = buildMaxHeap ( A , B )
rst = <unk> ( A , B ) <eos>
869
src = A の B 番 目 に C を 掛 け た 値を D で 割 った 余 り を A の B に 1 を加えた 値 番 目 にする
trg = A [ B + 1 ] = A [ B ] * C % D
rst = A [ B + 1 ] = A [ B ] * C % D <eos>
870
src = B を 2 で 割 った 余 り を A とする
trg = A = B % 2
rst = A = B % 2 <eos>
871
src = B 、 A を B で 割 った 余 り を A 、 B とする
trg = A , B = B , A % B
rst = A , B = B , A % B <eos>
872
src = ans ( A , B ) を出力する
trg = print ( ans ( A , B ) )
rst = print ( <unk> ( A , B ) ) <eos>
873
src = A の B の先頭 番 目 を削除する
trg = del A [ B [ 0 ] ]
rst = del A [ B [ 0 ] ] <eos>
874
src = x 、 y を パラメータ として x に y を 掛 け た 値を返す 関数を A とする
trg = A = lambda B , C : B * C
rst = A = lambda D , E : B * C <eos>
875
src = 0 が A 以下 かどうか が 9 以下 でない とき 、
trg = if not 0 <= A <= 9 :
rst = if not 0 <= A <= 9 : <eos>
876
src = 0 から B の size 未 満 までの 数 列 を 順に A として 、 繰り返す
trg = for A in range ( B . size ) :
rst = for A in range ( B . size ) : <eos>
877
src = A の 末 尾 に バイト 列 B を 文字コード C で 復 号 化した 文字列 、 D から の 整数値 から E を 引 いた 値 を追加する
trg = A . append ( int . from_bytes ( B . encode ( C ) , D ) - E )
rst = A . append ( int . <unk> ( B . encode ( C ) , D ) - E ) <eos>
878
src = A の name を出力する
trg = print ( A . name )
rst = print ( A . name ) <eos>
879
src = - B から 2 に B を 掛 け た 値 未 満 までの 数 列 を 順に A として 、 繰り返す
trg = for A in range ( - B , 2 * B ) :
rst = for A in range ( - B , 2 * B ) : <eos>
880
src = 未 定 値を A の next にする
trg = A . next = None
rst = A . next = None <eos>
881
src = ( B の 0 番 目 に C の先頭 を加えた 値を 2 で 割 った 値 、 B の 1 番 目 に C の 1 番 目 を加えた 値を 2 で 割 った 値 ) からなる 列 を A とする
trg = A = [ ( B [ 0 ] + C [ 0 ] ) / 2 , ( B [ 1 ] + C [ 1 ] ) / 2 ]
rst = A = [ ( B [ 0 ] + C [ 0 ] ) / 2 , ( B [ 1 ] + C [ 1 ] ) / 2 ] <eos>
882
src = 2 に B を 掛 け た 値 から 1 を 引 いた 値を A とする
trg = A = 2 * B - 1
rst = A = 2 * B - 1 <eos>
883
src = 2 から B 未 満 までの 2 間隔 の 数 列 を 順に A として 、 繰り返す
trg = for A in range ( 2 , B , 2 ) :
rst = for A in range ( 2 , B , 2 ) : <eos>
884
src = B の 0 番 目 から C の先頭 を 引 いた 値に D の 正 弦 を 掛 け た 値に B の 1 番 目 から C の 1 番 目 を 引 いた 値に D の 余 弦 を 掛 け た 値 を加えた 値に C の 1 番 目 を加えた 値を A の 1 番 目 にする
trg = A [ 1 ] = ( B [ 0 ] - C [ 0 ] ) * math . sin ( D ) + ( B [ 1 ] - C [ 1 ] ) * math . cos ( D ) + C [ 1 ]
rst = A [ 1 ] = ( B [ 0 ] - C [ 0 ] ) * sin ( D ) + ( B [ 1 ] - C [ 1 ] ) * math . cos ( D ) + C [ 1 ] <eos>
885
src = A が 100 と 等 しい とき 、
trg = if A == 100 :
rst = if A == 100 : <eos>
886
src = phase ( - B ) を A とする
trg = A = phase ( - B )
rst = A = phase ( B - B ) <eos>
887
src = A の - B から 1 を 引 いた 値 番 目 を C に D を 掛 け た 値 だけ 減少 させる
trg = A [ - B - 1 ] -= C * D
rst = A [ - B - 1 ] -= C * D <eos>
888
src = B に C を加えた 値を 10 で 割 った 余 り を A とする
trg = A = ( B + C ) % 10
rst = A = ( B + C ) % 10 <eos>
889
src = A に B に int ( input () ) を 100 で 割 った 値の 整数値 を 掛 け た 値 を加えた 値 を出力する
trg = print ( A + B * int ( int ( input ( ) ) / 100 ) )
rst = print ( A + B * int ( input ( ) / 100 ) ) <eos>
890
src = ( 4 、 1 、 4 、 1 、 2 、 1 、 2 、 1 、 4 、 1 、 4 、 1 、 2 、 1 、 2 、 1 ) からなる 列 を A とする
trg = A = [ 4 , 1 , 4 , 1 , 2 , 1 , 2 , 1 , 4 , 1 , 4 , 1 , 2 , 1 , 2 , 1 ]
rst = A = [ 4 , 1 , 4 , 1 , 2 , 1 , 2 , 4 , 1 , 4 , 2 , 1 , 2 , 1 , 2 , 1 ] <eos>
891
src = MyList ( [ 0 ] * A . V ) を A の itr にする
trg = A . itr = MyList ( [ 0 ] * A . V )
rst = A . itr = MyList ( [ 0 ] * A . V ) <eos>
892
src = dot ( B , C ) を dot ( C , C ) で 割 った 値を A とする
trg = A = dot ( B , C ) / dot ( C , C )
rst = A = dot ( B , C ) / dot ( C , C ) <eos>
893
src = A の 1 番目の 1 番 目 が B から 2 を 引 いた 値 と 等 しい とき 、
trg = if A [ 1 ] [ 1 ] == B - 2 :
rst = if A [ 1 ] [ 1 ] == B - 2 : <eos>
894
src = ( A 、 A に 1 を加えた 値 ) の 組 が B の C 番 目 に含まれる とき 、
trg = if ( A , A + 1 ) in B [ C ] :
rst = if ( A , A + 1 ) in B [ C ] : <eos>
895
src = A の B に 2 を加えた 値 番 目 を 1 だけ 増加 させる
trg = A [ B + 2 ] += 1
rst = A [ B + 2 ] += 1 <eos>
896
src = A の B に 1 を加えた 値 番 目 、 A の B 番 目 を A の B 番 目 、 A の B に 1 を加えた 値 番 目 とする
trg = A [ B ] , A [ B + 1 ] = A [ B + 1 ] , A [ B ]
rst = A [ B ] , A [ B + 1 ] = A [ B + 1 ] , A [ B ] <eos>
897
src = H を 展開 し 、 それぞれ A 、 B 、 C 、 D 、 E 、 F 、 G とする
trg = A , B , C , D , E , F , G = H
rst = A , B , C , D , E , F , G = H <eos>
898
src = 0 から C 未 満 までの 数 列 の 各要素 を B とし 、 0 から C 未 満 までの 数 列 の 各要素 を B とし 、 -1 の 列 の 列 を A とする
trg = A = [ [ - 1 for B in range ( C ) ] for B in range ( C ) ]
rst = A = [ [ - 1 for B in range ( C ) ] for B in range ( C ) ] <eos>
899
src = ネ イ ピ ア 数の 0 番 目 が 、 つまり ネ イ ピ ア 数の 1 番 目 と 等 しく なく かつ 、 つまり ネ イ ピ ア 数の 1 番 目 が 、 つまり ネ イ ピ ア 数の 2 番 目 と 等 しく なく かつ 、 つまり ネ イ ピ ア 数の 2 番 目 が 、 つまり ネ イ ピ ア 数 の先頭 と 等 しく ない とき 、
trg = if e [ 0 ] != e [ 1 ] and e [ 1 ] != e [ 2 ] and e [ 2 ] != e [ 0 ] :
rst = if e [ 0 ] != e [ 1 ] and e [ 1 ] != e [ 2 ] and e [ e [ 1 ] != e [ 2 ] : <eos>
900
src = A を 書式 として B の C 番 目 から 26 を 引 いた 値 で 整 形 した 文字列 を出力する
trg = print ( A . format ( B [ C ] - 26 ) )
rst = print ( A . format ( B [ C ] - 26 ) ) <eos>
901
src = B の C 番目の D に 1 を加えた 値 番目の E 番目の F から 1 を 引 いた 値 番 目 に 1 を加えた 値を A とする
trg = A = B [ C ] [ D + 1 ] [ E ] [ F - 1 ] + 1
rst = A = B [ C ] [ D + 1 ] [ E ] [ F - 1 ] + 1 <eos>
902
src = A の B 番目の C 番 目 に A の C 番目の D 番 目 を加えた 値に A の D 番目の B 番 目 を加えた 値が 0 より 小さい とき 、
trg = if A [ B ] [ C ] + A [ C ] [ D ] + A [ D ] [ B ] < 0 :
rst = if A [ B ] [ C ] + A [ C ] [ D ] + A [ D ] [ B ] < 0 : <eos>
903
src = B に C を 掛 け た 値に 4 を 掛 け た 値を A とする
trg = A = B * C * 4
rst = A = B * C * 4 <eos>
904
src = 0 から 200 未 満 までの 数 列 を 順に A として 、 繰り返す
trg = for A in range ( 200 ) :
rst = for A in range ( 200 ) : <eos>
905
src = A の B 番 目 、 C の B 番 目 、 D の B 番 目 を出力する
trg = print ( A [ B ] , C [ B ] , D [ B ] )
rst = print ( A [ B ] , C [ B ] , D [ B ] ) <eos>
906
src = 0 から 2 未 満 までの 数 列 の 各要素 を A とし 、 sorted ( [ int ( input () ) forAinrange ( 10 ) ] ) の -3 番 目 から 、 つまり 末 尾 までの 部分 列 の 総 和 の 列 を 展開 して を出力する
trg = print ( * ( [ sum ( sorted ( [ int ( input ( ) ) for A in range ( 10 ) ] ) [ - 3 : ] ) for A in range ( 2 ) ] ) )
rst = print ( * sum ( [ sum ( sorted ( [ int ( input ( ) ) for A in range ( 10 ) ] ) [ - 3 : ] ) for A in range ( 2 ) ] ) ) <eos>
907
src = write ( ' \ n ' . join ( [ A % ( B , C ) forB , Cinenumerate ( D ) ] ) )
trg = write ( '\n' . join ( [ A % ( B , C ) for B , C in enumerate ( D ) ] ) )
rst = write ( '\n' . join ( [ A % B for A in zip ( C , B ) ] ) ) <eos>
908
src = 空白 文字 に 空白 文字 を 間 に 入れ て A の先頭 を 除 いた 部分 列 の 各要素 に 整数 を適用した 列 を 連結 した 文字列 を加えた 値 を出力する
trg = print ( ' ' + ' ' . join ( map ( str , A [ 1 : ] ) ) )
rst = print ( ' ' + ' ' . join ( map ( str , A [ 1 : ] ) ) ) <eos>
909
src = A . op ( A . laz [ ( B < < 1 ) + 1 ] , A . laz [ B ] ) を A の laz の B を 1 だけ 左 シフト した 値に 1 を加えた 値 番 目 にする
trg = A . laz [ ( B << 1 ) + 1 ] = A . op ( A . laz [ ( B << 1 ) + 1 ] , A . laz [ B ] )
rst = A . laz [ ( B << 1 ) + 1 ] = A . op ( A . laz [ ( B << 1 ) + 1 ) ] , A . laz [ B ] ) <eos>
910
src = (1) からなる 列 の 100 0000 回 分 の 列 を A とする
trg = A = [ 1 ] * 1000000
rst = A = [ 1 ] * 1000000 <eos>
911
src = xn ( B /2 , B ) を A とする
trg = A = xn ( B / 2 , B )
rst = A = <unk> ( B , 2 ) <eos>
912
src = A が B の answers に 含まれ ない とき 、
trg = if not A in B . answers :
rst = if A not in B . answers : <eos>
913
src = 0 から B / /2 に 1 を加えた 値 未 満 までの 数 列 の 各要素 を A とし 、 e から math . sqrt ( A * * 2 + ( B - A ) * * 2 ) を 引 いた 値の 絶対 値の 列 の 最小 値 を出力する
trg = print ( min ( [ abs ( e - math . sqrt ( A ** 2 + ( B - A ) ** 2 ) ) for A in range ( B // 2 + 1 ) ] ) )
rst = print ( min ( [ abs ( A ** 2 - e . sqrt ( B * A + 2 * B - A ** 2 ) ** 2 ) for A in range ( B // 2 + 1 ) ] ) ) <eos>
914
src = ( ( 、 つまり 未 定 値 ) からなる 列 の 0 から 5 未 満 までの 数 列 の 各要素 を B とし 、 5 の 列 回 分 の 列 ) からなる 列 を A とする
trg = A = [ [ None ] * [ 5 for B in range ( 5 ) ] ]
rst = A = [ [ None ] * [ 5 for B in range ( 5 ) ] ] <eos>
915
src = A の B から 1 を 引 いた 値 番目の C 番 目 が A の B 番目の C 番 目 より 小さく かつ D の back が E より 大きい とき 、
trg = if A [ B - 1 ] [ C ] < A [ B ] [ C ] and D . back > E :
rst = if A [ B - 1 ] [ C ] < A [ B ] [ C ] and D . back > E : <eos>
916
src = A の長さ が 1 より 大きく かつ A の先頭 が B と 等 しく または C の長さ が 1 より 大きく かつ C の先頭 が B と 等 しく または D の長さ が 1 より 大きく かつ D の先頭 が B と 等 しい とき 、
trg = if len ( A ) > 1 and A [ 0 ] == B or len ( C ) > 1 and C [ 0 ] == B or len ( D ) > 1 and D [ 0 ] == B :
rst = if ( len ( A ) > 1 and A [ 0 ] == B ) or ( len ( C ) > 1 and C [ 0 ] == B ) or ( len ( D ) > 0 and D [ 0 ] == B ) : <eos>
917
src = A を A から 1 を 引 いた 値を 5 で 割 った 余 り だけ 減少 させる
trg = A -= ( A - 1 ) % 5
rst = A -= ( A - 1 ) % 5 <eos>
918
src = A の list の先頭 を出力する
trg = print ( A . list [ 0 ] )
rst = print ( A . list [ 0 ] ) <eos>
919
src = A の 最大 値に 0.5 を加えた 値の 整数 値を返す
trg = return int ( max ( A ) + 0.5 )
rst = return ( max ( A ) + 0.5 ) <eos>
920
src = ( B 、 C ) からなる 列 の D が A と 等 しい かどうか 番 目 に E を加えた 値 を出力する
trg = print ( [ B , C ] [ D == A ] + E )
rst = print ( [ B , C ] [ D == A ] + E ) <eos>
921
src = A の B 番 目 を A の B から C を 引 いた 値 番 目 で 割 った 商 を D で 割 った 余 り を出力する
trg = print ( ( A [ B ] // A [ B - C ] ) % D )
rst = print ( A [ B ] // ( A [ B - C ] ) % D ) <eos>
922
src = B の C 番目の 0 番 目 に D の C 番 目 を 掛 け た 値を A とする
trg = A = B [ C ] [ 0 ] * D [ C ]
rst = A = B [ C ] [ 0 ] * D [ C ] <eos>
923
src = B . deque ( [ int ( input () ) forCinrange ( D ) ] ) を A とする
trg = A = B . deque ( [ int ( input ( ) ) for C in range ( D ) ] )
rst = A = B . <unk> ( [ int ( input ( ) ) for C in range ( D ) ] ) <eos>
924
src = A の B 番目の C 番目の 末 尾 に 0 を追加する
trg = A [ B ] [ C ] . append ( 0 )
rst = A [ B ] [ C ] . append ( 0 ) <eos>
925
src = A 、 dfs ( B , C + 1, 0 , D , 1, 0 ) の 最小 値を A とする
trg = A = min ( A , dfs ( B , C + 1 , 0 , D , 1 , 0 ) )
rst = A = min ( A , dfs ( B , C + 1 , 0 , D , 1 , 0 ) ) <eos>
926
src = ( ( B , 真 ) 、 ( C , 偽 ) 、 ( D , 偽 ) ) からなる 辞書 を A とする
trg = A = { 'A' : True , 'B' : False , 'C' : False }
rst = A = { <unk> : True , <unk> : False , "C" : False } <eos>
927
src = B の head の next を A とする
trg = A = B . head . next
rst = A = B . head . next <eos>
928
src = 入力された 文字列を 空白 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 のリスト の先頭 を 除 いた 部分 列 を A とする
trg = A = list ( map ( int , input ( ) . split ( ) ) ) [ 1 : ]
rst = A = list ( map ( int , input ( ) . split ( ) ) ) [ 1 : ] <eos>
929
src = B の 、 つまり 先頭 から 10 番 目 までの 部分 列 を 順に A として 、 繰り返す
trg = for A in B [ : 10 ] :
rst = for A in B [ : 10 ] : <eos>
930
src = ( ( B の INFINITY ) からなる 列 の 0 から C 未 満 までの 数 列 の 各要素 を D とし 、 C の 列 回 分 の 列 ) からなる 列 を A の M にする
trg = A . M = [ [ B . INFINITY ] * [ C for D in range ( C ) ] ]
rst = A . M = [ [ B . INFINITY ] * [ C for D in range ( C ) ] ] <eos>
931
src = C . GetNodes () の 各要素 を B とし 、 C . InDegree ( B ) が 0 と 等 しい とき の B の 列 を A とする
trg = A = [ B for B in C . GetNodes ( ) if C . InDegree ( B ) == 0 ]
rst = A = [ B for B in C . GetNodes ( ) if C . <unk> ( B ) == 0 ] <eos>
932
src = A を B から C の D 番 目 を 引 いた 値の 絶対 値 、 B から C の D から 1 を 引 いた 値 番 目 を 引 いた 値の 絶対 値の 最小 値 だけ 増加 させる
trg = A += min ( abs ( B - C [ D ] ) , abs ( B - C [ D - 1 ] ) )
rst = A += min ( abs ( B - C [ D ] ) , abs ( B - C [ D - 1 ] ) ) <eos>
933
src = 1 を 開始 番号 として C 、 D 、 D の先頭 を 除 いた 部分 列 の 要素を それぞれ 組 にした 列 に 番号 付 した 組 の 列 を 順に A 、 B として 、 繰り返す
trg = for A , B in enumerate ( zip ( C , D , D [ 1 : ] ) , start = 1 ) :
rst = for A , B in enumerate ( zip ( C , D , D [ 1 : ] ) , start = 1 ) : <eos>
934
src = B を A の tail の prev の next にする
trg = A . tail . prev . next = B
rst = A . tail . prev . next = B <eos>
935
src = ( -1 ) からなる 列 の C 回 分 の 列 、 ( -1 ) からなる 列 の C 回 分 の 列 を A 、 B とする
trg = A , B = [ - 1 ] * C , [ - 1 ] * C
rst = A , B = [ - 1 ] * C , [ - 1 ] * C <eos>
936
src = A の B が 2 と 等 しい かどうか 番 目 を出力する
trg = print ( A [ B == 2 ] )
rst = print ( A [ B == 2 ] ) <eos>
937
src = ( 、 つまり 未 定 値 ) からなる 列 の 3 1 回 分 の 列 を A とする
trg = A = [ None ] * 31
rst = A = [ None ] * 31 <eos>
938
src = power ( A , B / /2 ) の 2 乗 に A を 掛 け た 値を C で 割 った 余 り を返す
trg = return power ( A , B // 2 ) ** 2 * A % C
rst = return ( power ( A , B // 2 ) ** 2 * A ) % C <eos>
939
src = D の長さ から E から F を 引 いた 値を 引 いた 値を A の B 番目の C 番 目 にする
trg = A [ B ] [ C ] = len ( D ) - ( E - F )
rst = A [ B ] [ C ] = len ( D ) - ( E - F ) <eos>
940
src = A が ( 2 、 3 ) からなる 列 と 等 しい とき 、
trg = if A == [ 2 , 3 ] :
rst = if A == [ 2 , 3 ] : <eos>
941
src = A かつ A に B の先頭 の 0 番 目 を 掛 け た 値が C より 小さい 間 、 次 を 繰り返す
trg = while A and A * B [ 0 ] [ 0 ] < C :
rst = while A and B [ 0 ] [ 0 ] < C : <eos>
942
src = A の 末 尾 に ( B 、 C 、 D 、 10 の 9 乗 、 0 、 0 ) の 組 を追加する
trg = A . append ( ( B , C , D , 10 ** 9 , 0 , 0 ) )
rst = A . append ( ( B , C , D , 10 ** 9 , 0 ) ) <eos>
943
src = swap ( A [ 0 ] )
trg = swap ( A [ 0 ] )
rst = swap ( A [ 0 ] ) <eos>
944
src = dcmp ( cross ( B [ 1 ]- B [ 0 ] , C - B [ 0 ] ) ) を A とする
trg = A = dcmp ( cross ( B [ 1 ] - B [ 0 ] , C - B [ 0 ] ) )
rst = A = <unk> ( cross ( B [ 1 ] - B [ 0 ] , C - B [ 0 ] ) ) <eos>
945
src = A と 1 0000 を 割 った とき の ( 商 を 展開 し 、 それぞれ A 、 B とする
trg = A , B = divmod ( A , 10000 )
rst = A , B = divmod ( A , 10000 ) <eos>
946
src = 4 から B に 1 を加えた 値 未 満 までの 2 間隔 の 数 列 を 順に A として 、 繰り返す
trg = for A in range ( 4 , B + 1 , 2 ) :
rst = for A in range ( 4 , B + 1 , 2 ) : <eos>
947
src = A を 3 、 A から 1 を 引 いた 値を 36 5 24 で 割 った 商 の 最小 値に 36 5 24 を 掛 け た 値 だけ 減少 させる
trg = A -= min ( 3 , ( A - 1 ) // 36524 ) * 36524
rst = A -= min ( 3 , ( A - 1 ) // <unk> * 365 ) <eos>
948
src = A の root の left が 、 つまり 未 定 値 と 等 しく ない とき 、
trg = if A . root . left is None :
rst = if A . root . left is None : <eos>
949
src = 空 列 を A の nodes にする
trg = A . nodes = [ ]
rst = A . nodes = [ ] <eos>
950
src = B . ccw ( C [ -1 ] , D , E ) を A とする
trg = A = B . ccw ( C [ - 1 ] , D , E )
rst = A = B . ccw ( C [ - 1 ] , D , E ) <eos>
951
src = A を B に C の D から E を 引 いた 値 から 1 を 引 いた 値 番 目 を 掛 け た 値 だけ 増加 させる
trg = A += B * C [ D - E - 1 ]
rst = A += B * C [ D - E - 1 ] <eos>
952
src = asin ( B / sqrt ( C ) ) を A とする
trg = A = asin ( B / sqrt ( C ) )
rst = A = asin ( B / sqrt ( C ) ) <eos>
953
src = A の data を 1 を B の 整数値 だけ 左 シフト した 値 と の 排 他 的 論理 和 にする
trg = A . data ^= 1 << int ( B )
rst = A . data ^= 1 << int ( B ) <eos>
954
src = A に B を加えた 値 でない とき 、
trg = if not A + B :
rst = if not A + B : <eos>
955
src = relax ( e )
trg = relax ( e )
rst = <unk> ( e ) <eos>
956
src = A の B 番目の とき C の D 番 目 、 そうでなければ E に 1 を加えた 値を返す
trg = return C [ D ] if A [ B ] else E + 1
rst = return C [ D ] if A [ B ] else E + 1 <eos>
957
src = A の先頭 を 10 で 割 った 商 が B 以下 かどうか が C の先頭 を 10 で 割 った 商 より 小さく または A の先頭 を 10 で 割 った 商 が C の先頭 を 10 で 割 った 商 と 等 しい かどうか が B と 等 しい とき 、
trg = if A [ 0 ] // 10 <= B < C [ 0 ] // 10 or A [ 0 ] // 10 == C [ 0 ] // 10 == B :
rst = if A [ 0 ] // 10 <= B < C [ 0 ] // 10 or A [ 0 ] [ 0 ] == ( C // 10 ) // 0 == B : <eos>
958
src = 入力された 文字列を 空白 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 のリスト に ( sys の maxsize ) からなる 列 を加えた 値を A とする
trg = A = list ( map ( int , input ( ) . split ( ) ) ) + [ sys . maxsize ]
rst = A = list ( map ( int , input ( ) . split ( ) ) ) + [ list ( map ( int , input ( ) ) ) ] <eos>
959
src = x を パラメータ として x の 1 番 目 を返す関数 を キー として C の キー と 値 の集まり を ソート した 列 の 逆 順 を 順に A 、 B として 、 繰り返す
trg = for A , B in sorted ( C . items ( ) , key = lambda D : D [ 1 ] ) [ : : - 1 ] :
rst = for A , B in sorted ( C . items ( ) , key = lambda E : D [ 1 ] ) [ : : - 1 ] : <eos>
960
src = A . push ( B , C )
trg = A . push ( B , C )
rst = A . push ( B , C ) <eos>
961
src = 2 * ( B - C ) * D から E * * 2 を 引 いた 値 から B の 2 乗 を 引 いた 値に F の 2 乗 を加えた 値に C の 2 乗 を加えた 値を 2 に F から E を 引 いた 値を 掛 け た 値 で 割 った 値を A とする
trg = A = ( 2 * ( B - C ) * D - E ** 2 - B ** 2 + F ** 2 + C ** 2 ) / ( 2 * ( F - E ) )
rst = A = ( 2 ** ( B - C ) - D ** 2 - E ** 2 - B ** 2 + F ** 2 ) / ( C ** 2 + E - F ** 2 ) <eos>
962
src = A の 末 尾 に ( 、 つまり 真 ) からなる 列 に ( 、 つまり 偽 ) からなる 列 の B に ( True ) からなる 列 を加えた 値 回 分 の 列 を加えた 値 を追加する
trg = A . append ( [ True ] + [ False ] * B + [ True ] )
rst = A . append ( [ True ] + [ False ] * ( B + True ) ) <eos>
963
src = ( 0 、 1 、 2 、 4 、 6 、 16 、 12 、 64 、 24 、 36 、 4 8 、 10 24 、 60 ) からなる 列 を A とする
trg = A = [ 0 , 1 , 2 , 4 , 6 , 16 , 12 , 64 , 24 , 36 , 48 , 1024 , 60 ]
rst = A = [ 0 , 1 , 2 , 4 , 6 , 16 , 12 , 64 , 24 , 36 , 48 , 1024 , 60 ] <eos>
964
src = A 、 B の 最大 値 を出力する
trg = print ( max ( A , B ) )
rst = print ( max ( A , B ) ) <eos>
965
src = x を パラメータ として ( - C の 1 番 目 、 x の 2 番 目 、 x の先頭 ) の 組 を返す関数 を キー として B を ソート した 列 を A とする
trg = A = sorted ( B , key = lambda C : ( - C [ 1 ] , C [ 2 ] , C [ 0 ] ) )
rst = A = sorted ( B , key = lambda C : ( - C [ 1 ] , C [ 2 ] , C [ 0 ] ) ) <eos>
966
src = C 、 D 、 A 、 B を A 、 B 、 C 、 D とする
trg = A , B , C , D = C , D , A , B
rst = A , B , C , D = C , D , A , B <eos>
967
src = A の先頭 の 1 番 目 が B と 等 しい 間 、 次 を 繰り返す
trg = while A [ 0 ] [ 1 ] == B :
rst = while A [ 0 ] [ 1 ] == B : <eos>
968
src = ( ( B , 0 ) 、 ( C , 0 ) 、 ( D , 0 ) 、 ( E , 0 ) ) からなる 辞書 を A とする
trg = A = { 'A' : 0 , 'B' : 0 , 'AB' : 0 , 'O' : 0 }
rst = A = { <unk> : 0 , <unk> : 0 , "C" : 0 } <eos>
969
src = C の 各要素 を B とし 、 B 内の -1 の 出現 回数 の 列 の 総 和 を A とする
trg = A = sum ( [ B . count ( - 1 ) for B in C ] )
rst = A = sum ( [ B . count ( - 1 ) for B in C ] ) <eos>
970
src = B に C から D を 引 いた 値に 1 を加えた 値を 掛 け た 値を A とする
trg = A = B * ( C - D + 1 )
rst = A = B * ( C - D + 1 ) <eos>
971
src = A を 3 で 割 った 余 り が 0 と 等 しく または B が A の 文字列 に含まれる とき 、
trg = if A % 3 == 0 or B in str ( A ) :
rst = if A % 3 == 0 or B in str ( A ) : <eos>
972
src = it () から B を 引 いた 値を A とする
trg = A = it ( ) - B
rst = A = it ( ) - B <eos>
973
src = B の C の D に 1 を加えた 値 番 目 番 目 を A とする
trg = A = B [ C [ D + 1 ] ]
rst = A = B [ C [ D + 1 ] ] <eos>
974
src = F の先頭 、 F の 1 番 目 、 F の 2 番 目 、 F の 3 番 目 、 F の 4 番 目 、 F の 5 番 目 を A 、 B 、 C 、 D 、 ネ イ ピ ア 数 、 E とする
trg = A , B , C , D , e , E = F [ 0 ] , F [ 1 ] , F [ 2 ] , F [ 3 ] , F [ 4 ] , F [ 5 ]
rst = A , B , C , D , e , E = F [ 0 ] , F [ 1 ] , F [ 2 ] , F [ 3 ] , F [ 4 ] , F [ 5 ] <eos>
975
src = B [ C ] の D 番目の 0 番 目 から B [ E -1 ] の D 番目の 0 番 目 を 引 いた 値 から B の C 番目の F から 1 を 引 いた 値 番目の 0 番 目 を 引 いた 値に B の E から 1 を 引 いた 値 番目の F から 1 を 引 いた 値 番目の 先頭 を加えた 値を A の 0 番 目 にする
trg = A [ 0 ] = B [ C ] [ D ] [ 0 ] - B [ E - 1 ] [ D ] [ 0 ] - B [ C ] [ F - 1 ] [ 0 ] + B [ E - 1 ] [ F - 1 ] [ 0 ]
rst = A [ 0 ] [ 0 ] = B [ C ] [ D ] [ 0 ] - B [ E - 1 ] [ D ] [ 0 ] - B [ C ] [ F - 1 ] [ 0 ] + B [ E - 1
976
src = A の real に B から C を 引 いた 値を 掛 け た 値に C を加えた 値を返す
trg = return A . real * ( B - C ) + C
rst = return A . real * ( B - C ) + C <eos>
977
src = A の B 番目の C 番 目 を A の B から 1 を 引 いた 値 番目の C 番 目 から C に 2 を加えた 値 までの 部分 列 の 最大 値 だけ 増加 させる
trg = A [ B ] [ C ] += max ( A [ B - 1 ] [ C : C + 2 ] )
rst = A [ B ] [ C ] += max ( A [ B - 1 ] [ C : C + 2 ] ) <eos>
978
src = C の B 番 目 に C の B に 1 を加えた 値 番 目 を加えた 値を 10 で 割 った 余 り を A の B 番 目 にする
trg = A [ B ] = ( C [ B ] + C [ B + 1 ] ) % 10
rst = A [ B ] = ( C [ B ] + C [ B + 1 ] ) % 10 <eos>
979
src = A の 末 尾 に B に 20 を 掛 け た 値 を追加する
trg = A . append ( B * 20 )
rst = A . append ( B * 20 ) <eos>
980
src = A の 末 尾 に 空白 文字 を追加する
trg = A . append ( ' ' )
rst = A . append ( ' ' ) <eos>
981
src = A の B 番目の 整数値 を出力する
trg = print ( int ( A [ B ] ) )
rst = print ( int ( A [ B ] ) ) <eos>
982
src = atan 2 ( B . c . y - C . c . y , B . c . x - C . c . x ) を A とする
trg = A = atan2 ( B . c . y - C . c . y , B . c . x - C . c . x )
rst = A = atan2 ( B . c . y - C . c . y , B . c . x - C . x ) <eos>
983
src = dot ( A , B ) が 0 より 小さい とき 、
trg = if dot ( A , B ) < 0 :
rst = if dot ( A , B ) < 0 : <eos>
984
src = funcs [ op ] ( A )
trg = funcs[op] ( A )
rst = <unk> ( A ) <eos>
985
src = A の 末 尾 に ( B 、 C 、 D 、 E から F を 引 いた 値 ) からなる 列 を追加する
trg = A . append ( [ B , C , D , E - F ] )
rst = A . append ( [ B , C , D , E - F ] ) <eos>
986
src = ( < __ main __ . Cammaobjectat 0 x 10 a 1 db 8 80 > ) の集合 を A とする
trg = A = { [ B for B in range ( C ) ] }
rst = A = { [ B for B in range ( 1 , C ) ] } <eos>
987
src = 0 から E に 2 を 掛 け た 値 から 1 を 引 いた 値 未 満 までの 数 列 の 各要素 を C とし 、 0 から D に 2 を 掛 け た 値 から 1 を 引 いた 値 未 満 までの 数 列 の 各要素 を C とし 、 B の 列 の 列 を A とする
trg = A = [ [ B for C in range ( D * 2 - 1 ) ] for C in range ( E * 2 - 1 ) ]
rst = A = [ [ B for C in range ( D * 2 - 1 ) ] for C in range ( E * 2 - 1 ) ] <eos>
988
src = A の 両 端 から 空白 改行 を取り 除 いた 文字列 内の B を C で 置き換え た 文字列 内の D を B で 置き換え た 文字列 内の C を D で 置き換え た 文字列 を出力する
trg = print ( A . strip ( ) . replace ( B , C ) . replace ( D , B ) . replace ( C , D ) )
rst = print ( A . strip ( ) . replace ( B , C ) . replace ( D , B ) . replace ( C , D ) ) <eos>
989
src = ( 、 つまり 未 定 値 ) からなる 列 の B 回 分 の 列 を A の [MASK] と 等 しい 要素 の最初の 位置 にする
trg = A . index = [ None ] * B
rst = A . index = [ None ] * B <eos>
990
src = B に C に ネ イ ピ ア 数 を加えた 値 から D を 引 いた 値を ネ イ ピ ア 数 から B を 引 いた 値 で 割 った 余 り を加えた 値を A とする
trg = A = B + ( ( C + e - D ) % ( e - B ) )
rst = A = B + ( ( C + e - D ) % ( e - B ) ) <eos>
991
src = B において 正規表現 A が 最初 にマッチする 位置 を A とする
trg = A = search ( A , B )
rst = A = search ( A , B ) <eos>
992
src = open ( 1, A ) . writelines ( [ B % bisect ( C , int ( readline () ) -1 ) forDinrange ( int ( readline () ) ) ] )
trg = open ( 1 , A ) . writelines ( [ B % bisect ( C , int ( readline ( ) ) - 1 ) for D in range ( int ( readline ( ) ) ) ] )
rst = open ( 1 , A ) . writelines ( [ B % C for C in range ( int ( readline ( ) ) - 1 ) ] ) <eos>
993
src = A 内の ( B に 1 を加えた 値 、 C ) からなる 列 と 等 しい 要素を 取り除く
trg = A . remove ( [ B + 1 , C ] )
rst = A . remove ( [ B + 1 , C ] ) <eos>
994
src = A が 、 つまり 無限大 と 等 しく ない とき A 、 そうでなければ 0 を出力する
trg = print ( A if A != inf else 0 )
rst = print ( A if A != inf else 0 ) <eos>
995
src = moveNodeW ( B . node , C ) を A とする
trg = A = moveNodeW ( B . node , C )
rst = A = <unk> ( B . node , C ) <eos>
996
src = A を B を C の D 番 目 で 割 った 商 だけ 増加 させる
trg = A += B // C [ D ]
rst = A += B // C [ D ] <eos>
997
src = write ( dfs ( A , 0 ) )
trg = write ( dfs ( A , 0 ) )
rst = write ( dfs ( A , 0 ) ) <eos>
998
src = B を 2 だけ 増加 させる
trg = B += 2
rst = B += 2 <eos>
999
src = A に B を 掛 け た 値に C に D を 掛 け た 値 を加えた 値が 0 と 等 しい とき 、
trg = if A * B + C * D == 0 :
rst = if A * B + C * D == 0 : <eos>
1000
src = paint ( A , B - 1, C ) を A とする
trg = A = paint ( A , B - 1 , C )
rst = A = paint ( A , B - 1 , C ) <eos>
1001
src = A の B に C を加えた 値 番目の 0 番 目 が 0 以上の とき 、
trg = if A [ B + C ] [ 0 ] >= 0 :
rst = if A [ B + C ] [ 0 ] >= 0 : <eos>
1002
src = range ( 5 ) の 各要素 を A とし 、 max ( 40 , int ( input () ) ) の 列 の 総 和 を 5 で 割 った 値の 整数値 を出力する
trg = print ( int ( sum ( [ max ( 40 , int ( input ( ) ) ) for A in range ( 5 ) ] ) / 5 ) )
rst = print ( int ( sum ( [ max ( 40 , int ( input ( ) ) ) / 5 for A in range ( 5 ) ] ) ) ) <eos>
1003
src = A の B から A の長さ を 引 いた 値 から 、 つまり 末 尾 までの 部分 列 に A の 、 つまり 先頭 から B 番 目 までの 部分 列 を加えた 値を A とする
trg = A = A [ B - len ( A ) : ] + A [ : B ]
rst = A = A [ B - len ( A ) : ] + A [ : B ] <eos>
1004
src = vector _ product ( A , B ) の 総 和 を返す
trg = return sum ( vector_product ( A , B ) )
rst = return sum ( vector ( A , B ) ) <eos>
1005
src = A に B を加えた 値に C を加えた 値が 20 以下の とき 、
trg = if A + B + C <= 20 :
rst = if A + B + C <= 20 : <eos>
1006
src = A の B から 1 を 引 いた 値 番 目 に C の B 番 目 を加えた 値を A の B 番 目 にする
trg = A [ B ] = A [ B - 1 ] + C [ B ]
rst = A [ B ] = A [ B - 1 ] + C [ B ] <eos>
1007
src = DFS ( A + 1 )
trg = DFS ( A + 1 )
rst = DFS ( A + 1 ) <eos>
1008
src = 0 から 1 を E だけ 左 シフト した 値 未 満 までの 数 列 の 各要素 を C とし 、 B の C 番目の D 番目の 列 の 最小 値を A とする
trg = A = min ( [ B [ C ] [ D ] for C in range ( 1 << E ) ] )
rst = A = min ( [ B [ C ] [ D ] for C in range ( 1 << E ) ] ) <eos>
1009
src = A を B の C 番 目 に C を 掛 け た 値 だけ 増加 させる
trg = A += B [ C ] * C
rst = A += B [ C ] * C <eos>
1010
src = B が ( 0 、 2 ) からなる 列 に含まれる とき F の 各要素 を E とし 、 F の 列 の 各要素 を D とし 、 C [ 1 ] [ D ] [ E ] に C [ D ] [ E ] [ 1 ] を加えた 値の 列 の 総 和 から F の 各要素 を D とし 、 C [ 1 ] [ D ] の 1 番目の 列 の 総 和 を 引 いた 値
trg = A [ 1 ] [ 0 ] [ 1 ] = sum ( [ C [ 1 ] [ D ] [ E ] + C [ D ] [ E ] [ 1 ] for D in [ F for E in F ] ] ) - sum ( [ C [ 1 ] [ D ] [ 1 ] for D in F ] ) if B in [ 0 , 2 ] else 0
rst = A [ 1 ] [ 1 ] = sum ( [ C [ D ] [ 1 ] [ E ] + C [ D ] [ E ] [ 1 ] for D in [ F for E in F ] ] ) - sum ( [ C [
1011
src = A . solve ( B , C , 1, 1, 1, 0 ) を出力する
trg = print ( A . solve ( B , C , 1 , 1 , 1 , 0 ) )
rst = print ( A . solve ( B , C , 1 , 1 , 1 , 0 ) ) <eos>
1012
src = A の B 番目の 1 番 目 が C と 等 しい とき 、
trg = if A [ B ] [ 1 ] == C :
rst = if A [ B ] [ 1 ] == C : <eos>
1013
src = A を 25 で 割 った 余 り にする
trg = A %= 25
rst = A %= 25 <eos>
1014
src = A に 19 11 を加えた 値を返す
trg = return A + 1911
rst = return A + 1911 <eos>
1015
src = A を 3 に B を 掛 け た 値 だけ 減少 させる
trg = A -= 3 * B
rst = A -= 3 * B <eos>
1016
src = C を 順に ネ イ ピ ア 数 、 A 、 B として 、 繰り返す
trg = for e , A , B in C :
rst = for e , A , B in C : <eos>
1017
src = A の 末 尾 に ( B 、 0 、 C 、 -1 ) の 組 を追加する
trg = A . append ( ( B , 0 , C , - 1 ) )
rst = A . append ( ( B , 0 , C , - 1 ) ) <eos>
1018
src = is _ passable ( A , B , C , D , E , F [ G ] , H [ G ] ) かつ I の J 番目の K 番 目 が L の 浮動小数点数 と 等 しい とき 、
trg = if is_passable ( A , B , C , D , E , F [ G ] , H [ G ] ) and I [ J ] [ K ] == float ( L ) :
rst = if <unk> ( A , B , C , D , E , F , G [ H ] [ I ] ) and float ( J [ K ] ) == L : <eos>
1019
src = 600 0 を返す
trg = return 6000
rst = return 6000 <eos>
1020
src = Cond ( A , B , C , D , E ) の とき 、
trg = if Cond ( A , B , C , D , E ) :
rst = if <unk> ( A , B , C , D , E ) : <eos>
1021
src = D に A の C の B から 1 を 引 いた 値 番目の C から E を 引 いた 値 番 目 を加えた 値を A の C の B 番目の C 番 目 にする
trg = A . C [ B ] [ C ] = D + A . C [ B - 1 ] [ C - E ]
rst = A . C [ B ] [ C ] = D + A [ C [ B - 1 ] [ C - E ] <eos>
1022
src = C の 両 端 から 空白 改行 を取り 除 いた 文字列を 空白 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 を 展開 し 、 それぞれ A 、 B とする
trg = A , B = map ( int , C . strip ( ) . split ( ) )
rst = A , B = map ( int , C . strip ( ) . split ( ) ) <eos>
1023
src = t を パラメータ として - t の 1 番 目 を返す関数 を key として A を ソート する
trg = A . sort ( key = lambda B : - B [ 1 ] )
rst = A . sort ( key = lambda B : - B . t [ 1 ] ) <eos>
1024
src = p を パラメータ として atan 2 ( C [ D ] [ 1 ]- E , C [ D ] [ 0 ]- F ) を返す関数 を key として A の B 番 目 を ソート する
trg = A [ B ] . sort ( key = lambda D : atan2 ( C [ D ] [ 1 ] - E , C [ D ] [ 0 ] - F ) )
rst = A [ B ] . sort ( key = lambda D : atan2 ( C [ D ] [ 1 ] - E , C [ D ] [ 0 ] - F ) ) <eos>
1025
src = 1 0000 を A の B 番目の C 番 目 にする
trg = A [ B ] [ C ] = 10000
rst = A [ B ] [ C ] = 10000 <eos>
1026
src = A を 1 と の 排 他 的 論理 和 にする
trg = A ^= 1
rst = A ^= 1 <eos>
1027
src = A の rev の B 番目の 末 尾 に C を追加する
trg = A . rev [ B ] . append ( C )
rst = A . rev [ B ] . append ( C ) <eos>
1028
src = solve ( B + 1, C ) を A とする
trg = A = solve ( B + 1 , C )
rst = A = solve ( B + 1 , C ) <eos>
1029
src = C の 1 番 目 から C の 先頭に 1 を加えた 値 までの 部分 列 を A の B 番 目 にする
trg = A [ B ] = C [ 1 : C [ 0 ] + 1 ]
rst = A [ B ] = C [ 1 : C [ 0 ] + 1 ] <eos>
1030
src = A の n が B と 等 しい とき 、
trg = if A . n == B :
rst = if A . n == B : <eos>
1031
src = A から A に 5 を加えた 値 未 満 までの 数 列 のリスト が B と 等 しい とき 、
trg = if list ( range ( A , A + 5 ) ) == B :
rst = if list ( range ( A , A + 5 ) ) == B : <eos>
1032
src = A に B を加えた 値を 2 で 割 った 値の 整数値 を出力する
trg = print ( int ( ( A + B ) / 2 ) )
rst = print ( int ( ( A + B ) / 2 ) ) <eos>
1033
src = A の 20 番 目 、 A の 18 番 目 を A の 18 番 目 、 A の 20 番 目 とする
trg = A [ 18 ] , A [ 20 ] = A [ 20 ] , A [ 18 ]
rst = A [ 18 ] , A [ 20 ] = A [ 20 ] , A [ 18 ] <eos>
1034
src = A の 4 番 目 を B だけ 増加 させる
trg = A [ 4 ] += B
rst = A [ 4 ] += B <eos>
1035
src = E に C に F を 掛 け た 値 を加えた 値を A の B に C に D を 掛 け た 値 を加えた 値 番 目 にする
trg = A [ B + C * D ] = E + C * F
rst = A [ B + C * D ] = E + C * F <eos>
1036
src = ( 0 、 1 ) からなる 列 の A が B より 小さい かどうか 番 目 を出力する
trg = print ( [ 0 , 1 ] [ A < B ] )
rst = print ( [ 0 , 1 ] [ A < B ] ) <eos>
1037
src = B を 3 600 で 割 った 商 の 文字列を 長さ 2 になる ように ' 0 ' 左 詰 め した 文字列を A とする
trg = A = str ( B // 3600 ) . zfill ( 2 )
rst = A = str ( B // 3600 ) . zfill ( 2 ) <eos>
1038
src = E の B 番目の D 番 目 を A の B に C を 掛 け た 値に D を加えた 値 番 目 にする
trg = A [ B * C + D ] = E [ B ] [ D ]
rst = A [ B * C + D ] = E [ B ] [ D ] <eos>
1039
src = 0 が A を 1000 で 割 った 余 り より 小さい かどうか が 500 以下の とき 、
trg = if 0 < A % 1000 <= 500 :
rst = if 0 < A % 1000 <= 500 : <eos>
1040
src = B の キー の集まり を 順に A として 、 繰り返す
trg = for A in B . keys ( ) :
rst = for A in B . keys ( ) : <eos>
1041
src = B に 2 を 掛 け た 値に C を加えた 値を 3 で 割 った 値を A とする
trg = A = ( B * 2 + C ) / 3
rst = A = ( B * 2 + C ) / 3 <eos>
1042
src = A を inorder ( B [ C ] [ 0 ] ) だけ 増加 させる
trg = A += ( inorder ( B [ C ] [ 0 ] ) )
rst = A += ( inorder ( B [ C ] [ 0 ] ) ) <eos>
1043
src = B の 、 つまり 先頭 から C に D を 掛 け た 値 までの 部分 列 を A の 、 つまり 先頭 から 、 つまり 末 尾 までの 部分 列 にする
trg = A [ : ] = B [ : C * D ]
rst = A [ : ] = B [ : C * D ] <eos>
1044
src = phase ( B ) を A とする
trg = A = phase ( B )
rst = A = phase ( B ) <eos>
1045
src = D の E 番 目 を 順に A 、 B 、 C として 、 繰り返す
trg = for A , B , C in D [ E ] :
rst = for A , B , C in D [ E ] : <eos>
1046
src = fib ( B -1 ) を A とする
trg = A = fib ( B - 1 )
rst = A = fib ( B - 1 ) <eos>
1047
src = A の -2 番 目 に A の -1 番 目 を加えた 値に 1 を加えた 値を A の -2 番 目 にする
trg = A [ - 2 ] = A [ - 2 ] + A [ - 1 ] + 1
rst = A [ - 2 ] = A [ - 2 ] + A [ - 1 ] + 1 <eos>
1048
src = A の B に C を加えた 値 番目の 末 尾 に ( B に D を加えた 値 、 E の C から D を 引 いた 値 から 1 を 引 いた 値 番 目 ) の 組 を追加する
trg = A [ B + C ] . append ( ( B + D , E [ C - D - 1 ] ) )
rst = A [ B + C ] . append ( ( B + D , E [ C - D - 1 ] ) ) <eos>
1049
src = A を B の先頭 を取り 出した 値 だけ 増加 させる
trg = A += B . pop ( )
rst = A += B . pop ( ) <eos>
1050
src = 0 から D -1 未 満 までの 数 列 の 各要素 を C とし 、 B の C 番目の 列 の 総 和 に E を加えた 値 から 1 を 引 いた 値を A とする
trg = A = sum ( [ B [ C ] for C in range ( D - 1 ) ] ) + E - 1
rst = A = sum ( [ B [ C ] for C in range ( D - 1 ) ] ) - ( E + 1 ) <eos>
1051
src = A の B 番目の 1 番 目 を そうでなければ 、 とする
trg = else = A [ B ] [ 1 ]
rst = else = A [ B ] [ 1 ] <eos>
1052
src = A の B に 1 を加えた 値 番目の C 番 目 を A の B 番目の C 番 目 にする
trg = A [ B ] [ C ] = A [ B + 1 ] [ C ]
rst = A [ B ] [ C ] = A [ B + 1 ] [ C ] <eos>
1053
src = A に 10 の B 乗 を 掛 け た 値に C を加えた 値を返す
trg = return A * 10 ** B + C
rst = return A * ( 10 ** B ) + C <eos>
1054
src = A に B の 文字列 を加えた 値に C を加えた 値に D の 文字列 を加えた 値 を出力する
trg = print ( A + str ( B ) + C + str ( D ) )
rst = print ( A + str ( B ) + C + str ( D ) ) <eos>
1055
src = A の q の B 番 目 が A の q の C 番 目 より 大きい とき 、
trg = if A . q [ B ] > A . q [ C ] :
rst = if A . q [ B ] > A . q [ C ] : <eos>
1056
src = 1 から 26 未 満 までの 数 列 を 順に A として 、 繰り返す
trg = for A in range ( 1 , 26 ) :
rst = for A in range ( 1 , 26 ) : <eos>
1057
src = A が B に 含まれ または C が B に含まれる とき 、
trg = if ( A in B ) or ( C in B ) :
rst = if A in B or C in B : <eos>
1058
src = 無限 の 整数 列 の先頭 の 1 番 目 が 3 と 等 しい とき 、
trg = if count [ 0 ] [ 1 ] == 3 :
rst = if count [ 0 ] [ 1 ] == 3 : <eos>
1059
src = A の time を B だけ 減少 させる
trg = A . time -= B
rst = A . time -= B <eos>
1060
src = ( - 、 つまり 円 周 率 、 -1 ) の 組 を A に ソート 順 で 最後に 挿入 する
trg = insort ( A , ( - pi , - 1 ) )
rst = insort ( A , ( - pi , - 1 ) ) <eos>
1061
src = 空文字列 を 間 に 入れ て 0 から E 未 満 までの 数 列 の 各要素 を D とし 、 0 が C に D を加えた 値 以下 かどうか が E より 小さい とき の B の C に D を加えた 値 番目の D 番目の 列 を 連結 した 文字列を A とする
trg = A = '' . join ( [ B [ C + D ] [ D ] for D in range ( E ) if 0 <= C + D < E ] )
rst = A = '' . join ( [ B [ C + D ] [ D ] for D in range ( E ) if 0 <= C + D < E ] ) <eos>
1062
src = B の 各要素 に A の [MASK] と 等 しい 要素 の最初の 位置 を適用した 列 を 順に ネ イ ピ ア 数 として 、 繰り返す
trg = for e in map ( A . index , B ) :
rst = for e in map ( A . index , B ) : <eos>
1063
src = next ( A )
trg = next ( A )
rst = next ( A ) <eos>
1064
src = A の B 番 目 を 2 を C だけ 左 シフト した 値 と の 論理 和 にする
trg = A [ B ] |= ( 2 << C )
rst = A [ B ] |= 2 << C <eos>
1065
src = 1 を A の 2 番 目 にする
trg = A [ 2 ] = 1
rst = A [ 2 ] = 1 <eos>
1066
src = A かつ B の A を A と - A の 論理 積 で 割 った 商 番 目 が 3 と 等 しい とき 、
trg = if A and B [ A // ( A & - A ) ] == 3 :
rst = if A and B [ A & - A ] == 3 : <eos>
1067
src = A を ( B 、 C ) の 組 で 割 った 余 り を返す
trg = return ( A % ( B , C ) )
rst = return A % ( B , C ) <eos>
1068
src = A の先頭 の 1 番 目 、 A の 1 番 目 を出力する
trg = print ( A [ 0 ] [ 1 ] , A [ 1 ] )
rst = print ( A [ 0 ] [ 1 ] , A [ 1 ] ) <eos>
1069
src = C が D 以下の とき C の 2 乗 に D の 2 乗 を加えた 値を 2 に C を 掛 け た 値 で 割 った 値 、 そうでなければ D を B とする
trg = B = ( ( C ** 2 + D ** 2 ) / ( 2 * C ) if C <= D else D )
rst = D = ( C ** 2 + D ** 2 ) / ( 2 * C ) if C <= D else D <eos>
1070
src = 11 から 100 0000 未 満 までの 数 列 を 順に A として 、 繰り返す
trg = for A in range ( 11 , 1000000 ) :
rst = for A in range ( 11 , 1000000 ) : <eos>
1071
src = 入力された 文字列 の 文字列を 順に A として 、 繰り返す
trg = for A in str ( input ( ) ) :
rst = for A in input ( ) : <eos>
1072
src = A を 400 で 割 った 余 り が 0 と 等 しく または A を 4 で 割 った 余 り が 0 と 等 しく かつ A を 100 で 割 った 余 り が 0 と 等 しく ない かどうか を返す
trg = return A % 400 == 0 or ( A % 4 == 0 and A % 100 != 0 )
rst = return A % 400 == 0 or A % 4 == 0 and A % 100 != 0 <eos>
1073
src = os . path の A 番目の B 番 目 を A とする
trg = A = path [ A ] [ B ]
rst = A = path [ A ] [ B ] <eos>
1074
src = (1) からなる 列 の B から A を 引 いた 値 回 分 の 列 を time の A 番 目 から B 番 目 までの 部分 列 にする
trg = time [ A : B ] = [ 1 ] * ( B - A )
rst = time [ A : B ] = [ 1 ] * ( B - A ) <eos>
1075
src = A を B が C を 2 で 割 った 商 より 大きい とき B 、 そうでなければ C から B を 引 いた 値 だけ 増加 させる
trg = A += B if B > C // 2 else C - B
rst = A += B if B > C // 2 else C - B <eos>
1076
src = A の 先頭に B の 4 番 目 から 、 つまり 末 尾 までの 部分 列 を追加する
trg = A . appendleft ( B [ 4 : ] )
rst = A . appendleft ( B [ 4 : ] ) <eos>
1077
src = A の 3 番 目 から B を 引 いた 値 から C を 引 いた 値 から 2 を 引 いた 値を ネ イ ピ ア 数 とする を A の 3 番 目 にする
trg = A [ 3 ] = e = A [ 3 ] - B - C - 2
rst = A [ 3 ] = e - B = A [ 3 ] - B - C - 2 <eos>
1078
src = 辞書 を A の ms にする
trg = A . ms = dict ( )
rst = A . ms = dict ( ) <eos>
1079
src = C を A の par の B 番 目 にする
trg = A . par [ B ] = C
rst = A . par [ B ] = C <eos>
1080
src = B が 0 と 等 しい かどうか に [MASK] を加えた 値を A とする
trg = A = + ( B == 0 )
rst = A = + ( B == 0 ) <eos>
1081
src = B の A 番 目 に 1 を加えた 値を A とする
trg = A = B [ A ] + 1
rst = A = B [ A ] + 1 <eos>
1082
src = A を B から C の値 の集まり の 最大 値を 引 いた 値 だけ 増加 させる
trg = A += B - max ( C . values ( ) )
rst = A += B - max ( C . values ( ) ) <eos>
1083
src = A の ONLINE _ FRONT を返す
trg = return A . ONLINE_FRONT
rst = return A . <unk> <eos>
1084
src = A の root を返す
trg = return A . root
rst = return A . root <eos>
1085
src = 1 、 B を 開 いた ファイル ストリーム の writelines を A とする
trg = A = open ( 1 , B ) . writelines
rst = A = open ( 1 , B ) . writelines <eos>
1086
src = B から C の D 番 目 を 引 いた 値 、 E の D 番 目 から F を 引 いた 値の 最大 値を A とする
trg = A = max ( B - C [ D ] , E [ D ] - F )
rst = A = max ( B - C [ D ] , E [ D ] - F ) <eos>
1087
src = A の bit 1 に B 、 - C に B から 1 を 引 いた 値を 掛 け た 値 を追加した 集 ま り
trg = A . bit1 . add ( B , - C * ( B - 1 ) )
rst = A . bit1 . add ( B , - C * ( B - 1 ) ) <eos>
1088
src = time が A より 大きい とき 、
trg = if time > A :
rst = if time > A : <eos>
1089
src = A の 2 に B を 掛 け た 値 から 1 を 引 いた 値 番 目 、 A の 2 に B を 掛 け た 値 番目の 最小 値を A の B から 1 を 引 いた 値 番 目 にする
trg = A [ B - 1 ] = min ( A [ 2 * B - 1 ] , A [ 2 * B ] )
rst = A [ B - 1 ] = min ( A [ 2 * B - 1 ] , A [ 2 * B ] ) <eos>
1090
src = B の 各要素 に A を適用した 列 の 総 和 に 1 を加えた 値を C で 割 った 余 り を返す
trg = return ( sum ( map ( A , B ) ) + 1 ) % C
rst = return ( sum ( map ( A , B ) + 1 ) % C ) <eos>
1091
src = A の 末 尾 に ( B に ( C ) からなる 列 を加えた 値 、 D から C を 引 いた 値 ) からなる 列 を追加する
trg = A . append ( [ B + [ C ] , D - C ] )
rst = A . append ( [ B + [ C ] , D - C ] ) <eos>
1092
src = ( ( -1 、 0 ) の 組 、 ( 0 、 1 ) の 組 、 ( 1 、 0 ) の 組 、 ( 0 、 -1 ) の 組 ) からなる 列 を A とする
trg = A = [ ( - 1 , 0 ) , ( 0 , 1 ) , ( 1 , 0 ) , ( 0 , - 1 ) ]
rst = A = [ ( - 1 , 0 ) , ( 0 , 1 ) , ( 1 , 0 ) , ( 0 , - 1 ) ] <eos>
1093
src = A を 書式 として B の top で 整 形 した 文字列 を出力する
trg = print ( A . format ( B . top ) )
rst = print ( A . format ( B . top ) ) <eos>
1094
src = saizo ( list ( map ( int , input () . split () ) ) )
trg = saizo ( list ( map ( int , input ( ) . split ( ) ) ) )
rst = <unk> ( list ( map ( int , input ( ) . split ( ) ) ) ) <eos>
1095
src = A に対応する 値 、 も し 存在 し なければ 、 つまり ネ イ ピ ア 数 、 0 に 1 を加えた 値を A の 、 つまり ネ イ ピ ア 数 番 目 にする
trg = A [ e ] = A . get ( e , 0 ) + 1
rst = A [ e ] = A . get ( e , 0 ) + 1 <eos>
1096
src = index ( A , B , C ) が D より 大きい 間 、 次 を 繰り返す
trg = while index ( A , B , C ) > D :
rst = while index ( A , B , C ) > D : <eos>
1097
src = A を 1000 で 割 った 値の 切り 上げ 整数値 に 1000 を 掛 け た 値を返す
trg = return math . ceil ( A / 1000 ) * 1000
rst = return math . ceil ( A / 1000 ) * 1000 <eos>
1098
src = check _ rightdown ( C , A , B , D ) を 展開 し 、 それぞれ A 、 B とする
trg = A , B = check_rightdown ( C , A , B , D )
rst = A , B = <unk> ( C , A , B , D ) <eos>
1099
src = setHeapUp _ max ( A , 0 )
trg = setHeapUp_max ( A , 0 )
rst = <unk> ( A , 0 ) <eos>
1100
src = A の B 番 目 に A の B に 1 を加えた 値 番 目 を加えた 値が 10 より 小さい とき 、
trg = if A [ B ] + A [ B + 1 ] < 10 :
rst = if A [ B ] + A [ B + 1 ] < 10 : <eos>
1101
src = A の 各要素 に 整数 を適用した 列 の リストを A とする
trg = A = list ( map ( int , A ) )
rst = A = list ( map ( int , A ) ) <eos>
1102
src = B の先頭 の先頭 を A の先頭 の 0 番 目 にする
trg = A [ 0 ] [ 0 ] = B [ 0 ] [ 0 ]
rst = A [ 0 ] [ 0 ] = B [ 0 ] [ 0 ] <eos>
1103
src = preorder _ tree _ walk ( A , A [ B ] . right _ node _ no , C )
trg = preorder_tree_walk ( A , A [ B ] . right_node_no , C )
rst = preorder_tree_walk ( A , A [ B ] . right_node_no , C ) <eos>
1104
src = write ( A % B [ 0 ] ifB [ 0 ] ! = -1 elseC )
trg = write ( A % B [ 0 ] if B [ 0 ] != - 1 else C )
rst = write ( A % B [ 0 ] [ 0 ] != - 1 ) <eos>
1105
src = C の集合 の 各要素 を B とし 、 C 内の B の 出現 回数 が 1 より 大きい とき の B の 列 を A とする
trg = A = [ B for B in set ( C ) if C . count ( B ) > 1 ]
rst = A = [ B for B in set ( C . count ( B ) ) if C . count ( B ) ] <eos>
1106
src = ( 0 、 0 、 0 、 1 ) からなる 列 を A の先頭 の B 番 目 にする
trg = A [ 0 ] [ B ] = [ 0 , 0 , 0 , 1 ]
rst = A [ 0 ] [ B ] = [ 0 , 0 , 0 , 1 ] <eos>
1107
src = heappush ( A , ( B + C , D + E ) )
trg = heappush ( A , ( B + C , D + E ) )
rst = heappush ( A , ( B + C , D + E ) ) <eos>
1108
src = A または E 、 D から 1 を 引 いた 値 、 F 、 1 において 正規表現 C の 各要素 を B とし 、 B が D と 等 しく ない とき の B の 列 が 最初 にマッチする 位置 を A とする
trg = A = A or search ( [ B for B in C if B != D ] , E , D - 1 , F , 1 )
rst = A = A or search ( [ B for B in C if B != D ] , E , F - 1 , C , B ) <eos>
1109
src = B [ 0 ] の 文字列 に B [ 1 ] の 文字列 を加えた 値に B の 2 番目の 文字列 を加えた 値に B の 3 番目の 文字列 を加えた 値に B の 4 番目の 文字列 を加えた 値を A とする
trg = A = str ( B [ 0 ] ) + str ( B [ 1 ] ) + str ( B [ 2 ] ) + str ( B [ 3 ] ) + str ( B [ 4 ] )
rst = A = str ( B [ 0 ] ) + str ( B [ 1 ] ) + B [ 2 ] + str ( B [ 3 ] ) + B [ 4 ] <eos>
1110
src = 空 列 を A の lr にする
trg = A . lr = [ ]
rst = A . lr = [ ] <eos>
1111
src = 0 から C 未 満 までの 数 列 の 各要素 を B とし 、 ( -1 ) からなる 列 に input () . split () の 各要素 に int を適用した 列 のリスト を加えた 値に ( -1 ) からなる 列 を加えた 値の 列 を A とする
trg = A = [ [ - 1 ] + list ( map ( int , input ( ) . split ( ) ) ) + [ - 1 ] for B in range ( C ) ]
rst = A = [ [ - 1 ] + list ( map ( int , input ( ) . split ( ) ) ) + [ - 1 ] for B in range ( C ) ] <eos>
1112
src = B の先頭 の 0 番 目 に B の 1 番目の 1 番 目 を加えた 値に B の 2 番目の 2 番 目 を加えた 値を A とする
trg = A = B [ 0 ] [ 0 ] + B [ 1 ] [ 1 ] + B [ 2 ] [ 2 ]
rst = A = B [ 0 ] [ 0 ] + B [ 1 ] [ 1 ] + B [ 2 ] [ 2 ] <eos>
1113
src = A の 1 番目の B 番目の とき 、
trg = if A [ 1 ] [ B ] :
rst = if A [ 1 ] [ B ] : <eos>
1114
src = A または judge ( B [ 3 : ] ) を A とする
trg = A = A or judge ( B [ 3 : ] )
rst = A = A or judge ( B [ 3 : ] ) <eos>
1115
src = A の iter _ size に 2 を 掛 け た 値 から 1 を 引 いた 値を A の size にする
trg = A . size = A . iter_size * 2 - 1
rst = A . size = A . iter_size * 2 - 1 <eos>
1116
src = B に 5 を 掛 け た 値 から 1 を 引 いた 値 から -1 未 満 までの -1 間隔 の 数 列 を 順に A として 、 繰り返す
trg = for A in range ( B * 5 - 1 , - 1 , - 1 ) :
rst = for A in range ( B * 5 - 1 , - 1 , - 1 ) : <eos>
1117
src = A を B の size から 1 を 引 いた 値 だけ 増加 させる
trg = A += B . size - 1
rst = A += B . size - 1 <eos>
1118
src = B から C に 1 を加えた 値 未 満 までの B 間隔 の 数 列 を 順に A として 、 繰り返す
trg = for A in range ( B , C + 1 , B ) :
rst = for A in range ( B , C + 1 , B ) : <eos>
1119
src = 7 に A に 1 を加えた 値を 掛 け た 値 を出力する
trg = print ( 7 * ( A + 1 ) )
rst = print ( 7 * ( A + 1 ) ) <eos>
1120
src = 19 25 に A を加えた 値 を出力する
trg = print ( 1925 + A )
rst = print ( 25 + A ) <eos>
1121
src = expr () を 展開 し 、 それぞれ A 、 B 、 C とする
trg = A , B , C = expr ( )
rst = A , B , C = expr ( ) <eos>
1122
src = B に C が D と 等 しく なく かつ E が D と 等 しい かどうか を加えた 値を A とする
trg = A = B + ( C != D and E == D )
rst = A = B + ( C != D ) and ( E == D ) <eos>
1123
src = A に 60 を 掛 け た 値に B を加えた 値 を出力する
trg = print ( A * 60 + B )
rst = print ( A * 60 + B ) <eos>
1124
src = 1 から 2 * B に 1 を加えた 値 未 満 までの 数 列 の集合 から C の集合 を 引 いた 値を ソート した 列 を A とする
trg = A = sorted ( set ( range ( 1 , 2 * B + 1 ) ) - set ( C ) )
rst = A = sorted ( set ( 1 , 2 * B + 1 ) - set ( C ) ) <eos>
1125
src = C の B 番目の 先頭に C の B 番目の 1 番 目 を 掛 け た 値に C の B に 1 を加えた 値 番目の 1 番 目 を 掛 け た 値を A の B 番目の B に 1 を加えた 値 番 目 にする
trg = A [ B ] [ B + 1 ] = C [ B ] [ 0 ] * C [ B ] [ 1 ] * C [ B + 1 ] [ 1 ]
rst = A [ B + 1 ] [ 1 ] = C [ B ] [ 0 ] * C [ B ] [ 1 ] + C [ B + 1 ] [ 1 ] * 1 <eos>
1126
src = A が 0 と 等 しく かつ B が 0 より 大きい とき 、
trg = if A == 0 and B > 0 :
rst = if A == 0 and B > 0 : <eos>
1127
src = A に 3 の B 乗 を加えた 値を A とする
trg = A = A + 3 ** B
rst = A = A + 3 ** B <eos>
1128
src = A に B を 掛 け た 値 から C に D を 掛 け た 値を 引 いた 値が 0 と 等 しい とき 、
trg = if A * B - C * D == 0 :
rst = if A * B - C * D == 0 : <eos>
1129
src = C の B 番 目 に C の B に 1 を加えた 値 番 目 を 掛 け た 値に C の B に 2 を加えた 値 番 目 を 掛 け た 値を A の B 番目の B に 1 を加えた 値 番 目 にする
trg = A [ B ] [ B + 1 ] = C [ B ] * C [ B + 1 ] * C [ B + 2 ]
rst = A [ B + 1 ] [ B + 1 ] = C [ B ] * C [ B + 1 ] + C [ B * 2 ] <eos>
1130
src = B から C の 順序 数 を 引 いた 値に 10 を加えた 値を A の 、 つまり 文字コード B の 文字 番 目 にする
trg = A [ chr ( B ) ] = B - ord ( C ) + 10
rst = A [ chr ( B ) ] = B - ord ( C ) + 10 <eos>
1131
src = A の 1 番 目 が B の 1 番 目 と 等 しい とき 、
trg = if A [ 1 ] == B [ 1 ] :
rst = if A [ 1 ] == B [ 1 ] : <eos>
1132
src = B を A の B 番 目 にする
trg = A [ B ] = B
rst = A [ B ] = B <eos>
1133
src = A の 末 尾 に ( B に 1 を加えた 値 、 ( C 、 D ) の 組 、 E 、 F ) の 組 を追加する
trg = A . append ( ( B + 1 , ( C , D ) , E , F ) )
rst = A . append ( ( B + 1 , ( C , D ) , E , F ) ) <eos>
1134
src = A に 1 86 7 を加えた 値を返す
trg = return A + 1867
rst = return A + 1867 <eos>
1135
src = A の B から C を 引 いた 値 番目の C 番 目 に A の B から 1 を 引 いた 値 番目の C から 1 を 引 いた 値 番 目 を加えた 値を D で 割 った 余 り を A の B 番目の C 番 目 にする
trg = A [ B ] [ C ] = ( A [ B - C ] [ C ] + A [ B - 1 ] [ C - 1 ] ) % D
rst = A [ B ] [ C ] = ( A [ B - C ] [ C ] + A [ B - 1 ] [ C - 1 ] ) % D <eos>
1136
src = A の 末 尾 に ( -1 に B の 1 番 目 を 掛 け た 値 、 B の先頭 ) からなる 列 を追加する
trg = A . append ( [ - 1 * B [ 1 ] , B [ 0 ] ] )
rst = A . append ( [ - 1 * B [ 1 ] , B [ 0 ] ] ) <eos>
1137
src = C を A の B 番目の parent にする
trg = A [ B ] . parent = C
rst = A [ B ] . parent = C <eos>
1138
src = A . cross ( B , C ) の 絶対 値が A の epsilon より 小さい かどうか を返す
trg = return abs ( A . cross ( B , C ) ) < A . epsilon
rst = return abs ( A . cross ( B , C ) ) < A . epsilon <eos>
1139
src = A の 1 番 目 を出力する
trg = print ( A [ 1 ] )
rst = print ( A [ 1 ] ) <eos>
1140
src = A の last が 、 つまり 未 定 値 と 等 しい とき 、
trg = if A . last is not None :
rst = if A . last == None : <eos>
1141
src = 文字コード C に B を加えた 値の 文字 を A の B 番 目 にする
trg = A [ B ] = chr ( C + B )
rst = A [ B ] = chr ( C + B ) <eos>
1142
src = score ( B & ~ C , D + E [ F ] , count + 1 ) を A とする
trg = A = score ( B & ~ C , D + E [ F ] , count + 1 )
rst = A = score ( B & ~ C , D + E [ F ] , count + 1 ) <eos>
1143
src = B に C を 掛 け た 値 から D に E を 掛 け た 値を 引 いた 値を F で 割 った 値を A とする
trg = A = ( B * C - D * E ) / F
rst = A = ( B * C - D * E ) / F <eos>
1144
src = A の direction の とき 、
trg = if A . direction :
rst = if A . heap : <eos>
1145
src = A を 1 から B を 引 いた 値 だけ 増加 させる
trg = A += ( 1 - B )
rst = A += 1 - B <eos>
1146
src = prim ( A ) を出力する
trg = print ( prim ( A ) )
rst = print ( prim ( A ) ) <eos>
1147
src = A の B 番 目 から C に 1 を加えた 値 までの 部分 列 の 整数値 を 2 で 割 った 商 に 1 を加えた 値を返す
trg = return int ( A [ B : C + 1 ] ) // 2 + 1
rst = return int ( A [ B : C + 1 ] ) // 2 + 1 <eos>
1148
src = B から A から B を 引 いた 値の 絶対 値を 引 いた 値を A とする
trg = A = B - abs ( A - B )
rst = A = B - abs ( A - B ) <eos>
1149
src = 0 から C に 1 を加えた 値 未 満 までの 数 列 の 各要素 を B とし 、 readline () を 空白 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 のリスト の 列 を A とする
trg = A = [ list ( map ( int , readline ( ) . split ( ) ) ) for B in range ( C + 1 ) ]
rst = A = [ list ( map ( int , readline ( ) . split ( ) ) ) for B in range ( C + 1 ) ] <eos>
1150
src = B の 辞書 カウンタ の 出現 頻 度 順 の 列 の先頭 の先頭 を A とする
trg = A = Counter ( B ) . most_common ( ) [ 0 ] [ 0 ]
rst = A = Counter ( B ) . most_common ( ) [ 0 ] [ 0 ] <eos>
1151
src = A に B を加えた 値を 4 で 割 った 余 り を A とする
trg = A = ( A + B ) % 4
rst = A = ( A + B ) % 4 <eos>
1152
src = A を dfs ( B + 1, C | ( 1 < < ( D * 4 + E ) ) ) だけ 増加 させる
trg = A += dfs ( B + 1 , C | ( 1 << ( D * 4 + E ) ) )
rst = A += dfs ( B + 1 , C | ( 1 << ( D * 4 + E ) ) ) <eos>
1153
src = triangle ( D , E , F ) を ( A 、 B 、 C ) の 組 とする
trg = ( A , B , C ) = triangle ( D , E , F )
rst = ( A , B , C ) = triangle ( D , E , F ) <eos>
1154
src = ( ( B の 浮動小数点数 ) からなる 列 の 0 から E 未 満 までの 数 列 の 各要素 を D とし 、 C の 列 回 分 の 列 ) からなる 列 を A とする
trg = A = [ [ float ( B ) ] * [ C for D in range ( E ) ] ]
rst = A = [ [ float ( B ) ] * [ C for D in range ( E ) ] ] <eos>
1155
src = ( ( B から C を 引 いた 値 ) からなる 列 の 0 から F に 1 を加えた 値 未 満 までの 数 列 の 各要素 を E とし 、 D に 1 を加えた 値の 列 回 分 の 列 ) からなる 列 を A とする
trg = A = [ [ B - C ] * [ ( D + 1 ) for E in range ( F + 1 ) ] ]
rst = A = [ [ B - C ] * [ ( D + 1 ) for E in range ( F + 1 ) ] ] <eos>
1156
src = dfs ( A [ B ] )
trg = dfs ( A [ B ] )
rst = dfs ( A [ B ] ) <eos>
1157
src = D を A の 2 に B を 掛 け た 値に 1 を加えた 値 番目の C から 1 を 引 いた 値 番 目 にする
trg = A [ 2 * B + 1 ] [ C - 1 ] = D
rst = A [ 2 * B + 1 ] [ C - 1 ] = D <eos>
1158
src = Fib ( A -1 ) に Fib ( A -2 ) を加えた 値を返す
trg = return Fib ( A - 1 ) + Fib ( A - 2 )
rst = return <unk> ( A - 1 ) + <unk> ( A - 2 ) <eos>
1159
src = A を 15 で 割 った 余 り が 0 と 等 しい とき 、
trg = if A % 15 == 0 :
rst = if A % 15 == 0 : <eos>
1160
src = SegmentTree ( B ) を A とする
trg = A = SegmentTree ( B )
rst = A = SegmentTree ( B ) <eos>
1161
src = f ( D , E , 1 ) 、 f ( F , G , 1 ) 、 f ( H , I , 1 ) を A 、 B 、 C とする
trg = A , B , C = f ( D , E , 1 ) , f ( F , G , 1 ) , f ( H , I , 1 )
rst = A , B , C = f ( D , E , 1 ) , f ( F , G , 1 ) , f ( H , I , J ) <eos>
1162
src = A に B の C 番 目 を加えた 値が D より 大きい とき 、
trg = if A + B [ C ] > D :
rst = if A + B [ C ] > D : <eos>
1163
src = ( A の 末 尾 の -2 番 目 、 B ) からなる 列 を 展開 して を出力する
trg = print ( * [ A [ - 1 ] [ - 2 ] , B ] )
rst = print ( * [ A [ - 1 ] [ - 2 ] , B ] ) <eos>
1164
src = 0 を C とする
trg = C = 0
rst = C = 0 <eos>
1165
src = -1 e 11 、 1 e 11 を A 、 B とする
trg = A , B = - 1e11 , 1e11
rst = A , B = - 1 , 1e-11 <eos>
1166
src = B が C より 小さく かつ D の E 番 目 が D の B 番 目 より 小さい かどうか を A とする
trg = A = B < C and D [ E ] < D [ B ]
rst = A = ( B < C and D [ E ] < D [ B ] ) <eos>
1167
src = B の 、 つまり 現在の 日 時 番 目 を 順に A として 、 繰り返す
trg = for A in B [ now ] :
rst = for A in B [ now ] : <eos>
1168
src = A の 末 尾 に B の C 番 目 が B の D 番 目 より 小さい とき ( B の C 番 目 、 B の D 番 目 ) の 組 、 そうでなければ ( B の D 番 目 、 B の C 番 目 ) の 組 を追加する
trg = A . append ( ( B [ C ] , B [ D ] ) if B [ C ] < B [ D ] else ( B [ D ] , B [ C ] ) )
rst = A . append ( ( B [ C ] , B [ D ] , B [ D ] ) if B [ C ] < B [ D ] else ( B [ D ] , B [ C ] ) ) <eos>
1169
src = _ in _ order _ line ( A . right )
trg = _in_order_line ( A . right )
rst = _in_order_line ( A . right ) <eos>
1170
src = A を 2 の 9 から B を 引 いた 値 乗 だけ 減少 させる
trg = A -= 2 ** ( 9 - B )
rst = A -= 2 ** ( 9 - B ) <eos>
1171
src = ( ( ( B 、 C ) の 組 , 0 から D 未 満 までの 数 列 の 各要素 を C とし 、 0 の 列 ) ) からなる 辞書 を A とする
trg = A = { (ALL, i) : [ 0 for C in range ( D ) ] }
rst = A = { idx <unk> <unk> <unk> <unk> : [ 0 for C in range ( D ) ] } <eos>
1172
src = 1 から 10 1 未 満 までの 数 列 の 各要素 を C とし 、 B 内の C の 出現 回数 の 列 を A とする
trg = A = [ B . count ( C ) for C in range ( 1 , 101 ) ]
rst = A = [ B . count ( C ) for C in range ( 1 , 101 ) ] <eos>
1173
src = A の B 番目の 7 番 目 を返す
trg = return A [ B ] [ 7 ]
rst = return A [ B ] [ 7 ] <eos>
1174
src = B の cards の 辞書 カウンタ を A とする
trg = A = Counter ( B . cards )
rst = A = Counter ( B . cards ) <eos>
1175
src = A が B から C から D を 引 いた 値の 絶対 値を 引 いた 値 より 小さい とき 、
trg = if A < B - abs ( C - D ) :
rst = if A < B - abs ( C - D ) : <eos>
1176
src = calc _ d ( B [ 0 ] , B [ C + 1 ] ) を A とする
trg = A = calc_d ( B [ 0 ] , B [ C + 1 ] )
rst = A = <unk> ( B [ 0 ] , B [ C + 1 ] ) <eos>
1177
src = depth ( C [ A [ B . PARENT ]]) に 1 を加えた 値を A の B の DEPTH 番 目 にする
trg = A [ B . DEPTH ] = depth ( C [ A [ B . PARENT ] ] ) + 1
rst = A [ B . DEPTH ] = depth ( C [ A [ B . PARENT ] + 1 ) <eos>
1178
src = B から C に D を加えた 値を 引 いた 値を A とする
trg = A = B - ( C + D )
rst = A = B - ( C + D ) <eos>
1179
src = scrap _ top _ left ( C ) を 展開 し 、 それぞれ A 、 B とする
trg = A , B = scrap_top_left ( C )
rst = A , B = <unk> ( C ) <eos>
1180
src = binsearch ( A , B ) の とき 、
trg = if binsearch ( A , B ) :
rst = if <unk> ( A , B ) : <eos>
1181
src = B に C から D を 引 いた 値に E を 掛 け た 値 を加えた 値を A とする
trg = A = B + ( C - D ) * E
rst = A = B + ( C - D ) * E <eos>
1182
src = A の node の B 番 目 を返す
trg = return A . node [ B ]
rst = return A . node [ B ] <eos>
1183
src = B に C を加えた 値 から 1 を 引 いた 値の 階乗 を B の 階乗 で 割 った 商 を C から 1 を 引 いた 値の 階乗 で 割 った 商 を A とする
trg = A = math . factorial ( B + C - 1 ) // math . factorial ( B ) // math . factorial ( C - 1 )
rst = A = ( math . factorial ( B + C - 1 ) // math . factorial ( B ) // math . factorial ( C - 1 ) ) // math . factorial ( B ) <eos>
1184
src = A の rank の B 番 目 、 A の par の C 番 目 に 1 を加えた 値の 最大 値を A の rank の B 番 目 にする
trg = A . rank [ B ] = max ( A . rank [ B ] , A . par [ C ] + 1 )
rst = A . rank [ B ] = max ( A . rank [ B ] , A . par [ C ] + 1 ) <eos>
1185
src = D の E 番 目 を 空白 で 分割 した 字句 列 の 各要素 を C とし 、 C の 浮動小数点数 の 列 を 展開 し 、 それぞれ A 、 B とする
trg = A , B = [ float ( C ) for C in D [ E ] . split ( ) ]
rst = A , B = [ float ( C ) for C in D [ E ] . split ( ) ] <eos>
1186
src = A の B に 1 を加えた 値 番 目 を A の B 番 目 だけ 増加 させる
trg = A [ B + 1 ] += A [ B ]
rst = A [ B + 1 ] += A [ B ] <eos>
1187
src = B から C の D 番 目 から C の E 番 目 を 引 いた 値を 引 いた 値を A とする
trg = A = B - ( C [ D ] - C [ E ] )
rst = A = B - ( C [ D ] - C [ E ] ) <eos>
1188
src = B の C を B の長さ で 割 った 余 り 番 目 を A とする
trg = A = B [ C % len ( B ) ]
rst = A = B [ C % len ( B ) ] <eos>
1189
src = A を 入力された 文字列 の 末 尾 から 空白 改行 を取り 除 いた 文字列 だけ 増加 させる
trg = A += input ( ) . rstrip ( )
rst = A += input ( ) . rstrip ( ) <eos>
1190
src = B を 書式 として C 、 D 、 E 、 F 、 G 、 H 、 I で 整 形 した 文字列を A とする
trg = A = B . format ( C , D , E , F , G , H , I )
rst = A = B . format ( C , D , E , F , G , H , I ) <eos>
1191
src = _ sort ( 0 , len ( B ) ) を A とする
trg = A = _sort ( 0 , len ( B ) )
rst = A = <unk> ( 0 , len ( B ) ) <eos>
1192
src = calc _ start ( B ) を A とする
trg = A = calc_start ( B )
rst = A = <unk> ( B ) <eos>
1193
src = A 、 B の 整数値 を出力する
trg = print ( A , int ( B ) )
rst = print ( A , int ( B ) ) <eos>
1194
src = heappush ( A , ( B + C , D , E , F ) )
trg = heappush ( A , ( B + C , D , E , F ) )
rst = heappush ( A , ( B + C , D , E , F ) ) <eos>
1195
src = A が B より 大きく かつ cross ( C [ A -1 ]- C [ A -2 ] , D [ E ]- C [ A -1 ] ) が 0 より 小さい 間 、 次 を 繰り返す
trg = while A > B and cross ( C [ A - 1 ] - C [ A - 2 ] , D [ E ] - C [ A - 1 ] ) < 0 :
rst = while A > B and cross ( C [ A - 1 ] - C [ A - 2 ] , D [ E ] - C [ A - 1 ] ) < 0 : <eos>
1196
src = B の長さ を 2 で 割 った 商 に 1 を加えた 値 から B の長さ 未 満 までの 数 列 を 順に A として 、 繰り返す
trg = for A in range ( len ( B ) // 2 + 1 , len ( B ) ) :
rst = for A in range ( len ( B ) // 2 + 1 , len ( B ) ) : <eos>
1197
src = koch ( A - 1, ( B , C ) , ( D , E ) )
trg = koch ( A - 1 , ( B , C ) , ( D , E ) )
rst = koch ( A - 1 , ( B , C ) , ( D , E ) ) <eos>
1198
src = ( B 、 C ) の 組 に D の 組 を加えた 値を A とする
trg = A = ( B , C ) + tuple ( D )
rst = A = ( B , C ) + D <eos>
1199
src = A の 0 番 目 が B と 等 しく かつ A の長さ が 1 より 大きく または C の 0 番 目 が B と 等 しく かつ C の長さ が 1 より 大きく または D の 0 番 目 が B と 等 しく かつ D の長さ が 1 より 大きい とき 、
trg = if ( A [ 0 ] == B and len ( A ) > 1 ) or ( C [ 0 ] == B and len ( C ) > 1 ) or ( D [ 0 ] == B and len ( D ) > 1 ) :
rst = if ( A [ 0 ] == B and len ( A ) > 1 ) or ( C [ 0 ] == B and len ( C ) > 1 ) or ( D [ 0 ] == B and len ( D ) > 1 ) : <eos>
1200
src = A の rm に対応する 値 、 も し 存在 し なければ B 、 0 を出力する
trg = print ( A . rm . get ( B , 0 ) )
rst = print ( A . rm , B . get ( 0 , 0 ) ) <eos>
1201
src = 2 に B を 掛 け た 値 から 2 に C を 掛 け た 値を 引 いた 値を A とする
trg = A = 2 * B - 2 * C
rst = A = 2 * B - 2 * C <eos>
1202
src = A 内の [MASK] の 出現 回数 が B の NQUEENS と 等 しい とき 、
trg = if A . count ( ) == B . NQUEENS :
rst = if A . count == B . <unk> : <eos>
1203
src = A 、 B の C 番 目 から B の D 番 目 を 引 いた 値の 最大 値を A とする
trg = A = max ( A , B [ C ] - B [ D ] )
rst = A = max ( A , B [ C ] - B [ D ] ) <eos>
1204
src = C の B 番 目 から D を 引 いた 値に A の B 番 目 を加えた 値を A の B に 1 を加えた 値 番 目 にする
trg = A [ B + 1 ] = ( C [ B ] - D ) + A [ B ]
rst = A [ B + 1 ] = C [ B ] - D + A [ B ] <eos>
1205
src = RKSearch ( B , C ) を A とする
trg = A = RKSearch ( B , C )
rst = A = <unk> ( B , C ) <eos>
1206
src = B から C に D を加えた 値に E を加えた 値に 1 を加えた 値 未 満 までの 数 列 を 順に A として 、 繰り返す
trg = for A in range ( B , C + D + E + 1 ) :
rst = for A in range ( B , C + D + E + 1 ) : <eos>
1207
src = A が datetime 、 B 、 C 、 D の 日付 以下の 間 、 次 を 繰り返す
trg = while A <= datetime . date ( B , C , D ) :
rst = while A <= datetime . date ( B , C , D ) : <eos>
1208
src = B から C を 引 いた 値を A とする
trg = A = B - C
rst = A = B - C <eos>
1209
src = C を A の B から 1 を 引 いた 値 番目の 、 つまり 先頭 から 、 つまり 末 尾 までの 部分 列 にする
trg = A [ B - 1 ] [ : ] = C
rst = A [ B - 1 ] [ : ] = C <eos>
1210
src = greatest _ common _ divisor ( A , B ) を出力する
trg = print ( greatest_common_divisor ( A , B ) )
rst = print ( <unk> ( A , B ) ) <eos>
1211
src = A が B と 等 しく または C と 1 を B だけ 左 シフト した 値の 論理 積 が 0 と 等 しい とき 、
trg = if A == B or C & ( 1 << B ) == 0 :
rst = if A == B or C & ( 1 << B ) == 0 : <eos>
1212
src = B の 1 番 目 から 、 つまり 末 尾 までの 部分 列 を C で 分割 した 字句 列 の集合 を A とする
trg = A = set ( B [ 1 : - 1 ] . split ( C ) )
rst = A = set ( B [ 1 : ] . split ( C ) ) <eos>
1213
src = ネ イ ピ ア 数が 2 と 等 しい とき 、
trg = if e == 2 :
rst = if e == 2 : <eos>
1214
src = 空白 文字 を 代わり の 行 末 として A の B 番目の 総 和 を出力する
trg = print ( sum ( A [ B ] ) , end = ' ' )
rst = print ( sum ( A [ B ] ) , end = ' ' ) <eos>
1215
src = A の B 番目の C 番 目 に ネ イ ピ ア 数 を加えた 値が A の B に 1 を加えた 値 番目の C に 1 を加えた 値 番 目 より 小さい とき 、
trg = if A [ B ] [ C ] + e < A [ B + 1 ] [ C + 1 ] :
rst = if A [ B ] [ C ] + e < A [ B + 1 ] [ C + 1 ] : <eos>
1216
src = 0 < = A が B より 小さく なく または 0 < = C が D より 小さく なく または E の A 番目の C 番 目 または F の A 番目の C 番目の とき 、
trg = if not 0 <= A < B or not 0 <= C < D or E [ A ] [ C ] or F [ A ] [ C ] :
rst = if not 0 <= A < B or not 0 <= C < D or E [ A ] [ C ] or F [ A ] [ C ] : <eos>
1217
src = A に B が C 以下の とき ( B 、 C ) の 組 、 そうでなければ ( C 、 B ) の 組 を追加した 集 ま り
trg = A . add ( ( B , C ) if B <= C else ( C , B ) )
rst = A . add ( ( B , C ) if B <= C else ( C , B ) ) <eos>
1218
src = A の left が 、 つまり 未 定 値 と 等 しい かどうか を返す
trg = return A . left is not None
rst = return A . left is not None <eos>
1219
src = ( 0 ) からなる 列 の 3 0000 1 回 分 の 列 を A とする
trg = A = [ 0 ] * 300001
rst = A = [ 0 ] * <unk> <eos>
1220
src = D から D から C を 引 いた 値 未 満 までの -1 間隔 の 数 列 を A の B 番 目 から B に C を加えた 値 までの 部分 列 にする
trg = A [ B : B + C ] = range ( D , D - C , - 1 )
rst = A [ B : B + C ] = range ( D , D - C , - 1 ) <eos>
1221
src = rec ( A + 1, B , C , D , E )
trg = rec ( A + 1 , B , C , D , E )
rst = rec ( A + 1 , B , C , D , E ) <eos>
1222
src = B に rect ( C , D + E ) を加えた 値を A とする
trg = A = B + rect ( C , D + E )
rst = A = B + rect ( C , D + E ) <eos>
1223
src = A の 1 番目の 先頭 、 B を 書式 として A の 1 番目の 1 番 目 で 整 形 した 文字列 を出力する
trg = print ( A [ 1 ] [ 0 ] , B . format ( A [ 1 ] [ 1 ] ) )
rst = print ( A [ 1 ] [ 0 ] , B . format ( A [ 1 ] [ 1 ] ) ) <eos>
1224
src = ( A ) からなる 列 に [MASK] を加えた 値に koch ( A , B , count -1 ) を加えた 値
trg = + [ A ] + koch ( A , B , count - 1 )
rst = + [ A ] + B + koch ( A , B , count - 1 ) <eos>
1225
src = D から E を 引 いた 値の 2 乗 に F から G を 引 いた 値の 2 乗 を加えた 値の . 5 乗 を A の C 番目の B 番 目 とする を A の B 番目の C 番 目 にする
trg = A [ B ] [ C ] = A [ C ] [ B ] = ( ( D - E ) ** 2 + ( F - G ) ** 2 ) ** .5
rst = A [ B ] [ C ] = A [ C ] [ B ] = ( ( D - E ) ** 2 + ( F - G ) ** 2 ) ** .5 <eos>
1226
src = input () . split () の 各要素 に int を適用した 列 の集合 を ソート した 列 を 展開 して を出力する
trg = print ( * sorted ( set ( map ( int , input ( ) . split ( ) ) ) ) )
rst = print ( * sorted ( set ( map ( int , input ( ) . split ( ) ) ) ) ) <eos>
1227
src = isStable ( A , B ) の とき 、
trg = if ( isStable ( A , B ) ) :
rst = if <unk> ( A , B ) : <eos>
1228
src = A の 最大 値 を出力する
trg = print ( max ( A ) )
rst = print ( max ( A ) ) <eos>
1229
src = write ( A % ( B ) )
trg = write ( A % ( B ) )
rst = write ( A % ( B ) ) <eos>
1230
src = B に B を 掛 け た 値に 2 に B を 掛 け た 値に C に C を 掛 け た 値に B * B を 4 で 割 った 値 を加えた 値の 平 方 根 を 掛 け た 値 を加えた 値を A とする
trg = A = B * B + 2 * B * math . sqrt ( C * C + B * B / 4 )
rst = A = B * B + 2 * B * math . sqrt ( C * C + B * B / 4 ) <eos>
1231
src = 真 を A の B から 1 を 引 いた 値 番 目 にする
trg = A [ B - 1 ] = True
rst = A [ B - 1 ] = True <eos>
1232
src = C . range _ hld ( 0 , D , edge = True ) を 順に A 、 B として 、 繰り返す
trg = for A , B in C . range_hld ( 0 , D , edge = True ) :
rst = for A , B in C . <unk> ( 0 , D , True ) : <eos>
1233
src = bubble _ sort ( B , C ) を A とする
trg = A = bubble_sort ( B , C )
rst = A = bubble_sort ( B , C ) <eos>
1234
src = A の 絶対 値 を出力する
trg = print ( abs ( A ) )
rst = print ( abs ( A ) ) <eos>
1235
src = 500 を A とする
trg = A = 500
rst = A = 500 <eos>
1236
src = B . print _ preorder () を A とする
trg = A = B . print_preorder ( )
rst = A = B . print_preorder ( ) <eos>
1237
src = B の 出現 頻 度 順 の 列 の先頭 の先頭 を A とする
trg = A = B . most_common ( ) [ 0 ] [ 0 ]
rst = A = B . most_common ( ) [ 0 ] [ 0 ] <eos>
1238
src = A の 1 から B と 1 の 論理 積 を 引 いた 値 番 目 を出力する
trg = print ( A [ 1 - ( B & 1 ) ] )
rst = print ( A [ 1 - ( B & 1 ) ] ) <eos>
1239
src = A の 総 和 の 整数 値を返す
trg = return int ( sum ( A ) )
rst = return int ( sum ( A ) ) <eos>
1240
src = B を 展開 して の 要素を それぞれ 組 にした 列 の 各要素 を A とし 、 A の 総 和 の 列 の 最大 値を返す
trg = return max ( [ sum ( A ) for A in zip ( * B ) ] )
rst = return max ( sum ( [ A for A in zip ( * B ) ] ) ) <eos>
1241
src = A に 1 を加えた 値 、 B を出力する
trg = print ( A + 1 , B )
rst = print ( A + 1 , B ) <eos>
1242
src = [MASK] の 両 端 キュー を A とする
trg = A = deque ( )
rst = A = deque ( ) <eos>
1243
src = D の B 番 目 を A の B と C の 論理 和 番 目 にする
trg = A [ B | C ] = D [ B ]
rst = A [ B | C ] = D [ B ] <eos>
1244
src = _ find ( A , B , 1, 1, C ) を返す
trg = return _find ( A , B , 1 , 1 , C )
rst = return _find ( A , B , 1 , C ) <eos>
1245
src = 空白 文字 を 間 に 入れ て B の C の 1 番 目 番目の 各要素 を A とし 、 A の 文字列 の 列 を 連結 した 文字列 を出力する
trg = print ( ' ' . join ( [ str ( A ) for A in B [ C [ 1 ] ] ] ) )
rst = print ( ' ' . join ( [ str ( A ) for A in B [ C [ 1 ] ] ) ) <eos>
1246
src = ( ( 0 、 0 ) の 組 、 ( B 、 C ) の 組 、 ( D 、 E ) の 組 ) からなる 列 を A とする
trg = A = [ ( 0 , 0 ) , ( B , C ) , ( D , E ) ]
rst = A = [ ( 0 , 0 ) , ( B , C ) , ( D , E ) ] <eos>
1247
src = A . _ dfs ( B , C , D + 1 )
trg = A . _dfs ( B , C , D + 1 )
rst = A . _dfs ( B , C , D + 1 ) <eos>
1248
src = A が B の 、 つまり ソート された 順序 を 保 った まま A を B に 挿入 できる 位置 番 目 と 等 しい とき 、
trg = if A == B [ bisect_left ( B , A ) ] :
rst = if A == B [ bisect . bisect_left ( A , B ) ] : <eos>
1249
src = ( ( A に B に C から A を 引 いた 値を 掛 け た 値 を加えた 値 、 D に B に E から D を 引 いた 値を 掛 け た 値 を加えた 値 ) の 組 ) からなる 列 を返す
trg = return [ ( A + B * ( C - A ) , D + B * ( E - D ) ) ]
rst = return [ ( A + B * ( C - A ) , D + B * ( E - D ) ) ] <eos>
1250
src = A の B の 整数値 番目の 先頭 を取り 出した 値
trg = A [ int ( B ) ] . pop ( )
rst = A [ int ( B ) ] . pop ( ) <eos>
1251
src = A の 、 つまり ソート された 順序 を 保 った まま B を A に 挿入 できる 位置 番 目 が B と 等 しい とき 、
trg = if A [ bisect_left ( A , B ) ] == B :
rst = if A [ bisect . bisect_left ( B , A ) ] == B : <eos>
1252
src = A を 長さ 5 になる ように ' 0 ' 左 詰 め した 文字列を A とする
trg = A = A . zfill ( 5 )
rst = A = A . zfill ( 5 ) <eos>
1253
src = A を B から C を 引 いた 値の D 乗 に C ( B , C ) を 掛 け た 値に -1 の C 乗 を 掛 け た 値 だけ 増加 させる
trg = A += ( B - C ) ** D * C ( B , C ) * ( - 1 ) ** C
rst = A += ( B - C ) ** D * C * ( B , C ) * ( - 1 ) ** C <eos>
1254
src = ( B 、 C 、 D ) からなる 列 を ソート した 列 を A とする
trg = A = sorted ( [ B , C , D ] )
rst = A = sorted ( [ B , C , D ] ) <eos>
1255
src = _ create ( _ root ( B ) ) を A とする
trg = A = _create ( _root ( B ) )
rst = A = <unk> ( B ) <eos>
1256
src = ( 0 ) からなる 列 の 4 5 回 分 の 列 を A とする
trg = A = [ 0 ] * 45
rst = A = [ 0 ] * 45 <eos>
1257
src = A の FLAGS と A の Masks の B 番目の 論理 積 が A の Masks の B 番 目 と 等 しい かどうか を返す
trg = return A . FLAGS & A . Masks [ B ] == A . Masks [ B ]
rst = return A . FLAGS & A . Masks [ B ] == A . Masks [ B ] <eos>
1258
src = A を A の 、 つまり 先頭 から B 番 目 までの 部分 列 だけ 増加 させる
trg = A += A [ : B ]
rst = A += A [ : B ] <eos>
1259
src = A を 2 で 割 った 余 り が 1 と 等 しい とき 、
trg = if A % 2 == 1 :
rst = if A % 2 == 1 : <eos>
1260
src = primeq ( int ( input () ) ) の とき 、
trg = if primeq ( int ( input ( ) ) ) :
rst = if <unk> ( int ( input ( ) ) ) : <eos>
1261
src = A を B が C と 等 しい とき 90 、 そうでなければ - 90 だけ 増加 させる
trg = A += 90 if B == C else - 90
rst = A += 90 if B == C else - 90 <eos>
1262
src = 無限 の 整数 列 が 1 0000 と 等 しい とき 、
trg = if count == 10000 :
rst = if count == 10000 : <eos>
1263
src = 0 から D に 1 を加えた 値 未 満 までの 数 列 の 各要素 を B とし 、 0 から C に 1 を加えた 値 未 満 までの 数 列 の 各要素 を B とし 、 0 の 列 の 列 を A とする
trg = A = [ [ 0 for B in range ( C + 1 ) ] for B in range ( D + 1 ) ]
rst = A = [ [ 0 for B in range ( C + 1 ) ] for B in range ( D + 1 ) ] <eos>
1264
src = A が B の INFINITY と 等 しい とき 、
trg = if A == B . INFINITY :
rst = if A == B . INFINITY : <eos>
1265
src = Node ( B , None , None ) を B の next とする を A とする
trg = A = B . next = Node ( B , None , None )
rst = A = B . next = Node ( B , None , None ) <eos>
1266
src = C の 各要素 を B とし 、 B 、 40 の 最大 値の 列 を A とする
trg = A = [ max ( B , 40 ) for B in C ]
rst = A = max ( [ B for B in C ] ) <eos>
1267
src = C に 1 を加えた 値 、 2 を A 、 B とする
trg = A , B = C + 1 , 2
rst = A , B = C + 1 , 2 <eos>
1268
src = A 、 B の graph の B . pv の C 番 目 番目の B の pe の C 番 目 番目の 2 番目の 最小 値を A とする
trg = A = min ( A , B . graph [ B . pv [ C ] ] [ B . pe [ C ] ] [ 2 ] )
rst = A = min ( A , B . graph [ B . pv [ C ] ] [ B . pe [ C ] [ 2 ] ) <eos>
1269
src = B の先頭 の 1 番 目 に B の 1 番目の 1 番 目 を加えた 値を 2 で 割 った 値を A とする
trg = A = ( B [ 0 ] [ 1 ] + B [ 1 ] [ 1 ] ) / 2
rst = A = ( B [ 0 ] [ 1 ] + B [ 1 ] [ 1 ] ) / 2 <eos>
1270
src = write ( A % ( B + ( C -1 ) / /2 * 2 ) )
trg = write ( A % ( B + ( C - 1 ) // 2 * 2 ) )
rst = write ( A % ( ( B + ( C - 1 ) // 2 ) ** 2 ) ) <eos>
1271
src = A の長さ が 0 と 等 しく または A の 最大 値が 2 より 小さい とき B 、 そうでなければ A の長さ に 1 を加えた 値 を出力する
trg = print ( B if len ( A ) == 0 or max ( A ) < 2 else len ( A ) + 1 )
rst = print ( B if len ( A ) == 0 or max ( A ) < 2 else len ( B ) + 1 ) <eos>
1272
src = paint ( A , B + 1, C + 1 ) を A とする
trg = A = paint ( A , B + 1 , C + 1 )
rst = A = paint ( A , B + 1 , C + 1 ) <eos>
1273
src = E を 順に A 、 B 、 C 、 D 、 ネ イ ピ ア 数 として 、 繰り返す
trg = for A , B , C , D , e in E :
rst = for A , B , C , D , e in E : <eos>
1274
src = gen ( B , C , D ) を A とする
trg = A = gen ( B , C , D )
rst = A = gen ( B , C , D ) <eos>
1275
src = ( B 、 C ) からなる 列 の __ getitem __ を A とする
trg = A = [ B , C ] . __getitem__
rst = A = [ B , C ] . __getitem__ <eos>
1276
src = A が 0 より 大きい とき A の 切り 捨 て 整数値 、 そうでなければ A の 切り 上げ 整数値 を A とする
trg = A = floor ( A ) if A > 0 else ceil ( A )
rst = A = math . floor ( A ) if A > 0 else math . ceil ( A ) <eos>
1277
src = B の _ nodes の B の cur を 2 で 割 った 商 から 1 を 引 いた 値 番 目 を A とする
trg = A = B . _nodes [ B . cur // 2 - 1 ]
rst = A = B . _nodes [ B . cur // 2 - 1 ] <eos>
1278
src = dij ( A [ 1 ]- 1, A [ 2 ]- 1, B )
trg = dij ( A [ 1 ] - 1 , A [ 2 ] - 1 , B )
rst = fill ( A [ 1 ] - 1 , A [ 2 ] - 1 , B ) <eos>
1279
src = A の 末 尾 に ( B 、 C 、 D の コピー された 列 ) の 組 を追加する
trg = A . append ( ( B , C , D [ : ] ) )
rst = A . append ( ( B , C , D [ : ] ) ) <eos>
1280
src = A . relations ( B , C )
trg = A . relations ( B , C )
rst = A . <unk> ( B , C ) <eos>
1281
src = 関数 read _ list を t を パラメータ として 定義 する
trg = def read_list ( B ) : return [ t ( A ) for A in input ( ) . split ( ) ]
rst = def <unk> ( B , C ) : return [ t ( input ( ) ) for A in range ( C ) ] <eos>
1282
src = ( ( ネ イ ピ ア 数 , C に 番号 付 した 組 の 列 の 各要素 を B 、 ネ イ ピ ア 数 とし 、 B の 列 ) ) からなる 辞書 を A とする
trg = A = { e : [ B for B , e in enumerate ( C ) ] }
rst = A = { <unk> <unk> <unk> : [ e for B , e in enumerate ( C ) ] } <eos>
1283
src = 90 を出力する
trg = print ( 90 )
rst = print ( 90 ) <eos>
1284
src = 1 を A の B の C 番 目 から 1 を 引 いた 値 番目の 1 番 目 にする
trg = A [ B [ C ] - 1 ] [ 1 ] = 1
rst = A [ B [ C ] - 1 ] [ 1 ] = 1 <eos>
1285
src = A に 空白 文字 を加えた 値に B に 5 を加えた 値の 文字列 を加えた 値を A とする
trg = A = A + ' ' + str ( B + 5 )
rst = A = A + ' ' + str ( B + 5 ) <eos>
1286
src = - A の 0 番 目 に B の 2 番 目 を 掛 け た 値に C の 1 番 目 を 掛 け た 値
trg = - A [ 0 ] * B [ 2 ] * C [ 1 ]
rst = - A [ 0 ] * B [ 2 ] * C [ 1 ] <eos>
1287
src = A が ( 2 、 3 、 5 、 7 ) からなる 列 に含まれる とき 、
trg = if A in [ 2 , 3 , 5 , 7 ] :
rst = if A in [ 2 , 3 , 5 , 7 ] : <eos>
1288
src = 50 が A 以下の とき 、
trg = if 50 <= A :
rst = if 50 <= A : <eos>
1289
src = A が B の長さ より 小さく かつ C が D の長さ より 小さい 間 、 次 を 繰り返す
trg = while A < len ( B ) and C < len ( D ) :
rst = while A < len ( B ) and C < len ( D ) : <eos>
1290
src = A の ( B 、 C 、 D ) の 組 番 目 に E を加えた 値を A の ( B 、 C 、 D ) の 組 番 目 にする
trg = A [ ( B , C , D ) ] = A [ ( B , C , D ) ] + E
rst = A [ ( B , C , D ) ] = A [ ( B , C , D ) ] + E <eos>
1291
src = A が B の長さ より 小さく かつ C が B の A 番 目 と 等 しい とき 、
trg = if A < len ( B ) and C == B [ A ] :
rst = if A < len ( B ) and C == B [ A ] : <eos>
1292
src = 改行 文字 を 間 に 入れ て 0 から D 未 満 までの 数 列 の 各要素 を C とし 、 bl ( A , int ( B . readline () ) ) の 文字列 の 列 を 連結 した 文字列 を出力する
trg = print ( '\n' . join ( [ str ( bl ( A , int ( B . readline ( ) ) ) ) for C in range ( D ) ] ) )
rst = print ( '\n' . join ( [ str ( A . bl ( B , int ( readline ( ) ) ) ) for C in range ( D ) ] ) ) <eos>
1293
src = ( B から C を 引 いた 値 、 D から E を 引 いた 値 ) からなる 列 を A とする
trg = A = [ B - C , D - E ]
rst = A = [ B - C , D - E ] <eos>
1294
src = A 、 dfs ( B + 1, C , D + E [ B ] , F , 0 , 0 ) の 最大 値を A とする
trg = A = max ( A , dfs ( B + 1 , C , D + E [ B ] , F , 0 , 0 ) )
rst = A = max ( A , dfs ( B + 1 , C , D + E [ B ] , F , 0 ) ) <eos>
1295
src = 0 から 3 未 満 までの 数 列 の 各要素 を B とし 、 0 から 10 未 満 までの 数 列 の 各要素 を A とし 、 0 の 列 の 列 を返す
trg = return [ [ 0 for A in range ( 10 ) ] for B in range ( 3 ) ]
rst = return [ [ 0 for A in range ( 10 ) ] for B in range ( 3 ) ] <eos>
1296
src = makeItems ( B , C ) を A とする
trg = A = makeItems ( B , C )
rst = A = <unk> ( B , C ) <eos>
1297
src = B に 1 を加えた 値 から C の長さ 未 満 までの 数 列 を 順に A として 、 繰り返す
trg = for A in range ( B + 1 , len ( C ) ) :
rst = for A in range ( B + 1 , len ( C ) ) : <eos>
1298
src = 0 から B の mat の長さ 未 満 までの 数 列 を 順に A として 、 繰り返す
trg = for A in range ( len ( B . mat ) ) :
rst = for A in range ( len ( B . mat ) ) : <eos>
1299
src = create _ prime ( 5 0000 ) を A とする
trg = A = create_prime ( 50000 )
rst = A = <unk> ( 50000 ) <eos>
1300
src = A の B + C 番 目 から A の B + D + C 番 目 を 引 いた 値 から E に F の C 番 目 を 掛 け た 値を 引 いた 値を G で 割 った 余 り が 0 と 等 しい とき 、
trg = if ( ( A [ B + C ] - A [ B + D + C ] ) - E * F [ C ] ) % G == 0 :
rst = if ( A [ B + C ] - A [ B + D + C ] - E * F [ C ] ) % G == 0 : <eos>
1301
src = A の 2 番目の とき 、
trg = if A [ 2 ] :
rst = if A [ 2 ] : <eos>
1302
src = B の 1 番 目 、 B の先頭 を A の B の先頭 番目の C 番 目 、 A の B の 1 番 目 番目の C 番 目 とする
trg = A [ B [ 0 ] ] [ C ] , A [ B [ 1 ] ] [ C ] = B [ 1 ] , B [ 0 ]
rst = A [ B [ 0 ] ] [ C ] , A [ B [ 1 ] ] [ C ] = B [ 1 ] , B [ 0 ] <eos>
1303
src = A の B から 1 を 引 いた 値 番目の C から 1 を 引 いた 値 番目の とき 、
trg = if A [ B - 1 ] [ C - 1 ] :
rst = if A [ B - 1 ] [ C - 1 ] : <eos>
1304
src = 入力された 文字列 の リストを A とする
trg = A = list ( input ( ) )
rst = A = list ( input ( ) ) <eos>
1305
src = input () . split () の 各要素 に int を適用した 列 の 総 和 の 文字列 の長さ を出力する
trg = print ( len ( str ( sum ( map ( int , input ( ) . split ( ) ) ) ) ) )
rst = print ( len ( str ( sum ( map ( int , input ( ) . split ( ) ) ) ) ) ) <eos>
1306
src = B を time で 割 った 値を A とする
trg = A = B / time
rst = A = B / time <eos>
1307
src = A の head が 、 つまり 未 定 値 と 等 しい とき 、
trg = if A . head is not None :
rst = if A . head is not None : <eos>
1308
src = topologicalSort ( B , e ) を 順に A として 、 繰り返す
trg = for A in topologicalSort ( B , e ) :
rst = for A in <unk> ( B , e ) : <eos>
1309
src = B の d の C 番 目 を A とする
trg = A = B . d [ C ]
rst = A = B . d [ C ] <eos>
1310
src = A の root が 、 つまり 未 定 値 と 等 しく ない とき 、
trg = if A . root is None :
rst = if A . root is None : <eos>
1311
src = -1 から 2 未 満 までの 数 列 の 各要素 を C とし 、 0 が B に C を加えた 値 以下 かどうか が A の長さ より 小さい とき の 、 つまり 空白 文字 を 間 に 入れ て A の B に C を加えた 値 番 目 を 連結 した 文字列 を出力する の 列
trg = [ print ( ' ' . join ( A [ B + C ] ) ) for C in range ( - 1 , 2 ) if 0 <= ( B + C ) < len ( A ) ]
rst = [ print ( ' ' . join ( A [ B + str ( C ) for B in range ( - 1 , 2 ) if 0 <= B + C < len ( A ) ] ) ) <eos>
1312
src = C の 各要素 を B とし 、 A を 書式 として B の先頭 、 B の 1 番 目 で 整 形 した 文字列 の 列 を 展開 して を出力する
trg = print ( * [ A . format ( B [ 0 ] , B [ 1 ] ) for B in C ] )
rst = print ( * [ ( A . format ( B [ 0 ] , B [ 1 ] ) ) for B in C ] ) <eos>
1313
src = A の B 番目の C 番 目 かつ D の B 番 目 が C と 等 しく ない とき 、
trg = if A [ B ] [ C ] and D [ B ] != C :
rst = if A [ B ] [ C ] and D [ B ] != C : <eos>
1314
src = binsearch ( A , B [ 0 ] ) を返す
trg = return binsearch ( A , B [ 0 ] )
rst = return <unk> ( A , B [ 0 ] ) <eos>
1315
src = A [ B ] が C と 等 しく かつ A [ B + 1 ] が D と 等 しく または A [ B ] が D と 等 しく かつ A [ B + 1 ] が C と 等 しく または A の B 番 目 が E と 等 しく かつ A の B + 1 番 目 が F と 等 しく または A の B 番 目 が F と 等 しく かつ A
trg = if ( A [ B ] == C and A [ B + 1 ] == D ) or ( A [ B ] == D and A [ B + 1 ] == C ) or ( A [ B ] == E and A [ B + 1 ] == F ) or ( A [ B ] == F and A [ B + 1 ] == E ) :
rst = if ( A [ B ] == C and A [ B + 1 ] == D ) or ( A [ B + 1 ] == D and A [ B + 1 ] == E ) or ( A [ B + 1 ] == F and A
1316
src = A の B 番目の 0 番 目 が C の D 番 目 より 大きい 間 、 次 を 繰り返す
trg = while A [ B ] [ 0 ] > C [ D ] :
rst = while A [ B ] [ 0 ] > C [ D ] : <eos>
1317
src = 10 の 9 乗 に 2 を加えた 値を A とする
trg = A = 10 ** 9 + 2
rst = A = 10 ** 9 + 2 <eos>
1318
src = B から C を 引 いた 値に D * * 2 - E * * 2 に F * * 2 を加えた 値 から C の 2 乗 を 引 いた 値を 掛 け た 値に C から F を 引 いた 値に G * * 2 - E * * 2 に B * * 2 を加えた 値 から C の 2 乗 を 引 いた 値を 掛 け た 値 を加えた 値を H で 割 った 値を A
trg = A = ( ( B - C ) * ( D ** 2 - E ** 2 + F ** 2 - C ** 2 ) + ( C - F ) * ( G ** 2 - E ** 2 + B ** 2 - C ** 2 ) ) / H
rst = A = ( ( B - C ) * ( D ** 2 - E ** 2 + F ** 2 - C ** 2 ) + ( E - F ** 2 - G ** 2 - C ** 2 + E ** 2 - H ** 2 )
1319
src = func ( A , [] )
trg = func ( A , [ ] )
rst = func ( A , [ ] ) <eos>
1320
src = A の B 番目の children の長さ が 0 と 等 しい とき 、
trg = if len ( A [ B ] . children ) == 0 :
rst = if len ( A [ B ] . children ) == 0 : <eos>
1321
src = ( ( B , 0 から C 未 満 までの 数 列 の 各要素 を B とし 、 [MASK] の 両 端 キュー の 列 ) ) からなる 辞書 を A とする
trg = A = { i : [ deque ( ) for B in range ( C ) ] }
rst = A = { i : [ deque ( ) for B in range ( C ) ] } <eos>
1322
src = 1 を 開始 番号 として D の 25 番 目 から 、 つまり 末 尾 までの 部分 列 に 番号 付 した 組 の 列 の 各要素 を B 、 C とし 、 C が E と 等 しい とき の 0.5 の B 乗 の 列 の 総 和 を A とする
trg = A = sum ( [ 0.5 ** B for B , C in enumerate ( D [ 25 : ] , start = 1 ) if C == E ] )
rst = A = sum ( [ B for B , C in enumerate ( D [ 25 : ] , start = 1 ) if C == E ] , 0.5 ] ) <eos>
1323
src = A の B の C と 等 しい 要素 の最初の 位置 を取り 出した 値
trg = A . pop ( B . index ( C ) )
rst = A . pop ( B . index ( C ) ) <eos>
1324
src = A の 0 番 目 に A の 4 番 目 を加えた 値に A の 8 番 目 を加えた 値を B で 割 った 余 り が C と 等 しく ない とき 、
trg = if ( A [ 0 ] + A [ 4 ] + A [ 8 ] ) % B != C :
rst = if ( A [ 0 ] + A [ 4 ] + A [ 8 ] ) % B != C : <eos>
1325
src = A を B の 2 番 目 に B の 1 番目の 整数値 を 掛 け た 値 だけ 増加 させる
trg = A += B [ 2 ] * int ( B [ 1 ] )
rst = A += B [ 2 ] * int ( B [ 1 ] ) <eos>
1326
src = A の 末 尾 に A の 末 尾 に B の C 番 目 を加えた 値 を追加する
trg = A . append ( A [ - 1 ] + B [ C ] )
rst = A . append ( A . rstrip ( B [ C ] ) ) <eos>
1327
src = A の w を A の top にする
trg = A . top = A . w
rst = A . top = A . w <eos>
1328
src = A が 0 より 大きく かつ B が 0 より 大きい とき 、
trg = if A > 0 and B > 0 :
rst = if A > 0 and B > 0 : <eos>
1329
src = A が B の A の長さ 番 目 に 含まれ ない とき 、
trg = if A not in B [ len ( A ) ] :
rst = if A not in len ( B [ A ] ) : <eos>
1330
src = 0 が A より 小さい かどうか が B 以下 かつ C の D 番目の A 番目の 、 つまり 現在の 日 時 番 目 が C [ now ] の E 番目の F 番 目 に G を A で 割 った 値 を加えた 値 より 大きい とき 、
trg = if 0 < A <= B and C [ D ] [ A ] [ now ] > C [ now ] [ E ] [ F ] + G / A :
rst = if 0 < A <= B and C [ D ] [ A ] [ now ] > E [ C [ F ] [ G ] + A : <eos>
1331
src = A の cursor の next を A の cursor にする
trg = A . cursor = A . cursor . next
rst = A . cursor = A . cursor . next <eos>
1332
src = string _ to _ complex ( B ) を A とする
trg = A = string_to_complex ( B )
rst = A = <unk> ( B ) <eos>
1333
src = B の 最大 値を A とする
trg = A = max ( B )
rst = A = max ( B ) <eos>
1334
src = D を 空白 で 分割 した 字句 列 の 各要素 を C とし 、 C の 浮動小数点数 の 列 を 展開 し 、 それぞれ A 、 B とする
trg = A , B = [ float ( C ) for C in D . split ( ) ]
rst = A , B = [ float ( C ) for C in D . split ( ) ] <eos>
1335
src = A を B の node の C 番 目 だけ 増加 させる
trg = A += B . node [ C ]
rst = A += B . node [ C ] <eos>
1336
src = A の B に 12 を加えた 値 番 目 、 A の B 番目の 最大 値を A の B 番 目 にする
trg = A [ B ] = max ( A [ B + 12 ] , A [ B ] )
rst = A [ B ] = max ( A [ B + 12 ] , A [ B ] ) <eos>
1337
src = A の B 番目の imag が A の C 番目の imag より 小さい とき 、
trg = if A [ B ] . imag < A [ C ] . imag :
rst = if A [ B ] . imag < A [ C ] . imag : <eos>
1338
src = 0 から B 未 満 までの C 間隔 の 数 列 を 順に A として 、 繰り返す
trg = for A in range ( 0 , B , C ) :
rst = for A in range ( 0 , B , C ) : <eos>
1339
src = 入力された 文字列を 空白 で 分割 した 字句 列 を 展開 し 、 それぞれ A 、 B とする
trg = A , B = input ( ) . split ( )
rst = A , B = input ( ) . split ( ) <eos>
1340
src = root ( A , A [ B ] ) を A の B 番 目 にする
trg = A [ B ] = root ( A , A [ B ] )
rst = A [ B ] = root ( A , A [ B ] ) <eos>
1341
src = B に 1 を加えた 値に C の D に 1 を加えた 値 番 目 が E と 等 しく ない かどうか を加えた 値を A とする
trg = A = B + 1 + ( C [ D + 1 ] != E )
rst = A = B + 1 + ( C [ D + 1 ] != E ) <eos>
1342
src = A の size が B の size より 小さい とき 、
trg = if A . size < B . size :
rst = if A . size < B . size : <eos>
1343
src = A の B 番目の -1 番 目 に 1 を加えた 値 、 - A の B 番目の 先頭 を出力する
trg = print ( A [ B ] [ - 1 ] + 1 , - A [ B ] [ 0 ] )
rst = print ( A [ B ] [ - 1 ] + 1 , - A [ B ] [ 0 ] ) <eos>
1344
src = check ( F ) を E とする
trg = E = check ( F )
rst = E = check ( F ) <eos>
1345
src = 100 に C を 掛 け た 値に D を加えた 値 、 100 に E を 掛 け た 値に F を加えた 値を A 、 B とする
trg = A , B = 100 * C + D , 100 * E + F
rst = A , B = 100 * C + D , 100 * E + F <eos>
1346
src = 空白 文字 を 間 に 入れ て bubbleSort ( D [ : ] , C ) の 各要素 を C 、 B とし 、 B に C の 文字列 を加えた 値の 列 を 連結 した 文字列を A とする
trg = A = ' ' . join ( [ B + str ( C ) for C , B in bubbleSort ( D [ : ] , C ) ] )
rst = A = ' ' . join ( [ B + str ( C ) for C , B in bubbleSort ( D [ : ] , C ) ] ) <eos>
1347
src = ネ イ ピ ア 数 を A の behind にする
trg = A . behind = e
rst = A . behind = e <eos>
1348
src = A の -1 番 目 に 3 を 掛 け た 値に 1 を加えた 値が B より 小さい 間 、 次 を 繰り返す
trg = while A [ - 1 ] * 3 + 1 < B :
rst = while A [ - 1 ] * 3 + 1 < B : <eos>
1349
src = A の集合 を返す
trg = return set ( A )
rst = return set ( A ) <eos>
1350
src = 0 から D 未 満 までの 数 列 の 各要素 を C とし 、 B の 0 番 目 に B の 1 番 目 から B の先頭 を 引 いた 値に C を 掛 け た 値 を加えた 値の 列 を A とする
trg = A = [ B [ 0 ] + ( B [ 1 ] - B [ 0 ] ) * C for C in range ( D ) ]
rst = A = [ B [ 0 ] + ( B [ 1 ] - B [ 0 ] ) * C for C in range ( D ) ] <eos>
1351
src = A の p 2 から A の p 1 を 引 いた 値を A の p 2 から A の p 1 を 引 いた 値の 絶対 値 で 割 った 値を ネ イ ピ ア 数 とする
trg = e = ( A . p2 - A . p1 ) / abs ( A . p2 - A . p1 )
rst = e = abs ( A . p2 - A . p1 ) / abs ( A . p2 - A . p1 ) <eos>
1352
src = A の ( B 、 C ) の 組 を取り 出した 値
trg = A . pop ( ( B , C ) )
rst = A . pop ( ( B , C ) ) <eos>
1353
src = A の集合 の長さ が B と 等 しく ない とき 、
trg = if len ( set ( A ) ) != B :
rst = if len ( set ( A ) ) != B : <eos>
1354
src = frame ( A , B )
trg = frame ( A , B )
rst = <unk> ( A , B ) <eos>
1355
src = 600 を B で 割 った 商 を A とする
trg = A = 600 // B
rst = A = 600 // B <eos>
1356
src = 0 が dot 2 ( A , B ) 以下 かどうか が dist 1 ( A ) 以下の とき 、
trg = if 0 <= dot2 ( A , B ) <= dist1 ( A ) :
rst = if 0 <= dot2 ( A , B ) <= dist1 ( A ) : <eos>
1357
src = Num ( A . x + B . x ) を返す
trg = return Num ( A . x + B . x )
rst = return Num ( A . x + B . x ) <eos>
1358
src = A を 3 だけ 減少 させる
trg = A -= 3
rst = A -= 3 <eos>
1359
src = ( x 、 y を パラメータ として x から 1 を 引 いた 値 、 y 、 C を追加し て B を 更新 する を返す関数 、 x 、 y を パラメータ として B の位置 E から 1 を 引 いた 値 から D から 1 を 引 いた 値を 探 して 見つかった 位置 を出力する を返す関数 ) の 組 を A とする
trg = A = ( lambda D , E : B . update ( D - 1 , E , C ) , lambda D , E : print ( B . find ( D - 1 , E - 1 ) ) )
rst = A = { B , C , D : print ( B . find ( E , D ) - 1 , B . find ( E - 1 , D ) ) <eos>
1360
src = -1 が A の B 番 目 と 等 しい とき 、
trg = if - 1 == A [ B ] :
rst = if - 1 == A [ B ] : <eos>
1361
src = D を E の C 番 目 だけ 増加 させる
trg = D += E [ C ]
rst = D += E [ C ] <eos>
1362
src = np が 0 より 大きい とき 、
trg = if np > 0 :
rst = if np > 0 : <eos>
1363
src = D の 各要素 に x を パラメータ として math . pow ( B , C ) を返す関数 を適用した 列 を A とする
trg = A = map ( lambda B : math . pow ( B , C ) , D )
rst = A = map ( lambda B : math . pow ( B , C ) , D ) <eos>
1364
src = 17 30 が A 以下 かどうか が 19 30 以下 かどうか を返す
trg = return 1730 <= A <= 1930
rst = return 330 <= A <= 1930 <eos>
1365
src = B を C に D に E に 1 を加えた 値を 掛 け た 値 を加えた 値 で 割 った 商 、 A の 最大 値を A とする
trg = A = max ( B // ( C + D * ( E + 1 ) ) , A )
rst = A = max ( B // ( C + D * ( E + 1 ) ) , A ) <eos>
1366
src = A が 、 つまり ネ イ ピ ア 数 より 小さい とき ( 0 、 1 ) の 組 を ( B 、 C ) の 組 とする 、 そうでなければ ( 1 、 0 ) の 組
trg = ( B , C ) = ( 0 , 1 ) if A < e else ( 1 , 0 )
rst = ( 0 , 1 ) = ( 0 , 1 ) if A < e else ( B , C ) <eos>
1367
src = 0 が A 以下 かどうか が B 以下 かどうか が C より 小さく なく または 0 が D 以下 かどうか が E 以下 かどうか が F より 小さく ない とき 、
trg = if not 0 <= A <= B < C or not 0 <= D <= E < F :
rst = if not 0 <= A <= B < C or not 0 <= D < E <= F : <eos>
1368
src = complist ( A , B ) の とき 、
trg = if complist ( A , B ) :
rst = if <unk> ( A , B ) : <eos>
1369
src = A の 2 乗 を返す
trg = return A ** 2
rst = return A ** 2 <eos>
1370
src = 現在の 日 時 を 60 で 割 った 余 り が A 以下 かどうか が B を 60 で 割 った 余 り 以下の とき 、
trg = if now % 60 <= A <= B % 60 :
rst = if now % 60 <= A <= B % 60 : <eos>
1371
src = 空白 文字 を 間 に 入れ て A の B に 1 を加えた 値 から 、 つまり 末 尾 までの 部分 列 の 各要素 に 整数 を適用した 列 を 連結 した 文字列 を出力する
trg = print ( ' ' . join ( map ( str , A [ B + 1 : ] ) ) )
rst = print ( ' ' . join ( map ( str , A [ B + 1 : ] ) ) ) <eos>
1372
src = 0 が A 以下 かどうか が B [ 0 ] の長さ より 小さく かつ 0 が C 以下 かどうか が B の長さ より 小さく なく または B の C 番目の A 番 目 が D と 等 しい とき 、
trg = if not ( 0 <= A < len ( B [ 0 ] ) and ( 0 <= C < len ( B ) ) ) or B [ C ] [ A ] == D :
rst = if 0 <= A < len ( B [ 0 ] ) and 0 <= C < len ( B [ C ] ) or B [ C ] [ A ] == D : <eos>
1373
src = ( ( 、 つまり 偽 ) からなる 列 の 0 から 20 1 未 満 までの 数 列 の 各要素 を B とし 、 20 1 の 列 回 分 の 列 ) からなる 列 を A とする
trg = A = [ [ False ] * [ 201 for B in range ( 201 ) ] ]
rst = A = [ [ False ] * [ 201 for B in range ( 201 ) ] ] <eos>
1374
src = (1) からなる 列 の 4 5 回 分 の 列 を A とする
trg = A = [ 1 ] * 45
rst = A = [ 1 ] * 45 <eos>
1375
src = segment _ line _ dist ( A , B , C ) が D に E を加えた 値の 2 乗 に F を加えた 値 より 小さい とき 、
trg = if segment_line_dist ( A , B , C ) < ( D + E ) ** 2 + F :
rst = if is_odd ( A , B , C ) < ( D + E ) ** 2 + F : <eos>
1376
src = ( B 、 C 、 D 、 E ) からなる 列 のうち 4 個 までの 順 列 を 順に A として 、 繰り返す
trg = for A in itertools . permutations ( [ B , C , D , E ] , 4 ) :
rst = for A in permutations ( [ B , C , D , E ] , 4 ) : <eos>
1377
src = A の 末 尾 に B 、 C の 最小 値 を追加する
trg = A . append ( min ( B , C ) )
rst = A . append ( min ( B , C ) ) <eos>
1378
src = ( A の log の B から 1 を 引 いた 値 番目の 先頭 、 A の log の B から 1 を 引 いた 値 番目の 1 番 目 、 A の step ) の 組 を A の log の B から 1 を 引 いた 値 番 目 にする
trg = A . log [ B - 1 ] = ( A . log [ B - 1 ] [ 0 ] , A . log [ B - 1 ] [ 1 ] , A . step )
rst = A . log [ B - 1 ] = ( A . log [ B - 1 ] [ 0 ] , A . log [ B - 1 ] [ 1 ] , A . step ) <eos>
1379
src = B の C 番 目 から D の C 番 目 を 引 いた 値を A とする
trg = A = B [ C ] - D [ C ]
rst = A = B [ C ] - D [ C ] <eos>
1380
src = heappush ( A , ( B , C , D , E , F ) )
trg = heappush ( A , ( B , C , D , E , F ) )
rst = heappush ( A , ( B , C , D , E , F ) ) <eos>
1381
src = x を パラメータ として ( - B の 2 番 目 、 x の 3 番 目 、 x の先頭 ) の 組 を返す関数 を キー として A を ソート した 列 を A とする
trg = A = sorted ( A , key = lambda B : ( - B [ 2 ] , B [ 3 ] , B [ 0 ] ) )
rst = A = sorted ( A , key = lambda B : ( - B [ 2 ] , B [ 3 ] , B [ 0 ] ) ) <eos>
1382
src = B の C 番 目 に D を加えた 値を A とする
trg = A = B [ C ] + D
rst = A = B [ C ] + D <eos>
1383
src = FifteenPuzzle ( B , 4 5 ) を A とする
trg = A = FifteenPuzzle ( B , 45 )
rst = A = <unk> ( B , 45 ) <eos>
1384
src = B を A の pos にする
trg = A . pos = B
rst = A . pos = B <eos>
1385
src = A の top が A の Max 以上 かどうか を返す
trg = return A . top >= A . Max
rst = return A . top >= A . <unk> <eos>
1386
src = A の B に 4 を加えた 値を 7 で 割 った 余 り 番 目 を出力する
trg = print ( A [ ( B + 4 ) % 7 ] )
rst = print ( A [ ( B + 4 ) % 7 ] ) <eos>
1387
src = push ( B , C [ D ] , A ) の 1 番 目 を A とする
trg = A = push ( B , C [ D ] , A ) [ 1 ]
rst = A = push ( B , C [ D ] , A ) [ 1 ] <eos>
1388
src = 0 から B から 2 に C を 掛 け た 値を 引 いた 値 未 満 までの 数 列 を 順に A として 、 繰り返す
trg = for A in range ( B - 2 * C ) :
rst = for A in range ( B - 2 * C ) : <eos>
1389
src = ネ イ ピ ア 数 から B を 引 いた 値を A とする
trg = A = e - B
rst = A = e - B <eos>
1390
src = A の 0 を取り 出した 値
trg = A . pop ( 0 )
rst = A . pop ( 0 ) <eos>
1391
src = A . _ sum ( B ) から A . _ sum ( C -1 ) を 引 いた 値を返す
trg = return A . _sum ( B ) - A . _sum ( C - 1 )
rst = return A . sum_ ( B ) - A . sum_ ( C - 1 ) <eos>
1392
src = gindex ( B , C ) を A とする
trg = A = gindex ( B , C )
rst = A = gindex ( B , C ) <eos>
1393
src = A の B から 1 を 引 いた 値 番目の penalty の C 番 目 を 20 だけ 増加 させる
trg = A [ B - 1 ] . penalty [ C ] += 20
rst = A [ B - 1 ] . penalty [ C ] += 20 <eos>
1394
src = time を 順に A として 、 繰り返す
trg = for A in time :
rst = for A in time : <eos>
1395
src = A の 末 尾 に ( B 、 C から D を 引 いた 値 ) の 組 を追加する
trg = A . append ( ( B , C - D ) )
rst = A . append ( ( B , C - D ) ) <eos>
1396
src = C が -1 と 等 しく ない とき A の C 番 目 に ( D ) からなる 列 を加えた 値 、 そうでなければ ( D ) からなる 列 を A の B 番 目 にする
trg = A [ B ] = ( A [ C ] + [ D ] ) if C != - 1 else [ D ]
rst = A [ B ] = A [ C ] + [ D ] if C != - 1 else [ D ] <eos>
1397
src = time を A の先頭 の 1 番 目 だけ 増加 させる
trg = time += A [ 0 ] [ 1 ]
rst = time += A [ 0 ] [ 1 ] <eos>
1398
src = A 、 B から 1 を 引 いた 値 、 C から 1 を 引 いた 値 を出力する
trg = print ( A , B - 1 , C - 1 )
rst = print ( A , B - 1 , C - 1 ) <eos>
1399
src = A の p の B 番 目 が -1 と 等 しく ない とき 、
trg = if A . p [ B ] != - 1 :
rst = if A . p [ B ] != - 1 : <eos>
1400
src = parse _ hash ( B , 0 ) を A とする
trg = A = parse_hash ( B , 0 )
rst = A = parse_hash ( B , 0 ) <eos>
1401
src = ( A 、 B 、 C 、 D 、 E ) の 組 が F に 含まれ ない とき 、
trg = if ( A , B , C , D , E ) not in F :
rst = if ( A , B , C , D , E ) not in F : <eos>
1402
src = B を 14 60 9 7 で 割 った 商 を A とする
trg = A = B // 146097
rst = A = B // 146097 <eos>
1403
src = 未 定 値を A の value の B 番 目 にする
trg = A . value [ B ] = None
rst = A . value [ B ] = None <eos>
1404
src = MagicalTiles ( B ) を A とする
trg = A = MagicalTiles ( B )
rst = A = <unk> ( B ) <eos>
1405
src = A の長さ が 0 より 大きい とき 、
trg = if len ( A ) > 0 :
rst = if len ( A ) > 0 : <eos>
1406
src = ( 、 つまり 未 定 値 、 未 定 値 、 未 定 値 ) からなる 列 を A とする
trg = A = [ None , None , None ]
rst = A = [ None , None , None ] <eos>
1407
src = A を 書式 として B 、 C 、 D 、 E で 整 形 した 文字列 を出力する
trg = print ( A . format ( B , C , D , E ) )
rst = print ( A . format ( B , C , D , E ) ) <eos>
1408
src = A の B 番 目 が ( 、 つまり 未 定 値 、 未 定 値 ) からなる 列 と 等 しい とき 、
trg = if A [ B ] == [ None , None ] :
rst = if A [ B ] == [ None , None ] : <eos>
1409
src = A を parse _ line ( B . strip () ) だけ 増加 させる
trg = A += parse_line ( B . strip ( ) )
rst = A += <unk> ( B . strip ( ) ) <eos>
1410
src = find ( A [ 1 ] ) の とき 、
trg = if find ( A [ 1 ] ) :
rst = if find ( A [ 1 ] ) : <eos>
1411
src = B の 各要素 に 整数 を適用した 列 の リストを ソート した 列 を A とする
trg = A = sorted ( list ( map ( int , B ) ) )
rst = A = sorted ( list ( map ( int , B ) ) ) <eos>
1412
src = find _ gcd ( A , B % A ) を返す
trg = return find_gcd ( A , B % A )
rst = return _find ( A , B % A ) <eos>
1413
src = A . add _ edge ( B [ C ] , D + 1, E , 0 )
trg = A . add_edge ( B [ C ] , D + 1 , E , 0 )
rst = A . add_edge ( B [ C ] , D + 1 , E , 0 ) <eos>
1414
src = B と - B の 論理 積 を A とする
trg = A = B & - B
rst = A = ( B & - B ) <eos>
1415
src = get _ bounds ( B ) を A とする
trg = A = get_bounds ( B )
rst = A = <unk> ( B ) <eos>
1416
src = mat _ mul ( A , B , C ) を A とする
trg = A = mat_mul ( A , B , C )
rst = A = mat_mul ( A , B , C ) <eos>
1417
src = B から C に D から B を 引 いた 値を 掛 け た 値を 引 いた 値 から E から F に G から E を 引 いた 値を 掛 け た 値を 引 いた 値を 引 いた 値を A とする
trg = A = ( B - C * ( D - B ) ) - ( E - F * ( G - E ) )
rst = A = B - C * ( D - B ) - ( E - F * ( G - E ) ) <eos>
1418
src = 0 x 7 fffff を A とする
trg = A = 0x7fffff
rst = A = <unk> <eos>
1419
src = ( 0 、 0 ) からなる 列 を A の 、 つまり 先頭 から 2 番 目 までの 部分 列 にする
trg = A [ : 2 ] = [ 0 , 0 ]
rst = A [ : 2 ] = [ 0 , 0 ] <eos>
1420
src = A の D 番目の E 番 目 に 1 を加えた 値 、 A の B 番目の C 番目の 最小 値を A の B 番目の C 番 目 にする
trg = A [ B ] [ C ] = min ( A [ D ] [ E ] + 1 , A [ B ] [ C ] )
rst = A [ B ] [ C ] = min ( A [ D ] [ E ] + 1 , A [ B ] [ C ] ) <eos>
1421
src = A から 1 を 引 いた 値を返す
trg = return A - 1
rst = return A - 1 <eos>
1422
src = A . is _ empty () でない とき 、
trg = if not A . is_empty ( ) :
rst = if not A . <unk> ( ) : <eos>
1423
src = 0 から D に 1 を加えた 値 未 満 までの 数 列 の 各要素 を C とし 、 B に 1 を加えた 値の 列 を A とする
trg = A = [ B + 1 for C in range ( D + 1 ) ]
rst = A = [ B + 1 for C in range ( D + 1 ) ] <eos>
1424
src = A の D 番目の E 番 目 に F を加えた 値を A の B 番目の C 番 目 にする
trg = A [ B ] [ C ] = A [ D ] [ E ] + F
rst = A [ B ] [ C ] = A [ D ] [ E ] + F <eos>
1425
src = B が C から 1 を 引 いた 値 と 等 しい かどうか から 10 未 満 までの 数 列 を 順に A として 、 繰り返す
trg = for A in range ( B == C - 1 , 10 ) :
rst = for A in range ( B , C - 1 , 10 ) : <eos>
1426
src = check _ circles ( A , B , C , D , E , F ) を出力する
trg = print ( check_circles ( A , B , C , D , E , F ) )
rst = print ( <unk> ( A , B , C , D , E , F ) ) <eos>
1427
src = A に 1 を加えた 値が B より 小さく かつ C の D * 2 番目の A 番 目 が 0 と 等 しく かつ E の D 番目の A に 1 を加えた 値 番 目 が F に 1 を加えた 値 より 大きい とき 、
trg = if A + 1 < B and C [ D * 2 ] [ A ] == 0 and E [ D ] [ A + 1 ] > F + 1 :
rst = if A + 1 < B and C [ D * 2 ] [ A ] == 0 and E [ D ] [ A + 1 ] > F + 1 : <eos>
1428
src = find _ upper ( A , B ) を返す
trg = return find_upper ( A , B )
rst = return <unk> ( A , B ) <eos>
1429
src = B を A の cap にする
trg = A . cap = B
rst = A . cap = B <eos>
1430
src = A の長さ かつ B が C と 等 しく なく かつ C の D 番 目 に A の長さ から 2 を 引 いた 値を 掛 け た 値が B の D 番 目 に A の長さ に 2 を加えた 値を 掛 け た 値 より 大きい とき 、
trg = if len ( A ) and B != C and C [ D ] * ( len ( A ) - 2 ) > B [ D ] * ( len ( A ) + 2 ) :
rst = if len ( A ) != B and C [ D ] * ( len ( A ) - 2 ) > B [ D ] * ( len ( A ) + 2 ) : <eos>
1431
src = 0 から 、 つまり ネ イ ピ ア 数の B 番目の 長さ 未 満 までの 数 列 を 順に A として 、 繰り返す
trg = for A in range ( len ( e [ B ] ) ) :
rst = for A in range ( len ( e [ B ] ) ) : <eos>
1432
src = A の値 の集まり の 最大 値が 100 0000 より 小さい とき 、
trg = if max ( A . values ( ) ) < 1000000 :
rst = if max ( A . values ( ) ) < 1000000 : <eos>
1433
src = A を 書式 として B と ネ イ ピ ア 数の 排 他 論理 和 で 整 形 した 文字列 を出力する
trg = print ( A . format ( B ^ e ) )
rst = print ( A . format ( B ^ e ) ) <eos>
1434
src = B の 1 番 目 から 、 つまり 末 尾 までの 2 間隔 による 部分 列 を A とする
trg = A = B [ 1 : : 2 ]
rst = A = B [ 1 : : 2 ] <eos>
1435
src = A の cnt を A の ord の B 番 目 にする
trg = A . ord [ B ] = A . cnt
rst = A . ord [ B ] = A . cnt <eos>
1436
src = primes 2 ( 10 * * 7 ) を A とする
trg = A = primes2 ( 10 ** 7 )
rst = A = primes2 ( 10 ** 7 ) <eos>
1437
src = 0 から E 未 満 までの 数 列 の 各要素 を B とし 、 ( B 、 C 、 D ) の 組 の 列 を追加し て A を 更新 する
trg = A . update ( [ ( B , C , D ) for B in range ( E ) ] )
rst = A . update ( [ ( B , C , D ) for B in range ( E ) ] ) <eos>
1438
src = - C を C とする
trg = C = - C
rst = C = - C <eos>
1439
src = A の B から 1 を 引 いた 値 番 目 が C と 等 しく ない 間 、 次 を 繰り返す
trg = while A [ B - 1 ] != C :
rst = while A [ B - 1 ] != C : <eos>
1440
src = C を A の lazy の B 番 目 にする
trg = A . lazy [ B ] = C
rst = A . lazy [ B ] = C <eos>
1441
src = A 、 B の C から 1 を 引 いた 値 番目の D 番目の 最大 値を A とする
trg = A = max ( A , B [ C - 1 ] [ D ] )
rst = A = max ( A , B [ C - 1 ] [ D ] ) <eos>
1442
src = A が B を 1 だけ 右 シフト した 値 より 大きい とき C 、 そうでなければ D を出力する
trg = print ( C if A > ( B >> 1 ) else D )
rst = print ( C if A > B >> 1 else D ) <eos>
1443
src = A の key が B の right と 等 しい とき 、
trg = if A . key == B . right :
rst = if A . key == B . right : <eos>
1444
src = Binaryserch () を出力する
trg = print ( Binaryserch ( ) )
rst = print ( <unk> ( ) ) <eos>
1445
src = A が 0 と 等 しく かつ B の とき 、
trg = if A == 0 and B :
rst = if A == 0 and B : <eos>
1446
src = 1 から 14 未 満 までの 数 列 の 各要素 を B とし 、 ( A 、 B ) の 組 が D に 含まれ ない とき の C の 列 の 各要素 を A とし 、 ( A 、 B ) の 組 の 列 を 順に A 、 B として 、 繰り返す
trg = for A , B in [ ( A , B ) for A in [ C for B in range ( 1 , 14 ) if ( A , B ) not in D ] ] :
rst = for A , B in [ ( A , B ) for B in [ range ( 1 , 14 ) for B in range ( 1 , 14 ) if ( A , B ) not in D ] : <eos>
1447
src = rdfs ( A [ B ] [ C ] , D )
trg = rdfs ( A [ B ] [ C ] , D )
rst = <unk> ( A [ B ] [ C ] , D ) <eos>
1448
src = A の B 番 目 が C より 大きい とき 、
trg = if A [ B ] > C :
rst = if A [ B ] > C : <eos>
1449
src = A を 2 で 割 った 余 り が B を 2 で 割 った 余 り と 等 しい とき 、
trg = if ( A % 2 ) == ( B % 2 ) :
rst = if A % 2 == B % 2 : <eos>
1450
src = ( ( A に B に C を 掛 け た 値を D で 割 った 値 を加えた 値 、 E に F に C を 掛 け た 値を D で 割 った 値 を加えた 値 ) の 組 、 G に H を 掛 け た 値を I で 割 った 値 ) の 組 を返す
trg = return ( ( A + B * C / D , E + F * C / D ) , G * H / I )
rst = return ( ( A + B * C / D , E + F * C / ( D + G * H ) , I ) ) <eos>
1451
src = B を 3 で 割 った 商 を A の spc _ y にする
trg = A . spc_y = B // 3
rst = A . spc_x = B // 3 <eos>
1452
src = 1 を A の B と 3 の 論理 積 番 目 にする
trg = A [ B & 3 ] = 1
rst = A [ B & 3 ] = 1 <eos>
1453
src = A に 1 を加えた 値の 3 乗 が 、 つまり ネ イ ピ ア 数 と 等 しい とき 、
trg = if ( A + 1 ) ** 3 == e :
rst = if ( A + 1 ) ** 3 == e : <eos>
1454
src = 40 を A の B 番 目 にする
trg = A [ B ] = 40
rst = A [ B ] = 40 <eos>
1455
src = 改行 せずに A を 英 小文字 に変換し た 文字列 を出力する
trg = print ( A . lower ( ) , end = '' )
rst = print ( A . lower ( ) , end = '' ) <eos>
1456
src = A の cnt を 1 だけ 増加 させる
trg = A . cnt += 1
rst = A . cnt += 1 <eos>
1457
src = A を B の C 番 目 に C + 1 、 E + 1 - C の 最大 値 から 10 1 未 満 までの 数 列 の 各要素 を D とし 、 B の D 番目の 列 の 総 和 を 掛 け た 値 だけ 増加 させる
trg = A += B [ C ] * sum ( [ B [ D ] for D in range ( max ( C + 1 , E + 1 - C ) , 101 ) ] )
rst = A += B [ C ] * sum ( [ B [ D ] for D in range ( 1 , E - C + 1 ) ] ) <eos>
1458
src = 入力された 文字列を 空白 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 の 組 を A とする
trg = A = tuple ( map ( int , input ( ) . split ( ) ) )
rst = A = tuple ( map ( int , input ( ) . split ( ) ) ) <eos>
1459
src = B の 1 番 目 から 、 つまり 末 尾 までの 部分 列 に ( 0 ) からなる 列 を加えた 値を 順に A として 、 繰り返す
trg = for A in B [ 1 : ] + [ 0 ] :
rst = for A in B [ 1 : ] + [ 0 ] : <eos>
1460
src = BubbleSort ( B , C ) を A とする
trg = A = BubbleSort ( B , C )
rst = A = BubbleSort ( B , C ) <eos>
1461
src = dot ( B , C - D ) を A とする
trg = A = dot ( B , C - D )
rst = A = dot ( B , C - D ) <eos>
1462
src = 0 から 27 未 満 までの 数 列 の 各要素 を A とし 、 A を 3 で 割 った 余 り の 列 を返す
trg = return [ A % 3 for A in range ( 27 ) ]
rst = return [ A % 3 for A in range ( 27 ) ] <eos>
1463
src = mod _ pow ( B * B % C , D / /2 ) を A とする
trg = A = mod_pow ( B * B % C , D // 2 )
rst = A = <unk> ( B * B % C , D // 2 ) <eos>
1464
src = A の iter の B 番 目 を 1 だけ 増加 させる
trg = A . iter [ B ] += 1
rst = A . iter [ B ] += 1 <eos>
1465
src = 3 60 から B の C 番 目 を 引 いた 値を A とする
trg = A = 360 - B [ C ]
rst = A = 360 - B [ C ] <eos>
1466
src = ( B の Status の white ) からなる 列 の A の num _ of _ nodes 回 分 の 列 を A の color にする
trg = A . color = [ B . Status . white ] * A . num_of_nodes
rst = A . color = [ B . Status . white ] * A . num_of_nodes <eos>
1467
src = A の 末 尾 に 文字列 B に C を加えた 値に D を加えた 値を 評価 した 値の 文字列 を追加する
trg = A . append ( str ( eval ( B + C + D ) ) )
rst = A . append ( eval ( B + C + D ) ) <eos>
1468
src = A の B 番目の 2 番目の とき 、
trg = if A [ B ] [ 2 ] :
rst = if A [ B ] [ 2 ] : <eos>
1469
src = 0 から B に C を 掛 け た 値 未 満 までの 数 列 を 順に A として 、 繰り返す
trg = for A in range ( B * C ) :
rst = for A in range ( B * C ) : <eos>
1470
src = A . is _ parallel ( B ) の とき 、
trg = if A . is_parallel ( B ) :
rst = if A . is_parallel ( B ) : <eos>
1471
src = 0 から E に 1 を加えた 値 未 満 までの 数 列 の 各要素 を D とし 、 0 から C に 1 を加えた 値 未 満 までの 数 列 の 各要素 を B とし 、 -1 の 列 の 列 を A とする
trg = A = [ [ - 1 for B in range ( C + 1 ) ] for D in range ( E + 1 ) ]
rst = A = [ [ - 1 for B in range ( C + 1 ) ] for D in range ( E + 1 ) ] <eos>
1472
src = A の ( B 、 4 ) の 組 番目の 各要素 を C とし 、 C に D を加えた 値の 列 を A の ( B 、 5 ) の 組 番 目 にする
trg = A [ ( B , 5 ) ] = [ C + D for C in A [ ( B , 4 ) ] ]
rst = A [ ( 5 , B ) ] = [ C + D for C in A [ ( B , 4 ) ] ] <eos>
1473
src = A の bits を返す
trg = return ( A . bits )
rst = return A . bits <eos>
1474
src = dfs 2 ( A [ B ] , C , D ) を返す
trg = return dfs2 ( A [ B ] , C , D )
rst = return dfs2 ( A [ B ] , C , D ) <eos>
1475
src = D の 3 個 までの コン ビ ネ ー ション を 順に A 、 B 、 C として 、 繰り返す
trg = for A , B , C in combinations ( D , 3 ) :
rst = for A , B , C in combinations ( D , 3 ) : <eos>
1476
src = ( 0 ) からなる 列 の 12 に 1 を加えた 値 回 分 の 列 を A とする
trg = A = [ 0 ] * ( 12 + 1 )
rst = A = [ 0 ] * ( 12 + 1 ) <eos>
1477
src = ネ イ ピ ア 数 を 展開 し 、 それぞれ A 、 B 、 C とする
trg = A , B , C = e
rst = A , B , C = e <eos>
1478
src = find ( B ) を A とする
trg = A = find ( B )
rst = A = find ( B ) <eos>
1479
src = B から C を 引 いた 値 から 1 を 引 いた 値に D の E 番 目 を 掛 け た 値を A とする
trg = A = ( B - C - 1 ) * D [ E ]
rst = A = ( B - C - 1 ) * D [ E ] <eos>
1480
src = 1 を A の 、 つまり 入力された 文字列 の 整数値 から 1 を 引 いた 値 番 目 にする
trg = A [ int ( input ( ) ) - 1 ] = 1
rst = A [ int ( input ( ) ) - 1 ] = 1 <eos>
1481
src = A に 1 を加えた 値 、 -1 を出力する
trg = print ( A + 1 , - 1 )
rst = print ( A + 1 , - 1 ) <eos>
1482
src = B の 整数値 に 300 を 掛 け た 値を A とする
trg = A = int ( B ) * 300
rst = A = int ( B ) * 300 <eos>
1483
src = A . heappush ( B , C . Node ( D , 0 ) )
trg = A . heappush ( B , C . Node ( D , 0 ) )
rst = A . heappush ( B , C . Node ( D , 0 ) ) <eos>
1484
src = A 、 B に C を 掛 け た 値を D で 割 った 値の 最大 値を A とする
trg = A = max ( A , B * C / D )
rst = A = max ( A , B * C / D ) <eos>
1485
src = A の 浮動小数点数 を B の 浮動小数点数 の 2 乗 で 割 った 値が 25 以上の とき 、
trg = if float ( A ) / float ( B ) ** 2 >= 25 :
rst = if float ( A ) / float ( B ) ** 2 >= 25 : <eos>
1486
src = A の pip の 0 番 目 が B と 等 しく かつ A の pip の 1 番 目 が C と 等 しい とき 、
trg = if A . pip [ 0 ] == B and A . pip [ 1 ] == C :
rst = if A . pip [ 0 ] == B and A . pip [ 1 ] == C : <eos>
1487
src = find ( A , int ( B [ C ] [ 5 : ] ) ) の とき 、
trg = if find ( A , int ( B [ C ] [ 5 : ] ) ) :
rst = if find ( A , int ( B [ C ] [ 5 : ] ) ) : <eos>
1488
src = B から C の D 番 目 から C の E 番 目 を 引 いた 値を 引 いた 値を 2 で 割 った 商 を A とする
trg = A = ( B - ( C [ D ] - C [ E ] ) ) // 2
rst = A = ( B - C [ D ] ) // ( C [ E ] ) // 2 <eos>
1489
src = B の C に 1 を加えた 値 番 目 を D とする
trg = D = B [ C + 1 ]
rst = D = B [ C + 1 ] <eos>
1490
src = Point ( 0 , 0 ) を A とする
trg = A = Point ( 0 , 0 )
rst = A = Point ( 0 , 0 ) <eos>
1491
src = A を B の 2 乗 で 割 った 値が 25 以上の とき 、
trg = if A / B ** 2 >= 25 :
rst = if A / ( B ** 2 ) >= 25 : <eos>
1492
src = prepare _ board () を A とする
trg = A = prepare_board ( )
rst = A = <unk> ( ) <eos>
1493
src = A が B より 小さく または 0 が C より 小さい とき 、
trg = if A < B or 0 < C :
rst = if A < B or 0 < C : <eos>
1494
src = B の C から 1 を 引 いた 値 番目の D に 1 を加えた 値 番 目 を A とする
trg = A = B [ C - 1 ] [ D + 1 ]
rst = A = B [ C - 1 ] [ D + 1 ] <eos>
1495
src = ( B から 1 を 引 いた 値 、 B から 1 を 引 いた 値 、 1 ) の 組 を A とする
trg = A = ( B - 1 , B - 1 , 1 )
rst = A = ( B - 1 , B - 1 , 1 ) <eos>
1496
src = 5 を r として B の コン ビ ネ ー ション を 順に A として 、 繰り返す
trg = for A in combinations ( B , r = 5 ) :
rst = for A in combinations ( B , r = 5 ) : <eos>
1497
src = 10 の 18 乗 を B とする
trg = B = 10 ** 18
rst = B = 10 ** 18 <eos>
1498
src = A に B を加えた 値を C の長さ で 割 った 余 り を A とする
trg = A = ( A + B ) % len ( C )
rst = A = ( A + B ) % len ( C ) <eos>
1499
src = ( 、 つまり ネ イ ピ ア 数 に 1 から B を 引 いた 値を 掛 け た 値に C に B を 掛 け た 値 を加えた 値 、 D に 1 から B を 引 いた 値を 掛 け た 値に E に B を 掛 け た 値 を加えた 値 ) の 組 を A とする
trg = A = ( ( e * ( 1 - B ) + C * B ) , ( D * ( 1 - B ) + E * B ) )
rst = A = ( e * ( 1 - B ) + C * B , D - 1 * B + E * B ) <eos>
1500
src = B 、 C の 要素を それぞれ 組 にした 列 を 順に A として 、 繰り返す
trg = for A in zip ( B , C ) :
rst = for A in zip ( B , C ) : <eos>
1501
src = A の C 番 目 、 A の B 番 目 を A の B 番 目 、 A の C 番 目 とする
trg = A [ B ] , A [ C ] = A [ C ] , A [ B ]
rst = A [ B ] , A [ C ] = A [ C ] , A [ B ] <eos>
1502
src = A の B 番 目 が C の inf と 等 しい とき 、
trg = if A [ B ] == C . inf :
rst = if A [ B ] == C . inf : <eos>
1503
src = B の f を A とする
trg = A = B . f
rst = A = B . f <eos>
1504
src = A の 0 番 目 が B と 等 しい とき C . popleft () 、 そうでなければ C の先頭 を取り 出した 値
trg = C . popleft ( ) if A [ 0 ] == B else C . pop ( )
rst = C . pop ( ) if A [ 0 ] == B else C . pop ( ) <eos>
1505
src = A を C 、 D 、 E 、 F 、 G において 正規表現 B が 最初 にマッチする 位置 だけ 増加 させる
trg = A += search ( B , C , D , E , F , G )
rst = A += search ( B , C , D , E , F , G ) <eos>
1506
src = 0 が A 以下 かつ B が dist 2 ( C , D ) 以下 かどうか を返す
trg = return 0 <= A and B <= dist2 ( C , D )
rst = return 0 <= A and B <= dist2 ( C , D ) <eos>
1507
src = 区切り なしで 空白 文字 を 代わり の 行 末 として A 、 B を出力する
trg = print ( A , B , sep = '' , end = ' ' )
rst = print ( A , B , sep = ' ' , end = ' ) <eos>
1508
src = B の値 の集まり の 最大 値を A とする
trg = A = max ( B . values ( ) )
rst = A = max ( B . values ( ) ) <eos>
1509
src = A の B 番 目 を C を 2 で 割 った 商 に 1 を加えた 値 だけ 増加 させる
trg = A [ B ] += C // 2 + 1
rst = A [ B ] += C // 2 + 1 <eos>
1510
src = A の B * 2 から 1 を 引 いた 値 番目の C 番 目 が 0 と 等 しい とき 、 つまり 真 、 そうでなければ 、 つまり 偽 を返す
trg = return True if A [ B * 2 - 1 ] [ C ] == 0 else False
rst = return True if A [ B * 2 - 1 ] [ C ] == 0 else False <eos>
1511
src = extendedEuler ( C , D ) を 展開 し 、 それぞれ A 、 B とする
trg = A , B = extendedEuler ( C , D )
rst = A , B = extendedEuler ( C , D ) <eos>
1512
src = B から B を 2 で 割 った 余 り の とき [ CforCinAifC % 2 ] の 最小 値 、 そうでなければ 0 を 引 いた 値を 2 で 割 った 商 を出力する
trg = print ( ( B - ( min ( [ C for C in A if C % 2 ] ) if B % 2 else 0 ) ) // 2 )
rst = print ( ( min ( <unk> ( B ) - E [ 2 ] if B % 2 else 0 ) // 2 ) ) <eos>
1513
src = B から C から 1 を 引 いた 値 未 満 までの -1 間隔 の 数 列 の リストを A とする
trg = A = list ( range ( B , C - 1 , - 1 ) )
rst = A = list ( range ( B , C - 1 , - 1 ) ) <eos>
1514
src = collision _ ll ( A , B , C , D ) の とき 、
trg = if collision_ll ( A , B , C , D ) :
rst = if <unk> ( A , B , C , D ) : <eos>
1515
src = aoj ()
trg = aoj ( )
rst = <unk> ( ) <eos>
1516
src = B を 4 で 割 った 値に C の 4 乗 から D の 4 乗 を 引 いた 値を 掛 け た 値に E から B に D を 掛 け た 値を 引 いた 値を 3 で 割 った 値に C の 3 乗 から D の 3 乗 を 引 いた 値を 掛 け た 値 を加えた 値を A とする
trg = A = B / 4 * ( C ** 4 - D ** 4 ) + ( E - B * D ) / 3 * ( C ** 3 - D ** 3 )
rst = A = B / 4 * ( C ** 4 - D ** 4 ) + ( E - B * D ) / 3 * ( C ** 3 - D ** 3 ) <eos>
1517
src = A を partition ( B , C - D ) に combination ( C , D ) を 掛 け た 値 だけ 増加 させる
trg = A += partition ( B , C - D ) * combination ( C , D )
rst = A += partition ( B , C - D ) * combination ( C , D ) <eos>
1518
src = A に 1 を加えた 値を B で 割 った 余 り が 0 より 大きい とき 、
trg = if ( A + 1 ) % B > 0 :
rst = if ( A + 1 ) % B > 0 : <eos>
1519
src = A に B を加えた 値に C を加えた 値を 整数 とする
trg = str = A + B + C
rst = str = A + B + C <eos>
1520
src = B の C 番目の x 座標 を A とする
trg = A = B [ C ] . x
rst = A = B [ C ] . x <eos>
1521
src = B 、 C 、 D を A の to 、 A の cap 、 A の rev とする
trg = A . to , A . cap , A . rev = B , C , D
rst = A . to , A . cap , A . rev = B , C , D <eos>
1522
src = ( ( B , -1 ) ) からなる 辞書 を A とする
trg = A = { 'start' : - 1 }
rst = A = { <unk> : - 1 } <eos>
1523
src = C から D に 1 を加えた 値 未 満 までの 数 列 の 各 値を B の isleap で フィルタ ー した 列 の リストを A とする
trg = A = list ( filter ( B . isleap , range ( C , D + 1 ) ) )
rst = A = list ( filter ( B , C , range ( D + 1 ) ) ) <eos>
1524
src = B の 平 方 根 の 整数値 を A の root にする
trg = A . root = int ( math . sqrt ( B ) )
rst = A . root = int ( math . sqrt ( B ) ) <eos>
1525
src = D の キー と 値 の集まり の 各要素 を B 、 C とし 、 C が E と 等 しい とき の B の 列 を A とする
trg = A = [ B for B , C in D . items ( ) if C == E ]
rst = A = [ B for B , C in D . items ( ) if C == E ] <eos>
1526
src = A を 1000 だけ 増加 させる
trg = A += 1000
rst = A += 1000 <eos>
1527
src = 入力された 文字列 の 整数値 、 入力された 文字列を 空白 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 の リストを A 、 B とする
trg = A , B = int ( input ( ) ) , list ( map ( int , input ( ) . split ( ) ) )
rst = A , B = int ( input ( ) ) , list ( map ( int , input ( ) . split ( ) ) ) <eos>
1528
src = B . root ( B . id [ C ] ) を A とする
trg = A = B . root ( B . id [ C ] )
rst = A = B . root ( B . id [ C ] ) <eos>
1529
src = A の B 番 目 から 、 つまり 末 尾 までの 2 間隔 による 部分 列 を出力する
trg = print ( A [ B : : 2 ] )
rst = print ( A [ B : : 2 ] ) <eos>
1530
src = 0 から len ( A ) から 2 を 引 いた 値 未 満 までの 数 列 の 各要素 を B とし 、 A [ B ] に A [ B + 1 ] を加えた 値に A の B + 2 番 目 を加えた 値の 列 の 最大 値 を出力する
trg = print ( max ( [ A [ B ] + A [ B + 1 ] + A [ B + 2 ] for B in range ( len ( A ) - 2 ) ] ) )
rst = print ( max ( [ A [ B ] + A [ B + 1 ] + A [ B + 2 ] for B in range ( len ( A ) - 2 ) ] ) ) <eos>
1531
src = B - C に D を加えた 値 から E を 引 いた 値 から 1 を 引 いた 値を D から E を 引 いた 値 で 割 った 商 、 0 の 最大 値を A とする
trg = A = max ( ( B - C + D - E - 1 ) // ( D - E ) , 0 )
rst = A = max ( ( B - C + D - E - 1 ) // ( D - E ) , 0 ) <eos>
1532
src = PathSum 2 ( B , 0 ) を A とする
trg = A = PathSum2 ( B , 0 )
rst = A = <unk> ( B , 0 ) <eos>
1533
src = A の B 番 目 が A の B に 1 を加えた 値 番 目 と 等 しく ない とき 、
trg = if A [ B ] != A [ B + 1 ] :
rst = if A [ B ] != A [ B + 1 ] : <eos>
1534
src = A の 2 番 目 、 A の先頭 を A の先頭 、 A の 2 番 目 とする
trg = A [ 0 ] , A [ 2 ] = A [ 2 ] , A [ 0 ]
rst = A [ 0 ] , A [ 2 ] = A [ 2 ] , A [ 0 ] <eos>
1535
src = A の 末 尾 に B に 8 を加えた 値 を追加する
trg = A . append ( B + 8 )
rst = A . append ( B + 8 ) <eos>
1536
src = KeyError ( A ) エラー となる
trg = raise KeyError ( A )
rst = raise <unk> ( A ) <eos>
1537
src = A かつ B または C の とき D 、 そうでなければ E を出力する
trg = print ( D if ( A and B ) or C else E )
rst = print ( D if A and B or C else E ) <eos>
1538
src = A の位置 C の left から B を 探 して 見つかった 位置 を返す
trg = return A . find ( B , C . left )
rst = return A . find ( B , C . left ) <eos>
1539
src = A の B 番 目 を A の 400 0 から B を 引 いた 値 番 目 にする
trg = A [ 4000 - B ] = A [ B ]
rst = A [ 4000 - B ] = A [ B ] <eos>
1540
src = A の 末 尾 に ( B に C を加えた 値 、 D ) の 組 を追加する
trg = A . append ( ( B + C , D ) )
rst = A . append ( ( B + C , D ) ) <eos>
1541
src = 0 から C 未 満 までの 数 列 の 各要素 を D とし 、 0 から C 未 満 までの 数 列 の 各要素 を B とし 、 、 つまり 空 列 の 列 の 列 を A とする
trg = A = [ [ [ ] for B in range ( C ) ] for D in range ( C ) ]
rst = A = [ [ [ ] for B in range ( C ) ] for D in range ( C ) ] <eos>
1542
src = A の B 番目の 末 尾 に 3 に C を 掛 け た 値に D を加えた 値 を追加する
trg = A [ B ] . append ( 3 * C + D )
rst = A [ B ] . append ( 3 * C + D ) <eos>
1543
src = ネ イ ピ ア 数 と 1 の 排 他 論理 和 を A の C 番目の B 番 目 とする を A の B 番目の C 番 目 にする
trg = A [ B ] [ C ] = A [ C ] [ B ] = e ^ 1
rst = A [ B ] [ C ] = A [ C ] [ B ] = e ^ 1 <eos>
1544
src = D の E 番 目 を F で 分割 した 字句 列 の 各要素 を C とし 、 C の 浮動小数点数 の 列 を 展開 し 、 それぞれ A 、 B とする
trg = A , B = [ float ( C ) for C in D [ E ] . split ( F ) ]
rst = A , B = [ float ( C ) for C in D [ E ] . split ( F ) ] <eos>
1545
src = B の 、 つまり 先頭 から 8 番 目 までの 部分 列 を A とする
trg = A = B [ : 8 ]
rst = A = B [ 0 : 8 ] <eos>
1546
src = A の status の B 番 目 を返す
trg = return A . status [ B ]
rst = return A . status [ B ] <eos>
1547
src = A の キー の集まり の 各要素 を ネ イ ピ ア 数 とし 、 ( 、 つまり ネ イ ピ ア 数 、 A の 、 つまり ネ イ ピ ア 数 番 目 ) の 組 の 列 を A とする
trg = A = [ ( e , A [ e ] ) for e in A . keys ( ) ]
rst = A = [ ( e , A [ e ] ) for e in A . keys ( ) ] <eos>
1548
src = A を B の C から 1 を 引 いた 値 番目の D から 1 を 引 いた 値 番 目 だけ 増加 させる
trg = A += B [ C - 1 ] [ D - 1 ]
rst = A += B [ C - 1 ] [ D - 1 ] <eos>
1549
src = A の B から 1 を 引 いた 値 番目の C 番 目 かつ D の B から 1 を 引 いた 値 番目の C 番 目 が 0 と 等 しい とき 、
trg = if A [ B - 1 ] [ C ] and D [ B - 1 ] [ C ] == 0 :
rst = if A [ B - 1 ] [ C ] and D [ B - 1 ] [ C ] == 0 : <eos>
1550
src = 2000 に A を 掛 け た 値 を出力する
trg = print ( 2000 * A )
rst = print ( 2000 * A ) <eos>
1551
src = B 、 C の 要素を それぞれ 組 にした 列 を 順に A 、 ネ イ ピ ア 数 として 、 繰り返す
trg = for A , e in zip ( B , C ) :
rst = for A , e in zip ( B , C ) : <eos>
1552
src = 0 から C 未 満 までの 数 列 の 各要素 を B とし 、 B の 列 を A の p にする
trg = A . p = [ B for B in range ( C ) ]
rst = A . p = [ B for B in range ( C ) ] <eos>
1553
src = A の pip の先頭 を出力する
trg = print ( A . pip [ 0 ] )
rst = print ( A . pip [ 0 ] ) <eos>
1554
src = 次 は 例外 に関する 条件 がある
trg = try :
rst = <unk> <eos>
1555
src = 0 を A の rank にする
trg = A . rank = 0
rst = A . rank = 0 <eos>
1556
src = A を 1 を B の C 番 目 だけ 左 シフト した 値 と の 論理 和 にする
trg = A |= 1 << B [ C ]
rst = A |= 1 << B [ C ] <eos>
1557
src = A を 5 から B を 引 いた 値に C を 掛 け た 値 だけ 増加 させる
trg = A += ( 5 - B ) * C
rst = A += ( 5 - B ) * C <eos>
1558
src = B の C の LEFT 番 目 を A の B の C の RIGHT 番 目 番目の C の SIBLING 番 目 にする
trg = A [ B [ C . RIGHT ] ] [ C . SIBLING ] = B [ C . LEFT ]
rst = A [ B [ C . RIGHT ] ] [ C . <unk> ] = B [ C . LEFT ] <eos>
1559
src = A の dist に B の 余 弦 を 掛 け た 値に A . rad の 2 乗 から ( A . dist * math . sin ( B ) ) の 2 乗 を 引 いた 値の 1 を 2 で 割 った 値 乗 を加えた 値が C より 大きい とき 、
trg = if A . dist * math . cos ( B ) + ( A . rad ** 2 - ( A . dist * math . sin ( B ) ) ** 2 ) ** ( 1 / 2 ) > C :
rst = if A . dist * math . cos ( B ) + A . rad ** 2 - A . dist ** 2 > ( B . sin ( C ) - 2 ) : <eos>
1560
src = A が 2 より 大きい とき 、
trg = if A > 2 :
rst = if A > 2 : <eos>
1561
src = 13 を B とする
trg = B = 13
rst = B = 13 <eos>
1562
src = Segment ( B . pt 1, C ) を A とする
trg = A = Segment ( B . pt1 , C )
rst = A = Segment ( B . pt1 , C ) <eos>
1563
src = A に ( B に 1 を加えた 値 、 C ) の 組 を追加した 集 ま り
trg = A . add ( ( B + 1 , C ) )
rst = A . add ( ( B + 1 , C ) ) <eos>
1564
src = A 、 dfs ( B - 1, C ) に 1 を加えた 値の 最小 値を A とする
trg = A = min ( A , dfs ( B - 1 , C ) + 1 )
rst = A = min ( A , dfs ( B - 1 , C ) + 1 ) <eos>
1565
src = A の 末 尾 に ( B 、 C 、 D の 整数値 に 3 を 掛 け た 値に E の 整数値 を加えた 値 ) の 組 を追加する
trg = A . append ( ( B , C , int ( D ) * 3 + int ( E ) ) )
rst = A . append ( ( B , C , int ( D ) * 3 + int ( E ) ) ) <eos>
1566
src = A が dist 2 ( B , C ) に 1 e - 9 を加えた 値 より 小さく かつ -1 e - 9 が D より 小さい かどうか を返す
trg = return A < dist2 ( B , C ) + 1e-9 and - 1e-9 < D
rst = return A < dist2 ( B , C ) + 1e-9 and - 1e9 < D <eos>
1567
src = A が 7 より 小さい とき 、
trg = if A < 7 :
rst = if A < 7 : <eos>
1568
src = ( 1 、 5 、 10 、 50 、 100 、 500 ) の 組 を A とする
trg = A = ( 1 , 5 , 10 , 50 , 100 , 500 )
rst = A = ( 1 , 5 , 10 , 50 , 100 , 500 ) <eos>
1569
src = A かつ B の A の 末 尾 番 目 が C の D 番 目 より 小さい 間 、 次 を 繰り返す
trg = while A and B [ A [ - 1 ] ] < C [ D ] :
rst = while A and B [ A [ - 1 ] ] < C [ D ] : <eos>
1570
src = A の B から 1 を 引 いた 値 番目の 0 番 目 が 0 と 等 しい とき 、
trg = if A [ B - 1 ] [ 0 ] == 0 :
rst = if A [ B - 1 ] [ 0 ] == 0 : <eos>
1571
src = A . _ replace ( left = B ) を A とする
trg = A = A . _replace ( left = B )
rst = A = A . _replace ( left = B ) <eos>
1572
src = A を B に C を加えた 値を 2 で 割 った 値 で 割 った 余 り を出力する
trg = print ( A % ( ( B + C ) / 2 ) )
rst = print ( A % ( B + C ) % 2 ) <eos>
1573
src = B に C 、 5 の 最大 値を 掛 け た 値に D に E 、 2 の 最大 値を 掛 け た 値 を加えた 値に 8 を 掛 け た 値を 10 で 割 った 商 を A とする
trg = A = ( B * max ( C , 5 ) + D * max ( E , 2 ) ) * 8 // 10
rst = A = B * max ( C , 5 ) + D * max ( E , 2 ) * 8 // 10 <eos>
1574
src = B の 1 番 目 を A の B の 2 番 目 番 目 にする
trg = A [ B [ 2 ] ] = B [ 1 ]
rst = A [ B [ 2 ] ] = B [ 1 ] <eos>
1575
src = B を 2 だけ 右 シフト する
trg = B >>= 2
rst = B <unk> <unk> <eos>
1576
src = B の キー の集まり の リストを 順に A として 、 繰り返す
trg = for A in list ( B . keys ( ) ) :
rst = for A in list ( B . keys ( ) ) : <eos>
1577
src = A の B 番 目 が C の B に D を加えた 値 番 目 から C の D 番 目 に E の B 番 目 を 掛 け た 値を 引 いた 値を F で 割 った 余 り と 等 しい とき 、
trg = if A [ B ] == ( C [ B + D ] - C [ D ] * E [ B ] ) % F :
rst = if ( A [ B ] == C [ B + D ] - C [ D ] * E [ B ] ) % F : <eos>
1578
src = A の 各要素 に lst を パラメータ として ( 0 ) からなる 列 に accumulate ( B ) のリスト を加えた 値を返す 関数 を適用した 列 の リストを A とする
trg = A = list ( map ( lambda B : [ 0 ] + list ( accumulate ( B ) ) , A ) )
rst = A = list ( map ( lambda B : [ 0 ] + list ( accumulate ( B ) ) , A . lst [ 0 ] ) ) <eos>
1579
src = 11 0000 を A とする
trg = A = 110000
rst = A = 110000 <eos>
1580
src = ネ イ ピ ア 数 を 空白 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 を 展開 し 、 それぞれ A 、 B とする
trg = A , B = map ( int , e . split ( ) )
rst = A , B = map ( int , e . split ( ) ) <eos>
1581
src = B の C 番目の D 番 目 に B の D 番目の E 番 目 を加えた 値を A とする
trg = A = B [ C ] [ D ] + B [ D ] [ E ]
rst = A = B [ C ] [ D ] + B [ D ] [ E ] <eos>
1582
src = A の 文字列 の長さ を出力する
trg = print ( len ( str ( A ) ) )
rst = print ( len ( str ( A ) ) ) <eos>
1583
src = heappush ( A , ( B + e , C , D ) )
trg = heappush ( A , ( B + e , C , D ) )
rst = heappush ( A , ( B + e , C , D ) ) <eos>
1584
src = 0 から 60 に 60 を 掛 け た 値に 24 を 掛 け た 値 未 満 までの 数 列 を 順に A として 、 繰り返す
trg = for A in range ( 60 * 60 * 24 ) :
rst = for A in range ( 60 * 60 * 24 ) : <eos>
1585
src = A が B の f _ keys の B の __ TOP 番 目 と 等 しく ない とき 、
trg = if A != B . f_keys [ B . __TOP ] :
rst = if A != B . f_keys [ B . __FRONT ] : <eos>
1586
src = 逆 順に 入力された 文字列を 空白 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 を ソート した 列 を 展開 し 、 それぞれ A 、 B とする
trg = A , B = sorted ( map ( int , input ( ) . split ( ) ) , reverse = True )
rst = A , B = sorted ( map ( int , input ( ) . split ( ) ) , reverse = True ) <eos>
1587
src = B の 6 番 目 から 、 つまり 末 尾 までの 部分 列 を A とする
trg = A = B [ 6 : ]
rst = A = B [ 6 : ] <eos>
1588
src = A の nodes の A の B と 等 しい 要素 の最初の 位置 に 1 を加えた 値 番 目 を返す
trg = return A . nodes [ A . index ( B ) + 1 ]
rst = return A . nodes [ A . index ( B ) + 1 ] <eos>
1589
src = 関数 read _ line を t を パラメータ として 定義 する
trg = def read_line ( A ) : return t ( input ( ) )
rst = def <unk> ( B ) : return [ t ( input ( ) ) for A in range ( C ) ] <eos>
1590
src = A の 整数値 が B 以下の とき 、
trg = if int ( A ) <= B :
rst = if int ( A ) <= B : <eos>
1591
src = rec ( A ) を返す
trg = return rec ( A )
rst = return rec ( A ) <eos>
1592
src = B の 2 乗 に C の 2 乗 を加えた 値に D の 2 乗 を加えた 値の 平 方 根 を A とする
trg = A = math . sqrt ( B ** 2 + C ** 2 + D ** 2 )
rst = A = math . sqrt ( B ** 2 + C ** 2 + D ** 2 ) <eos>
1593
src = C 、 D の 最大 値 、 C 、 D の 最小 値を A 、 B とする
trg = A , B = max ( C , D ) , min ( C , D )
rst = A , B = max ( C , D ) , min ( C , D ) <eos>
1594
src = ( 0 、 -1 、 0 、 1 ) の 組 を A とする
trg = A = ( 0 , - 1 , 0 , 1 )
rst = A = ( 0 , - 1 , 0 , 1 ) <eos>
1595
src = 0 から 100 0000 未 満 までの 数 列 を 順に A として 、 繰り返す
trg = for A in range ( 1000000 ) :
rst = for A in range ( 1000000 ) : <eos>
1596
src = B . splitlines () を 順に A として 、 繰り返す
trg = for A in B . splitlines ( ) :
rst = for A in B . <unk> ( ) : <eos>
1597
src = A の 末 尾 に stmt _ if ( * B [ 2 : ] ) を追加する
trg = A . append ( stmt_if ( * B [ 2 : ] ) )
rst = A . append ( <unk> ( * B [ 2 : ] ) ) <eos>
1598
src = get _ co ( C , D + 1 ) を 展開 し 、 それぞれ A 、 B とする
trg = A , B = get_co ( C , D + 1 )
rst = A , B = get_co ( C , D + 1 ) <eos>
1599
src = A を B の C 番 目 に 2 を 掛 け た 値 だけ 増加 させる
trg = A += B [ C ] * 2
rst = A += B [ C ] * 2 <eos>
1600
src = sorted _ topological ( B ) を 順に A として 、 繰り返す
trg = for A in sorted_topological ( B ) :
rst = for A in <unk> ( B ) : <eos>
1601
src = A に 200 を 掛 け た 値に B に 300 を 掛 け た 値 を加えた 値に C に 500 を 掛 け た 値 を加えた 値が D と 等 しい とき 、
trg = if A * 200 + B * 300 + C * 500 == D :
rst = if A * 200 + B * 300 + C * 500 == D : <eos>
1602
src = 無限 の 整数 列 の A の B 番 目 番 目 が 1 と 等 しく かつ A の B 番 目 が C 以下の とき 、
trg = if count [ A [ B ] ] == 1 and A [ B ] <= C :
rst = if count [ A [ B ] ] == 1 and A [ B ] <= C : <eos>
1603
src = A の B の C 番 目 番 目 を 1 だけ 増加 させる
trg = A [ B [ C ] ] += 1
rst = A [ B [ C ] ] += 1 <eos>
1604
src = C から B に D を 掛 け た 値を 引 いた 値 から E を 引 いた 値 、 F の G に 1 を加えた 値 番目の 最小 値を A の B 番 目 にする
trg = A [ B ] = min ( C - B * D - E , F [ G + 1 ] )
rst = A [ B ] = min ( C - B * D - E , F [ G + 1 ] ) <eos>
1605
src = 2 に B を 掛 け た 値に 2 に C を 掛 け た 値 を加えた 値を A とする
trg = A = 2 * B + 2 * C
rst = A = 2 * B + 2 * C <eos>
1606
src = A が B から 2 を 引 いた 値 以下の とき 、
trg = if A <= B - 2 :
rst = if A <= B - 2 : <eos>
1607
src = 0 から 8 未 満 までの 数 列 の 各要素 を B とし 、 、 つまり 入力された 文字列 の 列 を A とする
trg = A = [ input ( ) for B in range ( 8 ) ]
rst = A = [ input ( ) for B in range ( 8 ) ] <eos>
1608
src = A の長さ に B の value を 掛 け た 値を返す
trg = return len ( A ) * B . value
rst = return len ( A ) * B . value <eos>
1609
src = D に E を加えた 値の 各要素 に C を適用した 列 の集合 の 各要素 に B を適用した 列 の リストを A とする
trg = A = list ( map ( B , set ( map ( C , D + E ) ) ) )
rst = A = list ( map ( B , set ( C , D + E ) ) ) <eos>
1610
src = os . path の 末 尾 に ( ( 4 、 5 、 6 、 7 、 8 、 9 、 5 、 4 、 3 、 2 ) からなる 列 、 ( 4 、 3 、 2 、 1 、 0 ) からなる 列 ) からなる 列 を追加する
trg = path . append ( [ [ 4 , 5 , 6 , 7 , 8 , 9 , 5 , 4 , 3 , 2 ] , [ 4 , 3 , 2 , 1 , 0 ] ] )
rst = path . append ( [ [ 4 , 5 , 6 , 7 , 8 , 9 , 5 , 4 , 3 , 2 ] , [ 3 , 2 , 1 , 0 ] ] ) <eos>
1611
src = A から 1 を 引 いた 値を 1 だけ 右 シフト した 値を A とする
trg = A = ( A - 1 ) >> 1
rst = A = ( A - 1 ) >> 1 <eos>
1612
src = A の 末 尾 に B に C に 1 を加えた 値の 文字列 を加えた 値 を追加する
trg = A . append ( B + str ( C + 1 ) )
rst = A . append ( B + str ( C + 1 ) ) <eos>
1613
src = B が 2 と 等 しい とき 2 、 そうでなければ 2 の B から 2 を 引 いた 値 乗 を A とする
trg = A = 2 if B == 2 else 2 ** ( B - 2 )
rst = A = 2 if B == 2 else ( 2 ** B - 2 ) <eos>
1614
src = ( 1 、 4 、 1 、 4 、 1 、 2 、 1 、 2 ) の 組 を A とする
trg = A = ( 1 , 4 , 1 , 4 , 1 , 2 , 1 , 2 )
rst = A = ( 1 , 4 , 1 , 4 , 1 , 2 , 1 , 2 ) <eos>
1615
src = A の nskip が 、 つまり 未 定 値 と 等 しく ない とき 、
trg = if A . nskip is None :
rst = if A . nskip is None : <eos>
1616
src = ( ( ( 0 ) からなる 列 の 0 から 7 未 満 までの 数 列 の 各要素 を B とし 、 7 の 列 回 分 の 列 ) からなる 列 ) からなる 列 を A とする
trg = A = [ [ [ 0 ] * [ 7 for B in range ( 7 ) ] ] ]
rst = A = [ [ 0 ] * [ 7 for B in range ( 7 ) ] ] <eos>
1617
src = B に C を 掛 け た 値に D の 文字列 を加えた 値に B に C を 掛 け た 値 を加えた 値の 整数値 を A とする
trg = A = int ( B * C + str ( D ) + B * C )
rst = A = int ( B * C + str ( D ) + B * C ) <eos>
1618
src = A の B 番目の C に 1 を加えた 値 番 目 に D を加えた 値を A の B に 1 を加えた 値 番目の C に 1 を加えた 値 番 目 にする
trg = A [ B + 1 ] [ C + 1 ] = A [ B ] [ C + 1 ] + D
rst = A [ B + 1 ] [ C + 1 ] = A [ B ] [ C + 1 ] + D <eos>
1619
src = C が D と 等 しい かどうか に [MASK] を加えた 値を A の B 番 目 にする
trg = A [ B ] = + ( C == D )
rst = A [ B ] = + ( C == D ) <eos>
1620
src = os . path の 間 、 次 を 繰り返す
trg = while path :
rst = while path : <eos>
1621
src = 2001 を A とする
trg = A = 2001
rst = A = 2001 <eos>
1622
src = A を B の bit の C 番 目 だけ 増加 させる
trg = A += B . bit [ C ]
rst = A += B . bit [ C ] <eos>
1623
src = HeavyLightDecomposition ( B , C ) を A の hld にする
trg = A . hld = HeavyLightDecomposition ( B , C )
rst = A . hld = <unk> ( B , C ) <eos>
1624
src = A の -1 番 目 から A の 0 番 目 を 引 いた 値に 1 を加えた 値 から B の 、 つまり 先頭 から C から 1 を 引 いた 値 までの 部分 列 の 総 和 を 引 いた 値 を出力する
trg = print ( ( A [ - 1 ] - A [ 0 ] + 1 ) - sum ( B [ : C - 1 ] ) )
rst = print ( A [ - 1 ] - A [ 0 ] + 1 - sum ( B [ : C - 1 ] ) ) <eos>
1625
src = A の B 番目の C 番 目 に A の D 番目の E 番 目 を加えた 値 から A の B 番目の E 番 目 を 引 いた 値 から A の D 番目の C 番 目 を 引 いた 値を返す
trg = return A [ B ] [ C ] + A [ D ] [ E ] - A [ B ] [ E ] - A [ D ] [ C ]
rst = return A [ B ] [ C ] + A [ D ] [ E ] - A [ B ] [ E ] - A [ F - D ] [ C ] <eos>
1626
src = A の B 番目の 総 和 を A の B 番目の C 番 目 にする
trg = A [ B ] [ C ] = ( sum ( A [ B ] ) )
rst = A [ B ] [ C ] = sum ( A [ B ] ) <eos>
1627
src = 空白 文字 を 間 に 入れ て B の 各要素 を A とし 、 A の 0 番目の 列 を 連結 した 文字列 を出力する
trg = print ( ' ' . join ( [ A [ 0 ] for A in B ] ) )
rst = print ( ' ' . join ( [ A [ 0 ] for A in B ] ) ) <eos>
1628
src = 3 から 1 に B を 1 だけ 右 シフト した 値 を加えた 値 未 満 までの 2 間隔 の 数 列 を 順に A として 、 繰り返す
trg = for A in range ( 3 , 1 + ( B >> 1 ) , 2 ) :
rst = for A in range ( 3 , 1 + ( B >> 1 ) , 2 ) : <eos>
1629
src = 0 が A 以下 かつ B が C 以下の 間 、 次 を 繰り返す
trg = while 0 <= A and B <= C :
rst = while 0 <= A and B <= C : <eos>
1630
src = - sys の maxsize を A とする
trg = A = - sys . maxsize
rst = A = - sys . maxsize <eos>
1631
src = A の edge の B 番目の C 番目の 1 番 目 を D だけ 減少 させる
trg = A . edge [ B ] [ C ] [ 1 ] -= D
rst = A . edge [ B ] [ C ] [ 1 ] -= D <eos>
1632
src = A の 末 尾 に ( B 、 B に C を加えた 値 、 D ) の 組 を追加する
trg = A . append ( ( B , B + C , D ) )
rst = A . append ( ( B , B + C , D ) ) <eos>
1633
src = B から 1 を 引 いた 値 、 A . query ( B -1 ) に B を加えた 値を 追加 して A を 更新 する
trg = A . update ( B - 1 , A . query ( B - 1 ) + B )
rst = A . update ( B - 1 , A . query ( B - 1 ) + B ) <eos>
1634
src = 1 から 11 未 満 までの 数 列 の集合 から B の集合 を 引 いた 値の リストを A とする
trg = A = list ( set ( ( range ( 1 , 11 ) ) ) - set ( B ) )
rst = A = list ( set ( range ( 1 , 11 ) ) - B ) <eos>
1635
src = A の長さ が B の長さ より 大きく または A の長さ が B の長さ と 等 しく かつ A が B より 大きい とき 、
trg = if len ( A ) > len ( B ) or ( len ( A ) == len ( B ) and A > B ) :
rst = if len ( A ) > len ( B ) or ( len ( A ) == B and len ( A ) > B ) : <eos>
1636
src = ( A の hldid の B 番 目 、 A の hldid の B 番 目 に A の size の B 番 目 を加えた 値 ) の 組 を返す
trg = return ( A . hldid [ B ] , A . hldid [ B ] + A . size [ B ] )
rst = return ( A . hldid [ B ] , A . hldid [ B ] + A . size [ B ] ) <eos>
1637
src = B を A の cursor の prev の next にする
trg = A . cursor . prev . next = B
rst = A . cursor . prev . next = B <eos>
1638
src = A の B 番目の B に C を加えた 値 番 目 を 1 を D だけ 左 シフト した 値 と の 論理 和 にする
trg = A [ B ] [ B + C ] |= 1 << D
rst = A [ B ] [ B + C ] |= 1 << D <eos>
1639
src = A が B の先頭 より 大きい とき 、
trg = if A > B [ 0 ] :
rst = if A > B [ 0 ] : <eos>
1640
src = A の B 番 目 を C の D 番 目 倍 にする
trg = A [ B ] *= C [ D ]
rst = A [ B ] *= C [ D ] <eos>
1641
src = ( B [ 0 ] の 文字列 に B [ 1 ] の 文字列 を加えた 値の 整数値 、 B [ 1 ] の 文字列 に B [ 0 ] の 文字列 を加えた 値の 整数値 、 B [ 0 ] の 文字列 に B [ 2 ] の 文字列 を加えた 値の 整数値 、 B [ 2 ] の 文字列 に B [ 0 ] の 文字列 を加えた 値の 整数値 、 B [ 3 ] の 文字列 に B [ 0 ]
trg = A = sorted ( [ int ( str ( B [ 0 ] ) + str ( B [ 1 ] ) ) , int ( str ( B [ 1 ] ) + str ( B [ 0 ] ) ) , int ( str ( B [ 0 ] ) + str ( B [ 2 ] ) ) , int ( str ( B [ 2 ] ) + str ( B [ 0 ] ) )
rst = A = int ( str ( B [ 0 ] ) + str ( B [ 1 ] ) , int ( B [ 1 ] ) + str ( B [ 0 ] ) , int ( B [ 2 ] + B [ 0 ] ) , int
1642
src = 1 を A の B と 1 を C だけ 左 シフト した 値の 論理 和 番 目 にする
trg = A [ B | ( 1 << C ) ] = 1
rst = A [ B | ( 1 << C ) ] = 1 <eos>
1643
src = ( < __ main __ . Cammaobjectat 0 x 10 a 1 dbb 80 > ) の集合 を ネ イ ピ ア 数 とする
trg = e = { A , A [ : : - 1 ] }
rst = e = { [ ( B , C , D ) for B in range ( 1 , 14 ) ] } <eos>
1644
src = A を B の 総 和 だけ 増加 させる
trg = A += sum ( B )
rst = A += sum ( B ) <eos>
1645
src = B から 1 を 引 いた 値に 30 を 掛 け た 値に C を加えた 値 から 1 を 引 いた 値を A とする
trg = A = ( B - 1 ) * 30 + C - 1
rst = A = ( B - 1 ) * 30 + C - 1 <eos>
1646
src = os . path の 末 尾 に A の B 番 目 を追加する
trg = path . append ( A [ B ] )
rst = path . append ( A [ B ] ) <eos>
1647
src = A の先頭 の 整数値 を 2 で 割 った 商 に 1 を加えた 値を返す
trg = return int ( A [ 0 ] ) // 2 + 1
rst = return int ( A [ 0 ] ) // 2 + 1 <eos>
1648
src = A かつ A の 0 番 目 が B と 等 しく なく または A の 1 番 目 が B と 等 しく ない 間 、 次 を 繰り返す
trg = while A and ( A [ 0 ] is B or A [ 1 ] is B ) :
rst = while A and ( A [ 0 ] != B or A [ 1 ] != B ) : <eos>
1649
src = A . dump ( int ( B ) , int ( C ) )
trg = A . dump ( int ( B ) , int ( C ) )
rst = A . dump ( int ( B ) , int ( C ) ) <eos>
1650
src = A が 、 つまり 無限大 と 等 しく ない とき 、
trg = if A != inf :
rst = if A != inf : <eos>
1651
src = A が 、 つまり 未 定 値 と 等 しく かつ B が C の A 番目の 1 番 目 と 等 しい 間 、 次 を 繰り返す
trg = while A is not None and B == C [ A ] [ 1 ] :
rst = while A is not None and B == C [ A ] [ 1 ] : <eos>
1652
src = 0 から E 未 満 までの 数 列 の 各要素 を C とし 、 B の C 番 目 が D の C 番 目 と 等 しく ない かどうか の 列 の 総 和 を A とする
trg = A = sum ( [ B [ C ] != D [ C ] for C in range ( E ) ] )
rst = A = sum ( [ ( B [ C ] != D [ C ] ) for C in range ( E ) ] ) <eos>
1653
src = A の 末 尾 に (1) からなる 列 に ( 0 ) からなる 列 の B に (1) からなる 列 を加えた 値 回 分 の 列 を加えた 値 を追加する
trg = A . append ( [ 1 ] + [ 0 ] * B + [ 1 ] )
rst = A . append ( [ 1 ] + [ 0 ] * ( B + 1 ) ) <eos>
1654
src = A を B の長さ で 割 った 値の 平 方 根 を A とする
trg = A = math . sqrt ( A / len ( B ) )
rst = A = sqrt ( A / len ( B ) ) <eos>
1655
src = 2 に A を 掛 け た 値 から B を 引 いた 値の 絶対 値が 1 以下 かどうか を返す
trg = return abs ( 2 * A - B ) <= 1
rst = return abs ( 2 * A - B ) <= 1 <eos>
1656
src = A の B から C を 引 いた 値 番 目 に D を加えた 値 、 A の B 番目の 最小 値を A の B 番 目 にする
trg = A [ B ] = min ( A [ B - C ] + D , A [ B ] )
rst = A [ B ] = min ( A [ B - C ] + D , A [ B ] ) <eos>
1657
src = C を A の f _ key _ to _ val の B 番 目 にする
trg = A . f_key_to_val [ B ] = C
rst = A . f_val_to_key [ B ] = C <eos>
1658
src = 2 を 底 とする B の 対 数 を A とする
trg = A = log2 ( B )
rst = A = math . log ( B , 2 ) <eos>
1659
src = B の 5 番 目 から 7 番 目 までの 部分 列 を A とする
trg = A = B [ 5 : 7 ]
rst = A = B [ 5 : 7 ] <eos>
1660
src = B に 60 を 掛 け た 値に C を加えた 値を A の t にする
trg = A . t = B * 60 + C
rst = A . t = B * 60 + C <eos>
1661
src = 10 の 9 乗 に 7 を加えた 値を A とする
trg = A = 10 ** 9 + 7
rst = A = 10 ** 9 + 7 <eos>
1662
src = B を A の num にする
trg = A . num = B
rst = A . num = B <eos>
1663
src = B に 1 を加えた 値 から C から 2 を 引 いた 値 未 満 までの -1 間隔 の 数 列 を 順に A として 、 繰り返す
trg = for A in range ( B + 1 , C - 2 , - 1 ) :
rst = for A in range ( B + 1 , C - 2 , - 1 ) : <eos>
1664
src = 入力された 文字列 の 整数値 を 100 で 割 った 商 を A とする
trg = A = int ( input ( ) ) // 100
rst = A = int ( input ( ) ) // 100 <eos>
1665
src = ( 0 ) からなる 列 の 5 1 回 分 の 列 を ネ イ ピ ア 数 とする
trg = e = [ 0 ] * 51
rst = e = [ 0 ] * 51 <eos>
1666
src = A の 文字列 を出力する
trg = print ( str ( A ) )
rst = print ( str ( A ) ) <eos>
1667
src = ( 0 、 2 ) からなる 列 を 順に A として 、 繰り返す
trg = for A in [ 0 , 2 ] :
rst = for A in [ 0 , 2 ] : <eos>
1668
src = 空文字列 を 間 に 入れ て A の B 番 目 から C に 1 を加えた 値 までの 部分 列 を 連結 した 文字列 を出力する
trg = print ( '' . join ( A [ B : C + 1 ] ) )
rst = print ( '' . join ( A [ B : C + 1 ] ) ) <eos>
1669
src = B から C に D を 掛 け た 値を 引 いた 値を E から C を 引 いた 値 で 割 った 商 、 F 、 B を E で 割 った 商 の 最小 値を A とする
trg = A = min ( ( B - C * D ) // ( E - C ) , F , B // E )
rst = A = min ( ( B - C * D ) // ( E - C ) , ( F // B , E ) ) <eos>
1670
src = C を A の B の先頭 番 目 にする
trg = A [ B [ 0 ] ] = C
rst = A [ B [ 0 ] ] = C <eos>
1671
src = 1989 に B を加えた 値 から 1 を 引 いた 値を A とする
trg = A = 1989 + B - 1
rst = A = 1989 + B - 1 <eos>
1672
src = A に C の先頭 を加えた 値 、 B に C の 1 番 目 を加えた 値を A 、 B とする
trg = A , B = A + C [ 0 ] , B + C [ 1 ]
rst = A , B = A + C [ 0 ] , B + C [ 1 ] <eos>
1673
src = A の 末 尾 に func [ symbol ] ( B , C ) を追加する
trg = A . append ( func[symbol] ( B , C ) )
rst = A . append ( <unk> ( B , C ) ) <eos>
1674
src = A の B に 1 を加えた 値 番目の C と D の 論理 和 番 目 、 A の B 番目の E 番 目 に 1 を加えた 値の 最大 値を A の B に 1 を加えた 値 番目の C と D の 論理 和 番 目 にする
trg = A [ B + 1 ] [ C | D ] = max ( A [ B + 1 ] [ C | D ] , A [ B ] [ E ] + 1 )
rst = A [ B + 1 ] [ C + D ] [ D ] = max ( A [ B + 1 ] [ C | D ] , A [ B ] [ E ] + 1 ) <eos>
1675
src = ネ イ ピ ア 数の 、 つまり 先頭 から 、 つまり 末 尾 までの 2 間隔 による 部分 列 、 ネ イ ピ ア 数の 1 番 目 から 、 つまり 末 尾 までの 2 間隔 による 部分 列 の 要素を それぞれ 組 にした 列 を 順に A 、 B として 、 繰り返す
trg = for A , B in zip ( e [ : : 2 ] , e [ 1 : : 2 ] ) :
rst = for A , B in zip ( e [ : : 2 ] , e [ 1 : : 2 ] ) : <eos>
1676
src = 0 を A とする
trg = A = 0
rst = A = 0 <eos>
1677
src = A を 書式 として B で 整 形 した 文字列 に 空白 文字 を 間 に 入れ て prime _ factor ( B ) の 各要素 に 整数 を適用した 列 を 連結 した 文字列 を加えた 値 を出力する
trg = print ( A . format ( B ) + ' ' . join ( map ( str , prime_factor ( B ) ) ) )
rst = print ( A . format ( B ) + ' ' . join ( map ( str , prime_factor ( B ) ) ) ) <eos>
1678
src = A の B から 1 を 引 いた 値 番目の C 番 目 が 0 と 等 しい とき 、
trg = if A [ B - 1 ] [ C ] == 0 :
rst = if A [ B - 1 ] [ C ] == 0 : <eos>
1679
src = 0 から 、 つまり ネ イ ピ ア 数 から B を 引 いた 値を 2 で 割 った 商 未 満 までの 数 列 を 順に A として 、 繰り返す
trg = for A in range ( ( e - B ) // 2 ) :
rst = for A in range ( ( e - B ) // 2 ) : <eos>
1680
src = A の 0 に B の head の next を挿入する
trg = A . insert ( 0 , B . head . next )
rst = A . insert ( 0 , B . head . next ) <eos>
1681
src = A . dinic ( B , C ) を A の maxflow にする
trg = A . maxflow = A . dinic ( B , C )
rst = A . <unk> = A . dinic ( B , C ) <eos>
1682
src = calc () を A とする
trg = A = calc ( )
rst = A = calc ( ) <eos>
1683
src = ( 0 ) からなる 列 の 1 28 回 分 の 列 、 ( 0 ) からなる 列 の 1 28 回 分 の 列 を A 、 B とする
trg = A , B = [ 0 ] * 128 , [ 0 ] * 128
rst = A , B = [ 0 ] * 128 , [ 0 ] * 100003 <eos>
1684
src = A の B 番目の right が -1 と 等 しく ない とき 、
trg = if A [ B ] . right != - 1 :
rst = if A [ B ] . right != - 1 : <eos>
1685
src = A [ 0 ] + A [ 1 ] * 5 に A [ 2 ] * 10 を加えた 値に A [ 3 ] に 50 を 掛 け た 値 を加えた 値に A の 4 番 目 に 100 を 掛 け た 値 を加えた 値に A の 5 番 目 に 500 を 掛 け た 値 を加えた 値が 1000 以上の とき 、
trg = if A [ 0 ] + A [ 1 ] * 5 + A [ 2 ] * 10 + A [ 3 ] * 50 + A [ 4 ] * 100 + A [ 5 ] * 500 >= 1000 :
rst = if A [ 0 ] + A [ 1 ] * 5 + A [ 2 ] * 10 + A [ 3 ] * 50 + A [ 4 ] >= 1000 * 500 : <eos>
1686
src = walk _ preorder ( B , C ) を A とする
trg = A = walk_preorder ( B , C )
rst = A = <unk> ( B , C ) <eos>
1687
src = A . area () を出力する
trg = print ( A . area ( ) )
rst = print ( A . area ( ) ) <eos>
1688
src = ( ( A , B ) 、 ( C , D ) 、 ( E , F ) ) からなる 辞書 の G 番目の とき 、
trg = if { 'J' : B , 'O' : D , 'I' : F } [ G ] :
rst = if { <unk> : A , <unk> : 0 , <unk> : E , <unk> : G ] : <eos>
1689
src = ( B に 1 を加えた 値 ) からなる 列 の 2 回 分 の 列 を A とする
trg = A = [ B + 1 ] * 2
rst = A = [ B + 1 ] * 2 <eos>
1690
src = add ( A , B [ C ] ) を A とする
trg = A = add ( A , B [ C ] )
rst = A = add ( A , B [ C ] ) <eos>
1691
src = A が 2 以上 かどうか の 整数値 に 3 から A に 1 を加えた 値 未 満 までの 2 間隔 の 数 列 の 各要素 を C とし 、 B の C 番目の 列 の 総 和 を加えた 値を 無限 の 整数 列 とする
trg = count = int ( A >= 2 ) + sum ( [ B [ C ] for C in range ( 3 , A + 1 , 2 ) ] )
rst = count = ( A >= 2 ) + sum ( [ B [ C ] [ B [ C ] for C in range ( int ( A ) + 1 , 2 ) ] ) <eos>
1692
src = A の B 番目の 末 尾 に ( 、 つまり ネ イ ピ ア 数 、 C ) の 組 を追加する
trg = A [ B ] . append ( ( e , C ) )
rst = A [ B ] . append ( ( e , C ) ) <eos>
1693
src = B に C を 掛 け た 値に D に E を 掛 け た 値 を加えた 値に 0 . 8 を 掛 け た 値を A とする
trg = A = ( B * C + D * E ) * 0.8
rst = A = ( B * C + D * E ) * 0.8 <eos>
1694
src = A の B 番目の C 番 目 が D と 等 しい とき 、
trg = if A [ B ] [ C ] == D :
rst = if A [ B ] [ C ] == D : <eos>
1695
src = A . delete ( int ( B [ 7 : ] ) )
trg = A . delete ( int ( B [ 7 : ] ) )
rst = A . delete ( int ( B [ 7 : ] ) ) <eos>
1696
src = B から 読み 込 んだ 一行 の 浮動小数点数 を A とする
trg = A = float ( B . readline ( ) )
rst = A = float ( B . readline ( ) ) <eos>
1697
src = pushback ( A , B [ 1 ] , B [ 2 ] ) を A とする
trg = A = pushback ( A , B [ 1 ] , B [ 2 ] )
rst = A = <unk> ( A , B [ 1 ] , B [ 2 ] ) <eos>
1698
src = 0 を A の height とする を A の depth にする
trg = A . depth = A . height = 0
rst = A . depth = A . height = 0 <eos>
1699
src = 100 0000 を返す
trg = return 1000000
rst = return 1000000 <eos>
1700
src = ( 4 、 A の B の 2 番 目 番 目 、 A の B の 3 番 目 番 目 ) からなる 列 を返す
trg = return [ 4 , A [ B [ 2 ] ] , A [ B [ 3 ] ] ]
rst = return [ 4 , A [ B [ 2 ] ] , A [ B [ 3 ] ] ] <eos>
1701
src = 入力された 文字列 の 整数値 を A の 4 番 目 にする
trg = A [ 4 ] = int ( input ( ) )
rst = A [ 4 ] = int ( input ( ) ) <eos>
1702
src = B の 各要素 を A とし 、 A が 0 と 等 しい かどうか の 列 が 全て が 真 の とき 、
trg = if all ( [ A == 0 for A in B ] ) :
rst = if all ( [ A == 0 for A in B ] ) : <eos>
1703
src = A . add _ edge ( 0 , B + 1, 1, 0 )
trg = A . add_edge ( 0 , B + 1 , 1 , 0 )
rst = A . add_edge ( 0 , B + 1 , 1 , 0 ) <eos>
1704
src = simulate () を A とする
trg = A = simulate ( )
rst = A = <unk> ( ) <eos>
1705
src = ( A 、 B から C に A を 掛 け た 値を 引 いた 値 ) の 組 を返す
trg = return ( A , ( B - C * A ) )
rst = return ( A , B - C * A ) <eos>
1706
src = D を E で 割 った 値 、 F の real に G の real を加えた 値を 2 で 割 った 値 、 F の imag に G の imag を加えた 値を 2 で 割 った 値を A 、 B 、 C とする
trg = A , B , C = D / E , ( F . real + G . real ) / 2 , ( F . imag + G . imag ) / 2
rst = A , B , C = D / E , F . real + G . real / 2 , ( F . imag + G ) / 2 <eos>
1707
src = paint ( A , B + 3 , C ) を A とする
trg = A = paint ( A , B + 3 , C )
rst = A = paint ( A , B + 3 , C ) <eos>
1708
src = A を B の data の C から 1 を 引 いた 値 番 目 だけ 増加 させる
trg = A += B . data [ C - 1 ]
rst = A += B . data [ C - 1 ] <eos>
1709
src = A の B 番 目 を 英 大文字 に変換し た 文字列を A の B 番 目 にする
trg = A [ B ] = A [ B ] . upper ( )
rst = A [ B ] = A [ B ] . upper ( ) <eos>
1710
src = D の mp の C 番目の B 番 目 を A の 4 から B を 引 いた 値 番目の C 番 目 にする
trg = A [ 4 - B ] [ C ] = D . mp [ C ] [ B ]
rst = A . 4 [ B - C ] [ C ] = D . mp [ C ] [ B ] <eos>
1711
src = 3 に B を 掛 け た 値を A とする
trg = A = 3 * B
rst = A = 3 * B <eos>
1712
src = A の B 番 目 に C に D を 掛 け た 値 を加えた 値に 1 を加えた 値が E の長さ より 大きい とき 、
trg = if A [ B ] + C * D + 1 > len ( E ) :
rst = if A [ B ] + C * D + 1 > len ( E ) : <eos>
1713
src = bubble _ sort ( A , B ) を出力する
trg = print ( bubble_sort ( A , B ) )
rst = print ( bubble_sort ( A , B ) ) <eos>
1714
src = B を 1000 で 割 った 商 を A の 0 番 目 にする
trg = A [ 0 ] = B // 1000
rst = A [ 0 ] = B // 1000 <eos>
1715
src = A の 、 つまり 先頭 から B 番 目 までの 部分 列 に A の B 番 目 から e 番 目 までの 部分 列 を 反 転 した 列 のリスト を加えた 値に A の 、 つまり ネ イ ピ ア 数 番 目 から 、 つまり 末 尾 までの 部分 列 を加えた 値を A とする
trg = A = A [ : B ] + list ( reversed ( A [ B : e ] ) ) + A [ e : ]
rst = A = A [ : B ] + list ( reversed ( A [ B : e ] ) ) + A [ e : ] <eos>
1716
src = A から B を 引 いた 値が 1 80 以下の とき 、
trg = if A - B <= 180 :
rst = if A - B <= 180 : <eos>
1717
src = A . roll ( B . WEST )
trg = A . roll ( B . WEST )
rst = A . roll ( B . <unk> ) <eos>
1718
src = 12 0 に 60 を 掛 け た 値を A とする
trg = A = 120 * 60
rst = A = 120 * 60 <eos>
1719
src = calc _ hash ( A , B , C )
trg = calc_hash ( A , B , C )
rst = calc_hash ( A , B , C ) <eos>
1720
src = A . cross ( B , C ) が D の epsilon より 大きい とき 、
trg = if A . cross ( B , C ) > D . epsilon :
rst = if A . cross ( B , C ) > D . epsilon : <eos>
1721
src = enumerate _ dice ( A ) を 順に ネ イ ピ ア 数 として 、 繰り返す
trg = for e in enumerate_dice ( A ) :
rst = for e in <unk> ( A ) : <eos>
1722
src = G の H から 1 を 引 いた 値 番目の 各要素 を A 、 D 、 C 、 F とし 、 A が B 以下 かどうか が C 以下 かつ D が E 以下 かどうか が F 以下 かどうか の 列 が 少なくとも ひとつ は 真 の とき 、
trg = if any ( [ A <= B <= C and D <= E <= F for A , D , C , F in G [ H - 1 ] ] ) :
rst = if any ( [ A <= B <= C for A , D , C , F in G [ H - 1 ] ] ) : <eos>
1723
src = A . heappush ( B , ( C [ 1 ] , C [ 0 ] ) )
trg = A . heappush ( B , ( C [ 1 ] , C [ 0 ] ) )
rst = A . heappush ( B , ( C [ 1 ] , C [ 0 ] ) ) <eos>
1724
src = A が ( B 、 C ) からなる 列 に含まれる 間 、 次 を 繰り返す
trg = while A in [ B , C ] :
rst = while A in [ B , C ] : <eos>
1725
src = A . root . in _ order _ search ()
trg = A . root . in_order_search ( )
rst = A . root . <unk> ( ) <eos>
1726
src = A から B を 引 いた 値が C より 小さい かどうか が A に B を加えた 値 より 小さい かどうか を返す
trg = return A - B < C < A + B
rst = return A - B < C < A + B <eos>
1727
src = closest _ part 1 ( B [ : C ] , C ) 、 closest _ part 1 ( B [ C : ] , D - C ) の 最小 値を A とする
trg = A = min ( closest_part1 ( B [ : C ] , C ) , closest_part1 ( B [ C : ] , D - C ) )
rst = A = min ( calc_area ( B [ : C ] , C ) , <unk> ( B [ C : ] , D - C ) ) <eos>
1728
src = A . bst . put ( B , C )
trg = A . bst . put ( B , C )
rst = A . bst . put ( B , C ) <eos>
1729
src = A の _ size を A の size にする
trg = A . size = A . _size
rst = A . size = A . _size_ <eos>
1730
src = 0 を A の 3 番 目 にする
trg = A [ 3 ] = 0
rst = A [ 3 ] = 0 <eos>
1731
src = A を B 倍 にする
trg = A *= B
rst = A *= B <eos>
1732
src = B の ms の C 番 目 を A とする
trg = A = B . ms [ C ]
rst = A = B . ms [ C ] <eos>
1733
src = ( A 、 B ) からなる 列 を返す
trg = return [ A , B ]
rst = return [ A , B ] <eos>
1734
src = compute _ height ( A , 0 )
trg = compute_height ( A , 0 )
rst = compute_depth ( A , 0 ) <eos>
1735
src = A * 100 に ( 100 - B ) を 掛 け た 値を 100 で 割 った 値を C で 割 った 値の 整数値 を出力する
trg = print ( int ( A * 100 * ( 100 - B ) / 100 / C ) )
rst = print ( int ( A * ( 100 - B ) / 100 / C ) ) <eos>
1736
src = A の 1 番 目 を B の C から 1 を 引 いた 値 番 目 だけ 増加 させる
trg = A [ 1 ] += B [ C - 1 ]
rst = A [ 1 ] += B [ C - 1 ] <eos>
1737
src = A と 1 を 5 に B を 掛 け た 値に C を加えた 値 だけ 左 シフト した 値の 論理 積 の とき 、
trg = if A & ( 1 << ( 5 * B + C ) ) :
rst = if A & ( 1 << ( 5 * B + C ) ) : <eos>
1738
src = ( B の 末 尾 、 B の -2 番 目 、 B の -3 番 目 ) からなる 列 の 各要素 を A とし 、 A を出力する の 列
trg = [ print ( A ) for A in [ B [ - 1 ] , B [ - 2 ] , B [ - 3 ] ] ]
rst = [ print ( A ) for A in [ B [ - 1 ] , B [ - 2 ] , B [ - 3 ] ] <eos>
1739
src = A の 総 和 が B と 等 しい かどうか を返す
trg = return sum ( A ) == B
rst = return sum ( A ) == B <eos>
1740
src = A の e の B 番目の A . e の C [ B ] 番目の D の B 番 目 番目の rev 番目の cap を E だけ 増加 させる
trg = A . e [ B ] [ A . e [ C [ B ] ] [ D [ B ] ] . rev ] . cap += E
rst = A . e [ B ] [ A . e [ C [ B ] ] [ D [ B ] ] . rev ] . cap += E <eos>
1741
src = A を 36 6 だけ 増加 させる
trg = A += 366
rst = A += <unk> <eos>
1742
src = A に B の A 番 目 を加えた 値を C で 割 った 余 り を A とする
trg = A = ( A + B [ A ] ) % C
rst = A = ( A + B [ A ] ) % C <eos>
1743
src = remove ( A + B , C + D )
trg = remove ( A + B , C + D )
rst = remove ( A + B , C + D ) <eos>
1744
src = B の C の D に 1 を加えた 値 番 目 に E を加えた 値を F で 割 った 余 り 番 目 を A とする
trg = A = B [ ( C [ D + 1 ] + E ) % F ]
rst = A = B [ ( C [ D + 1 ] + E ) % F ] <eos>
1745
src = ( 3 、 A の B の 2 番 目 番 目 、 A の B の 3 番 目 番 目 、 B の 4 番目の 整数値 ) からなる 列 を返す
trg = return [ 3 , A [ B [ 2 ] ] , A [ B [ 3 ] ] , int ( B [ 4 ] ) ]
rst = return [ 3 , A [ B [ 2 ] ] , int ( A [ B [ 3 ] ] ) , int ( B [ 4 ] ) ] <eos>
1746
src = B の先頭 から C を 探 して 見つかった 位置 を A とする
trg = A = B . find ( C )
rst = A = B . find ( C ) <eos>
1747
src = 入力された 文字列を B で 分割 した 字句 列 の 各要素 に 浮動小数点数 を適用した 列 の リストを A とする
trg = A = list ( map ( float , input ( ) . split ( B ) ) )
rst = A = list ( map ( float , input ( ) . split ( B ) ) ) <eos>
1748
src = B の -2 番 目 に 1 を加えた 値を A の -2 番 目 にする
trg = A [ - 2 ] = B [ - 2 ] + 1
rst = A [ - 2 ] = B [ - 2 ] + 1 <eos>
1749
src = A から B を 引 いた 値の 絶対 値が C より 小さく かつ D から E を 引 いた 値の 絶対 値が C より 小さい とき 、
trg = if abs ( A - B ) < C and abs ( D - E ) < C :
rst = if abs ( A - B ) < C and abs ( D - E ) < C : <eos>
1750
src = A の sizes の B 番 目 が A の sizes の C 番 目 より 大きい とき 、
trg = if A . sizes [ B ] > A . sizes [ C ] :
rst = if A . <unk> [ B ] > A . <unk> [ C ] : <eos>
1751
src = 1 から B に 1 を加えた 値 未 満 までの 数 列 の 各要素 を A とし 、 C の A 番 目 が 0 と 等 しい とき の A を出力する の 列
trg = [ print ( A ) for A in range ( 1 , B + 1 ) if C [ A ] == 0 ]
rst = [ print ( A ) for A in range ( 1 , B + 1 ) if C [ A ] == 0 ] <eos>
1752
src = B かつ C の D に 1 を加えた 値 番目の とき E 、 そうでなければ 0 を A とする
trg = A = E if B and C [ D + 1 ] else 0
rst = A = E if B and C [ D + 1 ] else 0 <eos>
1753
src = D に E を加えた 値を C とする を A の B 番 目 にする
trg = A [ B ] = C = D + E
rst = A [ B ] = C = D + E <eos>
1754
src = ( B の C に 1 を加えた 値 番 目 、 D の C に 1 を加えた 値 番 目 ) の 組 を A とする
trg = A = ( B [ C + 1 ] , D [ C + 1 ] )
rst = A = ( B [ C + 1 ] , D [ C + 1 ] ) <eos>
1755
src = A の B 番 目 に C に D を 掛 け た 値 を加えた 値を A の B 番 目 にする
trg = A [ B ] = A [ B ] + C * D
rst = A [ B ] = A [ B ] + C * D <eos>
1756
src = trans ( A ) を出力する
trg = print ( trans ( A ) )
rst = print ( <unk> ( A ) ) <eos>
1757
src = A の data を 1 を B だけ 左 シフト した 値 と A の mask の 論理 積 と の 排 他 的 論理 和 にする
trg = A . data ^= ( 1 << B ) & A . mask
rst = A . data ^= ( 1 << B ) & A . mask <eos>
1758
src = 無限 の 整数 列 を 2 だけ 増加 させる
trg = count += 2
rst = count += 2 <eos>
1759
src = project ( A , B ) を 展開 して を出力する
trg = print ( * project ( A , B ) )
rst = print ( * project ( A , B ) ) <eos>
1760
src = A の B 番 目 、 A の C から 1 を 引 いた 値 番 目 に 1 を加えた 値の 最大 値を A の B 番 目 にする
trg = A [ B ] = max ( A [ B ] , A [ C - 1 ] + 1 )
rst = A [ B ] = max ( A [ B ] , A [ C - 1 ] + 1 ) <eos>
1761
src = A が 100 0000 0000 より 小さい とき 、
trg = if A < 10000000000 :
rst = if A < 1000000 : <eos>
1762
src = my _ solve ( A ) を出力する
trg = print ( my_solve ( A ) )
rst = print ( <unk> ( A ) ) <eos>
1763
src = ( A の INF ) からなる 列 の 2 に B を 掛 け た 値 から 1 を 引 いた 値 回 分 の 列 を A の val にする
trg = A . val = [ A . INF ] * ( 2 * B - 1 )
rst = A . val = [ A . INF ] * ( 2 * B - 1 ) <eos>
1764
src = 1 から 3 1 未 満 までの 数 列 の 各要素 を B とし 、 B の 列 を A とする
trg = A = [ B for B in range ( 1 , 31 ) ]
rst = A = [ B for B in range ( 1 , 31 ) ] <eos>
1765
src = A の _ size が 、 つまり 未 定 値 と 等 しく ない とき 、
trg = if A . _size is None :
rst = if A . _size_ is None : <eos>
1766
src = A の B から 1 を 引 いた 値 番目の 2 番 目 から 、 つまり 末 尾 までの 2 間隔 による 部分 列 の 総 和 を C で 割 った 余 り を A の B 番目の 4 番 目 にする
trg = A [ B ] [ 4 ] = sum ( A [ B - 1 ] [ 2 : : 2 ] ) % C
rst = A [ B ] [ 4 ] = sum ( A [ B - 1 ] [ 2 : : 2 ] ) % C <eos>
1767
src = A に 1 を加えた 値に B を 掛 け た 値が C 以下の 間 、 次 を 繰り返す
trg = while ( A + 1 ) * B <= C :
rst = while ( A + 1 ) * B <= C : <eos>
1768
src = B に 1 を加えた 値 から 2 に C を 掛 け た 値に 1 を加えた 値 未 満 までの 数 列 を 順に A として 、 繰り返す
trg = for A in range ( B + 1 , 2 * C + 1 ) :
rst = for A in range ( B + 1 , 2 * C + 1 ) : <eos>
1769
src = A が B より 小さい とき A 、 そうでなければ C を出力する
trg = print ( A if A < B else C )
rst = print ( A if A < B else C ) <eos>
1770
src = topological _ sort ( B , C ) を 順に A として 、 繰り返す
trg = for A in topological_sort ( B , C ) :
rst = for A in topological_sort ( B , C ) : <eos>
1771
src = init ( C * D , E ) を A の B 番 目 にする
trg = A [ B ] = init ( C * D , E )
rst = A [ B ] = init ( C * D , E ) <eos>
1772
src = _ heapq モジュール を用いる
trg = import _heapq
rst = import <unk> <eos>
1773
src = ino ( A [ B ] [ 2 ] )
trg = ino ( A [ B ] [ 2 ] )
rst = ino ( A [ B ] [ 2 ] ) <eos>
1774
src = ( Point ( x = 1, y = 3 ) 、 Point ( x = 1, y = 4 ) ) からなる 列
trg = [ Point ( x = 1 , y = 3 ) , Point ( x = 1 , y = 4 ) ]
rst = [ Point ( x = 1 , y = 3 ) , Point ( x = 1 , y = 4 ) ] <eos>
1775
src = A を B の C の D 番 目 から D に 5 を加えた 値 までの 部分 列 番 目 だけ 増加 させる
trg = A += B [ C [ D : D + 5 ] ]
rst = A += B [ C [ D : D + 5 ] ] <eos>
1776
src = C . popleft () を 展開 し 、 それぞれ A 、 B 、 os . path とする
trg = A , B , path = C . popleft ( )
rst = A , B , path = C . popleft ( ) <eos>
1777
src = A かつ A の 末 尾 の 1 番 目 が B 以下の 間 、 次 を 繰り返す
trg = while A and A [ - 1 ] [ 1 ] <= B :
rst = while A and A [ - 1 ] [ 1 ] <= B : <eos>
1778
src = is _ dead ( A , B , C ) の とき 、
trg = if is_dead ( A , B , C ) :
rst = if <unk> ( A , B , C ) : <eos>
1779
src = B の 1 番 目 に B の 2 番 目 を 掛 け た 値を A の B の先頭 番 目 にする
trg = A [ B [ 0 ] ] = B [ 1 ] * B [ 2 ]
rst = A [ B [ 0 ] ] = B [ 1 ] * B [ 2 ] <eos>
1780
src = dfs ( 0 , [ -1 ] * 26 , [ 0 ] * A )
trg = dfs ( 0 , [ - 1 ] * 26 , [ 0 ] * A )
rst = dfs ( 0 , [ - 1 ] * 26 , [ 0 ] * A ) <eos>
1781
src = A を calc ( [ B , C - 1, D , E , F ] ) に G の 1 番 目 を 掛 け た 値 だけ 増加 させる
trg = A += calc ( [ B , C - 1 , D , E , F ] ) * G [ 1 ]
rst = A += calc ( [ B , C - 1 , D , E , F ] ) * G [ 1 ] <eos>
1782
src = DoubleLinkedList () を A とする
trg = A = DoubleLinkedList ( )
rst = A = <unk> ( ) <eos>
1783
src = B の C 番 目 が A より 大きい とき 0 、 そうでなければ A から B の C 番 目 を 引 いた 値を A とする
trg = A = 0 if B [ C ] > A else A - B [ C ]
rst = A = 0 if B [ C ] > A else ( A - B [ C ] ) <eos>
1784
src = ( B の 0 番 目 に 2 に C の 0 番 目 を 掛 け た 値を 3 で 割 った 値 を加えた 値 、 B の 1 番 目 に 2 に C の 1 番 目 を 掛 け た 値を 3 で 割 った 値 を加えた 値 ) からなる 列 を A とする
trg = A = [ B [ 0 ] + 2 * C [ 0 ] / 3 , B [ 1 ] + 2 * C [ 1 ] / 3 ]
rst = A = [ ( B [ 0 ] + 2 * C [ 0 ] ) / 3 , ( B [ 1 ] + 2 * C [ 1 ] ) / 3 ] <eos>
1785
src = A の mm が 10 より 小さい とき 、
trg = if A . mm < 10 :
rst = if A . mm < 10 : <eos>
1786
src = A の長さ を 7 で 割 った 値が 0.5 以上の とき 、
trg = if len ( A ) / 7 >= 0.5 :
rst = if len ( A ) / 7 >= 0.5 : <eos>
1787
src = A の B 番 目 で なく かつ C の D 番目の B 番 目 が -1 と 等 しく なく かつ E の B 番 目 が C の D 番目の B 番 目 より 大きい とき 、
trg = if not A [ B ] and C [ D ] [ B ] != - 1 and E [ B ] > C [ D ] [ B ] :
rst = if not A [ B ] and C [ D ] [ B ] != - 1 and E [ B ] > C [ D ] [ B ] : <eos>
1788
src = C から 1 を 引 いた 値 、 D 、 E において 正規表現 B が 最初 にマッチする 位置 を A とする
trg = A = search ( B , C - 1 , D , E )
rst = A = search ( B , C - 1 , D , E ) <eos>
1789
src = ( ( B の x 座標 、 B の y 座標 ) の 組 ) からなる 列 を A とする
trg = A = [ ( B . x , B . y ) ]
rst = A = [ ( B . x , B . y ) ] <eos>
1790
src = B の C + 1 番目の D 番目の E から 1 を 引 いた 値 番目の F 番 目 に 1 を加えた 値を A とする
trg = A = B [ C + 1 ] [ D ] [ E - 1 ] [ F ] + 1
rst = A = B [ C + 1 ] [ D ] [ E - 1 ] [ F ] + 1 <eos>
1791
src = A の B に 1 を加えた 値 番 目 が 15 と 等 しい とき 、
trg = if A [ B + 1 ] == 15 :
rst = if A [ B + 1 ] == 15 : <eos>
1792
src = ( 0 、 3 1 、 28 、 3 1 、 30 、 3 1 、 30 、 3 1 、 3 1 、 30 、 3 1 、 30 、 3 1 ) からなる 列 を A とする
trg = A = [ 0 , 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 ]
rst = A = [ 0 , 31 , 28 , 31 , 30 , 31 , 30 , 31 , 30 , 31 ] <eos>
1793
src = A の B 番 目 が C より 小さく かつ C が A の B に 1 を加えた 値 番 目 以下の とき 、
trg = if A [ B ] < C and C <= A [ B + 1 ] :
rst = if A [ B ] < C and C <= A [ B + 1 ] : <eos>
1794
src = C の 2 に D を 掛 け た 値に 1 を加えた 値 番 目 を A の B 番目の C の 2 に D を 掛 け た 値 番 目 番 目 にする
trg = A [ B ] [ C [ 2 * D ] ] = C [ 2 * D + 1 ]
rst = A [ B ] [ C [ 2 * D ] ] = C [ 2 * D + 1 ] <eos>
1795
src = A の 末 尾 の 0 番 目 から A の先頭 の先頭 を 引 いた 値に 1 を加えた 値 、 B の 末 尾 の 1 番 目 から B の先頭 の 1 番 目 を 引 いた 値に 1 を加えた 値 を出力する
trg = print ( A [ - 1 ] [ 0 ] - A [ 0 ] [ 0 ] + 1 , B [ - 1 ] [ 1 ] - B [ 0 ] [ 1 ] + 1 )
rst = print ( A [ - 1 ] [ 0 ] - A [ 0 ] [ 0 ] + 1 , B [ - 1 ] [ 0 ] + 1 ) <eos>
1796
src = A の B から 1 を 引 いた 値 番 目 が 1 と 等 しく かつ A の C から 1 を 引 いた 値 番 目 が 1 と 等 しい とき 、
trg = if A [ B - 1 ] == 1 and A [ C - 1 ] == 1 :
rst = if A [ B - 1 ] == 1 and A [ C - 1 ] == 1 : <eos>
1797
src = A に 0.5 を加えた 値の 切り 捨 て 整数値 を出力する
trg = print ( math . floor ( A + 0.5 ) )
rst = print ( math . floor ( A + 0.5 ) ) <eos>
1798
src = A に A に 5 を 掛 け た 値を 100 で 割 った 商 を加えた 値を A とする
trg = A = A + ( A * 5 ) // 100
rst = A = A + A * 5 // 100 <eos>
1799
src = A が 1 0000 より 大きい とき 、
trg = if A > 10000 :
rst = if A > 10000 : <eos>
1800
src = ( 0 ) からなる 列 の B 回 分 の 列 を A とする
trg = A = [ 0 ] * B
rst = A = [ 0 ] * B <eos>
1801
src = D の キー と 値 の集まり の 各要素 を B 、 C とし 、 Node ( char = B , value = C ) の 列 を A とする
trg = A = [ Node ( char = B , value = C ) for B , C in D . items ( ) ]
rst = A = [ Node ( B , C . value = D . value ) for B , C in D . items ( ) ] <eos>
1802
src = A の B 番 目 と C の B 番目の 論理 積 の とき 、
trg = if A [ B ] & C [ B ] :
rst = if A [ B ] & C [ B ] : <eos>
1803
src = -10 0000 0000 7 を A とする
trg = A = - 10000000007
rst = A = - 1000000000 <eos>
1804
src = A が ( B 、 C ) からなる 列 に 含まれ ない とき 、
trg = if A not in [ B , C ] :
rst = if A not in [ B , C ] : <eos>
1805
src = ( ( 1 、 1 ) の 組 ) からなる 列 を A とする
trg = A = [ ( 1 , 1 ) ]
rst = A = [ ( 1 , 1 ) ] <eos>
1806
src = B に B を 掛 け た 値に C に C を 掛 け た 値 を加えた 値を A とする
trg = A = B * B + C * C
rst = A = B * B + C * C <eos>
1807
src = B の先頭 から [MASK] を 探 して 見つかった 位置 を A とする
trg = A = B . find
rst = A = B . find ( ) <eos>
1808
src = x を パラメータ として ( B の先頭 の長さ 、 x の先頭 ) の 組 を返す関数 を key として A を ソート する
trg = A . sort ( key = lambda B : ( len ( B [ 0 ] ) , B [ 0 ] ) )
rst = A . sort ( key = lambda B : ( len ( B [ 0 ] ) , B [ 0 ] ) ) <eos>
1809
src = 1 を A の C 番目の B 番 目 とする を A の B 番目の C 番 目 にする
trg = A [ B ] [ C ] = A [ C ] [ B ] = 1
rst = A [ B ] [ C ] = A [ C ] [ B ] = 1 <eos>
1810
src = br ( B , B [ C ] + D ) を A とする
trg = A = br ( B , B [ C ] + D )
rst = A = br ( B , B [ C ] + D ) <eos>
1811
src = B が 5 以下の とき C 、 そうでなければ B が 10 以下の とき D 、 そうでなければ B が 15 以下の とき E 、 そうでなければ B が 20 以下の とき F 、 そうでなければ B < = 25 の とき G 、 そうでなければ H を A とする
trg = A = C if B <= 5 else ( D if B <= 10 else ( E if B <= 15 else ( F if B <= 20 else ( G if B <= 25 else H ) ) ) )
rst = A = C if B <= 5 else ( D if B <= 10 else ( E if B <= 20 else ( F if B <= 25 else G ) ) ) <eos>
1812
src = delete _ node ( A , int ( B [ C ] [ 7 : ] ) )
trg = delete_node ( A , int ( B [ C ] [ 7 : ] ) )
rst = delete_node ( A , int ( B [ C ] [ 7 : ] ) ) <eos>
1813
src = _ remove ( A ) を A とする
trg = A = _remove ( A )
rst = A = _remove ( A ) <eos>
1814
src = A が ( 1 、 4 ) からなる 列 と 等 しい とき 、
trg = if A == [ 1 , 4 ] :
rst = if A == [ 1 , 4 ] : <eos>
1815
src = B に C の 2 番 目 を加えた 値を A とする
trg = A = B + C [ 2 ]
rst = A = B + C [ 2 ] <eos>
1816
src = ( ( 0 ) からなる 列 の 0 から 25 未 満 までの 数 列 の 各要素 を B とし 、 B の 列 回 分 の 列 ) からなる 列 を A とする
trg = A = [ [ 0 ] * [ B for B in range ( 25 ) ] ]
rst = A = [ [ 0 ] * [ B for B in range ( 25 ) ] ] <eos>
1817
src = func ( B ) を A とする
trg = A = func ( B )
rst = A = func ( B ) <eos>
1818
src = ( ( B , 0 ) 、 ( C , 0 ) 、 ( D , 1 ) 、 ( E , 1 ) ) からなる 辞書 を A とする
trg = A = { '+' : 0 , '-' : 0 , '/' : 1 , '*' : 1 }
rst = A = { <unk> : 0 , <unk> : 0 , <unk> : 1 } <eos>
1819
src = A . add _ edge ( B - 1, C , 1, - D )
trg = A . add_edge ( B - 1 , C , 1 , - D )
rst = A . add_edge ( B - 1 , C , 1 , - D ) <eos>
1820
src = A の 整数値 が 0 と 等 しい とき 、
trg = if int ( A ) == 0 :
rst = if int ( A ) == 0 : <eos>
1821
src = A の B 番 目 が C を 2 で 割 った 値 より 大きい とき 、
trg = if A [ B ] > C / 2 :
rst = if A [ B ] > C / 2 : <eos>
1822
src = A 年 B 月 C 日 の 日 時 から D 年 E 月 F 日 の 日 時 を 引 いた 値の days を出力する
trg = print ( ( datetime . datetime ( A , B , C ) - datetime . datetime ( D , E , F ) ) . days )
rst = print ( datetime . datetime ( A , B , C ) - datetime . datetime ( D , E , F ) . days ) <eos>
1823
src = A の 末 尾 に dfs ( B , C , D ) を追加する
trg = A . append ( dfs ( B , C , D ) )
rst = A . append ( dfs ( B , C , D ) ) <eos>
1824
src = A の B 番目の 2 番 目 を出力する
trg = print ( A [ B ] [ 2 ] )
rst = print ( A [ B ] [ 2 ] ) <eos>
1825
src = set _ pdt ( A , B , C + 1 )
trg = set_pdt ( A , B , C + 1 )
rst = <unk> ( A , B , C + 1 ) <eos>
1826
src = A の 末 尾 に B の 1 番 目 から 、 つまり 末 尾 までの 2 間隔 による 部分 列 を追加する
trg = A . append ( B [ 1 : : 2 ] )
rst = A . append ( B [ 1 : : 2 ] ) <eos>
1827
src = A の B 番 目 が C と 等 しく かつ D が E と 等 しい とき 、
trg = if A [ B ] == C and D == E :
rst = if A [ B ] == C and D == E : <eos>
1828
src = 0 を 実 部 、 1 を 虚 部 とした 複素数 を A とする
trg = A = complex ( 0 , 1 )
rst = A = complex ( 0 , 1 ) <eos>
1829
src = paint ( A )
trg = paint ( A )
rst = paint ( A ) <eos>
1830
src = B の 最大 値を C で 割 った 商 に 1 を加えた 値を A とする
trg = A = max ( B ) // C + 1
rst = A = max ( B ) // C + 1 <eos>
1831
src = A を 空白 文字 で 分割 した 字句 列 を A とする
trg = A = A . split ( ' ' )
rst = A = A . split ( ' ' ) <eos>
1832
src = A が 、 つまり 未 定 値 と 等 しく なければならない
trg = assert A is not None
rst = assert A is not None <eos>
1833
src = B . arg () を A とする
trg = A = B . arg ( )
rst = A = B . <unk> ( ) <eos>
1834
src = 改行 せずに 空白 文字 に A [ B ] [ 0 ] の 文字列 を加えた 値に C を加えた 値に D を 書式 として A の B 番目の 1 番 目 で 整 形 した 文字列 を加えた 値 を出力する
trg = print ( ' ' + str ( A [ B ] [ 0 ] ) + C + D . format ( A [ B ] [ 1 ] ) , end = '' )
rst = print ( ' ' + str ( A [ B ] [ 0 ] ) + C + D . format ( A [ B ] [ 1 ] ) , end = '' ) <eos>
1835
src = ( ( B ) からなる 列 の 0 から E 未 満 までの 数 列 の 各要素 を D とし 、 C に 1 を加えた 値の 列 回 分 の 列 ) からなる 列 を A とする
trg = A = [ [ B ] * [ ( C + 1 ) for D in range ( E ) ] ]
rst = A = [ [ B ] * [ ( C + 1 ) for D in range ( E ) ] ] <eos>
1836
src = A に B の C 番 目 を加えた 値を D の長さ で 割 った 余 り を A とする
trg = A = ( A + B [ C ] ) % len ( D )
rst = A = ( A + B [ C ] ) % len ( D ) <eos>
1837
src = heappush ( A , ( B [ C ] , C ) )
trg = heappush ( A , ( B [ C ] , C ) )
rst = heappush ( A , ( B [ C ] , C ) ) <eos>
1838
src = A の 末 尾 に 1 に 3 に A の 末 尾 を 掛 け た 値 を加えた 値 を追加する
trg = A . append ( 1 + 3 * A [ - 1 ] )
rst = A . append ( 1 + 3 * A [ - 1 ] ) <eos>
1839
src = A を 入力された 文字列を 英 小文字 に変換し た 文字列 だけ 増加 させる
trg = A += input ( ) . lower ( )
rst = A += input ( ) . lower ( ) <eos>
1840
src = A の 各要素 に bool を適用した 列 のリスト の 総 和 に 1 を加えた 値 を出力する
trg = print ( sum ( list ( map ( bool , A ) ) ) + 1 )
rst = print ( sum ( list ( map ( A , A ) ) ) + 1 ) <eos>
1841
src = プログラムを 正常 終了する
trg = sys . exit ( )
rst = exit = exit <eos>
1842
src = ( -1 ) からなる 列 の B 回 分 の 列 を A の p にする
trg = A . p = [ - 1 ] * B
rst = A . p = [ - 1 ] * B <eos>
1843
src = A の B 番 目 に対応する 値 、 も し 存在 し なければ C 、 0 に ネ イ ピ ア 数 を加えた 値を A の B 番目の C 番 目 にする
trg = A [ B ] [ C ] = A [ B ] . get ( C , 0 ) + e
rst = A [ B ] [ C ] = A [ B ] . get ( C , 0 ) + e . get ( C , 0 ) <eos>
1844
src = ( ( 0 ) からなる 列 の 0 から 2 * B に 1 を加えた 値 未 満 までの 数 列 の 各要素 を C とし 、 1 を 3 に B を 掛 け た 値 だけ 左 シフト した 値の 列 回 分 の 列 ) からなる 列 を A とする
trg = A = [ [ 0 ] * [ ( 1 << ( 3 * B ) ) for C in range ( 2 * B + 1 ) ] ]
rst = A = [ [ 0 ] * [ ( 1 << B ) for C in range ( 2 * B + 1 ) ] ] <eos>
1845
src = - A が B より 小さい かどうか が C に A を加えた 値 より 小さく なく または - A が D より 小さい かどうか が C に A を加えた 値 より 小さく ない とき 、
trg = if not - A < B < C + A or not - A < D < C + A :
rst = if not - A < B < C + A or not - D < C + A : <eos>
1846
src = A . _ treewalk _ preorder ( B . right )
trg = A . _treewalk_preorder ( B . right )
rst = A . _treewalk_preorder ( B . right ) <eos>
1847
src = F の C 番 目 を E とする
trg = E = F [ C ]
rst = E = F [ C ] <eos>
1848
src = B の 21 番 目 、 B の 22 番 目 、 B の 23 番 目 、 B の 6 番 目 、 B の 7 番 目 、 B の 8 番 目 を A の 6 番 目 、 A の 7 番 目 、 A の 8 番 目 、 A の 21 番 目 、 A の 22 番 目 、 A の 23 番 目 とする
trg = A [ 6 ] , A [ 7 ] , A [ 8 ] , A [ 21 ] , A [ 22 ] , A [ 23 ] = B [ 21 ] , B [ 22 ] , B [ 23 ] , B [ 6 ] , B [ 7 ] , B [ 8 ]
rst = A [ 61 ] , A [ 22 ] , A [ 23 ] , A [ 8 ] , A [ 21 ] , A [ 23 ] , A [ 22 ] , A [ 23 ] = B [ 21 ] , B [ 22 ] ,
1849
src = C 、 C の先頭 を 除 いた 部分 列 に ( C の先頭 ) からなる 列 を加えた 値の 要素を それぞれ 組 にした 列 の 各要素 を B 、 A とし 、 A から B を 引 いた 値の 列 を ネ イ ピ ア 数 とする
trg = e = [ A - B for B , A in zip ( C , C [ 1 : ] + [ C [ 0 ] ] ) ]
rst = e = [ A - B for B , A in zip ( C , C [ 1 : ] + [ C [ 0 ] ] ) ] <eos>
1850
src = mergeSort ( A , B , C ) を 無限 の 整数 列 とする
trg = count = mergeSort ( A , B , C )
rst = count = mergeSort ( A , B , C ) <eos>
1851
src = B の size を A とする
trg = A = B . size
rst = A = B . size <eos>
1852
src = A の B 番 目 に coprime ( C , D ) を追加した 集 ま り
trg = A [ B ] . add ( coprime ( C , D ) )
rst = A [ B ] . add ( coprime ( C , D ) ) <eos>
1853
src = A を B の 正 弦 に C を 掛 け た 値 だけ 増加 させる
trg = A += math . sin ( B ) * C
rst = A += math . sin ( B ) * C <eos>
1854
src = ( B の 0 番 目 に C の 0 番 目 を 3 で 割 った 値 を加えた 値 、 B の 1 番 目 に C の 1 番 目 を 3 で 割 った 値 を加えた 値 ) からなる 列 を A とする
trg = A = [ B [ 0 ] + C [ 0 ] / 3 , B [ 1 ] + C [ 1 ] / 3 ]
rst = A = [ B [ 0 ] + C [ 0 ] / 3 , B [ 1 ] + C [ 1 ] / 3 ] <eos>
1855
src = vec ( B , C ) を A とする
trg = A = vec ( B , C )
rst = A = <unk> ( B , C ) <eos>
1856
src = A . is _ intersected _ with ( B ) の とき 、
trg = if A . is_intersected_with ( B ) :
rst = if A . <unk> ( B ) : <eos>
1857
src = 改行 せずに A の value を出力する
trg = print ( A . value , end = '' )
rst = print ( A . value , end = '' ) <eos>
1858
src = A を 書式 として 、 つまり 文字コード B の 順序 数 に C を加えた 値の 文字 、 D で 整 形 した 文字列 を出力する
trg = print ( A . format ( chr ( ord ( B ) + C ) , D ) )
rst = print ( A . format ( chr ( ord ( B ) + C ) , D ) ) <eos>
1859
src = A に 1 を加えた 値が B より 小さく かつ C の A に 1 を加えた 値 番目の 先頭 が D 以下の 間 、 次 を 繰り返す
trg = while A + 1 < B and C [ A + 1 ] [ 0 ] <= D :
rst = while A + 1 < B and C [ A + 1 ] [ 0 ] <= D : <eos>
1860
src = 空文字列 を 間 に 入れ て B を 連結 した 文字列 の集合 を A とする
trg = A = set ( '' . join ( B ) )
rst = A = '' . join ( B ) <eos>
1861
src = A の B から 1 を 引 いた 値 番 目 に 1 を加えた 値を A の B から 1 を 引 いた 値 番 目 にする
trg = A [ B - 1 ] = A [ B - 1 ] + 1
rst = A [ B - 1 ] = A [ B - 1 ] + 1 <eos>
1862
src = B の C の D 番目の D 番 目 番 目 を A とする
trg = A = B [ C [ D ] [ D ] ]
rst = A = B [ C [ D ] [ D ] ] <eos>
1863
src = A の長さ が 1 より 大きく かつ A の 0 番 目 が B と 等 しい とき 、
trg = if len ( A ) > 1 and A [ 0 ] == B :
rst = if len ( A ) > 1 and A [ 0 ] == B : <eos>
1864
src = A . same _ check ( e . source , e . target ) でない とき 、
trg = if not A . same_check ( e . source , e . target ) :
rst = if not A . <unk> ( e . source , e . target ) : <eos>
1865
src = A . swim ( len ( A . q ) -1 )
trg = A . swim ( len ( A . q ) - 1 )
rst = A . <unk> ( len ( A . q ) - 1 ) <eos>
1866
src = x を パラメータ として x の 3 番 目 を返す関数 を key として A を ソート する
trg = A . sort ( key = lambda B : B [ 3 ] )
rst = A . sort ( key = lambda B : B [ 3 ] ) <eos>
1867
src = 2 を B の 1 番 目 とする を A とする
trg = A = B [ 1 ] = 2
rst = A = B [ 1 ] = 2 <eos>
1868
src = 0 を A の level の B 番 目 にする
trg = A . level [ B ] = 0
rst = A . level [ B ] = 0 <eos>
1869
src = longest _ common _ subsequence ( A , B ) を出力する
trg = print ( longest_common_subsequence ( A , B ) )
rst = print ( <unk> ( A , B ) ) <eos>
1870
src = D の 各要素 を C とし 、 B の C 番目の 列 の 最大 値を A とする
trg = A = max ( [ B [ C ] for C in D ] )
rst = A = max ( [ B [ C ] for C in D ] ) <eos>
1871
src = A を B の C から 1 を 引 いた 値 番 目 だけ 減少 させる
trg = A -= B [ C - 1 ]
rst = A -= B [ C - 1 ] <eos>
1872
src = A の [MASK] と 等 しい 要素 の最初の 位置 の 末 尾 に B を追加する
trg = A . index . append ( B )
rst = A . index . append ( B ) <eos>
1873
src = 0.0 を A の B 番 目 にする
trg = A [ B ] = 0.0
rst = A [ B ] = 0.0 <eos>
1874
src = index _ exsist ( 2 * B ) を A とする
trg = A = index_exsist ( 2 * B )
rst = A = <unk> ( 2 * B ) <eos>
1875
src = B の 0 番 目 から C の先頭 を 引 いた 値に D を 掛 け た 値に B の 1 番 目 から C の 1 番 目 を 引 いた 値に E を 掛 け た 値 を加えた 値に C の 1 番 目 を加えた 値を A とする
trg = A = ( B [ 0 ] - C [ 0 ] ) * D + ( B [ 1 ] - C [ 1 ] ) * E + C [ 1 ]
rst = A = ( B [ 0 ] - C [ 0 ] ) * D + ( B [ 1 ] - C [ 1 ] ) * E + C [ 1 ] <eos>
1876
src = ( A の face の 1 番 目 、 A の face の 5 番 目 、 A の face の 2 番 目 、 A の face の 3 番 目 、 A の face の先頭 、 A の face の 4 番 目 ) からなる 列 を A の face にする
trg = A . face = [ A . face [ 1 ] , A . face [ 5 ] , A . face [ 2 ] , A . face [ 3 ] , A . face [ 0 ] , A . face [ 4 ] ]
rst = A . face = [ A . face [ 1 ] , A . face [ 5 ] , A . face [ 2 ] , A . face [ 3 ] , A . face [ 0 ] , A . face [ 4 ] ] <eos>
1877
src = A の 0 に ( B ) からなる 列 の C に 2 を加えた 値 回 分 の 列 を挿入する
trg = A . insert ( 0 , [ B ] * ( C + 2 ) )
rst = A . insert ( 0 , [ B ] * ( C + 2 ) ) <eos>
1878
src = ネ イ ピ ア 数の リストを A とする
trg = A = list ( e )
rst = A = list ( e ) <eos>
1879
src = A の 末 尾 に B の 1 番目の 文字列 に B の先頭 の 文字列 を加えた 値の 整数値 を追加する
trg = A . append ( int ( str ( B [ 1 ] ) + str ( B [ 0 ] ) ) )
rst = A . append ( int ( str ( B [ 1 ] ) + str ( B [ 0 ] ) ) ) <eos>
1880
src = B と 1 の 論理 積 の とき B から 2 を 引 いた 値 、 そうでなければ B から 1 を 引 いた 値を A とする
trg = A = B - 2 if ( B & 1 ) else B - 1
rst = A = B - 2 if ( B & 1 ) else B - 1 <eos>
1881
src = cross ( A - B , C - B ) が 0 より 大きい かどうか を返す
trg = return cross ( A - B , C - B ) > 0
rst = return cross ( A - B , C - B ) > 0 <eos>
1882
src = C から D から 1 を 引 いた 値 未 満 までの -1 間隔 の 数 列 の 各要素 を B とし 、 A の 末 尾 に B を追加する の 列
trg = [ A . append ( B ) for B in range ( C , D - 1 , - 1 ) ]
rst = [ A . append ( B ) for B in range ( C , D - 1 , - 1 ) ] <eos>
1883
src = Bt () を A とする
trg = A = Bt ( )
rst = A = <unk> ( ) <eos>
1884
src = A を B の 0 番 目 から C を 引 いた 値 、 0 の 最大 値 だけ 増加 させる
trg = A += max ( B [ 0 ] - C , 0 )
rst = A += max ( B [ 0 ] - C , 0 ) <eos>
1885
src = C の B 番目の 1 番 目 を A の heavy の B 番 目 にする
trg = A . heavy [ B ] = C [ B ] [ 1 ]
rst = A . heavy [ B ] = C [ B ] [ 1 ] <eos>
1886
src = A の ( B 、 C ) の 組 番 目 を 1 だけ 増加 させる
trg = A [ ( B , C ) ] += 1
rst = A [ ( B , C ) ] += 1 <eos>
1887
src = ( 0 ) からなる 列 の B の 最大 値に 1 を加えた 値 回 分 の 列 を A とする
trg = A = [ 0 ] * ( max ( B ) + 1 )
rst = A = [ 0 ] * ( max ( B ) + 1 ) <eos>
1888
src = 1 から B から C を 引 いた 値に 2 を加えた 値 未 満 までの 数 列 を 順に A として 、 繰り返す
trg = for A in range ( 1 , B - C + 2 ) :
rst = for A in range ( 1 , B - C + 2 ) : <eos>
1889
src = north ( A ) を A とする
trg = A = north ( A )
rst = A = north ( A ) <eos>
1890
src = parse ( 0 )
trg = parse ( 0 )
rst = parse ( 0 ) <eos>
1891
src = 入力された 文字列を 空白 で 分割 した 字句 列 の 各要素 を B とし 、 B の 整数値 の 列 を 展開 し 、 それぞれ 、 つまり 無限 の 整数 列 、 A とする
trg = count , A = [ int ( B ) for B in input ( ) . split ( ) ]
rst = A , count = [ int ( B ) for B in input ( ) . split ( ) ] <eos>
1892
src = B の先頭 の 順序 数 から C を 引 いた 値を A とする
trg = A = ord ( B [ 0 ] ) - C
rst = A = ord ( B [ 0 ] ) - C <eos>
1893
src = A . push _ left ( B )
trg = A . push_left ( B )
rst = A . push ( B ) <eos>
1894
src = A を B を 5 だけ 左 シフト した 値 と の 論理 和 にする
trg = A |= ( B << 5 )
rst = A |= ( B << 5 ) <eos>
1895
src = ( ( 1, 1 ) ) からなる 辞書 を返す
trg = return { 1 : 1 }
rst = return { 1 : 1 } <eos>
1896
src = A の B 番 目 に C を加えた 値が A の D 番 目 と 等 しい とき 、
trg = if A [ B ] + C == A [ D ] :
rst = if A [ B ] + C == A [ D ] : <eos>
1897
src = ( A 、 B ) からなる 列 の C に 2 を 掛 け た 値 の先頭 から D を 探 して 見つかった 位置 が -1 と 等 しく ない かどうか 番 目 を出力する
trg = print ( [ A , B ] [ ( C * 2 ) . find ( D ) != - 1 ] )
rst = print ( [ A , B ] [ C * 2 - D . find ( D ) != - 1 ] ) <eos>
1898
src = D の 整数値 から 1 を 引 いた 値 、 E の 整数値 から 1 を 引 いた 値 、 F の 整数値 を A 、 B 、 C とする
trg = A , B , C = int ( D ) - 1 , int ( E ) - 1 , int ( F )
rst = A , B , C = int ( D ) - 1 , int ( E ) - 1 , int ( F ) <eos>
1899
src = A の 末 尾 に B の C 番目の D 番 目 に E の D から 1 を 引 いた 値 番 目 、 E の D 番目の 最大 値 を加えた 値 を追加する
trg = A . append ( B [ C ] [ D ] + max ( E [ D - 1 ] , E [ D ] ) )
rst = A . append ( B [ C ] [ D ] + max ( E [ D - 1 ] , E [ D ] ) ) <eos>
1900
src = A が 19 と 等 しく かつ B が 30 以下の とき 、
trg = if A == 19 and B <= 30 :
rst = if A == 19 and B <= 30 : <eos>
1901
src = A の 末 尾 に ( B 、 C の 整数値 、 D ) からなる 列 を追加する
trg = A . append ( [ B , int ( C ) , D ] )
rst = A . append ( [ B , int ( C ) , D ] ) <eos>
1902
src = D . length () を 展開 し 、 それぞれ A 、 B 、 C とする
trg = A , B , C = D . length ( )
rst = A , B , C = D . length ( ) <eos>
1903
src = dfs ( 0 , A [ 0 ] ) を出力する
trg = print ( dfs ( 0 , A [ 0 ] ) )
rst = print ( dfs ( 0 , A [ 0 ] ) ) <eos>
1904
src = A の 末 尾 に 10 e 10 を追加する
trg = A . append ( 10e10 )
rst = A . append ( 10e9 ) <eos>
1905
src = A を B の C 番 目 に D を 掛 け た 値 だけ 減少 させる
trg = A -= B [ C ] * D
rst = A -= B [ C ] * D <eos>
1906
src = B . func ( B . tree [ C ] , A ) を A とする
trg = A = B . func ( B . tree [ C ] , A )
rst = A = B . func ( B . tree [ C ] , A ) <eos>
1907
src = ( 20 に 2000 を 掛 け た 値に 1 を加えた 値 ) からなる 列 を A とする
trg = A = [ 20 * 2000 + 1 ]
rst = A = [ 20 * 2000 + 1 ] <eos>
1908
src = add _ parent _ node _ and _ depth ( A , B , C , D + 1 )
trg = add_parent_node_and_depth ( A , B , C , D + 1 )
rst = <unk> ( A , B , C , D + 1 ) <eos>
1909
src = 0 から 10 未 満 までの 数 列 の 各要素 を B とし 、 B に 1 を加えた 値の 列 を A とする
trg = A = [ B + 1 for B in range ( 10 ) ]
rst = A = [ B + 1 for B in range ( 10 ) ] <eos>
1910
src = 0 から 21 未 満 までの 数 列 の 各要素 を B とし 、 2 の B 乗 が 100 0000 以下の とき の 3 の B 乗 の 列 を A とする
trg = A = [ 3 ** B for B in range ( 21 ) if 2 ** B <= 1000000 ]
rst = A = [ 2 ** B for B in range ( 21 ) if 2 ** B <= 1000000 ] <eos>
1911
src = ( ( ( 0 、 -1 ) の 組 、 ( -1 、 0 ) の 組 、 ( 0 、 1 ) の 組 ) からなる 列 、 ( ( 1 、 -1 ) の 組 、 ( 2 、 0 ) の 組 、 ( 1 、 1 ) の 組 ) からなる 列 ) からなる 列 を A とする
trg = A = [ [ ( 0 , - 1 ) , ( - 1 , 0 ) , ( 0 , 1 ) ] , [ ( 1 , - 1 ) , ( 2 , 0 ) , ( 1 , 1 ) ] ]
rst = A = [ [ ( 0 , - 1 ) , ( - 1 , 0 ) , ( 0 , 1 ) ] , [ ( 1 , 1 ) , ( - 1 , 0 ) , ( 0 , 1 ) ] ] <eos>
1912
src = super () . push ( int ( A ) )
trg = super ( ) . push ( int ( A ) )
rst = super ( ) . push ( int ( A ) ) <eos>
1913
src = A 、 B の 絶対 値 を出力する
trg = print ( A , abs ( B ) )
rst = print ( A , abs ( B ) ) <eos>
1914
src = B に 0 、 C から D を 引 いた 値の 最大 値に E を 掛 け た 値 を加えた 値を A とする
trg = A = B + max ( 0 , C - D ) * E
rst = A = B + max ( 0 , C - D ) * E <eos>
1915
src = B から C を 引 いた 値の days を A とする
trg = A = ( B - C ) . days
rst = A = ( B - C ) . days <eos>
1916
src = A の 末 尾 に item ( B , C ) を追加する
trg = A . append ( item ( B , C ) )
rst = A . append ( item ( B , C ) ) <eos>
1917
src = B の 2 乗 から 4 に C を 掛 け た 値に D を 掛 け た 値を 引 いた 値を A とする
trg = A = B ** 2 - 4 * C * D
rst = A = B ** 2 - 4 * C * D <eos>
1918
src = 空 列 、 集合 を A 、 B とする
trg = A , B = [ ] , set ( )
rst = A , B = [ ] , set ( ) <eos>
1919
src = B を C の D 番 目 で 割 った 商 に E の D 番 目 を 掛 け た 値に B を C の D 番 目 で 割 った 余 り を F の D 番 目 で 割 った 商 に G の D 番 目 を 掛 け た 値 を加えた 値を A とする
trg = A = B // C [ D ] * E [ D ] + ( B % C [ D ] ) // F [ D ] * G [ D ]
rst = A = B // C [ D ] * E [ D ] + B [ C [ D ] % F [ D ] * G // D <eos>
1920
src = ( 10 0000 に 100 を 掛 け た 値に 1 を加えた 値 ) からなる 列 の B 回 分 の 列 を A とする
trg = A = [ 100000 * 100 + 1 ] * B
rst = A = [ 100000 * 100 + 1 ] * B <eos>
1921
src = fix ( A ) を A とする
trg = A = fix ( A )
rst = A = fix ( A ) <eos>
1922
src = A から B の size を 引 いた 値を返す
trg = return A - B . size
rst = return A - B . size <eos>
1923
src = 0 から C 未 満 までの 数 列 の 各要素 を B とし 、 BinaryTreeNode () の 列 を A とする
trg = A = [ BinaryTreeNode ( ) for B in range ( C ) ]
rst = A = [ BinaryTreeNode ( ) for B in range ( C ) ] <eos>
1924
src = 0 から C 未 満 までの 数 列 の 各要素 を B とし 、 ( 0 、 空 列 ) からなる 列 の 列 を A とする
trg = A = [ [ 0 , [ ] ] for B in range ( C ) ]
rst = A = [ [ 0 , [ 0 ] ] for B in range ( C ) ] <eos>
1925
src = operator ( C , D , E [ F ] ) を A の B 番 目 にする
trg = A [ B ] = operator ( C , D , E [ F ] )
rst = A [ B ] = Vector ( C , D , E [ F ] ) <eos>
1926
src = B [ 0 ] の 整数値 に 1000 を 掛 け た 値に B [ 1 ] の 整数値 に 100 を 掛 け た 値 を加えた 値に B の 2 番目の 整数値 に 10 を 掛 け た 値 を加えた 値に B の 3 番目の 整数値 を加えた 値を A とする
trg = A = int ( B [ 0 ] ) * 1000 + int ( B [ 1 ] ) * 100 + int ( B [ 2 ] ) * 10 + int ( B [ 3 ] )
rst = A = int ( B [ 0 ] ) * 1000 + int ( B [ 1 ] ) * 100 + int ( B [ 2 ] ) * 10 + int ( B [ 3 ] ) <eos>
1927
src = ( C 、 B ) の 組 を A の B 番 目 にする
trg = A [ B ] = ( C , B )
rst = A [ B ] = ( C , B ) <eos>
1928
src = A を B の -1 番 目 から B の C 番 目 を 引 いた 値 だけ 増加 させる
trg = A += B [ - 1 ] - B [ C ]
rst = A += B [ - 1 ] - B [ C ] <eos>
1929
src = A の B 番目の 1 番 目 が C の 1 番 目 以下の とき 、
trg = if A [ B ] [ 1 ] <= C [ 1 ] :
rst = if A [ B ] [ 1 ] <= C [ 1 ] : <eos>
1930
src = A . GetConnectedComponents () の長さ を出力する
trg = print ( len ( A . GetConnectedComponents ( ) ) )
rst = print ( len ( A . <unk> ( ) ) ) <eos>
1931
src = A を B に C から 読み 込 んだ 一行 の 末 尾 から 空白 改行 を取り 除 いた 文字列 を加えた 値に B を加えた 値 のリスト だけ 増加 させる
trg = A += list ( B + C . readline ( ) . rstrip ( ) + B )
rst = A += B + list ( C . readline ( ) . rstrip ( ) ) + B <eos>
1932
src = C . diam () を 展開 し 、 それぞれ A 、 B とする
trg = A , B = C . diam ( )
rst = A , B = C . <unk> ( ) <eos>
1933
src = A . _ is _ 2 node ( B . right ) の とき 、
trg = if A . _is_2node ( B . right ) :
rst = if A . <unk> ( B . right ) : <eos>
1934
src = insert ( A . right , B , C ) を A の right にする
trg = A . right = insert ( A . right , B , C )
rst = A . right = insert ( A . right , B , C ) <eos>
1935
src = C を A の ( B 、 0 ) の 組 番 目 にする
trg = A [ ( B , 0 ) ] = C
rst = A [ ( B , 0 ) ] = C <eos>
1936
src = A の B 番目の 末 尾 に ( C 、 0 、 - D 、 A の C 番目の 長さ から 1 を 引 いた 値 ) からなる 列 を追加する
trg = A [ B ] . append ( [ C , 0 , - D , len ( A [ C ] ) - 1 ] )
rst = A [ B ] . append ( [ C , 0 , - D , len ( A [ C ] ) - 1 ] ) <eos>
1937
src = ネ イ ピ ア 数 を 展開 し 、 それぞれ A 、 B 、 C 、 D とする
trg = A , B , C , D = e
rst = A , B , C , D = e <eos>
1938
src = 10 の 10 乗 を A の B 番 目 にする
trg = A [ B ] = pow ( 10 , 10 )
rst = A [ B ] = 10 ** 10 <eos>
1939
src = A の hldnxt の B 番 目 が 、 つまり 未 定 値 と 等 しい とき 、
trg = if A . hldnxt [ B ] is not None :
rst = if A . hldnxt [ B ] is not None : <eos>
1940
src = ( B 、 C 、 D 、 E 、 F 、 G 、 H ) からなる 列 の 2 回 分 の 列 を A とする
trg = A = [ B , C , D , E , F , G , H ] * 2
rst = A = [ B , C , D , E , F , G , H ] * 2 <eos>
1941
src = 0 から F 未 満 までの 数 列 の 各要素 を C とし 、 0 から E 未 満 までの 数 列 の 各要素 を D とし 、 B の C + 1 番目の D 番 目 から B の C 番目の D 番 目 を 引 いた 値の 列 の 列 を A とする
trg = A = [ [ B [ C + 1 ] [ D ] - B [ C ] [ D ] for D in range ( E ) ] for C in range ( F ) ]
rst = A = [ B [ C + 1 ] [ D - B [ C + 1 ] [ D ] for D in [ range ( E ) for C in range ( F ) ] ] <eos>
1942
src = A の E の e の to 番目の 、 つまり ネ イ ピ ア 数の rev 番目の cap が 1 と 等 しい とき 、
trg = if A . E [ e . to ] [ e . rev ] . cap == 1 :
rst = if A . E [ e . to ] [ e . rev ] . cap == 1 : <eos>
1943
src = 0 から 10 未 満 までの 数 列 の 各要素 を B とし 、 0 から 10 未 満 までの 数 列 の 各要素 を B とし 、 0 の 列 の 列 を A とする
trg = A = [ [ 0 for B in range ( 10 ) ] for B in range ( 10 ) ]
rst = A = [ [ 0 for B in range ( 10 ) ] for B in range ( 10 ) ] <eos>
1944
src = ( B 、 0 、 C 、 D 、 E ) の 組 を A とする
trg = A = ( B , 0 , C , D , E )
rst = A = ( B , 0 , C , D , E ) <eos>
1945
src = root ( A ) が root ( B ) と 等 しい とき 、
trg = if root ( A ) == root ( B ) :
rst = if root ( A ) == root ( B ) : <eos>
1946
src = B から C を 引 いた 値に 1 を 3 で 割 った 値を 掛 け た 値に C を加えた 値を A とする
trg = A = ( B - C ) * ( 1 / 3 ) + C
rst = A = ( B - C ) * ( 1 / 3 ) + C <eos>
1947
src = combi ( 2 )
trg = combi ( 2 )
rst = combi ( 2 ) <eos>
1948
src = 空白 文字 を 間 に 入れ て C の D に 1 を加えた 値 から E 番 目 までの 部分 列 の 各要素 を B とし 、 B の 文字列 の 列 を 連結 した 文字列を A とする
trg = A = ' ' . join ( [ str ( B ) for B in C [ D + 1 : E ] ] )
rst = A = ' ' . join ( [ str ( B ) for B in C [ D + 1 : E ] ] ) <eos>
1949
src = 0 から 2000 未 満 までの 数 列 の 各要素 を B とし 、 B に 1 を加えた 値の 列 を A とする
trg = A = [ B + 1 for B in range ( 2000 ) ]
rst = A = [ B + 1 for B in range ( 2000 ) ] <eos>
1950
src = A の 末 尾 に query ( B , C + 1 ) の 文字列 を追加する
trg = A . append ( str ( query ( B , C + 1 ) ) )
rst = A . append ( str ( query ( B , C + 1 ) ) ) <eos>
1951
src = ( A - B ) / ( C - D ) に ( E - F ) を 掛 け た 値を G から H を 引 いた 値 で 割 った 値に 1 を加えた 値の 絶対 値が 0.0 0000 01 より 小さい とき 、
trg = if abs ( ( A - B ) / ( C - D ) * ( E - F ) / ( G - H ) + 1 ) < 0.0000001 :
rst = if abs ( ( A - B ) / ( C - D ) * ( E - F ) + ( G - H ) ) < 0.001 : <eos>
1952
src = B の 0.5 乗 を A とする
trg = A = B ** 0.5
rst = A = B ** 0.5 <eos>
1953
src = calc _ d ( B [ C ] , B [ C + 1 ] ) を A とする
trg = A = calc_d ( B [ C ] , B [ C + 1 ] )
rst = A = <unk> ( B [ C ] , B [ C + 1 ] ) <eos>
1954
src = [MASK] において 正規表現 [MASK] が 最初 にマッチする 位置 を出力する
trg = print ( search ( ) )
rst = print ( search ( ) ) <eos>
1955
src = ( 7 ) からなる 列 を返す
trg = return [ 7 ]
rst = return [ 7 ] <eos>
1956
src = A かつ B が C と 等 しい とき 、
trg = if A and B == C :
rst = if A and B == C : <eos>
1957
src = B と C の 排 他 論理 和 を ソート した 列 を 順に A として 、 繰り返す
trg = for A in sorted ( B ^ C ) :
rst = for A in sorted ( B ^ C ) : <eos>
1958
src = swap ( A , B )
trg = swap ( A , B )
rst = swap ( A , B ) <eos>
1959
src = calc ( lambdaA , B : C [ A ] [ B ] , D , E ) に calc ( lambdaA , B : C [ B ] [ A ] , E , D ) を加えた 値 を出力する
trg = print ( calc ( lambda A , B : C [ A ] [ B ] , D , E ) + calc ( lambda A , B : C [ B ] [ A ] , E , D ) )
rst = print ( calc ( lambda B , C : A [ B ] , D [ E ] ) + calc ( B , C [ : B ] , A [ D ] , E ) ) <eos>
1960
src = A を cross ( B , C ) を 2 で 割 った 値 だけ 増加 させる
trg = A += cross ( B , C ) / 2
rst = A += cross ( B , C ) / 2 <eos>
1961
src = augment _ path () を 展開 し 、 それぞれ A 、 os . path とする
trg = A , path = augment_path ( )
rst = A , path = <unk> ( ) <eos>
1962
src = C の 2 個 までの コン ビ ネ ー ション の リストを 順に A 、 B として 、 繰り返す
trg = for A , B in list ( itertools . combinations ( C , 2 ) ) :
rst = for A , B in list ( itertools . combinations ( C , 2 ) ) : <eos>
1963
src = SSST ( B ) を A とする
trg = A = SSST ( B )
rst = A = <unk> ( B ) <eos>
1964
src = 2 の B 乗 から 1 を 引 いた 値を A の size にする
trg = A . size = 2 ** B - 1
rst = A . size = 2 ** B - 1 <eos>
1965
src = 0 から B 未 満 までの 数 列 の集合 から C を 引 いた 値を A とする
trg = A = set ( range ( B ) ) - C
rst = A = set ( range ( B ) ) - C <eos>
1966
src = 空 辞書 を A の idx にする
trg = A . idx = { }
rst = A . idx = { } <eos>
1967
src = B に C を 掛 け た 値に D に E を 掛 け た 値 を加えた 値に F を 掛 け た 値を A とする
trg = A = ( B * C + D * E ) * F
rst = A = ( B * C + D * E ) * F <eos>
1968
src = 0 が A 以下 かどうか が B の x 座標 より 小さく かつ 0 が C 以下 かどうか が B の y 座標 より 小さい とき 、
trg = if 0 <= A < B . x and 0 <= C < B . y :
rst = if 0 <= A < B . x and 0 <= C < B . y : <eos>
1969
src = 1 から B 未 満 までの 数 列 の 順 列 を 順に A として 、 繰り返す
trg = for A in permutations ( range ( 1 , B ) ) :
rst = for A in permutations ( range ( 1 , B ) ) : <eos>
1970
src = B の 平 方 根 の 切り 捨 て 整数値 に 1 を加えた 値を A とする
trg = A = math . floor ( math . sqrt ( B ) ) + 1
rst = A = math . floor ( math . sqrt ( B ) ) + 1 <eos>
1971
src = A を 7 で 割 った 余 り が 3 と 等 しい とき 、
trg = if A % 7 == 3 :
rst = if A % 7 == 3 : <eos>
1972
src = B の 整数値 を A とする
trg = A = int ( B )
rst = A = int ( B ) <eos>
1973
src = 無限 の 整数 列 の A 番目の B 番 目 、 無限 の 整数 列 の A 番目の C 番 目 を出力する
trg = print ( count [ A ] [ B ] , count [ A ] [ C ] )
rst = print ( count [ A ] [ B ] , count [ A ] [ C ] ) <eos>
1974
src = A に B / A の 正 弦 を 掛 け た 値に C * B を A で 割 った 値の 余 弦 を 掛 け た 値を ( C -1 ) に B を 掛 け た 値を A で 割 った 値の 余 弦 で 割 った 値 を出力する
trg = print ( A * math . sin ( B / A ) * math . cos ( C * B / A ) / math . cos ( ( C - 1 ) * B / A ) )
rst = print ( A * sin ( B / A ) * math . cos ( C * B / A ) / math . cos ( C * B ) ) <eos>
1975
src = B を C に 1 を加えた 値 で 割 った 値の 切り 上げ 整数値 を A とする
trg = A = math . ceil ( B / ( C + 1 ) )
rst = A = ceil ( B / ( C + 1 ) ) <eos>
1976
src = A の B 番目の 末 尾 に ( C の D 番 目 、 C の D に 1 を加えた 値 番 目 ) の 組 を追加する
trg = A [ B ] . append ( ( C [ D ] , C [ D + 1 ] ) )
rst = A [ B ] . append ( ( C [ D ] , C [ D + 1 ] ) ) <eos>
1977
src = A を B の 、 つまり 先頭 から C 番 目 までの 部分 列 の 総 和 だけ 増加 させる
trg = A += sum ( B [ : C ] )
rst = A += sum ( B [ : C ] ) <eos>
1978
src = A の B から 1 を 引 いた 値 番 目 または A の C から 1 を 引 いた 値 番目の とき 、
trg = if A [ B - 1 ] or A [ C - 1 ] :
rst = if A [ B - 1 ] or A [ C - 1 ] : <eos>
1979
src = A が B に 1 を加えた 値 と 等 しく ない とき 、
trg = if A != B + 1 :
rst = if A != B + 1 : <eos>
1980
src = A が B に 含まれ ない 間 、 次 を 繰り返す
trg = while A not in B :
rst = while A not in B : <eos>
1981
src = 1 から 14 未 満 までの 数 列 の 各要素 を B とし 、 B の 列 を A とする
trg = A = [ B for B in range ( 1 , 14 ) ]
rst = A = [ B for B in range ( 1 , 14 ) ] <eos>
1982
src = A に B を加えた 値を 2 で 割 った 商 を出力する
trg = print ( ( A + B ) // 2 )
rst = print ( ( A + B ) // 2 ) <eos>
1983
src = 10 の 6 乗 を A とする
trg = A = 10 ** 6
rst = A = 10 ** 6 <eos>
1984
src = 0 が A 以下 かどうか が 9 以下の とき 、
trg = if 0 <= A <= 9 :
rst = if 0 <= A <= 9 : <eos>
1985
src = 真 を A の negativeCycle にする
trg = A . negativeCycle = True
rst = A . negativeCycle = True <eos>
1986
src = A を dfs ( B + 1, C / / 10 ) だけ 増加 させる
trg = A += dfs ( B + 1 , C // 10 )
rst = A += dfs ( B + 1 , C // 10 ) <eos>
1987
src = ソート された 順序 を 保 った まま C を B に 挿入 できる 位置 から 、 つまり ソート された 順序 を 保 った まま D を B に 挿入 できる 最後の 位置 未 満 までの 数 列 を 順に A として 、 繰り返す
trg = for A in range ( bisect_left ( B , C ) , bisect_right ( B , D ) ) :
rst = for A in range ( bisect_left ( B , C ) , bisect_right ( B , D ) ) : <eos>
1988
src = B の C 番 目 から B の D に 1 を加えた 値 番 目 を 引 いた 値に E の D 番 目 から F を 引 いた 値 を加えた 値を A とする
trg = A = ( B [ C ] - B [ D + 1 ] ) + ( E [ D ] - F )
rst = A = ( B [ C ] - B [ D + 1 ] ) + ( E [ D ] - F ) <eos>
1989
src = A が 1 より 大きく かつ B の A から 2 を 引 いた 値 番目の C 番 目 が D と 等 しい とき 、
trg = if A > 1 and B [ A - 2 ] [ C ] == D :
rst = if A > 1 and B [ A - 2 ] [ C ] == D : <eos>
1990
src = 400 を A とする
trg = A = 400
rst = A = 400 <eos>
1991
src = B に 7 を 掛 け た 値を A とする
trg = A = B * 7
rst = A = B * 7 <eos>
1992
src = A の inv の B に 1 を加えた 値 番 目 に B に 1 を加えた 値を 掛 け た 値を C で 割 った 余 り を A の inv の B 番 目 にする
trg = A . inv [ B ] = A . inv [ B + 1 ] * ( B + 1 ) % C
rst = A . inv [ B ] = A . inv [ B + 1 ] * ( B + 1 ) % C <eos>
1993
src = B を 10 で 割 った 商 から C に 100 を 掛 け た 値を 引 いた 値 から D に 10 を 掛 け た 値を 引 いた 値を A とする
trg = A = B // 10 - C * 100 - D * 10
rst = A = B // 10 - C * 100 - D * 10 <eos>
1994
src = B を A の先頭 の先頭 にする
trg = A [ 0 ] [ 0 ] = B
rst = A [ 0 ] [ 0 ] = B <eos>
1995
src = dfs ( 0 , A , 0 ) でない とき 、
trg = if not dfs ( 0 , A , 0 ) :
rst = if not dfs ( 0 , A , 0 ) : <eos>
1996
src = 0 から B を 1 200 で 割 った 商 に 1 を加えた 値 未 満 までの 数 列 を 順に A として 、 繰り返す
trg = for A in range ( B // 1200 + 1 ) :
rst = for A in range ( B // 1200 + 1 ) : <eos>
1997
src = A の ラ ジ アン を返す
trg = return math . radians ( A )
rst = return math . radians ( A ) <eos>
1998
src = erase ( A , B , C [ 1 ] ) を 展開 し 、 それぞれ A 、 B とする
trg = A , B = erase ( A , B , C [ 1 ] )
rst = A , B = erase ( A , B , C [ 1 ] ) <eos>
1999
src = A の 末 尾 に B . dist ( C , D ) 、 B . dist ( E , D ) の 最大 値 を追加する
trg = A . append ( max ( B . dist ( C , D ) , B . dist ( E , D ) ) )
rst = A . append ( max ( B . dist ( C , D ) , B . dist ( E , D ) ) ) <eos>
2000
src = A の root の B 番 目 を返す
trg = return A . root [ B ]
rst = return A . root [ B ] <eos>
2001
src = A の 29 番 目 、 A の 6 番 目 を A の 6 番 目 、 A の 29 番 目 とする
trg = A [ 6 ] , A [ 29 ] = A [ 29 ] , A [ 6 ]
rst = A [ 6 ] , A [ 29 ] = A [ 29 ] , A [ 6 ] <eos>
2002
src = A に B を追加した 集 ま り
trg = A . add ( B )
rst = A . add ( B ) <eos>
2003
src = A に B を加えた 値を ネ イ ピ ア 数 とする
trg = e = A + B
rst = e = A + B <eos>
2004
src = A の 、 つまり 入力された 文字列 の 整数値 から 1 を 引 いた 値 番 目 を 1 だけ 増加 させる
trg = A [ int ( input ( ) ) - 1 ] += 1
rst = A [ int ( input ( ) ) - 1 ] += 1 <eos>
2005
src = B の edge を 順に A として 、 繰り返す
trg = for A in B . edge :
rst = for A in B . edge : <eos>
2006
src = A の B 番 目 が 0 と 等 しい 間 、 次 を 繰り返す
trg = while A [ B ] == 0 :
rst = while A [ B ] == 0 : <eos>
2007
src = ( ( 10 の 18 乗 ) からなる 列 の 0 から D に 1 を加えた 値 未 満 までの 数 列 の 各要素 を C とし 、 B に 1 を加えた 値の 列 回 分 の 列 ) からなる 列 を A とする
trg = A = [ [ 10 ** 18 ] * [ ( B + 1 ) for C in range ( D + 1 ) ] ]
rst = A = [ [ 10 ** 18 ] * [ ( B + 1 ) for C in range ( D + 1 ) ] ] <eos>
2008
src = B を 0.5 に C を 掛 け た 値 で 割 った 値を A とする
trg = A = B / ( 0.5 * C )
rst = A = B / ( 0.5 * C ) <eos>
2009
src = ネ イ ピ ア 数 を A の B の 、 つまり ネ イ ピ ア 数 番 目 番 目 にする
trg = A [ B [ e ] ] = e
rst = A [ B [ e ] ] = e <eos>
2010
src = A が 0 と 等 しく なく または B が 0 と 等 しく ない 間 、 次 を 繰り返す
trg = while A != 0 or B != 0 :
rst = while A != 0 or B != 0 : <eos>
2011
src = B を _ pow ( 10 , 32 ) で 割 った 商 を A とする
trg = A = B // _pow ( 10 , 32 )
rst = A = B // _pow ( 10 , 32 ) <eos>
2012
src = A の B から 1 を 引 いた 値 番 目 を C の先頭 だけ 増加 させる
trg = A [ B - 1 ] += C [ 0 ]
rst = A [ B - 1 ] += C [ 0 ] <eos>
2013
src = add ( A , B [ 0 ] , B [ 2 ] )
trg = add ( A , B [ 0 ] , B [ 2 ] )
rst = add ( A , B [ 0 ] , B [ 2 ] ) <eos>
2014
src = B を C で 分割 した 字句 列 を 順に A として 、 繰り返す
trg = for A in B . split ( C ) :
rst = for A in B . split ( C ) : <eos>
2015
src = ( 0 、 0 、 0 、 0 ) からなる 列 を A とする
trg = A = [ 0 , 0 , 0 , 0 ]
rst = A = [ 0 , 0 , 0 , 0 ] <eos>
2016
src = ( B ) の 2 乗 に ( C - B ) の 2 乗 を加えた 値の 0.5 乗 から 、 つまり ネ イ ピ ア 数 を 引 いた 値の 絶対 値を A とする
trg = A = abs ( ( ( B ) ** 2 + ( C - B ) ** 2 ) ** 0.5 - e )
rst = A = abs ( ( B ) ** 2 + ( C - B ) ** 2 ) ** 0.5 - e <eos>
2017
src = 7 から 10 未 満 までの 数 列 を 順に A として 、 繰り返す
trg = for A in range ( 7 , 10 ) :
rst = for A in range ( 7 , 10 ) : <eos>
2018
src = comp ( A , B ) が 0 より 小さい とき 、
trg = if comp ( A , B ) < 0 :
rst = if ( ( time ( A , B ) ) < 0 ) : <eos>
2019
src = A に 入力された 文字列 の 整数値 を 掛 け た 値を A とする
trg = A = A * int ( input ( ) )
rst = A = A * int ( input ( ) ) <eos>
2020
src = ( B ) からなる 列 の A の size に 2 を 掛 け た 値に 2 を加えた 値 回 分 の 列 を A の data にする
trg = A . data = [ B ] * ( A . size * 2 + 2 )
rst = A . data = [ B ] * ( A . size * 2 + 2 ) <eos>
2021
src = A の 1 番目の 整数値 が B 以下の とき 、
trg = if int ( A [ 1 ] ) <= B :
rst = if int ( A [ 1 ] ) <= B : <eos>
2022
src = D を A の B から C を 引 いた 値に 1 を加えた 値 番 目 にする
trg = A [ B - C + 1 ] = D
rst = A [ B - C + 1 ] = D <eos>
2023
src = 空白 文字 を 間 に 入れ て A の 各要素 に 整数 を適用した 列 を 連結 した 文字列 、 B を出力する
trg = print ( ' ' . join ( map ( str , A ) ) , B )
rst = print ( ' ' . join ( map ( str , A ) ) , B ) <eos>
2024
src = B を 20 で 割 った 余 り を A の 4 番 目 にする
trg = A [ 4 ] = B % 20
rst = A [ 4 ] = B % 20 <eos>
2025
src = write ( ' ' . join ( A [ B : ] ) )
trg = write ( '' . join ( A [ B : ] ) )
rst = write ( '' . join ( A [ B : ] ) ) <eos>
2026
src = 8 に A に B を加えた 値を 掛 け た 値 を出力する
trg = print ( 8 * ( A + B ) )
rst = print ( 8 * ( A + B ) ) <eos>
2027
src = A を 0 から 3 を 引 いた 値に B を 掛 け た 値 だけ 増加 させる
trg = A += ( 0 - 3 ) * B
rst = A += ( 0 - 3 ) * B <eos>
2028
src = A 、 ( B の distance の C 番目の 総 和 、 C ) の 組 の 最小 値を A とする
trg = A = min ( A , ( sum ( B . distance [ C ] ) , C ) )
rst = A = min ( A , ( B . distance [ C ] , C ) ) <eos>
2029
src = new _ node ( int ( readline () ) ) を B とする を A とする
trg = A = B = new_node ( int ( readline ( ) ) )
rst = A = <unk> ( int ( readline ( ) ) ) <eos>
2030
src = 0 から E の長さ に 1 を加えた 値 未 満 までの 数 列 の 各要素 を B とし 、 0 から D の長さ に 1 を加えた 値 未 満 までの 数 列 の 各要素 を C とし 、 B に C を加えた 値の 列 の 列 を A とする
trg = A = [ [ B + C for C in range ( len ( D ) + 1 ) ] for B in range ( len ( E ) + 1 ) ]
rst = A = [ [ B + C for C in range ( len ( D ) + 1 ) ] for B in range ( len ( E ) + 1 ) ] <eos>
2031
src = A の A の長さ から 1 を 引 いた 値 番 目 が 0 より 大きく かつ B の C 番 目 が 0 より 大きい とき 、
trg = if A [ len ( A ) - 1 ] > 0 and B [ C ] > 0 :
rst = if A [ len ( A ) - 1 ] > 0 and B [ C ] > 0 : <eos>
2032
src = A の 先頭に B を追加する
trg = A . appendleft ( B )
rst = A . appendleft ( B ) <eos>
2033
src = ( ( 0 、 -1 ) の 組 、 ( 1 、 -1 ) の 組 、 ( 1 、 0 ) の 組 、 ( 1 、 1 ) の 組 、 ( 0 、 1 ) の 組 、 ( -1 、 0 ) の 組 ) の 組 を A とする
trg = A = ( ( 0 , - 1 ) , ( 1 , - 1 ) , ( 1 , 0 ) , ( 1 , 1 ) , ( 0 , 1 ) , ( - 1 , 0 ) )
rst = A = ( ( 0 , - 1 ) , ( 1 , - 1 ) , ( 1 , 0 ) , ( 1 , 1 ) , ( 0 , 1 ) , ( 0 , 1 ) ) <eos>
2034
src = A の color が B の BLACK と 等 しい かどうか を返す
trg = return A . color == B . BLACK
rst = return A . color == B . BLACK <eos>
2035
src = A が B と 等 しく なく かつ C の A 番 目 が D から C の E 番 目 を 引 いた 値 と 等 しい とき 、
trg = if A != B and C [ A ] == D - C [ E ] :
rst = if A != B and C [ A ] == D - C [ E ] : <eos>
2036
src = A に B の C - D + E + F + G -1 番 目 に H の C - D 番 目 を 掛 け た 値を I で 割 った 余 り を 掛 け た 値を I で 割 った 余 り を A とする
trg = A = A * ( B [ C - D + E + F + G - 1 ] * H [ C - D ] % I ) % I
rst = A = A * ( B [ C - D + E + F + G + - 1 ] * H [ C - D ] % I ) % I <eos>
2037
src = root ( A ) が A と 等 しい とき 、
trg = if root ( A ) == A :
rst = if root ( A ) == A : <eos>
2038
src = A を 現在の 日 時 とする
trg = now = A
rst = now = A <eos>
2039
src = A を B の C に 1 を加えた 値 番 目 から B の C 番 目 を 引 いた 値 から 2 に D を 掛 け た 値を 引 いた 値 だけ 増加 させる
trg = A += B [ C + 1 ] - B [ C ] - 2 * D
rst = A += ( B [ C + 1 ] - B [ C ] - 2 * D ) <eos>
2040
src = B の C 番 目 から C に D の長さ を加えた 値 までの 部分 列 を A とする
trg = A = B [ C : C + len ( D ) ]
rst = A = B [ C : C + len ( D ) ] <eos>
2041
src = E を 空白 で 分割 した 字句 列 の 各要素 を D とし 、 D の 整数値 の 列 を 展開 し 、 それぞれ A 、 B 、 C とする
trg = A , B , C = [ int ( D ) for D in E . split ( ) ]
rst = A , B , C = [ int ( D ) for D in E . split ( ) ] <eos>
2042
src = C . root ( D ) 、 C . root ( E ) を A 、 B とする
trg = A , B = C . root ( D ) , C . root ( E )
rst = A , B = C . root ( D ) , C . root ( E ) <eos>
2043
src = A の B から 1 を 引 いた 値 番目の C から 1 を 引 いた 値 番 目 が 1 と 等 しい とき 、
trg = if A [ B - 1 ] [ C - 1 ] == 1 :
rst = if A [ B - 1 ] [ C - 1 ] == 1 : <eos>
2044
src = A の B 番目の C 番 目 が D より 小さい とき 、
trg = if A [ B ] [ C ] < D :
rst = if A [ B ] [ C ] < D : <eos>
2045
src = A を postorder ( B [ C ] [ 1 ] ) だけ 増加 させる
trg = A += ( postorder ( B [ C ] [ 1 ] ) )
rst = A += ( postorder ( B [ C ] [ 1 ] ) ) <eos>
2046
src = ( ( 、 つまり 未 定 値 ) からなる 列 の 0 から C 未 満 までの 数 列 の 各要素 を B とし 、 20 の 列 回 分 の 列 ) からなる 列 を A とする
trg = A = [ [ None ] * [ 20 for B in range ( C ) ] ]
rst = A = [ [ None ] * [ 20 for B in range ( C ) ] ] <eos>
2047
src = A の B から 1 を 引 いた 値 番目の C 番 目 を返す
trg = return A [ B - 1 ] [ C ]
rst = return A [ B - 1 ] [ C ] <eos>
2048
src = B を 書式 として C に 1 を加えた 値 、 D の C 番 目 で 整 形 した 文字列を A とする
trg = A = B . format ( C + 1 , D [ C ] )
rst = A = B . format ( C + 1 , D [ C ] ) <eos>
2049
src = A の dp の B から 1 を 引 いた 値 番目の C から 1 を 引 いた 値 番 目 、 A . dp の B -1 番目の C 番 目 、 A . dp の B 番目の C から 1 を 引 いた 値 番目の 最小 値の 最小 値に 1 を加えた 値を A の dp の B 番目の C 番 目 にする
trg = A . dp [ B ] [ C ] = min ( A . dp [ B - 1 ] [ C - 1 ] , min ( A . dp [ B - 1 ] [ C ] , A . dp [ B ] [ C - 1 ] ) ) + 1
rst = A . a [ B ] [ C - 1 ] = min ( A . dp [ B - 1 ] [ C - 1 ] , A . dp [ B - 1 ] [ C ] , A . dp [ B ] [ C - 1
2050
src = 13 に 3 600 を 掛 け た 値を A とする
trg = A = 13 * 3600
rst = A = 13 * 3600 <eos>
2051
src = 1 から C に 1 を加えた 値 未 満 までの 数 列 の 各要素 を B とし 、 C を B で 割 った 余 り が 0 と 等 しい とき の B の 列 を A とする
trg = A = [ B for B in range ( 1 , C + 1 ) if C % B == 0 ]
rst = A = [ B for B in range ( 1 , C + 1 ) if C % B == 0 ] <eos>
2052
src = 0 から C に 2 を加えた 値 未 満 までの 数 列 の 各要素 を B とし 、 、 つまり 真 の 列 を A とする
trg = A = [ True for B in range ( C + 2 ) ]
rst = A = [ True for B in range ( C + 2 ) ] <eos>
2053
src = ( ( B , D に 番号 付 した 組 の 列 の 各要素 を C 、 B とし 、 C の 列 ) ) からなる 辞書 を A とする
trg = A = { x : [ C for C , B in enumerate ( D ) ] }
rst = A = { i : [ C for C , B in enumerate ( D ) ] } <eos>
2054
src = A . operator _ func ( A . node [ 2 * B + 1 ] , A . node [ 2 * B + 2 ] ) を A の node の B 番 目 にする
trg = A . node [ B ] = A . operator_func ( A . node [ 2 * B + 1 ] , A . node [ 2 * B + 2 ] )
rst = A . node [ B ] = A . operator_func ( A . node [ 2 * B + 1 ] , A . node [ 2 * B + 2 ] ) <eos>
2055
src = ( ( 0 、 0 ) からなる 列 ) からなる 列 を A とする
trg = A = [ [ 0 , 0 ] ]
rst = A = [ [ 0 , 0 ] ] <eos>
2056
src = clear ( A [ 1 ] )
trg = clear ( A [ 1 ] )
rst = clear ( A [ 1 ] ) <eos>
2057
src = A が 、 つまり 空 列 と 等 しく なく かつ A の 0 番 目 が B と 等 しく ない 間 、 次 を 繰り返す
trg = while A != [ ] and A [ 0 ] != B :
rst = while A != [ ] and A [ 0 ] != B : <eos>
2058
src = B 、 C の 1 番目の 最小 値を A とする
trg = A = min ( B , C [ 1 ] )
rst = A = min ( B , C [ 1 ] ) <eos>
2059
src = SME ( A ) を返す
trg = return SME ( A )
rst = return <unk> ( A ) <eos>
2060
src = A に B を 掛 け た 値 、 C に B を 掛 け た 値に 2 を 掛 け た 値の 最小 値に D / 1000 の 切り 上げ 整数値 に A を 掛 け た 値 、 D / 500 の 切り 上げ 整数値 に C を 掛 け た 値の 最小 値 を加えた 値 を出力する
trg = print ( min ( A * B , C * B * 2 ) + min ( math . ceil ( D / 1000 ) * A , math . ceil ( D / 500 ) * C ) )
rst = print ( min ( A * B , math . ceil ( C * C * B * math . ceil ( D / 3 ) ) + D * ( A / 500 ) ) ) <eos>
2061
src = check ( A , B , C , D , E ) の とき 、
trg = if check ( A , B , C , D , E ) :
rst = if check ( A , B , C , D , E ) : <eos>
2062
src = B の C 番 目 から B の D に 1 を加えた 値 番 目 を 引 いた 値に E から F の C から 1 を 引 いた 値 番 目 を 引 いた 値 を加えた 値を A とする
trg = A = ( B [ C ] - B [ D + 1 ] ) + ( E - F [ C - 1 ] )
rst = A = ( B [ C ] - B [ D + 1 ] ) + ( E - F [ C - 1 ] ) <eos>
2063
src = c ( int ( A ) + int ( B ) ) を返す
trg = return c ( int ( A ) + int ( B ) )
rst = return c ( int ( A ) + int ( B ) ) <eos>
2064
src = C の B 番 目 に 2 を 掛 け た 値 から 2 から B 未 満 までの 数 列 の 各要素 を D とし 、 B % D が 0 と 等 しい とき の A の D 番目の 列 の 総 和 を 引 いた 値を E で 割 った 余 り を A の B 番 目 にする
trg = A [ B ] = ( C [ B ] * 2 - sum ( [ A [ D ] for D in range ( 2 , B ) if B % D == 0 ] ) ) % E
rst = A [ B ] = ( sum ( [ A [ B ] for D in range ( C [ B ] ) if D % 2 == B ] ) ) % D <eos>
2065
src = A の 末 尾 に ( B 、 C に D の B 番 目 を加えた 値 ) の 組 を追加する
trg = A . append ( ( B , C + D [ B ] ) )
rst = A . append ( ( B , C + D [ B ] ) ) <eos>
2066
src = B の 、 つまり 先頭 から C 番 目 までの 部分 列 に D の E 番 目 を加えた 値に B の C に 2 を加えた 値 から 、 つまり 末 尾 までの 部分 列 を加えた 値を A とする
trg = A = B [ : C ] + D [ E ] + B [ C + 2 : ]
rst = A = B [ : C ] + D [ E ] + B [ C + 2 : ] <eos>
2067
src = 0 から B の長さ に 10 を加えた 値 未 満 までの 数 列 を 順に A として 、 繰り返す
trg = for A in range ( len ( B ) + 10 ) :
rst = for A in range ( len ( B ) + 10 ) : <eos>
2068
src = B と C の ユ ー クリ ッ ド 距 離 を A とする
trg = A = dist ( B , C )
rst = A = dist ( B , C ) <eos>
2069
src = A が B 以上 かつ Sosu ( A ) の とき 、
trg = if A >= B and Sosu ( A ) :
rst = if A >= B and Sosu ( A ) : <eos>
2070
src = A の B 番目の C 番 目 でない とき 、
trg = if not A [ B ] [ C ] :
rst = if not A [ B ] [ C ] : <eos>
2071
src = A から B を 引 いた 値に C から B を 引 いた 値を 掛 け た 値に D から E を 引 いた 値に F から E を 引 いた 値を 掛 け た 値 を加えた 値を返す
trg = return ( A - B ) * ( C - B ) + ( D - E ) * ( F - E )
rst = return ( A - B ) * ( C - B ) + ( D - E ) * ( F - E ) <eos>
2072
src = 1 を B だけ 左 シフト した 値を A とする
trg = A = 1 << B
rst = A = 1 << B <eos>
2073
src = C の 各要素 を B とし 、 B の 1 番目の 列 を A とする
trg = A = [ B [ 1 ] for B in C ]
rst = A = [ B [ 1 ] for B in C ] <eos>
2074
src = ( 0 ) からなる 列 の 100 2 回 分 の 列 、 ( 0 ) からなる 列 の 100 2 回 分 の 列 、 ( 0 ) からなる 列 の 100 2 回 分 の 列 、 ( 0 ) からなる 列 の 100 2 回 分 の 列 を A 、 B 、 C 、 D とする
trg = A , B , C , D = [ 0 ] * 1002 , [ 0 ] * 1002 , [ 0 ] * 1002 , [ 0 ] * 1002
rst = A , B , C , D = [ 0 ] * 1002 , [ 0 ] * 1002 , [ 0 ] * 1002 <eos>
2075
src = B を 3 で 割 った 商 を 3 で 割 った 余 り を C とする
trg = C = ( B // 3 ) % 3
rst = C = ( B // 3 ) % 3 <eos>
2076
src = A の checked の B に C を加えた 値 番目の D に E を加えた 値 番目の とき 、
trg = if A . checked [ B + C ] [ D + E ] :
rst = if A . checked [ B + C ] [ D + E ] : <eos>
2077
src = B を A の number の 0 番 目 にする
trg = A . number [ 0 ] = B
rst = A . number [ 0 ] = B <eos>
2078
src = E の 各要素 に x を パラメータ として 円 周 率 に x を 掛 け た 値を 1 80 . で 割 った 値を返す 関数 を適用した 列 を 展開 し 、 それぞれ A 、 B 、 C 、 D とする
trg = A , B , C , D = map ( lambda F : pi * F / 180. , E )
rst = A , B , C , D = map ( lambda E : E * math . pi / 180. , E ) <eos>
2079
src = A から B を 引 いた 値に C を 掛 け た 値が D から E を 引 いた 値に F を 掛 け た 値 と 等 しく ない とき 、
trg = if ( A - B ) * C != ( D - E ) * F :
rst = if ( A - B ) * C != ( D - E ) * F : <eos>
2080
src = A 内の A の先頭 の 出現 回数 が 4 と 等 しい とき 、
trg = if A . count ( A [ 0 ] ) == 4 :
rst = if A . count ( A [ 0 ] ) == 4 : <eos>
2081
src = D の B から 1 を 引 いた 値 番目の 0 番 目 に A の B から 1 を 引 いた 値 番目の C から D の B -1 番目の 1 番 目 を 引 いた 値 番 目 を加えた 値を A の B 番目の C 番 目 にする
trg = A [ B ] [ C ] = D [ B - 1 ] [ 0 ] + A [ B - 1 ] [ C - D [ B - 1 ] [ 1 ] ]
rst = A [ B ] [ C ] = D [ B - 1 ] [ 0 ] + A [ B - 1 ] [ C - D [ B - 1 ] ] [ 1 ] <eos>
2082
src = B から C を 引 いた 値に D を 掛 け た 値 から E から F を 引 いた 値に G を 掛 け た 値を 引 いた 値を A とする
trg = A = ( B - C ) * D - ( E - F ) * G
rst = A = ( B - C ) * D - ( E - F ) * G <eos>
2083
src = 0 から E 未 満 までの 数 列 の 各要素 を D とし 、 readline () の 両 端 から 空白 改行 を取り 除 いた 文字列 の 各要素 に x を パラメータ として ord ( B ) から C を 引 いた 値を返す 関数 を適用した 列 のリスト の 列 を A とする
trg = A = [ list ( map ( lambda B : ord ( B ) - C , readline ( ) . strip ( ) ) ) for D in range ( E ) ]
rst = A = [ list ( map ( lambda B : int ( B ) - C , readline ( ) . strip ( ) ) ) - C for D in range ( E ) ] <eos>
2084
src = B の neighbor _ dict の C 番 目 を 順に A として 、 繰り返す
trg = for A in B . neighbor_dict [ C ] :
rst = for A in B . neighbor_dict [ C ] : <eos>
2085
src = A を 書式 として B 、 空文字列 を 間 に 入れ て E の 各要素 を D とし 、 C を 書式 として D で 整 形 した 文字列 の 列 を 連結 した 文字列 で 整 形 した 文字列 を出力する
trg = print ( A . format ( B , '' . join ( [ C . format ( D ) for D in E ] ) ) )
rst = print ( A . format ( B , '' . join ( [ str ( C . format ( D ) for D in E ] ) ) ) ) <eos>
2086
src = A の B 番目の C から 1 を 引 いた 値 番 目 が D と 等 しい とき 、
trg = if A [ B ] [ C - 1 ] == D :
rst = if A [ B ] [ C - 1 ] == D : <eos>
2087
src = A . delete ( int ( B ) )
trg = A . delete ( int ( B ) )
rst = A . delete ( int ( B ) ) <eos>
2088
src = B を A の先頭 の 1 番 目 にする
trg = A [ 0 ] [ 1 ] = B
rst = A [ 0 ] [ 1 ] = B <eos>
2089
src = A の 末 尾 に ( ( B , C ) 、 ( D , E ) 、 ( F , G ) 、 ( H , I ) 、 ( J , K ) 、 ( L , M ) ) からなる 辞書 を追加する
trg = A . append ( { 'up' : C , 'front' : E , 'right' : G , 'left' : I , 'back' : K , 'bottom' : M } )
rst = A . append ( { <unk> : C , 'C' : E , 'E' : G , 'A' : I , <unk> : K , <unk> : M } ) <eos>
2090
src = B に C を加えた 値が D 以下 かつ B から C を 引 いた 値が 0 以上 かどうか を A とする
trg = A = ( B + C <= D ) and ( B - C >= 0 )
rst = A = ( B + C <= D and B - C >= 0 ) <eos>
2091
src = number () を A とする
trg = A = number ( )
rst = A = number ( ) <eos>
2092
src = [MASK] の 両 端 キュー を A の Q にする
trg = A . Q = deque ( )
rst = A . Q = deque ( ) <eos>
2093
src = solve ( A , B ) の 最大 値 を出力する
trg = print ( max ( solve ( A , B ) ) )
rst = print ( max ( solve ( A , B ) ) ) <eos>
2094
src = A 、 B の A 番 目 を出力する
trg = print ( A , B [ A ] )
rst = print ( A , B [ A ] ) <eos>
2095
src = B から C を 引 いた 値の 絶対 値を A とする
trg = A = abs ( B - C )
rst = A = abs ( B - C ) <eos>
2096
src = 0.0 0 8 7 26 64 6 25 99 7 1 64 7 88 4 6 18 4 5 38 4 24 4 を A とする
trg = A = 0.00872664625997164788461845384244
rst = A = <unk> <eos>
2097
src = A を 展開 して の 要素を それぞれ 組 にした 列 の 各要素 を B とし 、 B のリスト の 列 を A とする
trg = A = [ list ( B ) for B in zip ( * A ) ]
rst = A = [ list ( B ) for B in zip ( * A ) ] <eos>
2098
src = x を パラメータ として ( - len ( B ) に count [ B ] が 1 より 大きい かどうか を 掛 け た 値 、 x ) の 組 を返す関数 を key として 無限 の 整数 列 の 最小 値を A とする
trg = A = min ( count , key = lambda B : ( - len ( B ) * ( count [ B ] > 1 ) , B ) )
rst = A = min ( A , key = lambda B : ( - len ( B ) * ( B [ 1 ] ) > B . count , B [ 0 ] ) ) <eos>
2099
src = A の B に 1 を加えた 値 番目の C に 1 を加えた 値 番目の とき 、
trg = if A [ B + 1 ] [ C + 1 ] :
rst = if A [ B + 1 ] [ C + 1 ] : <eos>
2100
src = A の先頭 から B を 探 して 見つかった 位置 が 0 以上の とき 、
trg = if A . find ( B ) >= 0 :
rst = if A . find ( B ) >= 0 : <eos>
2101
src = calc _ minkowski _ distance ( B , C , D ) を A とする
trg = A = calc_minkowski_distance ( B , C , D )
rst = A = <unk> ( B , C , D ) <eos>
2102
src = add ( D , E [ C ] ) を D とする
trg = D = add ( D , E [ C ] )
rst = D = add ( D , E [ C ] ) <eos>
2103
src = A の q に B 、 - C を追加した 集 ま り
trg = A . q . add ( B , - C )
rst = A . q . add ( B , - C ) <eos>
2104
src = A の 末 尾 に extract ( B ) を追加する
trg = A . append ( extract ( B ) )
rst = A . append ( <unk> ( B ) ) <eos>
2105
src = B の長さ を A の N にする
trg = A . N = len ( B )
rst = A . N = len ( B ) <eos>
2106
src = A の ( 5 、 4 ) の 組 番目の 各要素 を B とし 、 B に C を加えた 値の 列 を A の ( 6 、 4 ) の 組 番 目 にする
trg = A [ ( 6 , 4 ) ] = [ B + C for B in A [ ( 5 , 4 ) ] ]
rst = A [ ( 4 , 6 ) ] = [ B + C for B in A [ ( 5 , 4 ) ] ] <eos>
2107
src = search _ strongly _ connection ( A , B , C , D , E )
trg = search_strongly_connection ( A , B , C , D , E )
rst = <unk> ( A , B , C , D , E ) <eos>
2108
src = FenwickTree ( B ) を A の bit 1 にする
trg = A . bit1 = FenwickTree ( B )
rst = A . bit1 = FenwickTree ( B ) <eos>
2109
src = delete _ node ( A , B . key )
trg = delete_node ( A , B . key )
rst = delete_node ( A , B . key ) <eos>
2110
src = A の p 1 の x 座標 が A の p 2 の x 座標 と 等 しい とき 、
trg = if A . p1 . x == A . p2 . x :
rst = if A . p1 . x == A . p2 . x : <eos>
2111
src = A の B 番 目 を 2 に A の B 番 目 を 2 で 割 った 商 を 掛 け た 値 だけ 減少 させる
trg = A [ B ] -= 2 * ( A [ B ] // 2 )
rst = A [ B ] -= 2 * ( A [ B ] // 2 ) <eos>
2112
src = A が 、 つまり 改行 文字 と 等 しく ない とき 、
trg = if ( A != '\n' ) :
rst = if A != '\n' : <eos>
2113
src = B を 書式 として C から D を 引 いた 値 で 整 形 した 文字列を A とする
trg = A = B . format ( C - D )
rst = A = B . format ( C - D ) <eos>
2114
src = ( - B 、 C ) からなる 列 を A とする
trg = A = [ - B , C ]
rst = A = [ - B , C ] <eos>
2115
src = A の Zeller ( 2004 , B , C ) 番 目 を出力する
trg = print ( A [ Zeller ( 2004 , B , C ) ] )
rst = print ( A [ <unk> ( 2004 , B , C ) ] ) <eos>
2116
src = A から B を 引 いた 値に C を 掛 け た 値に D を加えた 値に 1 を加えた 値を返す
trg = return ( A - B ) * C + D + 1
rst = return ( A - B ) * C + ( D + 1 ) <eos>
2117
src = A を A の -1 番 目 にする
trg = A [ - 1 ] = A
rst = A [ - 1 ] = A <eos>
2118
src = A . zero () を返す
trg = return A . zero ( )
rst = return A . zero ( ) <eos>
2119
src = ( B 、 0 ) の 組 を A の B 番 目 にする
trg = A [ B ] = ( B , 0 )
rst = A [ B ] = ( B , 0 ) <eos>
2120
src = B に 1 を加えた 値 から C 未 満 までの 数 列 を 反 転 した 列 を 順に A として 、 繰り返す
trg = for A in reversed ( range ( B + 1 , C ) ) :
rst = for A in reversed ( range ( B + 1 , C ) ) : <eos>
2121
src = ( 、 つまり 空文字列 ) からなる 列 の 100 回 分 の 列 を A とする
trg = A = [ '' ] * 100
rst = A = [ '' ] * 100 <eos>
2122
src = A が B から C を 引 いた 値の 2 乗 と 等 しい とき 、
trg = if A == ( B - C ) ** 2 :
rst = if A == ( B - C ) ** 2 : <eos>
2123
src = dfs ( A . index ( max ( A ) ) )
trg = dfs ( A . index ( max ( A ) ) )
rst = dfs ( A . index ( max ( A ) ) ) <eos>
2124
src = A の B 番目の 長さ を 2 で 割 った 余 り が 1 と 等 しい とき 、
trg = if len ( A [ B ] ) % 2 == 1 :
rst = if len ( A [ B ] ) % 2 == 1 : <eos>
2125
src = 0 、 2 の C の n の ビット 長 から 1 を 引 いた 値 乗 を A 、 B とする
trg = A , B = 0 , 2 ** ( ( C . n ) . bit_length ( ) - 1 )
rst = A , B = 0 , 2 ** C . n . bit_length ( ) - 1 <eos>
2126
src = A の B 番目の 1 番 目 が C より 小さい とき 、
trg = if A [ B ] [ 1 ] < C :
rst = if A [ B ] [ 1 ] < C : <eos>
2127
src = dfs ( A + 1, B , C , D , A + 1, E ) の とき 、
trg = if dfs ( A + 1 , B , C , D , A + 1 , E ) :
rst = if dfs ( A + 1 , B , C , D , A + 1 , E ) : <eos>
2128
src = A が B の C に 1 を加えた 値 番 目 より 大きい とき 、
trg = if A > B [ C + 1 ] :
rst = if A > B [ C + 1 ] : <eos>
2129
src = 0 から 1 に B を 1 だけ 右 シフト した 値 を加えた 値 未 満 までの 数 列 を 順に A として 、 繰り返す
trg = for A in range ( 1 + ( B >> 1 ) ) :
rst = for A in range ( 1 + ( B >> 1 ) ) : <eos>
2130
src = A を A に 0.0 5 を 掛 け た 値の 整数値 だけ 増加 させる
trg = A += int ( A * ( 0.05 ) )
rst = A += int ( A * <unk> ) <eos>
2131
src = A に dfs ( B ) を 掛 け た 値を C で 割 った 余 り を A とする
trg = A = A * dfs ( B ) % C
rst = A = A * dfs ( B ) % C <eos>
2132
src = A の 末 尾 に ( B の C 番目の D から 1 を 引 いた 値 番目の とき D 、 そうでなければ D から 1 を 引 いた 値 、 C 、 B の E 番目の F に 1 を加えた 値 番目の とき F 、 そうでなければ F に 1 を加えた 値 、 E 、 G ) の 組 を追加する
trg = A . append ( ( D if B [ C ] [ D - 1 ] else D - 1 , C , F if B [ E ] [ F + 1 ] else F + 1 , E , G ) )
rst = A . append ( ( D if B [ C ] [ D - 1 ] else D - 1 , E , F if B [ C ] [ F + 1 ] else F + 1 , E , G ) ) <eos>
2133
src = A の B 番 目 から B に 5 を加えた 値 までの 部分 列 が C と 等 しい とき 、
trg = if A [ B : B + 5 ] == C :
rst = if A [ B : B + 5 ] == C : <eos>
2134
src = A の B 番 目 が B に 1 を加えた 値 以上の とき 、
trg = if A [ B ] >= B + 1 :
rst = if A [ B ] >= B + 1 : <eos>
2135
src = 空白 文字 に A [ B ] の C 番目の D 番目の 文字列 を加えた 値 を出力する
trg = print ( ' ' + str ( A [ B ] [ C ] [ D ] ) )
rst = print ( ' ' + str ( A [ B ] [ C ] [ D ] ) ) <eos>
2136
src = 6 5 2 80 を A とする
trg = A = 65280
rst = A = 65535 <eos>
2137
src = ( C に ネ イ ピ ア 数の weight を加えた 値 、 D ) の 組 を A の B 番 目 に ソート 順 で 最後に 挿入 する
trg = bisect . insort ( A [ B ] , ( C + e . weight , D ) )
rst = bisect . insort ( A [ B ] , ( C + e . weight , D ) ) <eos>
2138
src = A が B と 等 しく なく なければならない
trg = assert A != B
rst = assert A != B <eos>
2139
src = get ( D ) を C とする を A の B 番 目 にする
trg = A [ B ] = C = get ( D )
rst = A [ B ] = C = get ( D ) <eos>
2140
src = Koch ( B , C ) の 末 尾 を 除 いた 部分 列 に Koch ( D , C ) を加えた 値を A とする
trg = A = Koch ( B , C ) [ : - 1 ] + Koch ( D , C )
rst = A = ( Koch ( B , C ) [ : - 1 ] ) + ( D , C ) <eos>
2141
src = A の 浮動小数点数 を返す
trg = return float ( A )
rst = return float ( A ) <eos>
2142
src = ( -1 、 -1 ) の 組 を A とする
trg = A = ( - 1 , - 1 )
rst = A = ( - 1 , - 1 ) <eos>
2143
src = A . marge _ next _ wait ( B )
trg = A . marge_next_wait ( B )
rst = A . <unk> ( B ) <eos>
2144
src = 空 列 を A の bridges にする
trg = A . bridges = [ ]
rst = A . bridges = [ ] <eos>
2145
src = B が C の長さ より 小さく かつ C の B 番 目 が C の A 番 目 より 大きい とき B 、 そうでなければ A を A とする
trg = A = B if B < len ( C ) and C [ B ] > C [ A ] else A
rst = A = B if B < len ( C ) and C [ B ] > C [ A ] else B <eos>
2146
src = 0 から C の ビット 長 に 1 を加えた 値 未 満 までの 数 列 の 各要素 を B とし 、 、 つまり 空 列 の 列 を A の data にする
trg = A . data = [ [ ] for B in range ( C . bit_length ( ) + 1 ) ]
rst = A . data = [ [ ] for B in range ( C . bit_length ( ) + 1 ) ] <eos>
2147
src = heappush ( A , ( B , C , D , E ) )
trg = heappush ( A , ( B , C , D , E ) )
rst = heappush ( A , ( B , C , D , E ) ) <eos>
2148
src = A に 2 を加えた 値が B の C に 1 を加えた 値 番目の D 番 目 より 小さい とき 、
trg = if A + 2 < B [ C + 1 ] [ D ] :
rst = if A + 2 < B [ C + 1 ] [ D ] : <eos>
2149
src = heappush ( A , - int ( B [ 2 ] ) )
trg = heappush ( A , - int ( B [ 2 ] ) )
rst = heappush ( A , - int ( B [ 2 ] ) ) <eos>
2150
src = dfs ( A , 0 , B )
trg = dfs ( A , 0 , B )
rst = dfs ( A , 0 , B ) <eos>
2151
src = ( 5 、 A の B の 2 番 目 番 目 、 B の 3 番目の 整数値 ) からなる 列 を返す
trg = return [ 5 , A [ B [ 2 ] ] , int ( B [ 3 ] ) ]
rst = return [ 5 , A [ B [ 2 ] ] , int ( B [ 3 ] ) ] <eos>
2152
src = 空文字列 を 間 に 入れ て 、 つまり 逆 順に B を ソート した 列 を 連結 した 文字列 の 整数値 を A とする
trg = A = int ( '' . join ( sorted ( B , reverse = True ) ) )
rst = A = int ( '' . join ( sorted ( B , reverse = True ) ) ) <eos>
2153
src = factor () を 展開 し 、 それぞれ A 、 B とする
trg = A , B = factor ( )
rst = A , B = factor ( ) <eos>
2154
src = A に 13 を 掛 け た 値を B の size で 割 った 余 り を返す
trg = return ( A * 13 ) % B . size
rst = return ( A * 13 ) % B . size <eos>
2155
src = A から B を 引 いた 値が -1 より 大きい とき 、
trg = if A - B > - 1 :
rst = if A - B > - 1 : <eos>
2156
src = A と B の 最大 公 約 数 を返す
trg = return gcd ( A , B )
rst = return gcd ( A , B ) <eos>
2157
src = A 、 B の C 番目の C に 1 を加えた 値 番 目 に B の C に 1 を加えた 値 番目の D に 1 を加えた 値 番 目 を加えた 値の 最大 値を A とする
trg = A = max ( A , B [ C ] [ C + 1 ] + B [ C + 1 ] [ D + 1 ] )
rst = A = max ( A , B [ C ] [ C + 1 ] + B [ C + 1 ] [ D + 1 ] ) <eos>
2158
src = A . front == B . front かつ A . behind == B . behind かつ A . left が B . left と 等 しく かつ A の right が B の right と 等 しく かつ A の top が B の top と 等 しく かつ A の bottom が B の bottom と 等 しい かどうか を返す
trg = return A . front == B . front and A . behind == B . behind and A . left == B . left and A . right == B . right and A . top == B . top and A . bottom == B . bottom
rst = return A . front == B . front and A . behind . year == B . behind and A . left == B . right and A . top == B . bottom and A . top == B . top <eos>
2159
src = f ( A , B , C , D )
trg = f ( A , B , C , D )
rst = f ( A , B , C , D ) <eos>
2160
src = _ get ( A * 2 + 2 , B + 1, C ) を返す
trg = return _get ( A * 2 + 2 , B + 1 , C )
rst = return _get ( A * 2 + 2 , B + 1 , C ) <eos>
2161
src = A の長さ が 1 と 等 しく または B が C [ 1 ] を A [ 1 ] で 割 った 値に 1 を加えた 値の 整数値 以下の 間 、 次 を 繰り返す
trg = while len ( A ) == 1 or B <= int ( C [ 1 ] / A [ 1 ] + 1 ) :
rst = while len ( A ) == 1 or B <= int ( C [ 1 ] / A [ 1 ] ) + 1 : <eos>
2162
src = B 、 trace _ back ( C , D ) の 各要素 を ネ イ ピ ア 数 とし 、 、 つまり ネ イ ピ ア 数の 0 番目の 列 の 最小 値の 最小 値を A とする
trg = A = min ( B , min ( [ e [ 0 ] for e in trace_back ( C , D ) ] ) )
rst = A = min ( B , <unk> ( C , D ) ) [ e [ 0 ] for e in B ] ) <eos>
2163
src = ソート された 順序 を 保 った まま D の B 番目の 整数値 を C に 挿入 できる 位置 の 文字列を A の B 番 目 にする
trg = A [ B ] = str ( bisect . bisect_left ( C , int ( D [ B ] ) ) )
rst = A [ B ] = str ( bisect_left ( C , int ( D [ B ] ) ) ) <eos>
2164
src = A を dfs _ rev ( e , B , C ) だけ 増加 させる
trg = A += dfs_rev ( e , B , C )
rst = A += <unk> ( e , B , C ) <eos>
2165
src = 空文字列 を 間 に 入れ て 0 から 26 未 満 までの 数 列 の 各要素 を D とし 、 、 つまり 文字コード B の 順序 数 に ( C * D + E ) を 26 で 割 った 余 り を加えた 値の 文字 の 列 を 連結 した 文字列を A とする
trg = A = '' . join ( [ chr ( ord ( B ) + ( C * D + E ) % 26 ) for D in range ( 26 ) ] )
rst = A = '' . join ( [ chr ( ord ( B ) + C * ( D + E ) % 26 ) for D in range ( 26 ) ] ) <eos>
2166
src = t を パラメータ として t を 100 で 割 った 商 に 60 を 掛 け た 値に t を 100 で 割 った 余 り を加えた 値を返す 関数を A とする
trg = A = lambda B : ( B // 100 ) * 60 + ( B % 100 )
rst = A = lambda B : B // 100 * 100 + C % 100 <eos>
2167
src = 改行 せずに A の B に 2 を加えた 値 番 目 を出力する
trg = print ( A [ B + 2 ] , end = '' )
rst = print ( A [ B + 2 ] , end = '' ) <eos>
2168
src = A の B に C に D を 掛 け た 値 を加えた 値 番 目 を A の B 番 目 だけ 増加 させる
trg = A [ B + C * D ] += A [ B ]
rst = A [ B + C * D ] += A [ B ] <eos>
2169
src = multi _ lcm ( A ) を返す
trg = return multi_lcm ( A )
rst = return <unk> ( A ) <eos>
2170
src = time ( tuple ( map ( int , input () . split () ) ) )
trg = time ( tuple ( map ( int , input ( ) . split ( ) ) ) )
rst = time ( tuple ( map ( int , input ( ) . split ( ) ) ) ) <eos>
2171
src = B の C に D を加えた 値 番 目 から B の C 番 目 に E を 掛 け た 値を 引 いた 値を F で 割 った 余 り を A とする
trg = A = ( B [ C + D ] - B [ C ] * E ) % F
rst = A = ( B [ C + D ] - B [ C ] * E ) % F <eos>
2172
src = ( 0 ) からなる 列 の B から C を 引 いた 値に 1 を加えた 値 回 分 の 列 を A とする
trg = A = [ 0 ] * ( B - C + 1 )
rst = A = [ 0 ] * ( ( B - C + 1 ) ) <eos>
2173
src = A の left を A の parent の right にする
trg = A . parent . right = A . left
rst = A . parent . right = A . left <eos>
2174
src = F を G で 割 った 余 り を F とする を A の B 番目の C 番目の D 番目の E 番 目 にする
trg = A [ B ] [ C ] [ D ] [ E ] = F = F % G
rst = A [ B ] [ C ] [ D ] [ E ] = F % G <eos>
2175
src = B の C 番目の D を取り 出した 値を A とする
trg = A = B [ C ] . pop ( D )
rst = A = B [ C ] . pop ( D ) <eos>
2176
src = A の B に 2 を 掛 け た 値 番目の C 番 目 が 0 と 等 しい とき 、 つまり 真 、 そうでなければ 、 つまり 偽 を返す
trg = return True if A [ B * 2 ] [ C ] == 0 else False
rst = return True if A [ B * 2 ] [ C ] == 0 else False <eos>
2177
src = A の先頭 を 除 いた 部分 列 を ソート した 列 に ( A の先頭 ) からなる 列 を加えた 値を返す
trg = return sorted ( A [ 1 : ] ) + [ A [ 0 ] ]
rst = return sorted ( A [ 1 : ] ) + sorted ( [ A [ 0 ] ] ) <eos>
2178
src = B から C の D 番 目 を 引 いた 値を 順に A として 、 繰り返す
trg = for A in B - C [ D ] :
rst = for A in B - C [ D ] : <eos>
2179
src = B に C を 掛 け た 値に D に E を加えた 値を 掛 け た 値を A とする
trg = A = B * C * ( D + E )
rst = A = B * C * ( D + E ) <eos>
2180
src = 0 を A の max _ width にする
trg = A . max_width = 0
rst = A . max_width = 0 <eos>
2181
src = A を 36 0.0 だけ 増加 させる
trg = A += 360.0
rst = A += 0.0 <eos>
2182
src = 未 定 値を A の degree にする
trg = A . degree = None
rst = A . degree = None <eos>
2183
src = B の coprime ( C , D ) に coprime ( E , D ) を加えた 値 番 目 を A とする
trg = A = B [ coprime ( C , D ) + coprime ( E , D ) ]
rst = A = B . coprime ( C , D ) + coprime ( E , D ) ] <eos>
2184
src = A の 2 に B を 掛 け た 値に 1 を加えた 値 番 目 、 A の 2 に B を 掛 け た 値に 2 を加えた 値 番目の 最大 値を A の B 番 目 にする
trg = A [ B ] = max ( A [ 2 * B + 1 ] , A [ 2 * B + 2 ] )
rst = A [ B ] = max ( A [ 2 * B + 1 ] , A [ 2 * B + 2 ] ) <eos>
2185
src = A の 1 番 目 から 、 つまり 末 尾 までの 部分 列 を B だけ 増加 させる
trg = A [ 1 : ] += B
rst = A [ 1 : ] += B <eos>
2186
src = A の 総 和 、 B の 総 和 の 最大 値 を出力する
trg = print ( max ( sum ( A ) , sum ( B ) ) )
rst = print ( max ( sum ( A ) , sum ( B ) ) ) <eos>
2187
src = 100 から 0 未 満 までの -1 間隔 の 数 列 を 順に A として 、 繰り返す
trg = for A in range ( 100 , 0 , - 1 ) :
rst = for A in range ( 100 , 0 , - 1 ) : <eos>
2188
src = insertionsort ( A , B , C [ D ] )
trg = insertionsort ( A , B , C [ D ] )
rst = <unk> ( A , B , C [ D ] ) <eos>
2189
src = ( 1 、 A の 1 番 目 、 A の 2 番 目 、 B の 1 番 目 、 B の 2 番 目 ) の 組 を A とする
trg = A = ( 1 , A [ 1 ] , A [ 2 ] , B [ 1 ] , B [ 2 ] )
rst = A = ( 1 , A [ 1 ] , A [ 2 ] , B [ 1 ] , B [ 2 ] ) <eos>
2190
src = ソート された 順序 を 保 った まま C の 1 番目の 整数値 を B に 挿入 できる 最後の 位置 を A とする
trg = A = bisect . bisect_right ( B , int ( C [ 1 ] ) )
rst = A = bisect . bisect_right ( B , int ( C [ 1 ] ) , D ) <eos>
2191
src = A の B 番目の C 番 目 を A の D 番目の E 番 目 だけ 増加 させる
trg = A [ B ] [ C ] += A [ D ] [ E ]
rst = A [ B ] [ C ] += A [ D ] [ E ] <eos>
2192
src = ( 0 、 0 ) からなる 列 に (1) からなる 列 の 9 99 99 99 回 分 の 列 を加えた 値を A とする
trg = A = [ 0 , 0 ] + [ 1 ] * 9999999
rst = A = [ 0 , 0 ] + [ 1 ] * <unk> <eos>
2193
src = 改行 せずに 空白 文字 に A の value の 文字列 を加えた 値 を出力する
trg = print ( ' ' + str ( A . value ) , end = '' )
rst = print ( ' ' + str ( A . value ) , end = '' ) <eos>
2194
src = 空 辞書 を A とする
trg = A = { }
rst = A = { } <eos>
2195
src = 0.5 に 0 から B の長さ 未 満 までの 数 列 の 各要素 を C とし 、 A . cross ( B [ C -1 ] , B [ C ] ) の 列 の 総 和 を 掛 け た 値を返す
trg = return 0.5 * sum ( [ A . cross ( B [ C - 1 ] , B [ C ] ) for C in range ( len ( B ) ) ] )
rst = return 0.5 * sum ( [ A . cross ( B [ C - 1 ] , B [ C ] ) for C in range ( len ( B ) ) ] ) <eos>
2196
src = 0 から B に 1 を加えた 値 未 満 までの 数 列 の 各要素 を C とし 、 B から C を 引 いた 値の 列 の 組 を A とする
trg = A = tuple ( [ B - C for C in range ( B + 1 ) ] )
rst = A = tuple ( [ B - C for C in range ( B + 1 ) ] ) <eos>
2197
src = A の 1 番 目 が B の先頭 の 1 番 目 と 等 しい とき 、
trg = if A [ 1 ] == B [ 0 ] [ 1 ] :
rst = if A [ 1 ] == B [ 0 ] [ 1 ] : <eos>
2198
src = A . isDisjoint ( B , C ) の とき 、
trg = if A . isDisjoint ( B , C ) :
rst = if A . <unk> ( B , C ) : <eos>
2199
src = A が B の C 番 目 に 含まれ ない とき 、
trg = if A not in B [ C ] :
rst = if A not in B [ C ] : <eos>
2200
src = A を 4 で 割 った 余 り が 0 と 等 しく かつ A を 100 で 割 った 余 り が 0 と 等 しく なく または A を 400 で 割 った 余 り が 0 と 等 しい かどうか を返す
trg = return A % 4 == 0 and ( A % 100 != 0 or A % 400 == 0 )
rst = return A % 4 == 0 and ( A % 100 != 0 or A % 400 == 0 ) <eos>
2201
src = ( B を 2 で 割 った 余 り の とき C の B を 2 で 割 った 商 番 目 、 そうでなければ 0 から E に 2 を 掛 け た 値 未 満 までの 数 列 の 各要素 を B とし 、 D の B を 2 で 割 った 商 番目の 列 ) からなる 列 を A とする
trg = A = [ C [ B // 2 ] if B % 2 else [ D [ B // 2 ] for B in range ( E * 2 ) ] ]
rst = A = [ C [ B // 2 ] if B % 2 else [ D // 2 for B in range ( E ) ] ] <eos>
2202
src = B の先頭 の 0 番 目 に B の 2 番目の 先頭 を加えた 値を 2 で 割 った 値を A とする
trg = A = ( B [ 0 ] [ 0 ] + B [ 2 ] [ 0 ] ) / 2
rst = A = ( B [ 0 ] [ 0 ] + B [ 2 ] [ 0 ] ) / 2 <eos>
2203
src = A 、 B に 1 を加えた 値の 文字列 に C を加えた 値 を出力する
trg = print ( A , str ( B + 1 ) + C )
rst = print ( A , str ( B + 1 ) + C ) <eos>
2204
src = A が B から 2 を 引 いた 値 と 等 しく かつ C が D より 小さい とき 、
trg = if A == B - 2 and C < D :
rst = if A == B - 2 and C < D : <eos>
2205
src = check ( B ) を A とする
trg = A = check ( B )
rst = A = check ( B ) <eos>
2206
src = D の C 番目の 各要素 を B とし 、 B が E に 含まれ ない とき の ( B 、 C ) の 組 の 列 を追加し て A を拡張する
trg = A . extend ( [ ( B , C ) for B in D [ C ] if B not in E ] )
rst = A . extend ( [ ( B , C ) for B in D [ C ] if B not in E [ C ] ] ) <eos>
2207
src = 1 から B に C を加えた 値 から 1 を 引 いた 値 未 満 までの 数 列 を 順に A として 、 繰り返す
trg = for A in range ( 1 , B + C - 1 ) :
rst = for A in range ( 1 , B + C - 1 ) : <eos>
2208
src = A の B 番 目 を 2 で 割 った 余 り が 0 と 等 しい とき 、
trg = if A [ B ] % 2 == 0 :
rst = if A [ B ] % 2 == 0 : <eos>
2209
src = A の 末 尾 に query ( B [ 0 ] , B [ 1 ] + 1 ) を追加する
trg = A . append ( query ( B [ 0 ] , B [ 1 ] + 1 ) )
rst = A . append ( query ( B [ 0 ] , B [ 1 ] + 1 ) ) <eos>
2210
src = A が 0 以下 かつ B が 0 以下 かどうか を返す
trg = return A <= 0 and B <= 0
rst = return A <= 0 and B <= 0 <eos>
2211
src = B を C の D 番 目 で 割 った 商 を A とする
trg = A = B // C [ D ]
rst = A = B // ( C [ D ] ) <eos>
2212
src = A の graph の 、 つまり ネ イ ピ ア 数の 1 番 目 番目の 末 尾 に ネ イ ピ ア 数 の先頭 を追加する
trg = A . graph [ e [ 1 ] ] . append ( e [ 0 ] )
rst = A . graph [ e [ 1 ] ] . append ( e [ 0 ] ) <eos>
2213
src = reconstruction ( 0 , len ( A ) )
trg = reconstruction ( 0 , len ( A ) )
rst = reconstruction ( 0 , len ( A ) ) <eos>
2214
src = 0 から C の長さ 未 満 までの 数 列 の 各要素 を D とし 、 B 、 ( 0 ) からなる 列 の C の先頭 の長さ 回 分 の 列 から の配列 の 列 を A とする
trg = A = [ array ( B , [ 0 ] * len ( C [ 0 ] ) ) for D in range ( len ( C ) ) ]
rst = A = [ [ 0 ] * [ len ( C [ 0 ] ) for D in range ( len ( C ) ) ] <eos>
2215
src = A の B の 組 番 目 を 1 を C だけ 左 シフト した 値 と の 論理 和 にする
trg = A [ tuple ( B ) ] |= 1 << C
rst = A [ tuple ( B ) ] |= ( 1 << C ) <eos>
2216
src = C に D を加えた 値 、 E に F を加えた 値を A 、 B とする
trg = A , B = C + D , E + F
rst = A , B = C + D , E + F <eos>
2217
src = A の先頭 から B の 整数値 を 探 して 見つかった 位置
trg = A . find ( int ( B ) )
rst = A . find ( int ( B ) ) <eos>
2218
src = C の 0 番 目 に C の 1 番 目 を加えた 値を A の B 番 目 にする
trg = A [ B ] = C [ 0 ] + C [ 1 ]
rst = A [ B ] = C [ 0 ] + C [ 1 ] <eos>
2219
src = euler _ phi ( A ) を出力する
trg = print ( euler_phi ( A ) )
rst = print ( <unk> ( A ) ) <eos>
2220
src = B から 読み 込 んだ 一行 を 空白 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 の 両 端 キュー を A とする
trg = A = deque ( map ( int , B . readline ( ) . split ( ) ) )
rst = A = deque ( map ( int , B . readline ( ) . split ( ) ) ) <eos>
2221
src = A の先頭 の B から 1 を 引 いた 値 番 目 を A の先頭 の B 番 目 にする
trg = A [ 0 ] [ B ] = A [ 0 ] [ B - 1 ]
rst = A [ 0 ] [ B ] = A [ 0 ] [ B - 1 ] <eos>
2222
src = 整数 の 1 番 目 から A に 1 を加えた 値 までの 部分 列 を出力する
trg = print ( str [ 1 : A + 1 ] )
rst = print ( str [ 1 : A + 1 ] ) <eos>
2223
src = A の -1 番 目 を 1 だけ 減少 させる
trg = A [ - 1 ] -= 1
rst = A [ - 1 ] -= 1 <eos>
2224
src = B を 9 だけ 左 シフト した 値に C を 18 だけ 左 シフト した 値 を加えた 値を A とする
trg = A = ( B << 9 ) + ( C << 18 )
rst = A = ( B << 9 ) + ( C << 18 ) <eos>
2225
src = 3 9 を A とする
trg = A = 39
rst = A = 39 <eos>
2226
src = A の -1 番 目 から A の先頭 を 引 いた 値 を出力する
trg = print ( A [ - 1 ] - A [ 0 ] )
rst = print ( A [ - 1 ] - A [ 0 ] ) <eos>
2227
src = A を ( B 、 C 、 D ) の 組 で 割 った 余 り を出力する
trg = print ( A % ( B , C , D ) )
rst = print ( A % ( B , C , D ) ) <eos>
2228
src = 0 から B の長さ 未 満 までの 13 間隔 の 数 列 を 順に A として 、 繰り返す
trg = for A in range ( 0 , len ( B ) , 13 ) :
rst = for A in range ( 0 , len ( B ) , 13 ) : <eos>
2229
src = A の 末 尾 に Card ( B , int ( C ) ) を追加する
trg = A . append ( Card ( B , int ( C ) ) )
rst = A . append ( <unk> ( B , int ( C ) ) ) <eos>
2230
src = ( ( A から 1 を 引 いた 値 、 B から 1 を 引 いた 値 ) の 組 、 ( A 、 B から 1 を 引 いた 値 ) の 組 、 ( A から 1 を 引 いた 値 、 B ) の 組 、 ( A に 1 を加えた 値 、 B ) の 組 、 ( A から 1 を 引 いた 値 、 B に 1 を加えた 値 ) の 組 、 (
trg = ( ( A - 1 , B - 1 ) , ( A , B - 1 ) , ( A - 1 , B ) , ( A + 1 , B ) , ( A - 1 , B + 1 ) , ( A , B + 1 ) )
rst = A = [ ( A - 1 , B - 1 ) , ( A - 1 , B - 1 ) , ( A , B + 1 ) , ( A , B + 1 ) , ( A , B + 1 ) ] <eos>
2231
src = A に B を 掛 け た 値 から C に D を 掛 け た 値を 引 いた 値の 絶対 値が E に F を加えた 値に G を 掛 け た 値 から H を 引 いた 値 より 小さい とき 、
trg = if abs ( A * B - C * D ) < ( E + F ) * G - H :
rst = if abs ( A * B - C * D ) < ( E + F * G - H ) : <eos>
2232
src = A の value を返す
trg = return A . value
rst = return A . value <eos>
2233
src = B の C を 2 で 割 った 商 から C 番 目 までの 部分 列 を A とする
trg = A = B [ C // 2 : C ]
rst = A = B [ C // 2 : C ] <eos>
2234
src = 0 、 1 を A の B 番 目 、 os . path の B 番 目 とする
trg = A [ B ] , path [ B ] = 0 , 1
rst = A [ B ] , path [ B ] = 0 , 1 <eos>
2235
src = A を B の C に D を加えた 値 番目の E に F を加えた 値 番 目 だけ 増加 させる
trg = A += B [ C + D ] [ E + F ]
rst = A += B [ C + D ] [ E + F ] <eos>
2236
src = C に 5 8 を 掛 け た 値に D を加えた 値を E に 1 を加えた 値 で 割 った 余 り を C とする を A の B 番 目 にする
trg = A [ B ] = C = ( C * 58 + D ) % ( E + 1 )
rst = A [ B ] = C = ( C * 5 + 8 ) % ( D + E + 1 ) <eos>
2237
src = dis ( A , B , 1.0 ) を出力する
trg = print ( dis ( A , B , 1.0 ) )
rst = print ( dis ( A , B , 1.0 ) ) <eos>
2238
src = A の B の長さ から 1 を 引 いた 値 番目の C の長さ から 1 を 引 いた 値 番 目 を出力する
trg = print ( A [ len ( B ) - 1 ] [ len ( C ) - 1 ] )
rst = print ( A [ len ( B ) - 1 ] [ len ( C ) - 1 ] ) <eos>
2239
src = bubbleSort ( A , B ) が selectionSort ( C , B ) と 等 しい とき 、
trg = if bubbleSort ( A , B ) == selectionSort ( C , B ) :
rst = if bubbleSort ( A , B ) == selectionSort ( C , B ) : <eos>
2240
src = 0 から 26 未 満 までの 数 列 の 各要素 を B とし 、 、 つまり 空文字列 の 列 を A とする
trg = A = [ '' for B in range ( 26 ) ]
rst = A = [ '' for B in range ( 26 ) ] <eos>
2241
src = Check ( A , B , C + 1, D , E )
trg = Check ( A , B , C + 1 , D , E )
rst = Check ( A , B , C + 1 , D , E ) <eos>
2242
src = A を dist _ ll ( ( B , C ) , ( D , E ) , ( F , G ) , ( H , I ) ) で 割 った 余 り を出力する
trg = print ( A % dist_ll ( ( B , C ) , ( D , E ) , ( F , G ) , ( H , I ) ) )
rst = print ( A % <unk> ( ( B , C ) , ( D , E ) , ( F , G ) , ( H , I ) ) ) <eos>
2243
src = A の 、 つまり ネ イ ピ ア 数 番 目 が 0 と 等 しく かつ B の 、 つまり ネ イ ピ ア 数 番 目 が 、 つまり 偽 と 等 しい とき 、
trg = if A [ e ] == 0 and B [ e ] == False :
rst = if A [ e ] == 0 and B [ e ] == False : <eos>
2244
src = 0 から D に 1 を加えた 値 から E を 引 いた 値 未 満 までの 数 列 の 各要素 を C とし 、 B の C 番目の 列 を A とする
trg = A = [ B [ C ] for C in range ( D + 1 - E ) ]
rst = A = [ B [ C ] for C in range ( D + 1 - E ) ] <eos>
2245
src = A の head を A の tail の prev にする
trg = A . tail . prev = A . head
rst = A . tail . prev = A . head <eos>
2246
src = A の先頭 を A の 4 番 目 にする
trg = A [ 4 ] = A [ 0 ]
rst = A [ 4 ] = A [ 0 ] <eos>
2247
src = e . add _ flow ( A , B )
trg = e . add_flow ( A , B )
rst = e . flow_with_limit ( A , B ) <eos>
2248
src = A から 1 を 引 いた 値が 0 以上 かつ B の C * 2 番目の A から 1 を 引 いた 値 番 目 が 0 と 等 しく かつ D の C 番目の A から 1 を 引 いた 値 番 目 が E に 1 を加えた 値 より 大きい とき 、
trg = if A - 1 >= 0 and B [ C * 2 ] [ A - 1 ] == 0 and D [ C ] [ A - 1 ] > E + 1 :
rst = if A - 1 >= 0 and B [ C * 2 - 1 ] [ 0 ] == D and C [ A - 1 ] [ E + 1 ] > E + 1 : <eos>
2249
src = 2 に A を 掛 け た 値に 1 を加えた 値が B 以下の とき 、
trg = if 2 * A + 1 <= B :
rst = if 2 * A + 1 <= B : <eos>
2250
src = A の 0 番 目 を 1 だけ 減少 させる
trg = A [ 0 ] -= 1
rst = A [ 0 ] -= 1 <eos>
2251
src = 0 が A より 小さい かどうか が B から 1 を 引 いた 値 より 小さい とき 、
trg = if 0 < A < B - 1 :
rst = if 0 < A < B - 1 : <eos>
2252
src = kesu ( ( A [ 0 ] + 1, A [ 1 ] ) , B , C , D + 1 )
trg = kesu ( ( A [ 0 ] + 1 , A [ 1 ] ) , B , C , D + 1 )
rst = kesu ( ( A [ 0 ] + 1 , A [ 1 ] ) , B , C , D + 1 ) <eos>
2253
src = A が B から 1 を 引 いた 値 より 小さく かつ C の A に 1 を加えた 値 番 目 が 0 と 等 しく ない とき 、
trg = if A < B - 1 and C [ A + 1 ] != 0 :
rst = if A < B - 1 and C [ A + 1 ] != 0 : <eos>
2254
src = B から 読み 込 んだ 一行 の 各要素 に 整数 を適用した 列 を A とする
trg = A = map ( int , B . readline ( ) )
rst = A = map ( int , B . readline ( ) ) <eos>
2255
src = B を A の left _ child にする
trg = A . left_child = B
rst = A . left = B <eos>
2256
src = calc _ LIS ( B ) を A とする
trg = A = calc_LIS ( B )
rst = A = <unk> ( B ) <eos>
2257
src = ( ( 、 つまり 無限大 ) からなる 列 の 0 から B 未 満 までの 数 列 の 各要素 を C とし 、 B の 列 回 分 の 列 ) からなる 列 を A とする
trg = A = [ [ inf ] * [ B for C in range ( B ) ] ]
rst = A = [ [ inf ] * [ B for C in range ( B ) ] ] <eos>
2258
src = A の 末 尾 に B の先頭 の 文字列 に B の 1 番目の 文字列 を加えた 値の 整数値 を追加する
trg = A . append ( int ( str ( B [ 0 ] ) + str ( B [ 1 ] ) ) )
rst = A . append ( int ( str ( B [ 0 ] ) + str ( B [ 1 ] ) ) ) <eos>
2259
src = A の 辞書 カウンタ を A とする
trg = A = Counter ( A )
rst = A = Counter ( A ) <eos>
2260
src = A の parent が 、 つまり 未 定 値 と 等 しい とき 、
trg = if A . parent == None :
rst = if A . parent == None : <eos>
2261
src = A が 50 以下 かつ B の A 番 目 が 0 と 等 しく または B の A 番 目 が C より 大きい とき 、
trg = if ( A <= 50 and B [ A ] == 0 ) or B [ A ] > C :
rst = if A <= 50 and ( B [ A ] == 0 or B [ A ] > C ) : <eos>
2262
src = bfs ( [ building () , building () ] ) を出力する
trg = print ( bfs ( [ building ( ) , building ( ) ] ) )
rst = print ( bfs ( [ <unk> ( ) for A in range ( <unk> ( ) ] ) ) ) <eos>
2263
src = cross ( A , B ) が 0 より 大きい とき 、
trg = if cross ( A , B ) > 0 :
rst = if cross ( A , B ) > 0 : <eos>
2264
src = 入力された 文字列を 空白 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 を 展開 し 、 それぞれ A 、 B 、 B とする
trg = A , B , B = map ( int , input ( ) . split ( ) )
rst = A , B = map ( int , input ( ) . split ( ) ) <eos>
2265
src = C の B に 1 を加えた 値 番 目 を D で 割 った 値を A の先頭 の B 番 目 にする
trg = A [ 0 ] [ B ] = C [ B + 1 ] / D
rst = A [ 0 ] [ B ] = C [ B + 1 ] / D <eos>
2266
src = 無限 の 整数 列 を A の B に 1 を加えた 値 番 目 が 0 より 大きい とき A の B に 1 を加えた 値 番 目 に C を 掛 け た 値 、 そうでなければ A の B に 1 を加えた 値 番 目 に D を 掛 け た 値 だけ 増加 させる
trg = count += A [ B + 1 ] * C if A [ B + 1 ] > 0 else A [ B + 1 ] * D
rst = count += A [ B + 1 ] * C if A [ B + 1 ] > 0 else A [ B + 1 ] * D <eos>
2267
src = D の C 番 目 に C から B を 引 いた 値に 1 を加えた 値を 掛 け た 値 から E の C 番 目 から E の B 番 目 を 引 いた 値に D の B 番 目 を加えた 値を 引 いた 値を A の B 番目の C 番 目 にする
trg = A [ B ] [ C ] = D [ C ] * ( C - B + 1 ) - ( E [ C ] - E [ B ] + D [ B ] )
rst = A [ B ] [ C ] = D [ C ] + ( C - B + 1 ) * ( E [ C ] - E [ C ] ) + B [ D ] <eos>
2268
src = A が B の 文字列 と 等 しい かどうか を返す
trg = return A == str ( B )
rst = return A == str ( B ) <eos>
2269
src = 0 から 3 1 未 満 までの 数 列 の 各要素 を B とし 、 、 つまり 集合 の 列 を A とする
trg = A = [ set ( ) for B in range ( 31 ) ]
rst = A = [ set ( ) for B in range ( 31 ) ] <eos>
2270
src = B と C の 最小 公 倍 数 を A とする
trg = A = lcm ( B , C )
rst = A = lcm ( B , C ) <eos>
2271
src = A の dist を A の v だけ 減少 させる
trg = A . dist -= A . v
rst = A . dist -= A . v <eos>
2272
src = B の 2 番 目 から B の 1 番 目 に C を 掛 け た 値を 引 いた 値を B の先頭 で 割 った 値を A とする
trg = A = ( B [ 2 ] - B [ 1 ] * C ) / B [ 0 ]
rst = A = ( B [ 2 ] - B [ 1 ] * C ) / B [ 0 ] <eos>
2273
src = A の 総 和 を B で 割 った 値の 整数値 を出力する
trg = print ( int ( sum ( A ) / B ) )
rst = print ( int ( sum ( A ) / B ) ) <eos>
2274
src = A の 2 乗 に B の 2 乗 を加えた 値 から C を 引 いた 値が 1 e -8 以下 かつ D の 2 乗 に E の 2 乗 を加えた 値 から C を 引 いた 値が 1 e -8 以下の とき 、
trg = if A ** 2 + B ** 2 - C <= 1e-8 and D ** 2 + E ** 2 - C <= 1e-8 :
rst = if A ** 2 + B ** 2 - C <= 1e-6 and D ** 2 + E ** 2 <= C - 734858 : <eos>
2275
src = C が D より 大きい とき C 、 そうでなければ D を A の B 番目の height にする
trg = A [ B ] . height = C if C > D else D
rst = A [ B ] . height = C if C > D else D <eos>
2276
src = ( findk ( A , B ) 、 未 定 値 ) の 組 を返す
trg = return ( findk ( A , B ) , None )
rst = return ( <unk> ( A , B ) , None ) <eos>
2277
src = ( 、 つまり 未 定 値 ) からなる 列 の A の size 回 分 の 列 を A の nodes にする
trg = A . nodes = [ None ] * A . size
rst = A . nodes = [ None ] * A . size <eos>
2278
src = 0 から 0 x 1 0000 未 満 までの 数 列 の 各要素 を B とし 、 B の 2 進 数 文字列 内の C の 出現 回数 の 列 を A とする
trg = A = [ bin ( B ) . count ( C ) for B in range ( 0x10000 ) ]
rst = A = [ bin ( B ) . count ( C ) for B in range ( <unk> ) ] <eos>
2279
src = ( B 、 C 、 D 、 E 、 空白 文字 ) からなる 列 を A とする
trg = A = [ B , C , D , E , ' ' ]
rst = A = [ B , C , D , E , ' ' ] <eos>
2280
src = Dice ( * [ int ( B ) forBininput () . split ( ' ' ) ] ) を A とする
trg = A = Dice ( * [ int ( B ) for B in input ( ) . split ( ' ' ) ] )
rst = A = Dice ( * [ int ( B ) for B in input ( ) . split ( ' ' ) ] ) <eos>
2281
src = A と B の C 番 目 、 C の 和 集合
trg = A . union ( B [ C ] , C )
rst = A . union ( B [ C ] , C ) <eos>
2282
src = A の sibling を A とする
trg = A = A . sibling
rst = A = A . sibling <eos>
2283
src = A が 、 つまり ネ イ ピ ア 数の cap より 大きい とき 、
trg = if A > e . cap :
rst = if A > e . cap : <eos>
2284
src = A の値 の集まり のリスト を返す
trg = return list ( A . values ( ) )
rst = return list ( A . values ) <eos>
2285
src = A の lpdtop の B 番 目 を A の lpdtop の A の lpdnxt の B 番 目 番 目 にする
trg = A . lpdtop [ A . lpdnxt [ B ] ] = A . lpdtop [ B ]
rst = A . lpdtop [ A . lpdnxt [ B ] ] = A . lpdtop [ B ] <eos>
2286
src = heappush ( A , ( B , C , D , E ^ 1 ) )
trg = heappush ( A , ( B , C , D , E ^ 1 ) )
rst = heappush ( A , ( B , C , D , E ^ 1 ) ) <eos>
2287
src = time を elapsed _ time ( A ) だけ 増加 させる
trg = time += elapsed_time ( A )
rst = time += <unk> ( A ) <eos>
2288
src = D 、 E の 要素を それぞれ 組 にした 列 の 各要素 を B 、 C とし 、 B に C を 掛 け た 値の 列 の 総 和 を A とする
trg = A = sum ( [ B * C for B , C in zip ( D , E ) ] )
rst = A = sum ( [ B * C for B , C in zip ( D , E ) ] ) <eos>
2289
src = ( 0 ) からなる 列 の 6 に ( 1 、 0 、 1 、 0 、 0 、 0 、 0 ) からなる 列 の 4 28 5 7 回 分 の 列 を加えた 値 回 分 の 列 を A とする
trg = A = [ 0 ] * 6 + [ 1 , 0 , 1 , 0 , 0 , 0 , 0 ] * 42857
rst = A = [ 0 ] * 6 + [ 1 , 0 , 1 , 0 , 0 , 4 , 0 , 5 , 7 ] * <unk> <eos>
2290
src = A を dfs ( 0 , B . difference ( { C } ) ) だけ 増加 させる
trg = A += dfs ( 0 , B . difference ( { C } ) )
rst = A += dfs ( 0 , B . difference ( { C } ) ) <eos>
2291
src = A . shuffle ( B )
trg = A . shuffle ( B )
rst = A . <unk> ( B ) <eos>
2292
src = 入力された 文字列を 空白 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 の リストを 展開 し 、 それぞれ A 、 B 、 C 、 D 、 E 、 F とする
trg = A , B , C , D , E , F = list ( map ( int , input ( ) . split ( ) ) )
rst = A , B , C , D , E , F = list ( map ( int , input ( ) . split ( ) ) ) <eos>
2293
src = A の 整数値 を 2 で 割 った 余 り が 0 と 等 しい とき 、
trg = if int ( A ) % 2 == 0 :
rst = if int ( A ) % 2 == 0 : <eos>
2294
src = ( ( B 、 C ) の 組 、 ( D 、 E ) の 組 ) の 組 を A とする
trg = A = ( ( B , C ) , ( D , E ) )
rst = A = ( ( B , C ) , ( D , E ) ) <eos>
2295
src = 1 から E を 2 で 割 った 商 に 1 を加えた 値 未 満 までの 数 列 の 各要素 を B とし 、 ( c ( d ( B , C ) , D ) 、 c ( d ( E - B , C ) , D ) ) からなる 列 の 列 を A とする
trg = A = ( [ [ c ( d ( B , C ) , D ) , c ( d ( E - B , C ) , D ) ] for B in range ( 1 , E // 2 + 1 ) ] )
rst = A = [ [ B . d , C , D ] for B in range ( 1 , E // 2 ) ] , [ B . c ( C , D ) ] <eos>
2296
src = A の先頭 と A の 2 番 目 を 入れ替え る
trg = A [ 0 ] , A [ 2 ] = A [ 2 ] , A [ 0 ]
rst = A [ 0 ] , A [ 2 ] = A [ 0 ] , A [ 2 ] <eos>
2297
src = A の B から 1 を 引 いた 値 番目の C 番 目 に A の B から 1 を 引 いた 値 番目の C に 1 を加えた 値 番 目 を加えた 値を 10 で 割 った 余 り を A の B 番目の C 番 目 にする
trg = A [ B ] [ C ] = ( A [ B - 1 ] [ C ] + A [ B - 1 ] [ C + 1 ] ) % 10
rst = A [ B ] [ C ] = ( A [ B - 1 ] [ C ] + A [ B - 1 ] [ C + 1 ] ) % 10 <eos>
2298
src = A を 3 で 割 った 余 り が 0 と 等 しい 間 、 次 を 繰り返す
trg = while A % 3 == 0 :
rst = while A % 3 == 0 : <eos>
2299
src = rolling _ hash ( B , C , D ) を A とする
trg = A = rolling_hash ( B , C , D )
rst = A = <unk> ( B , C , D ) <eos>
2300
src = A から B を 引 いた 値が 、 つまり 集合 と 等 しい とき 、
trg = if A - B == set ( ) :
rst = if A - B == set ( ) : <eos>
2301
src = A の集合 の長さ が B の集合 の長さ より 大きい とき 、
trg = if len ( set ( A ) ) > len ( set ( B ) ) :
rst = if len ( set ( A ) ) > len ( set ( B ) ) : <eos>
2302
src = 2 に E から F を 引 いた 値を 掛 け た 値を D とする
trg = D = 2 * ( E - F )
rst = D = 2 * ( E - F ) <eos>
2303
src = heappush ( A , ( B + 1, 1, C ) )
trg = heappush ( A , ( B + 1 , 1 , C ) )
rst = heappush ( A , ( B + 1 , C ) ) <eos>
2304
src = B の C 番 目 を A の B の長さ から C を 引 いた 値 から 1 を 引 いた 値 番目の C 番 目 にする
trg = A [ len ( B ) - C - 1 ] [ C ] = B [ C ]
rst = A [ len ( B ) - C - 1 ] [ C ] = B [ C ] <eos>
2305
src = B の 2 乗 に C の 2 乗 を加えた 値 から D の 2 乗 を 引 いた 値に E の 2 乗 を 掛 け た 値を A とする
trg = A = ( B ** 2 + C ** 2 - D ** 2 ) * E ** 2
rst = A = ( B ** 2 + C ** 2 - D ** 2 ) * E ** 2 <eos>
2306
src = ( 0 、 1 、 5 、 4 ) からなる 列 を A とする
trg = A = [ 0 , 1 , 5 , 4 ]
rst = A = [ 0 , 1 , 5 , 4 ] <eos>
2307
src = 100 を返す
trg = return 100
rst = return 100 <eos>
2308
src = A の値 の集まり の 総 和 を 1000 7 で 割 った 余 り を返す
trg = return sum ( A . values ( ) ) % 10007
rst = return sum ( A . values ( ) ) % 10007 <eos>
2309
src = A の B に 1 を加えた 値 番目の C から 1 を 引 いた 値 番 目 が D から 2 を 引 いた 値 と 等 しい とき 、
trg = if A [ B + 1 ] [ C - 1 ] == D - 2 :
rst = if A [ B + 1 ] [ C - 1 ] == D - 2 : <eos>
2310
src = ( ( B 、 C ) の 組 ) からなる 列 を追加し て A を拡張する
trg = A . extend ( [ ( B , C ) ] )
rst = A . extend ( [ ( B , C ) ] ) <eos>
2311
src = ( ( ( 0 、 B から 1 を 引 いた 値 ) の 組 , 0 ) ) からなる 辞書 を A とする
trg = A = { (0, L-1) : 0 }
rst = A = { (0, 0, 1) : 0 } <eos>
2312
src = 0 を A の先頭 の 2 番 目 にする
trg = A [ 0 ] [ 2 ] = 0
rst = A [ 0 ] [ 2 ] = 0 <eos>
2313
src = A を B で 割 った 余 り 、 B を C で 割 った 余 り を A 、 B とする
trg = A , B = A % B , B % C
rst = A , B = A % B , B % C <eos>
2314
src = A に対応する 値 、 も し 存在 し なければ B の とき 、
trg = if A . get ( B ) :
rst = if A . get ( B , 0 ) : <eos>
2315
src = D を A の 、 つまり 文字コード B の 順序 数 に C を加えた 値の 文字 番 目 にする
trg = A [ chr ( ord ( B ) + C ) ] = D
rst = A [ chr ( B ) + C ] = D <eos>
2316
src = A . heappush ( B , Node [ T ] ( C , 0 ) )
trg = A . heappush ( B , Node[T] ( C , 0 ) )
rst = A . heappush ( B , [ Node ( C , 0 ) ] ) <eos>
2317
src = A の 末 尾 に B の C 番目の 文字列 に B の D 番目の 文字列 を加えた 値の 整数値 を追加する
trg = A . append ( int ( str ( B [ C ] ) + str ( B [ D ] ) ) )
rst = A . append ( int ( str ( B [ C ] ) + str ( B [ D ] ) ) ) <eos>
2318
src = A の 末 尾 に dot ( orthogonal ( B ) , C ) を追加する
trg = A . append ( dot ( orthogonal ( B ) , C ) )
rst = A . append ( orthogonal ( B ) , C ) <eos>
2319
src = A の B 番目の C 番 目 を D の B 番目の E 番目の 整数値 に F の E 番目の C 番目の 整数値 を 掛 け た 値 だけ 増加 させる
trg = A [ B ] [ C ] += int ( D [ B ] [ E ] ) * int ( F [ E ] [ C ] )
rst = A [ B ] [ C ] += int ( D [ B ] [ E ] ) * int ( F [ E ] [ C ] ) <eos>
2320
src = B の 1 番 目 から 、 つまり 末 尾 までの 部分 列 を 順に A として 、 繰り返す
trg = for A in B [ 1 : ] :
rst = for A in B [ 1 : ] : <eos>
2321
src = A を 12 で 割 った 余 り が 9 と 等 しく ない とき 、
trg = if A % 12 != 9 :
rst = if A % 12 != 9 : <eos>
2322
src = B から B の 整数値 を 引 いた 値を A とする
trg = A = B - int ( B )
rst = A = B - int ( B ) <eos>
2323
src = ( 0 ) からなる 列 に A を加えた 値に ( 0 ) からなる 列 を加えた 値を A とする
trg = A = [ 0 ] + A + [ 0 ]
rst = A = [ 0 ] + A + [ 0 ] <eos>
2324
src = A の 末 尾 の 末 尾 が A の -2 番目の 末 尾 に B を加えた 値 から C を 引 いた 値 より 大きい とき 、
trg = if A [ - 1 ] [ - 1 ] > A [ - 2 ] [ - 1 ] + B - C :
rst = if A [ - 1 ] [ - 1 ] > A [ - 2 ] [ B + C ] : <eos>
2325
src = A に 1 を加えた 値を B で 割 った 余 り を返す
trg = return ( A + 1 ) % B
rst = return ( A + 1 ) % B <eos>
2326
src = A . __ class __ ( B , C , D , E , F , G ) を返す
trg = return A . __class__ ( B , C , D , E , F , G )
rst = return A . __class__ ( B , C , D , E , F , G ) <eos>
2327
src = D に C を 掛 け た 値に B に E を 掛 け た 値 を加えた 値を F とする
trg = F = ( D * C + B * E )
rst = F = D * C + B * E <eos>
2328
src = 0 から 26 から 3 を 引 いた 値 未 満 までの 数 列 を 順に A として 、 繰り返す
trg = for A in range ( 26 - 3 ) :
rst = for A in range ( 26 - 3 ) : <eos>
2329
src = A の B 番目の C 番目の D 番 目 が E より 小さく または B が F に G を 掛 け た 値 と 等 しい とき 、
trg = if A [ B ] [ C ] [ D ] < E or B == F * G :
rst = if A [ B ] [ C ] [ D ] < E or B == F * G : <eos>
2330
src = heappush ( A [ B [ 1 ]] , - B [ 2 ] )
trg = heappush ( A [ B [ 1 ] ] , - B [ 2 ] )
rst = heappush ( A [ B [ 1 ] ] , - B [ 2 ] ) <eos>
2331
src = B の needle の 各要素 を C とし 、 B . _ hash ( C , D ) の 列 を A とする
trg = A = [ B . _hash ( C , D ) for C in B . needle ]
rst = A = [ B . _hash ( C , D ) for C in B . needle ] <eos>
2332
src = A の B 番目の C 番目の D 番 目 に E を加えた 値を A の B 番目の C 番目の D 番 目 にする
trg = A [ B ] [ C ] [ D ] = A [ B ] [ C ] [ D ] + E
rst = A [ B ] [ C ] [ D ] = A [ B ] [ C ] [ D ] + E <eos>
2333
src = A の graph の B 番目の 長さ を A の iter の B 番 目 にする
trg = A . iter [ B ] = len ( A . graph [ B ] )
rst = A . iter [ B ] = len ( A . graph [ B ] ) <eos>
2334
src = A の B 番 目 、 C の 最小 値を A の B 番 目 にする
trg = A [ B ] = min ( A [ B ] , C )
rst = A [ B ] = min ( A [ B ] , C ) <eos>
2335
src = D を A の B から 1 を 引 いた 値 から C を 引 いた 値 番目の C 番 目 にする
trg = A [ B - 1 - C ] [ C ] = D
rst = A [ B - 1 - C ] [ C ] = D <eos>
2336
src = Tree ( 0 , B ) を A の 1 番 目 にする
trg = A [ 1 ] = Tree ( 0 , B )
rst = A [ 1 ] = Tree ( 0 , B ) <eos>
2337
src = A を 書式 として B に 1 を加えた 値 、 C の B 番 目 に D を 掛 け た 値 で 整 形 した 文字列 を出力する
trg = print ( A . format ( B + 1 , C [ B ] * D ) )
rst = print ( A . format ( B + 1 , C [ B ] * D ) ) <eos>
2338
src = write ( A % min ( count ( B , 2 ) , count ( B , 5 ) ) )
trg = write ( A % min ( count ( B , 2 ) , count ( B , 5 ) ) )
rst = write ( A % min ( count ( B , 2 ) , count ( B , 5 ) ) ) <eos>
2339
src = A を 6 で 割 った 値の 整数値 を出力する
trg = print ( int ( A / 6 ) )
rst = print ( int ( A / 6 ) ) <eos>
2340
src = A に A を加えた 値を A とする
trg = A = A + A
rst = A = A + A <eos>
2341
src = 0 から 100 未 満 までの 数 列 の 各要素 を B とし 、 ( 0 、 B に 1 を加えた 値 ) からなる 列 の 列 を A とする
trg = A = [ [ 0 , B + 1 ] for B in range ( 100 ) ]
rst = A = [ [ 0 , B + 1 ] for B in range ( 100 ) ] <eos>
2342
src = A に B を加えた 値に C を加えた 値が 0 と 等 しい とき 、
trg = if A + B + C == 0 :
rst = if A + B + C == 0 : <eos>
2343
src = process _ command ( A , B )
trg = process_command ( A , B )
rst = <unk> ( A , B ) <eos>
2344
src = ( B の 5 番 目 、 B の 4 番 目 、 B の先頭 、 B の 1 番 目 ) からなる 列 を A の list _ sn にする
trg = A . list_sn = [ B [ 5 ] , B [ 4 ] , B [ 0 ] , B [ 1 ] ]
rst = A . list_sn = [ B [ 5 ] , B [ 4 ] , B [ 0 ] , B [ 1 ] ] <eos>
2345
src = 空文字列 を 間 に 入れ て ( A が B に 含まれ ない とき C の A 番 目 、 そうでなければ range ( F ) の 各要素 を A とし 、 ( DifC [ A ] == EelseE ) の 列 ) からなる 列 を 連結 した 文字列 を出力する
trg = print ( '' . join ( [ C [ A ] if A not in B else [ ( D if C [ A ] == E else E ) for A in range ( F ) ] ] ) )
rst = print ( '' . join ( [ C [ A [ B ] if A not in B else [ ( A == C for A in range ( F ) ] ] ) for A in range ( B ) ] ) ) <eos>
2346
src = B の 1 を 2 で 割 った 値 乗 の 整数値 から 0 未 満 までの -1 間隔 の 数 列 を 順に A として 、 繰り返す
trg = for A in range ( int ( B ** ( 1 / 2 ) ) , 0 , - 1 ) :
rst = for A in range ( int ( B ** ( 1 / 2 ) ) , 0 , - 1 ) : <eos>
2347
src = C 、 C の 1 番 目 から 、 つまり 末 尾 までの 部分 列 に ( C の先頭 ) からなる 列 を加えた 値の 要素を それぞれ 組 にした 列 を 順に A 、 B として 、 繰り返す
trg = for A , B in zip ( C , C [ 1 : ] + [ C [ 0 ] ] ) :
rst = for A , B in zip ( C , C [ 1 : ] + [ C [ 0 ] ] ) : <eos>
2348
src = " H { } " を返す
trg = return H{Y-1988}
rst = return <unk> <eos>
2349
src = D の 、 つまり 先頭 から E 番 目 までの 部分 列 、 D の E 番 目 から 、 つまり 末 尾 までの 部分 列 の 要素を それぞれ 組 にした 列 の 各要素 を B 、 C とし 、 ( B 、 C ) からなる 列 の 列 を A とする
trg = A = [ [ B , C ] for B , C in zip ( D [ : E ] , D [ E : ] ) ]
rst = A = [ [ B , C ] for B , C in zip ( D [ : E ] , D [ E : ] ) ] <eos>
2350
src = ( 5 、 1 ) からなる 列 を A の 4 番 目 にする
trg = A [ 4 ] = [ 5 , 1 ]
rst = A [ 4 ] = [ 5 , 1 ] <eos>
2351
src = ( A から 1 を 引 いた 値 、 B ) の 組 を返す
trg = return ( A - 1 , B )
rst = return ( A - 1 , B ) <eos>
2352
src = 1 を A の B を C で 割 った 商 を D で 割 った 余 り 番 目 にする
trg = A [ ( B // C ) % D ] = 1
rst = A [ B // C % D ] = 1 <eos>
2353
src = A を getPaintCount ( B [ C ] , D ) だけ 増加 させる
trg = A += getPaintCount ( B [ C ] , D )
rst = A += <unk> ( B [ C ] , D ) <eos>
2354
src = A の C から 1 を 引 いた 値 番 目 、 A の B から 1 を 引 いた 値 番 目 を A の B から 1 を 引 いた 値 番 目 、 A の C から 1 を 引 いた 値 番 目 とする
trg = A [ B - 1 ] , A [ C - 1 ] = A [ C - 1 ] , A [ B - 1 ]
rst = A [ B - 1 ] , A [ C - 1 ] = A [ C - 1 ] , A [ B - 1 ] <eos>
2355
src = MinCostFlow ( 2 * B + 2 ) を A とする
trg = A = MinCostFlow ( 2 * B + 2 )
rst = A = MinCostFlow ( 2 * B + 2 ) <eos>
2356
src = A の height の とき 、
trg = if A . height :
rst = if A . height : <eos>
2357
src = 入力された 文字列を 空白 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 を 展開 し 、 それぞれ A 、 B 、 A 、 C とする
trg = A , B , A , C = map ( int , input ( ) . split ( ) )
rst = A , B , C = map ( int , input ( ) . split ( ) ) <eos>
2358
src = A が 99 99 99 以上の とき 、
trg = if A >= 999999 :
rst = if A >= <unk> : <eos>
2359
src = B に 5 を 掛 け た 値に C に 3 を 掛 け た 値 を加えた 値を A とする
trg = A = B * 5 + C * 3
rst = A = B * 5 + C * 3 <eos>
2360
src = - B を A の 0 番 目 にする
trg = A [ 0 ] = - B
rst = A [ 0 ] = - B <eos>
2361
src = A の B 番 目 が C より 大きい かどうか を返す
trg = return A [ B ] > C
rst = return A [ B ] > C <eos>
2362
src = A に B の C 番目の D 番 目 を追加した 集 ま り
trg = A . add ( B [ C ] [ D ] )
rst = A . add ( B [ C ] [ D ] ) <eos>
2363
src = is _ in _ ABC ( A ) でない とき 、
trg = if ( not is_in_ABC ( A ) ) :
rst = if not <unk> ( A ) : <eos>
2364
src = A の長さ が B の長さ 以上の とき 、
trg = if len ( A ) >= len ( B ) :
rst = if len ( A ) >= len ( B ) : <eos>
2365
src = A の B 番目の C 番 目 が 0 と 等 しい かどうか
trg = A [ B ] [ C ] == 0
rst = A [ B ] [ C ] == 0 <eos>
2366
src = 4 5 を A とする
trg = A = 45
rst = A = 45 <eos>
2367
src = ( B 、 C 、 D 、 E 、 F 、 G 、 H 、 I 、 J 、 K 、 L ) からなる 列 を A とする
trg = A = [ B , C , D , E , F , G , H , I , J , K , L ]
rst = A = [ B , C , D , E , F , G , H , I , J , K , L , M ] <eos>
2368
src = C に B を 掛 け た 値を D で 割 った 余 り を C とする を A の B 番 目 にする
trg = A [ B ] = C = C * B % D
rst = A [ B ] = C = C * B % D <eos>
2369
src = A の 末 尾 に B の C の D の E 番 目 と 等 しい 要素 の最初の 位置 番 目 を追加する
trg = A . append ( B [ C . index ( D [ E ] ) ] )
rst = A . append ( B [ C . index ( D [ E ] ) ] ) <eos>
2370
src = calc _ d ( B [ 0 ] , B [ C ] ) を A とする
trg = A = calc_d ( B [ 0 ] , B [ C ] )
rst = A = <unk> ( B [ 0 ] , B [ C ] ) <eos>
2371
src = 空白 文字 を 間 に 入れ て A の 文字列 のリスト の 各要素 に 整数 を適用した 列 を 連結 した 文字列 を出力する
trg = print ( ' ' . join ( map ( str , list ( str ( A ) ) ) ) )
rst = print ( ' ' . join ( map ( str , list ( A ) ) ) ) <eos>
2372
src = fibonacci ( int ( input () ) ) を出力する
trg = print ( fibonacci ( int ( input ( ) ) ) )
rst = print ( fibonacci ( int ( input ( ) ) ) ) <eos>
2373
src = B に 2 を 掛 け た 値に 1 を加えた 値 、 C 、 D 、 E を追加し て A を 更新 する
trg = A . update ( B * 2 + 1 , C , D , E )
rst = A . update ( B * 2 + 1 , C , D , E ) <eos>
2374
src = min _ capacity ( B , C , D ) を A とする
trg = A = min_capacity ( B , C , D )
rst = A = _min ( B , C , D ) <eos>
2375
src = heappush ( A , ( B + 1, ( C , D ) ) )
trg = heappush ( A , ( B + 1 , ( C , D ) ) )
rst = heappush ( A , ( B + 1 , ( C , D ) ) ) <eos>
2376
src = calc ( A ) が 0 と 等 しい とき 、
trg = if calc ( A ) == 0 :
rst = if calc ( A ) == 0 : <eos>
2377
src = A の 末 尾 に ( -1 、 2 に [MASK] を加えた 値 ) の 組 を追加する
trg = A . append ( ( - 1 , + 2 ) )
rst = A . append ( ( - 1 , + 2 ) ) <eos>
2378
src = B に 1 を加えた 値 、 A の 最大 値を A とする
trg = A = max ( B + 1 , A )
rst = A = max ( B + 1 , A ) <eos>
2379
src = B 、 C を D で 割 った 商 の 最小 値を A とする
trg = A = min ( B , C // D )
rst = A = min ( B , C // D ) <eos>
2380
src = 入力された 文字列 の 文字列を A とする
trg = A = str ( input ( ) )
rst = A = str ( input ( ) ) <eos>
2381
src = margeSort ( A , 0 , len ( A ) )
trg = margeSort ( A , 0 , len ( A ) )
rst = <unk> ( A , 0 , len ( A ) ) <eos>
2382
src = ( ( 0 、 0 ) の 組 、 ( -1 、 1 ) の 組 、 ( 0 、 1 ) の 組 、 ( 1 、 1 ) の 組 、 ( 0 、 2 ) の 組 ) からなる 列 を A とする
trg = A = [ ( 0 , 0 ) , ( - 1 , 1 ) , ( 0 , 1 ) , ( 1 , 1 ) , ( 0 , 2 ) ]
rst = A = [ ( 0 , 0 ) , ( - 1 , 1 ) , ( 0 , 1 ) , ( 1 , 1 ) , ( 0 , 2 ) ] <eos>
2383
src = BIT ( dfs ( 0 , 1 ) ) を A とする
trg = A = BIT ( dfs ( 0 , 1 ) )
rst = A = BIT ( 0 , 1 ) <eos>
2384
src = A の 末 尾 に B の 順序 数 から C を 引 いた 値に 27 を加えた 値 を追加する
trg = A . append ( ord ( B ) - C + 27 )
rst = A . append ( ord ( B ) - C + 27 ) <eos>
2385
src = ( 1 、 5 、 10 、 50 、 100 、 500 、 1000 ) からなる 列 を A とする
trg = A = [ 1 , 5 , 10 , 50 , 100 , 500 , 1000 ]
rst = A = [ 1 , 5 , 10 , 50 , 100 , 500 , 1000 ] <eos>
2386
src = A の 末 尾 に B の 、 つまり 先頭 から C 番 目 までの 部分 列 を追加する
trg = A . append ( B [ : C ] )
rst = A . append ( B [ : C ] ) <eos>
2387
src = A の とき A 、 そうでなければ B の 最大 値 を出力する
trg = print ( A if A else max ( B ) )
rst = print ( max ( A if A else B ) ) <eos>
2388
src = ( 0 ) からなる 列 の 2019 回 分 の 列 を A とする
trg = A = [ 0 ] * 2019
rst = A = [ 0 ] * 2019 <eos>
2389
src = A . ListIterator ( B ) を返す
trg = return A . ListIterator ( B )
rst = return A . <unk> ( B ) <eos>
2390
src = 0 から 1000 1 未 満 までの 数 列 の 各要素 を B とし 、 C の B 番目の とき の B の 列 を A とする
trg = A = [ B for B in range ( 10001 ) if C [ B ] ]
rst = A = [ B for B in range ( 10001 ) if C [ B ] ] <eos>
2391
src = 0 が A より 小さい かどうか が 1 より 小さく かつ 0 が B より 小さい かどうか が 1 より 小さく かつ 0 が C より 小さい かどうか が 1 より 小さい かどうか を返す
trg = return 0 < A < 1 and 0 < B < 1 and 0 < C < 1
rst = return 0 < A < 1 and 0 < B < 1 and 0 < C < 1 <eos>
2392
src = D に 番号 付 した 組 の 列 の 各要素 を B 、 C とし 、 C の先頭 が ( E 、 F ) の 組 と 等 しい とき の B の 列 の先頭 を A とする
trg = A = [ B for B , C in enumerate ( D ) if C [ 0 ] == ( E , F ) ] [ 0 ]
rst = A = [ B for B , C in enumerate ( D ) if C [ 0 ] == E [ F ] ] [ 0 ] <eos>
2393
src = A . push ( 0 , B )
trg = A . push ( 0 , B )
rst = A . push ( 0 , B ) <eos>
2394
src = 入力された 文字列 の 整数値 を 無限 の 整数 列 とする
trg = count = int ( input ( ) )
rst = count = int ( input ( ) ) <eos>
2395
src = value ( A , B ) が value ( A , C ) より 小さい とき 、
trg = if value ( A , B ) < value ( A , C ) :
rst = if value ( A , B ) < value ( A , C ) : <eos>
2396
src = x を パラメータ として x の 2 番 目 を返す関数 を key として A を ソート する
trg = A . sort ( key = lambda B : B [ 2 ] )
rst = A . sort ( key = lambda B : B [ 2 ] ) <eos>
2397
src = A を 3 60 で 割 った 値に 2 を 掛 け た 値に 円 周 率 を 掛 け た 値を A とする
trg = A = ( A / 360 ) * 2 * math . pi
rst = A = A / 360 * 2 * pi <eos>
2398
src = B から 1 を 引 いた 値を 2 で 割 った 商 を A とする
trg = A = ( B - 1 ) // 2
rst = A = ( B - 1 ) // 2 <eos>
2399
src = A を B の B の C と 等 しい 要素 の最初の 位置 に D を 掛 け た 値に E を加えた 値を 26 で 割 った 余 り 番 目 だけ 増加 させる
trg = A += B [ ( B . index ( C ) * D + E ) % 26 ]
rst = A += B [ ( B . index ( C ) * D + E ) % 26 ] <eos>
2400
src = A の B の 2 番 目 が A の 2 番 目 以上 かどうか 番 目 を A とする
trg = A = A [ B [ 2 ] >= A [ 2 ] ]
rst = A = A [ B [ 2 ] >= A [ 2 ] ] <eos>
2401
src = D に 1 を加えた 値を C とする を A の B 番 目 にする
trg = A [ B ] = C = D + 1
rst = A [ B ] = C = D + 1 <eos>
2402
src = ( 1 、 1 ) からなる 列 に ( 0 ) からなる 列 の 、 つまり 入力された 文字列 の 整数値 から 1 を 引 いた 値 回 分 の 列 を加えた 値を A とする
trg = A = [ 1 , 1 ] + [ 0 ] * ( int ( input ( ) ) - 1 )
rst = A = [ 1 , 1 ] + [ 0 ] * ( int ( input ( ) ) - 1 ) <eos>
2403
src = max _ profit ( A ) を出力する
trg = print ( max_profit ( A ) )
rst = print ( <unk> ( A ) ) <eos>
2404
src = ( 0 、 空 列 ) の 組 を返す
trg = return ( 0 , [ ] )
rst = return ( 0 , [ ] ) <eos>
2405
src = A が B の C 番目の D 番 目 と 等 しく かつ E の C 番目の D 番 目 が 、 つまり 未 定 値 と 等 しい とき 、
trg = if A == B [ C ] [ D ] and E [ C ] [ D ] == None :
rst = if A == B [ C ] [ D ] and E [ C ] [ D ] == None : <eos>
2406
src = D の B から C を 引 いた 値 番 目 を E だけ 増加 させる
trg = D [ B - C ] += E
rst = D [ B - C ] += E <eos>
2407
src = 0 が A 以下 でない とき 、
trg = if not 0 <= A :
rst = if not 0 <= A : <eos>
2408
src = A が B の limit 以下 かつ A を 12 で 割 った 余 り が 1 と 等 しく または A を 12 で 割 った 余 り が 5 と 等 しい とき 、
trg = if A <= B . limit and ( A % 12 == 1 or A % 12 == 5 ) :
rst = if A <= B . limit and ( A % 12 == 1 or A % 12 == 5 ) : <eos>
2409
src = 2 、 0 を A 、 B とする
trg = A , B = 2 , 0
rst = A , B = 2 , 0 <eos>
2410
src = D の B 番目の E に C を加えた 値 番 目 を A の B 番目の C 番 目 にする
trg = A [ B ] [ C ] = D [ B ] [ E + C ]
rst = A [ B ] [ C ] = D [ B ] [ E + C ] <eos>
2411
src = A 、 B の 最大 値を そうでなければ 、 とする
trg = else = max ( A , B )
rst = else = max ( A , B ) <eos>
2412
src = A の real が 0 以上の とき 、
trg = if A . real >= 0 :
rst = if A . real >= 0 : <eos>
2413
src = 2 の 64 乗 から 1 を 引 いた 値を A の mask にする
trg = A . mask = 2 ** 64 - 1
rst = A . mask = 2 ** 64 - 1 <eos>
2414
src = triangle _ check ( B , C , D ) を A とする
trg = A = triangle_check ( B , C , D )
rst = A = <unk> ( B , C , D ) <eos>
2415
src = A [ B ] [ C ] の D 番目の D 番 目 に A [ B ] [ C ] の E 番目の E 番 目 を加えた 値を 10 0000 で 割 った 余 り を出力する
trg = print ( ( A [ B ] [ C ] [ D ] [ D ] + A [ B ] [ C ] [ E ] [ E ] ) % 100000 )
rst = print ( ( A [ B ] [ C ] [ D ] + A [ B ] [ C ] [ E ] [ E ] ) % 100000 ) <eos>
2416
src = A . printl ( 3 )
trg = A . printl ( 3 )
rst = A . <unk> ( 3 ) <eos>
2417
src = A の 末 尾 に B の C 番 目 に 空白 文字 を加えた 値に B の D 番 目 を加えた 値 を追加する
trg = A . append ( B [ C ] + ' ' + B [ D ] )
rst = A . append ( B [ C ] + ' ' + B [ D ] ) <eos>
2418
src = enqueue ( 1, A , B , C , D )
trg = enqueue ( 1 , A , B , C , D )
rst = enqueue ( 1 , A , B , C , D ) <eos>
2419
src = G に C を加えた 値を 60 で 割 った 余 り を F とする
trg = F = ( G + C ) % 60
rst = F = ( G + C ) % 60 <eos>
2420
src = A に 1 を加えた 値が B より 小さく かつ C の D 番目の A 番 目 が C の D 番目の A に 1 を加えた 値 番 目 と 等 しい とき 、
trg = if A + 1 < B and C [ D ] [ A ] == C [ D ] [ A + 1 ] :
rst = if A + 1 < B and C [ D ] [ A ] == C [ D ] [ A + 1 ] : <eos>
2421
src = B の C 番 目 から C に 3 を加えた 値 までの 部分 列 を A とする
trg = A = B [ C : C + 3 ]
rst = A = B [ C : C + 3 ] <eos>
2422
src = 2 の 3 1 乗 を A とする
trg = A = 2 ** 31
rst = A = 2 ** 31 <eos>
2423
src = D の先頭 、 D の 1 番 目 、 E の先頭 を A 、 B 、 C とする
trg = A , B , C = D [ 0 ] , D [ 1 ] , E [ 0 ]
rst = A , B , C = D [ 0 ] , D [ 1 ] , E [ 0 ] <eos>
2424
src = A に B の C 番 目 に D を 掛 け た 値 を加えた 値が 1000 以下の とき 、
trg = if A + B [ C ] * D <= 1000 :
rst = if A + B [ C ] * D <= 1000 : <eos>
2425
src = A の 8 番 目 を 1 だけ 増加 させる
trg = A [ 8 ] += 1
rst = A [ 8 ] += 1 <eos>
2426
src = B に ネ イ ピ ア 数 を加えた 値に C を加えた 値を 2 で 割 った 値を A とする
trg = A = ( B + e + C ) / 2
rst = A = ( B + e + C ) / 2 <eos>
2427
src = A の 末 尾 に 現在の 日 時 を追加する
trg = A . append ( now )
rst = A . append ( now ) <eos>
2428
src = A の 3 番 目 が 1 と 等 しい とき 、
trg = if A [ 3 ] == 1 :
rst = if A [ 3 ] == 1 : <eos>
2429
src = A の par の to を A とする
trg = A = A . par . to
rst = A = A . par . to <eos>
2430
src = A の B 番 目 、 E の 要素を それぞれ 組 にした 列 の 各要素 を C 、 D とし 、 C 、 D の 最大 値の 列 を A の B 番目の 、 つまり 先頭 から 、 つまり 末 尾 までの 部分 列 にする
trg = A [ B ] [ : ] = ( [ max ( C , D ) for C , D in zip ( A [ B ] , E ) ] )
rst = A [ B ] [ : ] = max ( [ max ( C , D ) for C , D in zip ( A [ B ] , E ) ] ) <eos>
2431
src = B の C 番目の D 番目の 整数値 を A とする
trg = A = int ( B [ C ] [ D ] )
rst = A = int ( B [ C ] [ D ] ) <eos>
2432
src = 空文字列 を 間 に 入れ て A の 各要素 に 整数 を適用した 列 を 連結 した 文字列 を出力する
trg = print ( '' . join ( map ( str , A ) ) )
rst = print ( '' . join ( map ( str , A ) ) ) <eos>
2433
src = 1 から B に 2 を加えた 値 未 満 までの 数 列 を 順に A として 、 繰り返す
trg = for A in range ( 1 , B + 2 ) :
rst = for A in range ( 1 , B + 2 ) : <eos>
2434
src = 5 5 を A とする
trg = A = 55
rst = A = 52 <eos>
2435
src = 0 から 10 未 満 までの 数 列 の B 個 までの コン ビ ネ ー ション の 各要素 を A とし 、 A の 総 和 の 列 内の C の 出現 回数 を出力する
trg = print ( [ sum ( A ) for A in combinations ( range ( 10 ) , B ) ] . count ( C ) )
rst = print ( sum ( [ sum ( A . count ( C ) for A in combinations ( range ( 10 ) , B ) , C ) ] ) ) <eos>
2436
src = B . op ( C , B . rt [ -1 ] [ 1 ] ) を A とする
trg = A = B . op ( C , B . rt [ - 1 ] [ 1 ] )
rst = A = B . op ( C , B . rt [ - 1 ] [ 1 ] ) <eos>
2437
src = A の B 番目の C 番 目 かつ D の C 番 目 が E と 等 しい とき 、
trg = if A [ B ] [ C ] and D [ C ] == E :
rst = if A [ B ] [ C ] and D [ C ] == E : <eos>
2438
src = A が 、 つまり 無限大 より 小さい とき 、
trg = if A < inf :
rst = if A < inf : <eos>
2439
src = B の 各要素 を A とし 、 C 内の ( A の先頭 、 A の 1 番 目 ) からなる 列 の 出現 回数 が D 以上の とき の ( A の先頭 、 A の 1 番 目 ) の 組 の 列 を A とする
trg = A = [ ( A [ 0 ] , A [ 1 ] ) for A in B if C . count ( [ A [ 0 ] , A [ 1 ] ] ) >= D ]
rst = A = [ ( A [ 0 ] , A [ 1 ] ) for A in B if C . count ( A [ 0 ] ) >= D ] <eos>
2440
src = str ( A [ 0 ] ) に ' ' を加えた 値に A [ B ] の 文字列 を加えた 値に 空白 文字 を加えた 値に C の 文字列 を加えた 値 を出力する
trg = print ( str ( A [ 0 ] ) + ' ' + str ( A [ B ] ) + ' ' + str ( C ) )
rst = print ( str ( A [ 0 ] ) + ' ' + str ( A [ B ] ) + ' ' + str ( C ) ) <eos>
2441
src = B の C 番 目 に D を加えた 値 から B の E 番 目 を 引 いた 値を A とする
trg = A = B [ C ] + D - B [ E ]
rst = A = B [ C ] + D - B [ E ] <eos>
2442
src = B を 6 で 割 った 値を A とする
trg = A = B / 6
rst = A = B / 6 <eos>
2443
src = B の 上位 1 個の 出現 頻 度 順 の 列 を A とする
trg = A = B . most_common ( 1 )
rst = A = B . most_common ( 1 ) <eos>
2444
src = B の 正 弦 に C の 余 弦 を 掛 け た 値を A とする
trg = A = math . sin ( B ) * math . cos ( C )
rst = A = sin ( B ) * math . cos ( C ) <eos>
2445
src = answer ( A , True )
trg = answer ( A , True )
rst = <unk> ( A , True ) <eos>
2446
src = C から 読み 込 んだ 一行 の 両 端 から 空白 改行 を取り 除 いた 文字列を 空白 で 分割 した 字句 列 を 展開 し 、 それぞれ A 、 B とする
trg = A , B = C . readline ( ) . strip ( ) . split ( )
rst = A , B = C . readline ( ) . strip ( ) . split ( ) <eos>
2447
src = dice ( B [ C ] . pip ) を A とする
trg = A = dice ( B [ C ] . pip )
rst = A = dice ( B [ C ] . pip ) <eos>
2448
src = A の 末 尾 に B . min ( C [ 0 ] , C [ 1 ] ) を追加する
trg = A . append ( B . min ( C [ 0 ] , C [ 1 ] ) )
rst = A . append ( B . min ( C [ 0 ] , C [ 1 ] ) ) <eos>
2449
src = B に C から D を 引 いた 値を 掛 け た 値に E に F から G を 引 いた 値を 掛 け た 値 を加えた 値に H に I から J を 引 いた 値を 掛 け た 値 を加えた 値を A とする
trg = A = B * ( C - D ) + E * ( F - G ) + H * ( I - J )
rst = A = B * ( C - D ) + E * ( F - G ) + H * ( I - J ) <eos>
2450
src = A の 末 尾 に input () を 空白 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 のリスト の 総 和 を追加する
trg = A . append ( sum ( list ( map ( int , input ( ) . split ( ) ) ) ) )
rst = A . append ( sum ( list ( map ( int , input ( ) . split ( ) ) ) ) ) <eos>
2451
src = A . is _ orthogonal ( B , C ) を返す
trg = return A . is_orthogonal ( B , C )
rst = return A . is_orthogonal ( B , C ) <eos>
2452
src = ( A 、 B ) からなる 列 の dfs ( 7 , 7 , 1 ) 番 目 を出力する
trg = print ( [ A , B ] [ dfs ( 7 , 7 , 1 ) ] )
rst = print ( [ A , B ] [ dfs ( 7 , 7 , 1 ) ] ) <eos>
2453
src = B の 末 尾 から C を 逆 順に 探 して 見つかった 位置 を A とする
trg = A = B . rfind ( C )
rst = A = B . find ( C , reverse = True ) <eos>
2454
src = A に B を加えた 値が C 以下 または A に B を加えた 値が D 以下 かつ E に F [ A + B ] を加えた 値 から G を 引 いた 値が A に B を加えた 値 から C を 引 いた 値 と 等 しい とき 、
trg = if ( A + B <= C ) or ( A + B <= D and ( E + F [ A + B ] - G ) == ( A + B - C ) ) :
rst = if A + B <= C or A + B <= D and E + F [ A + B ] - G == C : <eos>
2455
src = ( A 、 B 、 C 、 D 、 E 、 F ) の 組 を返す
trg = return ( A , B , C , D , E , F )
rst = return ( A , B , C , D , E , F ) <eos>
2456
src = C 、 D の 要素を それぞれ 組 にした 列 を 順に A 、 B として 、 繰り返す
trg = for A , B in zip ( C , D ) :
rst = for A , B in zip ( C , D ) : <eos>
2457
src = dfs ( B + 1, C / / 10 ) を A とする
trg = A = dfs ( B + 1 , C // 10 )
rst = A = dfs ( B + 1 , C // 10 ) <eos>
2458
src = A . connected ( e . src , e . dest ) でない とき 、
trg = if not A . connected ( e . src , e . dest ) :
rst = if not A . connected ( e . src , e . dest ) : <eos>
2459
src = matrix () を A とする
trg = A = matrix ( )
rst = A = <unk> ( ) <eos>
2460
src = - E から F を 引 いた 値を D とする
trg = D = - E - F
rst = D = - ( E - F ) <eos>
2461
src = A が 50 以上の とき 、
trg = if A >= 50 :
rst = if A >= 50 : <eos>
2462
src = A 、 B から C を 引 いた 値に D を 掛 け た 値に E から F を 引 いた 値 を加えた 値の 絶対 値の 最小 値を A とする
trg = A = min ( A , abs ( ( B - C ) * D + ( E - F ) ) )
rst = A = min ( A , abs ( ( B - C ) * D + abs ( E - F ) ) ) <eos>
2463
src = A の 、 つまり 先頭 から B から C を 引 いた 値 までの 部分 列 が D の C 番 目 から B 番 目 までの 部分 列 と 等 しく ない とき 、
trg = if A [ : B - C ] != D [ C : B ] :
rst = if A [ : B - C ] != D [ C : B ] : <eos>
2464
src = B が 3 と 等 しい とき C 、 そうでなければ C に D に B から 1 を 引 いた 値を 掛 け た 値 を加えた 値を A とする
trg = A = C if B == 3 else C + D * ( B - 1 )
rst = A = C if B == 3 else C + D * ( B - 1 ) <eos>
2465
src = A の 、 つまり 先頭 から 2 番 目 までの 部分 列 が B と 等 しく かつ A の 末 尾 が C と 等 しく かつ D が A に含まれる とき 、
trg = if A [ : 2 ] == B and A [ - 1 ] == C and D in A :
rst = if A [ : 2 ] == B and A [ - 1 ] == C and D in A : <eos>
2466
src = A が 1 と 等 しく または A が 6 と 等 しい とき B 、 そうでなければ C を出力する
trg = print ( B if A == 1 or A == 6 else C )
rst = print ( B if A == 1 or A == 6 else C ) <eos>
2467
src = 4 を 底 とする B の 対 数の 整数値 を A とする
trg = A = int ( math . log ( B , 4 ) )
rst = A = int ( math . log ( B , 4 ) ) <eos>
2468
src = B に 100 に C を加えた 値を 掛 け た 値を 100 で 割 った 商 に D に 100 に C を加えた 値を 掛 け た 値を 100 で 割 った 商 を加えた 値を A とする
trg = A = ( B * ( 100 + C ) // 100 ) + ( D * ( 100 + C ) // 100 )
rst = A = B * ( 100 + C ) // 100 + D * ( 100 + C ) // 100 <eos>
2469
src = A を B から C を 引 いた 値に D から E を 引 いた 値を 掛 け た 値が 0 より 大きい とき B から C を 引 いた 値の 絶対 値 、 D から E を 引 いた 値の 絶対 値の 最大 値 、 そうでなければ B から C を 引 いた 値の 絶対 値に D から E を 引 いた 値の 絶対 値 を加えた 値 だけ 増加 させる
trg = A += max ( abs ( B - C ) , abs ( D - E ) ) if ( B - C ) * ( D - E ) > 0 else abs ( B - C ) + abs ( D - E )
rst = A += max ( abs ( B - C ) * ( D - E ) , abs ( B - C ) + abs ( D - E ) ) if abs ( B - C ) * ( D - E ) + abs ( B - C
2470
src = 未 定 値を A の root にする
trg = A . root = None
rst = A . root = None <eos>
2471
src = B と 1 の 論理 積 が 0 より 大きい かどうか を A とする
trg = A = ( ( B & 1 ) > 0 )
rst = A = ( ( B & 1 ) > 0 ) <eos>
2472
src = B の先頭 の長さ から 2 を 引 いた 値 から -1 未 満 までの -1 間隔 の 数 列 を 順に A として 、 繰り返す
trg = for A in range ( len ( B [ 0 ] ) - 2 , - 1 , - 1 ) :
rst = for A in range ( len ( B [ 0 ] ) - 2 , - 1 , - 1 ) : <eos>
2473
src = ( 13 、 17 、 19 、 23 ) からなる 列 を A とする
trg = A = [ 13 , 17 , 19 , 23 ]
rst = A = [ 13 , 17 , 19 , 23 ] <eos>
2474
src = 0 が A 以下 かどうか が 8 より 小さく かつ 0 が B 以下 かどうか が 8 より 小さい とき 、
trg = if 0 <= A < 8 and 0 <= B < 8 :
rst = if 0 <= A < 8 and 0 <= B < 8 : <eos>
2475
src = B の C 番 目 に B の C に 1 を加えた 値 番 目 を加えた 値を A とする
trg = A = B [ C ] + B [ C + 1 ]
rst = A = B [ C ] + B [ C + 1 ] <eos>
2476
src = A の B 番目の C 番目の D 番 目 が 0 と 等 しい とき 、
trg = if A [ B ] [ C ] [ D ] == 0 :
rst = if A [ B ] [ C ] [ D ] == 0 : <eos>
2477
src = A の 末 尾 に B の hldnxt の C 番 目 を追加する
trg = A . append ( B . hldnxt [ C ] )
rst = A . append ( B . hldnxt [ C ] ) <eos>
2478
src = A の B 番 目 が C から D を 引 いた 値 から E の B 番 目 を 引 いた 値 以上の とき 、
trg = if A [ B ] >= C - D - E [ B ] :
rst = if A [ B ] >= C - D - E [ B ] : <eos>
2479
src = B の C 番 目 、 未 定 値を A 、 B の C 番 目 とする
trg = A , B [ C ] = B [ C ] , None
rst = A , B [ C ] = B [ C ] , None <eos>
2480
src = 0 から B 未 満 までの 数 列 を 順に A として 、 繰り返す
trg = for A in range ( B ) :
rst = for A in range ( B ) : <eos>
2481
src = A が 1 と 等 しく または B が 1 と 等 しい とき 、
trg = if A == 1 or B == 1 :
rst = if A == 1 or B == 1 : <eos>
2482
src = A . roll ( B . SOUTH )
trg = A . roll ( B . SOUTH )
rst = A . roll ( B . <unk> ) <eos>
2483
src = B の 2 個 までの 重複 コン ビ ネ ー ション を A とする
trg = A = combinations_with_replacement ( B , 2 )
rst = A = itertools . combinations_with_replacement ( B , 2 ) <eos>
2484
src = 10 を repeat として ( 0 、 1 ) からなる 列 と [MASK] の 直 積 を 順に A として 、 繰り返す
trg = for A in product ( [ 0 , 1 ] , repeat = 10 ) :
rst = for A in product ( [ 0 , 1 ] , repeat = 10 ) : <eos>
2485
src = ( -1 、 0 、 1 、 -2 、 -2 、 -2 、 2 、 2 、 2 、 -1 、 0 、 1 ) からなる 列 を A とする
trg = A = [ - 1 , 0 , 1 , - 2 , - 2 , - 2 , 2 , 2 , 2 , - 1 , 0 , 1 ]
rst = A = [ - 1 , 0 , 1 , - 2 , - 2 , 2 , 2 , 2 , - 2 , - 1 , 0 , 1 ] <eos>
2486
src = solve _ gcd ( A [ 0 ] , B ) を返す
trg = return solve_gcd ( A [ 0 ] , B )
rst = return <unk> ( A [ 0 ] , B ) <eos>
2487
src = ( B に C に 2 を加えた 値を 掛 け た 値 ) からなる 列 に 0 から E 未 満 までの 数 列 の 各要素 を D とし 、 B に input () を加えた 値に B を加えた 値の 列 を加えた 値に ( B に C に 2 を加えた 値を 掛 け た 値 ) からなる 列 を加えた 値を A とする
trg = A = [ B * ( C + 2 ) ] + [ B + input ( ) + B for D in range ( E ) ] + [ B * ( C + 2 ) ]
rst = A = [ B * ( C + 2 ) ] + [ B + input ( ) + B for D in range ( E ) ] + [ B * ( C + 2 ) ] <eos>
2488
src = 空 列 を A の rank にする
trg = A . rank = [ ]
rst = A . rank = [ ] <eos>
2489
src = ( ( 0 、 0 ) からなる 列 ) からなる 列 の 6 回 分 の 列 を A とする
trg = A = [ [ 0 , 0 ] ] * 6
rst = A = [ [ 0 , 0 ] * 6 <eos>
2490
src = A 内の B を C 、 D で 置き換え た 文字列
trg = A . replace ( B , C , D )
rst = A . replace ( B , C , D ) <eos>
2491
src = A 、 1 の 最小 値を A とする
trg = A = min ( A , 1 )
rst = A = min ( A , 1 ) <eos>
2492
src = A . push ( None )
trg = A . push ( None )
rst = A . push ( None ) <eos>
2493
src = 0 を A の B 番目の C から D を 引 いた 値 から 1 を 引 いた 値 番 目 にする
trg = A [ B ] [ C - D - 1 ] = 0
rst = A [ B ] [ C - D - 1 ] = 0 <eos>
2494
src = A から 10 を 引 いた 値を返す
trg = return A - 10
rst = return A - 10 <eos>
2495
src = A 、 B の 0 番 目 から 1989 を 引 いた 値に 1 を加えた 値 、 B の 1 番 目 、 B の 2 番 目 を出力する
trg = print ( A , B [ 0 ] - 1989 + 1 , B [ 1 ] , B [ 2 ] )
rst = print ( A , B [ 0 ] - 1989 + 1 , B [ 1 ] , B [ 2 ] ) <eos>
2496
src = A を calc ( [ B , C , D , E , F -1 ] ) に G の 4 番 目 を 掛 け た 値 だけ 増加 させる
trg = A += calc ( [ B , C , D , E , F - 1 ] ) * G [ 4 ]
rst = A += calc ( [ B , C , D , E , F - 1 ] ) * G [ 4 ] <eos>
2497
src = 1 から 14 未 満 までの 数 列 を 順に A として 、 繰り返す
trg = for A in range ( 1 , 14 ) :
rst = for A in range ( 1 , 14 ) : <eos>
2498
src = 2 に B を加えた 値を A とする
trg = A = 2 + B
rst = A = 2 + B <eos>
2499
src = B . cross ( Vector ( B . pt 1, C . pt 1 ) ) の 絶対 値を A とする
trg = A = abs ( B . cross ( Vector ( B . pt1 , C . pt1 ) ) )
rst = A = abs ( B . cross ( Vector ( B . pt1 , C . pt1 ) ) ) <eos>
2500
src = A の先頭 から B を 探 して 見つかった 位置 が A の先頭 から C を 探 して 見つかった 位置 と 等 しく ない かどうか を返す
trg = return A . find ( B ) != A . find ( C )
rst = return A . find ( B ) != A . find ( C ) <eos>
2501
src = A に B を 掛 け た 値に C に D を 掛 け た 値 を加えた 値を A の 2 乗 に C の 2 乗 を加えた 値 で 割 った 余 り が 1 より 小さく かつ A に D を 掛 け た 値 から C に B を 掛 け た 値を 引 いた 値を A の 2 乗 に C の 2 乗 を加えた 値 で 割 った 余 り が 1 より 小さい とき
trg = if ( A * B + C * D ) % ( A ** 2 + C ** 2 ) < 1 and ( A * D - C * B ) % ( A ** 2 + C ** 2 ) < 1 :
rst = if ( A * B + C * D ) % ( A ** 2 + C ** 2 ) and ( A * B - C ** 2 ) % ( 1 + D ** 2 ) < ( A * C ** 2 ) : <eos>
2502
src = A が ( B 、 C ) からなる 列 に含まれる とき 、
trg = if A in [ B , C ] :
rst = if A in [ B , C ] : <eos>
2503
src = A を B から C を 引 いた 値の 絶対 値に D から E を 引 いた 値の 絶対 値 を加えた 値 だけ 増加 させる
trg = A += abs ( B - C ) + abs ( D - E )
rst = A += abs ( B - C ) + abs ( D - E ) <eos>
2504
src = post _ from _ pre _ in ( A , B )
trg = post_from_pre_in ( A , B )
rst = in_order_from ( A , B ) <eos>
2505
src = A の B の imag に C の imag を加えた 値の 整数値 番目の B の real に C の real を加えた 値の 整数値 番目の とき 、
trg = if A [ int ( B . imag + C . imag ) ] [ int ( B . real + C . real ) ] :
rst = if int ( A [ B . imag + C . imag ] . real ) : <eos>
2506
src = A - B が 6 以上 かつ C [ B ] が D に 含まれ かつ C の B に 1 を加えた 値 番 目 かつ C の B に 1 を加えた 値 番 目 が E に 含まれ かつ C の A から 1 を 引 いた 値 番 目 が F に含まれる とき 、
trg = if A - B >= 6 and C [ B ] in D and C [ B + 1 ] and C [ B + 1 ] in E and C [ A - 1 ] in F :
rst = if A >= B and C [ B ] in D and C [ B + 1 ] and C [ B + 1 ] in E and C [ B - 1 ] in F : <eos>
2507
src = A の B と 等 しい 要素 の最初の 位置 に 1 を加えた 値が 2020 より 小さく かつ A の A の B と 等 しい 要素 の最初の 位置 に 1 を加えた 値 番 目 が 200 と 等 しい とき 、
trg = if A . index ( B ) + 1 < 2020 and A [ A . index ( B ) + 1 ] == 200 :
rst = if A . index ( B ) + 1 < A . index ( B ) + 1 ] == 200 : <eos>
2508
src = B の C 番 目 から D の C 番 目 を 引 いた 値の 絶対 値を A とする
trg = A = abs ( B [ C ] - D [ C ] )
rst = A = abs ( B [ C ] - D [ C ] ) <eos>
2509
src = A の B 番 目 が C より 小さい とき A の B 番 目 、 そうでなければ D を出力する
trg = print ( A [ B ] if A [ B ] < C else D )
rst = print ( A [ B ] if A [ B ] < C else D ) <eos>
2510
src = A かつ B に 10 を加えた 値が 21 以下の 間 、 次 を 繰り返す
trg = while A and B + 10 <= 21 :
rst = while A and B + 10 <= 21 : <eos>
2511
src = 1 から 12 に 1 を加えた 値 未 満 までの 数 列 を 順に A として 、 繰り返す
trg = for A in range ( 1 , 12 + 1 ) :
rst = for A in range ( 1 , 12 + 1 ) : <eos>
2512
src = A が B と 等 しく なく かつ C が A の right と 等 しい 間 、 次 を 繰り返す
trg = while A != B and C == A . right :
rst = while A != B and C == A . right : <eos>
2513
src = 0 から 5 を 底 とする 1 e 6 の 対 数の 切り 上げ 整数値 に 1 を加えた 値 未 満 までの 数 列 を 順に A として 、 繰り返す
trg = for A in range ( ceil ( log ( 1e6 , 5 ) ) + 1 ) :
rst = for A in range ( ceil ( log ( 1e6 , 56 ) ) + 1 ) : <eos>
2514
src = 1 を C とする
trg = C = 1
rst = C = 1 <eos>
2515
src = A の B から C を 引 いた 値 番 目 を ネ イ ピ ア 数 とする
trg = e = A [ B - C ]
rst = e = A [ B - C ] <eos>
2516
src = 2 から B の長さ 未 満 までの 2 間隔 の 数 列 を 順に A として 、 繰り返す
trg = for A in range ( 2 , len ( B ) , 2 ) :
rst = for A in range ( 2 , len ( B ) , 2 ) : <eos>
2517
src = A の 2 番目の 1 番 目 が A の先頭 の 1 番 目 と 等 しい とき 、
trg = if A [ 2 ] [ 1 ] == A [ 0 ] [ 1 ] :
rst = if A [ 2 ] [ 1 ] == A [ 0 ] [ 1 ] : <eos>
2518
src = C から 0 未 満 までの -1 間隔 の 数 列 、 D の 要素を それぞれ 組 にした 列 を 順に A 、 B として 、 繰り返す
trg = for A , B in zip ( range ( C , 0 , - 1 ) , D ) :
rst = for A , B in zip ( range ( C , 0 , - 1 ) , D ) : <eos>
2519
src = ( A に 1.0 を 掛 け た 値 、 B に 1.0 を 掛 け た 値 ) の 組 を返す
trg = return ( A * 1.0 , B * 1.0 )
rst = return ( A * 1.0 , B * 1.0 ) <eos>
2520
src = B の 浮動小数点数 を A の slope にする
trg = A . slope = float ( B )
rst = A . slope = float ( B ) <eos>
2521
src = f ( B ) を 10 で 割 った 商 を A とする
trg = A = f ( B ) // 10
rst = A = f ( B ) // 10 <eos>
2522
src = x を パラメータ として x の real を返す関数 を key として B の 最小 値を A とする
trg = A = min ( B , key = lambda C : C . real )
rst = A = min ( B , key = lambda C : C . real ) <eos>
2523
src = bst _ insert ( A , B ) を A とする
trg = A = bst_insert ( A , B )
rst = A = bst_insert ( A , B ) <eos>
2524
src = A の B 番目の C 番 目 内の D と 等 しい 要素を 取り除く
trg = A [ B ] [ C ] . remove ( D )
rst = A [ B ] [ C ] . remove ( D ) <eos>
2525
src = compute _ lcs ( B , C ) を A とする
trg = A = compute_lcs ( B , C )
rst = A = <unk> ( B , C ) <eos>
2526
src = 1 が A の B 番目の 長さ より 小さい とき 、
trg = if 1 < len ( A [ B ] ) :
rst = if 1 < len ( A [ B ] ) : <eos>
2527
src = A が 2 に B を 掛 け た 値 より 大きい とき 、
trg = if A > 2 * B :
rst = if A > 2 * B : <eos>
2528
src = 1 500 1 を A とする
trg = A = 15001
rst = A = <unk> <eos>
2529
src = B の B の 最小 値 と 等 しい 要素 の最初の 位置 を A とする
trg = A = B . index ( min ( B ) )
rst = A = B . index ( min ( B ) ) <eos>
2530
src = A の 末 尾 に ( A の B 番目の 先頭 、 A の B 番目の 1 番 目 に 1 を加えた 値 ) からなる 列 を追加する
trg = A . append ( [ A [ B ] [ 0 ] , A [ B ] [ 1 ] + 1 ] )
rst = A . append ( [ A [ B ] [ 0 ] , A [ B ] [ 1 ] + 1 ] ) <eos>
2531
src = A が 5 より 小さい とき 、
trg = if A < 5 :
rst = if A < 5 : <eos>
2532
src = 1 を A の先頭 の B の C 番 目 番 目 にする
trg = A [ 0 ] [ B [ C ] ] = 1
rst = A [ 0 ] [ B [ C ] ] = 1 <eos>
2533
src = Euc ( A , B , C ) の先頭 、 Euc ( A , B , C ) の 1 番 目 を出力する
trg = print ( Euc ( A , B , C ) [ 0 ] , Euc ( A , B , C ) [ 1 ] )
rst = print ( <unk> ( A , B , C ) [ 0 ] , <unk> ( A , B , C ) [ 1 ] ) <eos>
2534
src = A 、 B の 最大 値を返す
trg = return max ( A , B )
rst = return max ( A , B ) <eos>
2535
src = B と C 、 A の コン ビ ネ ー ション を A とする
trg = A = comb ( B , C , A )
rst = A = B , C , A <eos>
2536
src = A の 2 に B を 掛 け た 値に 1 を加えた 値 番 目 が 4 より 小さい とき 、
trg = if A [ 2 * B + 1 ] < 4 :
rst = if A [ 2 * B + 1 ] < 4 : <eos>
2537
src = max _ param ( A ) 、 max _ param ( B ) 、 max _ param ( C ) の 最大 値 を出力する
trg = print ( max ( max_param ( A ) , max_param ( B ) , max_param ( C ) ) )
rst = print ( max ( <unk> ( A ) , <unk> ( B ) , <unk> ( C ) ) ) <eos>
2538
src = A の B 番目の 1 番 目 が A の B から 1 を 引 いた 値 番目の 1 番 目 と 等 しく ない とき 、
trg = if A [ B ] [ 1 ] != A [ B - 1 ] [ 1 ] :
rst = if A [ B ] [ 1 ] != A [ B - 1 ] [ 1 ] : <eos>
2539
src = A [ B ]- A [ B - C ]- A [ B - D ] から A [ B - E ] を 引 いた 値に A の B - ( C + D ) 番 目 を加えた 値に A の B から ( D + E ) を 引 いた 値 番 目 を加えた 値に A の B から E に C を加えた 値を 引 いた 値 番 目 を加えた 値 から A の B から C に
trg = return A [ B ] - A [ B - C ] - A [ B - D ] - A [ B - E ] + A [ B - ( C + D ) ] + A [ B - ( D + E ) ] + A [ B - ( E + C ) ] - A [ B - ( C + D + E ) ]
rst = A [ B - A [ B ] - C - A [ B - D ] - A [ B + E ] + A [ B - C + D ] + A [ B - ( C + D ) ] + A [ B - E
2540
src = ネ イ ピ ア 数が 1 と 等 しい とき 、
trg = if e == 1 :
rst = if e == 1 : <eos>
2541
src = A の B 番 目 、 A の C 番 目 に D の C 番目の B 番 目 を加えた 値の 最小 値を A の B 番 目 にする
trg = A [ B ] = min ( A [ B ] , A [ C ] + D [ C ] [ B ] )
rst = A [ B ] = min ( A [ B ] , A [ C ] + D [ C ] [ B ] ) <eos>
2542
src = 0 から B の size 未 満 までの 数 列 の 各要素 を A とし 、 test ( A ) の とき の 1 の 列 の 総 和 を返す
trg = return sum ( [ 1 for A in range ( B . size ) if test ( A ) ] )
rst = return sum ( [ 1 for A in range ( B . size ) if re . test ( A ) ] ) <eos>
2543
src = A の 1.0 を B で 割 った 値 乗 を返す
trg = return A ** ( 1.0 / B )
rst = return A ** ( 1.0 / B ) <eos>
2544
src = A の siz を 1 だけ 減少 させる
trg = A . siz -= 1
rst = A . siz -= 1 <eos>
2545
src = scc ( C , D , E ) を 展開 し 、 それぞれ A 、 B とする
trg = A , B = scc ( C , D , E )
rst = A , B = <unk> ( C , D , E ) <eos>
2546
src = G の H 番 目 を 空白 で 分割 した 字句 列 の 各要素 を F とし 、 F の 浮動小数点数 の 列 を 展開 し 、 それぞれ A 、 B 、 C 、 D 、 ネ イ ピ ア 数 、 E とする
trg = A , B , C , D , e , E = [ float ( F ) for F in G [ H ] . split ( ) ]
rst = A , B , C , D , e , E = [ float ( F ) for F in G [ H ] . split ( ) ] <eos>
2547
src = A を ( 0 、 1 ) からなる 列 の B が B の 逆 順 と 等 しい かどうか 番 目 だけ 増加 させる
trg = A += [ 0 , 1 ] [ B == B [ : : - 1 ] ]
rst = A += [ 0 , 1 ] [ B == B [ : : - 1 ] ] <eos>
2548
src = pop ()
trg = pop ( )
rst = pop ( ) <eos>
2549
src = A の ( B 、 C ) の 組 番 目 を A の ( B 、 C から 1 を 引 いた 値 ) の 組 番目の 各要素 を D とし 、 D に E を加えた 値の 列 だけ 増加 させる
trg = A [ ( B , C ) ] += [ D + E for D in A [ ( B , C - 1 ) ] ]
rst = A [ ( B , C ) ] += A [ ( B , C - 1 ) ] [ D + E for D in A [ ( B , C ) ] ] <eos>
2550
src = A の a が B の 浮動小数点数 と 等 しい とき 、
trg = if A . a == float ( B ) :
rst = if A . a == float ( B ) : <eos>
2551
src = 5 に B を加えた 値を 5 で 割 った 値を A とする
trg = A = ( 5 + B ) / 5
rst = A = ( 5 + B ) / 5 <eos>
2552
src = A を返す
trg = return A
rst = return A <eos>
2553
src = B の MAXV を A とする
trg = A = B . MAXV
rst = A = B . <unk> <eos>
2554
src = A の長さ から A 内の B の 出現 回数 を 引 いた 値を返す
trg = return len ( A ) - A . count ( B )
rst = return len ( A ) - A . count ( B ) <eos>
2555
src = C の 各要素 を B とし 、 B が D の 部分 集合 の とき の B の 列 の集合 を A とする
trg = A = set ( [ B for B in C if B . issubset ( D ) ] )
rst = A = set ( [ B for B in C if B . issubset ( D ) ] ) <eos>
2556
src = A の長さ が 1 より 大きい とき 、
trg = if len ( A ) > 1 :
rst = if len ( A ) > 1 : <eos>
2557
src = B に C を C に D を加えた 値 で 割 った 値に E から B を 引 いた 値を 掛 け た 値 を加えた 値を A とする
trg = A = B + C / ( C + D ) * ( E - B )
rst = A = B + C / ( C + D ) * ( E - B ) <eos>
2558
src = collision ( A , B , C , D ) の とき 、
trg = if collision ( A , B , C , D ) :
rst = if <unk> ( A , B , C , D ) : <eos>
2559
src = A が B から 1 を 引 いた 値 と 等 しく ない とき 、
trg = if A != B - 1 :
rst = if A != B - 1 : <eos>
2560
src = A が 1 と 等 しく かつ B が 1 と 等 しく かつ C が 1 と 等 しい とき 、
trg = if A == 1 and B == 1 and C == 1 :
rst = if A == 1 and B == 1 and C == 1 : <eos>
2561
src = A が ( 1 、 10 、 11 、 12 、 13 ) からなる 列 と 等 しく かつ B の とき 、
trg = if A == [ 1 , 10 , 11 , 12 , 13 ] and B :
rst = if A == [ 1 , 10 , 11 , 12 , 13 , B ] : <eos>
2562
src = ( ( 0 、 1 ) の 組 、 ( 1 、 0 ) の 組 ) からなる 列 を A とする
trg = A = [ ( 0 , 1 ) , ( 1 , 0 ) ]
rst = A = [ ( 0 , 1 ) , ( 1 , 0 ) ] <eos>
2563
src = B に C の B 番 目 を加えた 値を A とする
trg = A = B + C [ B ]
rst = A = B + C [ B ] <eos>
2564
src = ( ( 、 つまり 未 定 値 ) からなる 列 の 0 から 14 未 満 までの 数 列 の 各要素 を B とし 、 8 の 列 回 分 の 列 ) からなる 列 を A とする
trg = A = [ [ None ] * [ 8 for B in range ( 14 ) ] ]
rst = A = [ [ None ] * [ 8 for B in range ( 14 ) ] ] <eos>
2565
src = A の長さ を 3 で 割 った 余 り が 0 と 等 しく ない とき 、
trg = if len ( A ) % 3 != 0 :
rst = if len ( A ) % 3 != 0 : <eos>
2566
src = A の articulations に B を追加した 集 ま り
trg = A . articulations . add ( B )
rst = A . <unk> . add ( B ) <eos>
2567
src = A の 0 番 目 を B で 割 った 余 り が 0 と 等 しく かつ A の 1 番 目 を B で 割 った 余 り が 0 と 等 しく かつ A の 2 番 目 を B で 割 った 余 り が 0 と 等 しい とき 、
trg = if A [ 0 ] % B == 0 and A [ 1 ] % B == 0 and A [ 2 ] % B == 0 :
rst = if A [ 0 ] % B == 0 and A [ 1 ] % B == 0 and A [ 2 ] % B == 0 : <eos>
2568
src = A の B 番目の 末 尾 に B に C の B 番 目 を加えた 値を D で 割 った 余 り を追加する
trg = A [ B ] . append ( ( B + C [ B ] ) % D )
rst = A [ B ] . append ( ( B + C [ B ] ) % D ) <eos>
2569
src = A の B 番目の C に 1 を加えた 値 番目の D 番 目 を 1 だけ 減少 させる
trg = A [ B ] [ C + 1 ] [ D ] -= 1
rst = A [ B ] [ C + 1 ] [ D ] -= 1 <eos>
2570
src = pre _ order _ from ( A . root )
trg = pre_order_from ( A . root )
rst = pre_order_from ( A . root ) <eos>
2571
src = B を 書式 として C の 2 乗 で 整 形 した 文字列を A とする
trg = A = B . format ( C ** 2 )
rst = A = B . format ( C ** 2 ) <eos>
2572
src = A の 、 つまり 現在の 日 時の 週 番 目 を出力する
trg = print ( A [ now . weekday ( ) ] )
rst = print ( A [ now . weekday ( ) ] ) <eos>
2573
src = cross 3 ( B , C , D ) が - E より 大きい とき D 、 そうでなければ C を A とする
trg = A = D if cross3 ( B , C , D ) > - E else C
rst = A = - D if cross3 ( B , C , D ) > - E else C <eos>
2574
src = ソート された 順序 を 保 った まま C の 2 番 目 を B の C の 1 番 目 番 目 に 挿入 できる 位置 を A とする
trg = A = bisect . bisect_left ( B [ C [ 1 ] ] , C [ 2 ] )
rst = A = bisect . bisect_left ( B [ C [ 2 ] ] , B [ C [ 1 ] ) <eos>
2575
src = A の B から 1 を 引 いた 値 番 目 が C と 等 しく ない とき 、
trg = if A [ B - 1 ] != C :
rst = if A [ B - 1 ] != C : <eos>
2576
src = 2 の A 乗 に対する B の 剰 余 に 1 を加えた 値を B で 割 った 余 り を出力する
trg = print ( ( pow ( 2 , A , B ) + 1 ) % B )
rst = print ( ( pow ( 2 , A , B ) + 1 ) % B ) <eos>
2577
src = sys の stdin から 読み 込 んだ データを 空白 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 の リストを A とする
trg = A = list ( map ( int , sys . stdin . read ( ) . split ( ) ) )
rst = A = list ( map ( int , sys . stdin . read ( ) . split ( ) ) ) <eos>
2578
src = A を 10 だけ 増加 させる
trg = A += 10
rst = A += 10 <eos>
2579
src = B の 6 番 目 から 9 番 目 までの 部分 列 を A とする
trg = A = B [ 6 : 9 ]
rst = A = B [ 6 : 9 ] <eos>
2580
src = chs ( B , B - C , D ) を A とする
trg = A = chs ( B , B - C , D )
rst = A = chs ( B , B - C , D ) <eos>
2581
src = preParse ( A )
trg = preParse ( A )
rst = preParse ( A ) <eos>
2582
src = dfs _ tree ( 0 )
trg = dfs_tree ( 0 )
rst = <unk> ( 0 ) <eos>
2583
src = A の B 番 目 が 0 と 等 しく かつ C の B 番 目 でない とき 、
trg = if A [ B ] == 0 and not C [ B ] :
rst = if A [ B ] == 0 and not C [ B ] : <eos>
2584
src = A が B の C 番 目 から B の D 番 目 を 引 いた 値の 絶対 値 より 小さい とき 、
trg = if A < abs ( B [ C ] - B [ D ] ) :
rst = if A < abs ( B [ C ] - B [ D ] ) : <eos>
2585
src = A が B の C の A 番 目 と 等 しい 要素 の最初の 位置 と 等 しい とき 、
trg = if A == B . index ( C [ A ] ) :
rst = if A == B . index ( C [ A ] ) : <eos>
2586
src = A . flow ( B ) を返す
trg = return A . flow ( B )
rst = return A . flow ( B ) <eos>
2587
src = B の 整数値 から C 未 満 までの 数 列 を 順に A として 、 繰り返す
trg = for A in range ( int ( B ) , C ) :
rst = for A in range ( int ( B ) , C ) : <eos>
2588
src = _ add ( A , B , - C )
trg = _add ( A , B , - C )
rst = _add ( A , B , - C ) <eos>
2589
src = B . dfs ( e . to , C , min ( D , e . cap ) ) を A とする
trg = A = B . dfs ( e . to , C , min ( D , e . cap ) )
rst = A = B . dfs ( e . to , C , min ( D , e . cap ) ) <eos>
2590
src = A の B 番目の C 番 目 が D 以下の とき 、
trg = if A [ B ] [ C ] <= D :
rst = if A [ B ] [ C ] <= D : <eos>
2591
src = B の par の C 番 目 を A とする
trg = A = B . par [ C ]
rst = A = B . par [ C ] <eos>
2592
src = B の集合 と C の集合 の 論理 積 を ソート した 列 を 順に A として 、 繰り返す
trg = for A in sorted ( set ( B ) & set ( C ) ) :
rst = for A in sorted ( set ( B ) & set ( C ) ) : <eos>
2593
src = 0 から C 未 満 までの 数 列 の 各要素 を B とし 、 next ( map ( int , input () . split () ) ) の 列 を A とする
trg = A = [ next ( map ( int , input ( ) . split ( ) ) ) for B in range ( C ) ]
rst = A = [ next ( map ( int , input ( ) . split ( ) ) ) for B in range ( C ) ] <eos>
2594
src = A の bl ( A , B ) に B を挿入する
trg = A . insert ( bl ( A , B ) , B )
rst = A . insert ( A , B ) <eos>
2595
src = A を 15 に B を 掛 け た 値に 15 から 2 を 引 いた 値に 5 を 掛 け た 値に B を 掛 け た 値 を加えた 値 だけ 増加 させる
trg = A += 15 * B + ( 15 - 2 ) * 5 * B
rst = A += 15 * B + ( 15 - 2 ) * 5 * B <eos>
2596
src = A の B 番目の C 番 目 が D と 等 しく かつ E の F 番 目 が 0 と 等 しい とき 、
trg = if A [ B ] [ C ] == D and E [ F ] == 0 :
rst = if A [ B ] [ C ] == D and E [ F ] == 0 : <eos>
2597
src = A 、 B の C から 1 を 引 いた 値 番 目 から B の C 番 目 を 引 いた 値の 最大 値を A とする
trg = A = max ( A , B [ C - 1 ] - B [ C ] )
rst = A = max ( A , B [ C - 1 ] - B [ C ] ) <eos>
2598
src = A を 書式 として 、 つまり 空文字列 を 間 に 入れ て B を 連結 した 文字列 で 整 形 した 文字列 を出力する
trg = print ( A . format ( '' . join ( B ) ) )
rst = print ( A . format ( '' . join ( B ) ) ) <eos>
2599
src = A から B の C 番目の 1 番 目 を 引 いた 値が 0 以上の とき 、
trg = if A - B [ C ] [ 1 ] >= 0 :
rst = if A - B [ C ] [ 1 ] >= 0 : <eos>
2600
src = 入力された 文字列を 空白 で 分割 した 字句 列 の 各要素 を D とし 、 D の 整数値 の 列 を ソート した 列 を 展開 し 、 それぞれ A 、 B 、 C とする
trg = A , B , C = sorted ( [ int ( D ) for D in input ( ) . split ( ) ] )
rst = A , B , C = sorted ( [ int ( D ) for D in input ( ) . split ( ) ] ) <eos>
2601
src = F を 空白 で 分割 した 字句 列 の 各要素 を E とし 、 E の 整数値 の 列 を 展開 し 、 それぞれ A 、 B 、 C 、 D とする
trg = A , B , C , D = [ int ( E ) for E in F . split ( ) ]
rst = A , B , C , D = [ int ( E ) for E in F . split ( ) ] <eos>
2602
src = E 、 F の 要素を それぞれ 組 にした 列 の 各要素 を C 、 B とし 、 B から C を 引 いた 値を D で 割 った 余 り の 列 を A とする
trg = A = [ ( B - C ) % D for C , B in zip ( E , F ) ]
rst = A = [ ( B - C ) % D for C , B in zip ( E , F ) ] <eos>
2603
src = B の sink を A とする
trg = A = B . sink
rst = A = B . sink <eos>
2604
src = B の 各要素 を A とし 、 ( A < 40 ) * 40 に ( A > = 40 ) * A を加えた 値の 列 の 総 和 を 5 で 割 った 商 を出力する
trg = print ( sum ( [ ( A < 40 ) * 40 + ( A >= 40 ) * A for A in B ] ) // 5 )
rst = print ( sum ( [ ( A // 40 ) * 140 + A * 40 for A in B ] ) // 5 ) <eos>
2605
src = A の mark が B と 等 しく なく かつ ( C 、 D ) の 組 が A の path に含まれる とき 、
trg = if A . mark != B and ( C , D ) in A . path :
rst = if A . mark != B and ( C , D ) in path : <eos>
2606
src = pushBack ( A [ 1 ] , A [ 2 ] )
trg = pushBack ( A [ 1 ] , A [ 2 ] )
rst = pushBack ( A [ 1 ] , A [ 2 ] ) <eos>
2607
src = B を 1 だけ 右 シフト する
trg = B >>= 1
rst = B <unk> 1 <eos>
2608
src = Point ( A . x / B , A . y / B ) を返す
trg = return Point ( A . x / B , A . y / B )
rst = return Point ( A . x / B , A . y / B ) <eos>
2609
src = 3 600 に B [ 3 ] から B [ 0 ] を 引 いた 値を 掛 け た 値に 60 に B [ 4 ] から B [ 1 ] を 引 いた 値を 掛 け た 値 を加えた 値に B の 5 番 目 を加えた 値 から B の 2 番 目 を 引 いた 値を A とする
trg = A = 3600 * ( B [ 3 ] - B [ 0 ] ) + 60 * ( B [ 4 ] - B [ 1 ] ) + B [ 5 ] - B [ 2 ]
rst = A = 3600 * ( B [ 3 ] - B [ 0 ] ) + 60 * ( B [ 4 ] - B [ 1 ] ) + B [ 5 ] - B [ 2 ] <eos>
2610
src = f ( A , B ) を C の B 番 目 で 割 った 商 を D で 割 った 余 り を出力する
trg = print ( ( f ( A , B ) // C [ B ] ) % D )
rst = print ( f ( A , B ) // C [ B ] % D ) <eos>
2611
src = A . add _ edge ( B , C , D )
trg = A . add_edge ( B , C , D )
rst = A . add_edge ( B , C , D ) <eos>
2612
src = 0.5 を A とする
trg = A = 0.5
rst = A = 0.5 <eos>
2613
src = B を A の N 0 にする
trg = A . N0 = B
rst = A . N0 = B <eos>
2614
src = A に ネ イ ピ ア 数の B 番 目 を加えた 値が C の D 番 目 より 小さい とき 、
trg = if A + e [ B ] < C [ D ] :
rst = if A + e [ B ] < C [ D ] : <eos>
2615
src = B から B から C を 引 いた 値の 絶対 値 、 B から D を 引 いた 値の 絶対 値の 最大 値を 引 いた 値を A とする
trg = A = B - max ( abs ( B - C ) , abs ( B - D ) )
rst = A = max ( abs ( B - B ) , abs ( B - C ) ) <eos>
2616
src = A の B 番目の C 番 目 が 0 より 大きい とき 、
trg = if A [ B ] [ C ] > 0 :
rst = if A [ B ] [ C ] > 0 : <eos>
2617
src = B を追加し て A を拡張する
trg = A . extend ( B )
rst = A . extend ( B ) <eos>
2618
src = 改行 せずに A を 書式 として B の C に 2 を 掛 け た 値 番 目 、 B の C に 2 を 掛 け た 値に 1 を加えた 値 番 目 で 整 形 した 文字列 を出力する
trg = print ( A . format ( B [ C * 2 ] , B [ C * 2 + 1 ] ) , end = '' )
rst = print ( A . format ( B [ C * 2 ] , B [ C * 2 + 1 ] ) , end = '' ) <eos>
2619
src = B 、 C の D 番目の 1 番目の 最小 値を A とする
trg = A = min ( B , C [ D ] [ 1 ] )
rst = A = min ( B , C [ D ] [ 1 ] ) <eos>
2620
src = A が B の C 番 目 と 等 しく ない 間 、 次 を 繰り返す
trg = while A != B [ C ] :
rst = while A != B [ C ] : <eos>
2621
src = ( ( 6 、 7 、 8 ) からなる 列 、 ( 2 、 5 、 8 ) からなる 列 、 ( 0 、 1 、 2 ) からなる 列 、 ( 0 、 3 、 6 ) からなる 列 ) からなる 列 を A とする
trg = A = [ [ 6 , 7 , 8 ] , [ 2 , 5 , 8 ] , [ 0 , 1 , 2 ] , [ 0 , 3 , 6 ] ]
rst = A = [ [ 6 , 7 , 8 ] , [ 2 , 5 , 8 ] , [ 0 , 1 , 2 ] , [ 0 , 3 ] , [ 0 , 6 ] ] <eos>
2622
src = 無限 の 整数 列 が 0 と 等 しい とき 、
trg = if count == 0 :
rst = if count == 0 : <eos>
2623
src = A の長さ が 2 以上 かつ cross 3 ( A [ -2 ] , A [ -1 ] , B ) が 0 以上の 間 、 次 を 繰り返す
trg = while len ( A ) >= 2 and cross3 ( A [ - 2 ] , A [ - 1 ] , B ) >= 0 :
rst = while len ( A ) >= 2 and cross3 ( A [ - 2 ] , A [ - 1 ] , B ) >= 0 : <eos>
2624
src = 0.0 0000 1 を A とする
trg = A = 0.000001
rst = A = <unk> <eos>
2625
src = B を A の root にする
trg = A . root = B
rst = A . root = B <eos>
2626
src = A の 1 番 目 を 2 で 割 った 余 り が 1 と 等 しく かつ A の 2 番 目 を 2 で 割 った 余 り が 1 と 等 しい とき 、
trg = if A [ 1 ] % 2 == 1 and A [ 2 ] % 2 == 1 :
rst = if A [ 1 ] % 2 == 1 and A [ 2 ] % 2 == 1 : <eos>
2627
src = A . set _ value ( 0 )
trg = A . set_value ( 0 )
rst = A . set_value ( 0 ) <eos>
2628
src = A が 1 より 大きく かつ B が 0 より 大きい 間 、 次 を 繰り返す
trg = while A > 1 and B > 0 :
rst = while A > 1 and B > 0 : <eos>
2629
src = ( 10 0.0 、 0.0 ) の 組 を A とする
trg = A = ( 100.0 , 0.0 )
rst = A = ( 100.0 , 0.0 ) <eos>
2630
src = A の 末 尾 に B の 総 和 を追加する
trg = A . append ( sum ( B ) )
rst = A . append ( sum ( B ) ) <eos>
2631
src = 入力された 文字列を 空白 で 分割 した 字句 列 の 各要素 を B とし 、 B の 整数値 から 1 を 引 いた 値の 列 を A とする
trg = A = [ int ( B ) - 1 for B in input ( ) . split ( ) ]
rst = A = [ int ( B ) - 1 for B in input ( ) . split ( ) ] <eos>
2632
src = A の stl の B 番目の C 番 目 を返す
trg = return A . stl [ B ] [ C ]
rst = return A . stl [ B ] [ C ] <eos>
2633
src = A 、 B の 整数値 、 C から A を 引 いた 値 を出力する
trg = print ( A , int ( B ) , C - A )
rst = print ( A , int ( B ) , C - A ) <eos>
2634
src = writelines ( [ A % ( B , C [ B ] , D [ B ] , E [ B ] , F [ B ] , G [ B ] , HifC [ B ] == -1 elseIifE [ B ] == 0 elseJ ) forBinrange ( K ) ] )
trg = writelines ( [ A % ( B , C [ B ] , D [ B ] , E [ B ] , F [ B ] , G [ B ] , H if C [ B ] == - 1 else I if E [ B ] == 0 else J ) for B in range ( K ) ] )
rst = writelines ( [ A % ( B , C [ B ] , D [ B ] , E [ F ] , G [ B ] , ( E [ F ] , G [ B - 1 ] ) for B in range ( G [ 0 ]
2635
src = 逆 順に C を ソート した 列 を 順に A 、 B として 、 繰り返す
trg = for A , B in sorted ( C , reverse = True ) :
rst = for A , B in sorted ( C , reverse = True ) : <eos>
2636
src = B から 読み 込 んだ 一行 を 空白 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 の 組 を A とする
trg = A = tuple ( map ( int , B . readline ( ) . split ( ) ) )
rst = A = tuple ( map ( int , B . readline ( ) . split ( ) ) ) <eos>
2637
src = x を パラメータ として ( x の 最小 値 、 x の 最大 値 ) の 組 を返す関数 を キー として B の bridges を ソート した 列 を A とする
trg = A = sorted ( B . bridges , key = lambda C : ( min ( C ) , max ( C ) ) )
rst = A = sorted ( B . bridges , key = lambda C : ( min ( C ) , max ( C ) ) ) <eos>
2638
src = print _ p ( A )
trg = print_p ( A )
rst = <unk> ( A ) <eos>
2639
src = A の x 座標 が 0 と 等 しく かつ A の y 座標 が 0 と 等 しく または B の x 座標 が 0 と 等 しく かつ B の y 座標 が 0 と 等 しい とき 、
trg = if ( A . x == 0 and A . y == 0 ) or ( B . x == 0 and B . y == 0 ) :
rst = if ( A . x == 0 and A . y == 0 or B . x == 0 and B . y == 0 ) : <eos>
2640
src = A の 各要素 を B とし 、 B に C を加えた 値の 列 を追加し て A を拡張する
trg = A . extend ( [ B + C for B in A ] )
rst = A . extend ( [ B + C for B in A ] ) <eos>
2641
src = B に C を加えた 値 から D を 引 いた 値を A とする
trg = A = ( B + C - D )
rst = A = B + C - D <eos>
2642
src = B の 2 乗 から C の 2 乗 を 引 いた 値の 平 方 根 を A とする
trg = A = math . sqrt ( B ** 2 - C ** 2 )
rst = A = math . sqrt ( B ** 2 - C ** 2 ) <eos>
2643
src = 9 99 から A を 引 いた 値を 3 で 割 った 余 り が 1 と 等 しい とき 、
trg = if ( 999 - A ) % 3 == 1 :
rst = if ( 999 - A ) % 3 == 1 : <eos>
2644
src = A が B に 2 を 掛 け た 値 以上の とき 、
trg = if A >= B * 2 :
rst = if A >= B * 2 : <eos>
2645
src = 0 から 、 つまり 整数 の長さ 未 満 までの 2 間隔 の 数 列 を 順に A として 、 繰り返す
trg = for A in range ( 0 , len ( str ) , 2 ) :
rst = for A in range ( 0 , len ( str ) , 2 ) : <eos>
2646
src = A の B から 1 を 引 いた 値 番 目 でない とき 、
trg = if not A [ B - 1 ] :
rst = if not A [ B - 1 ] : <eos>
2647
src = C を A の B の parent 番目の right にする
trg = A [ B . parent ] . right = C
rst = A [ B . parent ] . right = C <eos>
2648
src = C の D 番目の D 番 目 を 展開 し 、 それぞれ A 、 B とする
trg = A , B = C [ D ] [ D ]
rst = A , B = C [ D ] [ D ] <eos>
2649
src = B の head の next を A の tail の next にする
trg = A . tail . next = B . head . next
rst = A . tail . next = B . head . next <eos>
2650
src = 空文字列 を 間 に 入れ て A を 連結 した 文字列 を出力する
trg = print ( '' . join ( A ) )
rst = print ( '' . join ( A ) ) <eos>
2651
src = calc ( A ) の とき 、
trg = if calc ( A ) :
rst = if calc ( A ) : <eos>
2652
src = B の 2 乗 に C から D に math . cos ( E ) を 掛 け た 値を 引 いた 値の 2 乗 を加えた 値の 平 方 根 を A とする
trg = A = math . sqrt ( B ** 2 + ( C - D * math . cos ( E ) ) ** 2 )
rst = A = math . sqrt ( B ** 2 + ( C - D * math . cos ( math . radians ( E ) ) ) ) ** 2 <eos>
2653
src = ネ イ ピ ア 数の ( A 、 B 、 C 、 D ) からなる 列 の 総 和 番 目 を 1 だけ 増加 させる
trg = e [ sum ( [ A , B , C , D ] ) ] += 1
rst = e [ A , B , C , D ] += sum ( [ A , B , C , D ] ) <eos>
2654
src = A の A の A の 最大 値 と 等 しい 要素 の最初の 位置 を取り 出した 値
trg = A . pop ( A . index ( max ( A ) ) )
rst = A . pop ( A . index ( max ( A ) ) ) <eos>
2655
src = - B に C の . 5 乗 を加えた 値を D で 割 った 値を A とする
trg = A = ( - B + C ** .5 ) / D
rst = A = ( - B + C ** .5 ) / D <eos>
2656
src = A が 、 つまり 未 定 値 と 等 しく かつ B の C 番目の 1 番目の とき 、
trg = if A == None and B [ C ] [ 1 ] :
rst = if A is not None and B [ C ] [ 1 ] : <eos>
2657
src = D 、 E 、 F の 最大 値を A の B 番目の C 番 目 にする
trg = A [ B ] [ C ] = max ( D , E , F )
rst = A [ B ] [ C ] = max ( D , E , F ) <eos>
2658
src = 600 を A とする
trg = A = 600
rst = A = 600 <eos>
2659
src = A の 総 和 を返す
trg = return sum ( A )
rst = return sum ( A ) <eos>
2660
src = B の 正 弦 に C を 掛 け た 値を A とする
trg = A = math . sin ( B ) * C
rst = A = math . sin ( B ) * C <eos>
2661
src = paint ( A - 1, B )
trg = paint ( A - 1 , B )
rst = paint ( A - 1 , B ) <eos>
2662
src = A の B に 1 を加えた 値 番 目 が C と 等 しく ない とき 、
trg = if A [ B + 1 ] != C :
rst = if A [ B + 1 ] != C : <eos>
2663
src = A の B に 2 を加えた 値 番 目 に C を加えた 値を そうでなければ 、 とする
trg = else = A [ B + 2 ] + C
rst = else = A [ B + 2 ] + C <eos>
2664
src = A . heappush ( B , ( C , e , D , E ) )
trg = A . heappush ( B , ( C , e , D , E ) )
rst = A . heappush ( B , ( C , e , D , E ) ) <eos>
2665
src = - heappop ( A ) を出力する
trg = print ( - heappop ( A ) )
rst = print ( - heappop ( A ) ) <eos>
2666
src = push ( ( A , B ) )
trg = push ( ( A , B ) )
rst = push ( ( A , B ) ) <eos>
2667
src = B を A の N にする
trg = A . N = B
rst = A . N = B <eos>
2668
src = A が ( 0 、 1 ) の 組 に含まれる とき 、
trg = if A in ( 0 , 1 ) :
rst = if A in ( 0 , 1 ) : <eos>
2669
src = B を 空白 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 を 展開 し 、 それぞれ A 、 B とする
trg = A , B = map ( int , B . split ( ) )
rst = A , B = map ( int , B . split ( ) ) <eos>
2670
src = B を 4 . 9 で 割 った 値の 平 方 根 を A とする
trg = A = sqrt ( B / 4.9 )
rst = A = sqrt ( B / 4.9 ) <eos>
2671
src = A 、 calc ( int ( B + C [ D : ] ) ) から E を 引 いた 値の 最小 値を A とする
trg = A = min ( A , calc ( int ( B + C [ D : ] ) ) - E )
rst = A = min ( A , calc ( int ( B + C [ D : ] ) ) - E ) <eos>
2672
src = A に B を 掛 け た 値を C で 割 った 商 が D より 小さい とき 、
trg = if A * B // C < D :
rst = if A * B // C < D : <eos>
2673
src = B の 2 番 目 から 6 番 目 までの 部分 列 の 整数値 を A とする
trg = A = int ( B [ 2 : 6 ] )
rst = A = int ( B [ 2 : 6 ] ) <eos>
2674
src = CP ( B , C , D ) を A とする
trg = A = CP ( B , C , D )
rst = A = <unk> ( B , C , D ) <eos>
2675
src = A を B の C 番 目 に D の E 番 目 に F を 掛 け た 値に G の E 番 目 を加えた 値を 掛 け た 値 だけ 減少 させる
trg = A -= B [ C ] * ( D [ E ] * F + G [ E ] )
rst = A -= B [ C ] * D [ E ] * F + G [ E ] <eos>
2676
src = ( ( B 、 3 5 . 50 、 7 1.0 0 ) からなる 列 、 ( C 、 3 7 . 50 、 77 . 00 ) からなる 列 、 ( D 、 4 0.0 0 、 8 3.0 0 ) からなる 列 、 ( E 、 4 3.0 0 、 89 . 00 ) からなる 列 、 ( F 、 50 . 00 、 10 5.0 0 ) からなる 列 、 ( G 、 5 5.0 0 、
trg = A = [ [ B , 35.50 , 71.00 ] , [ C , 37.50 , 77.00 ] , [ D , 40.00 , 83.00 ] , [ E , 43.00 , 89.00 ] , [ F , 50.00 , 105.00 ] , [ G , 55.00 , 116.00 ] , [ H , 70.00 , 148.00 ] ]
rst = A = [ [ B , 5 , <unk> , <unk> , <unk> ] , [ <unk> , <unk> , <unk> , <unk> , <unk> ] , [ int ( <unk> , <unk> , 0.0000 ] , <unk> , <unk> , <unk> , <unk> ] <eos>
2677
src = 0 、 0 を出力する
trg = print ( 0 , 0 )
rst = print ( 0 , 0 ) <eos>
2678
src = 6 に B を 掛 け た 値を A とする
trg = A = 6 * B
rst = A = 6 * B <eos>
2679
src = ネ イ ピ ア 数の 0 番 目 が A と 等 しい とき 、
trg = if e [ 0 ] == A :
rst = if e [ 0 ] == A : <eos>
2680
src = A に B を 掛 け た 値に C に D を 掛 け た 値 を加えた 値 、 0 . 8 に A * max ( 5 , B ) に C * max ( 2 , D ) を加えた 値を 掛 け た 値の 整数値 の 最小 値 を出力する
trg = print ( min ( A * B + C * D , int ( 0.8 * ( A * max ( 5 , B ) + C * max ( 2 , D ) ) ) ) )
rst = print ( min ( A * B + C * D , 0 ) + min ( A * max ( B , 5 ) * max ( B , C * max ( D , 2 ) ) ) ) <eos>
2681
src = A の 末 尾 に B の C 番目の D の C 番 目 番 目 を追加する
trg = A . append ( B [ C ] [ D [ C ] ] )
rst = A . append ( B [ C ] [ D [ C ] ] ) <eos>
2682
src = 0 、 B から C を 引 いた 値の 最大 値 から B に C を加えた 値 、 D から 1 を 引 いた 値の 最小 値に 1 を加えた 値 未 満 までの 数 列 を 順に A として 、 繰り返す
trg = for A in range ( max ( 0 , B - C ) , min ( B + C , D - 1 ) + 1 ) :
rst = for A in range ( max ( B , B - C ) , B + min ( C , D - 1 ) ) : <eos>
2683
src = 2 に A を 掛 け た 値に 1 を加えた 値に B を 掛 け た 値が 2 に C を 掛 け た 値 以下の とき 、
trg = if ( 2 * A + 1 ) * B <= 2 * C :
rst = if 2 * A + 1 * B <= 2 * C : <eos>
2684
src = A の 末 尾 に B * * 2 に ( C - B ) * * 2 を加えた 値の 0.5 乗 から 、 つまり ネ イ ピ ア 数 を 引 いた 値の 絶対 値 を追加する
trg = A . append ( abs ( ( B ** 2 + ( C - B ) ** 2 ) ** 0.5 - e ) )
rst = A . append ( abs ( B ** 2 + ( C - B ) ** 2 ) ** 0.5 - e ) ) <eos>
2685
src = A を B に ネ イ ピ ア 数 を加えた 値 だけ 増加 させる
trg = A += ( B + e )
rst = A += B + e <eos>
2686
src = 2 から B の 0.5 乗 の 整数値 に 2 を加えた 値 未 満 までの 数 列 を 順に A として 、 繰り返す
trg = for A in range ( 2 , int ( B ** 0.5 ) + 2 ) :
rst = for A in range ( 2 , int ( B ** 0.5 ) + 2 ) : <eos>
2687
src = A を 書式 として B から 19 25 を 引 いた 値 で 整 形 した 文字列 を出力する
trg = print ( A . format ( B - 1925 ) )
rst = print ( A . format ( B - 1925 ) ) <eos>
2688
src = A の 末 尾 の 1 番 目 を 1 だけ 増加 させる
trg = A [ - 1 ] [ 1 ] += 1
rst = A [ - 1 ] [ 1 ] += 1 <eos>
2689
src = era _ transformation ( A , B , C )
trg = era_transformation ( A , B , C )
rst = <unk> ( A , B , C ) <eos>
2690
src = 7 0000 を A とする
trg = A = 70000
rst = A = 1000000007 <eos>
2691
src = C を A の 1 を B だけ 左 シフト した 値 番 目 にする
trg = A [ 1 << B ] = C
rst = A [ 1 << B ] = C <eos>
2692
src = distf ( * B [ C -1 ] ) を A とする
trg = A = distf ( * B [ C - 1 ] )
rst = A = <unk> ( * B [ C - 1 ] ) <eos>
2693
src = 入力された 文字列を 空白 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 を 展開 し 、 それぞれ A 、 re とする
trg = A , re = map ( int , input ( ) . split ( ) )
rst = re , A = map ( int , input ( ) . split ( ) ) <eos>
2694
src = A の 末 尾 に ( B 、 C の 最大 値 、 D ) からなる 列 を追加する
trg = A . append ( [ max ( B , C ) , D ] )
rst = A . append ( [ B , max ( C ) , D ] ) <eos>
2695
src = 1 を A の B から 1 を 引 いた 値 番目の 1 番 目 にする
trg = A [ B - 1 ] [ 1 ] = 1
rst = A [ B - 1 ] [ 1 ] = 1 <eos>
2696
src = A が B の 浮動小数点数 と 等 しい とき 、
trg = if A == float ( B ) :
rst = if A == float ( B ) : <eos>
2697
src = A の B 番 目 に 1 を加えた 値を A の 、 つまり ネ イ ピ ア 数の to 番 目 にする
trg = A [ e . to ] = A [ B ] + 1
rst = A [ e . to ] = A [ B ] + 1 <eos>
2698
src = itemgetter ( F ) を キー として C の D 番 目 から E に 1 を加えた 値 までの 部分 列 を ソート した 列 に 番号 付 した 組 の 列 を 順に A 、 B として 、 繰り返す
trg = for A , B in enumerate ( sorted ( C [ D : E + 1 ] , key = itemgetter ( F ) ) ) :
rst = for A , B in enumerate ( sorted ( C [ D : E + 1 ] , key = itemgetter ( F ) ) ) : <eos>
2699
src = A から B を 3 に C を 掛 け た 値 で 割 った 値を 引 いた 値を A とする
trg = A = A - B / ( 3 * C )
rst = A = A - B / ( 3 * C ) <eos>
2700
src = B に B を 掛 け た 値 から C に 1 を加えた 値 未 満 までの B 間隔 の 数 列 を 順に A として 、 繰り返す
trg = for A in range ( B * B , C + 1 , B ) :
rst = for A in range ( B * B , C + 1 , B ) : <eos>
2701
src = A の B 番目の C 番 目 を D だけ 増加 させる
trg = A [ B ] [ C ] += D
rst = A [ B ] [ C ] += D <eos>
2702
src = B から 600 未 満 までの B 間隔 の 数 列 の 各要素 を A とし 、 A に A を 掛 け た 値に B を 掛 け た 値の 列 の 総 和 を出力する
trg = print ( sum ( [ A * A * B for A in range ( B , 600 , B ) ] ) )
rst = print ( sum ( [ A * B for A in range ( B , 600 , B ) ] ) ) <eos>
2703
src = C を B とする
trg = B = C
rst = B = C <eos>
2704
src = B の spc _ x に C を加えた 値を A とする
trg = A = B . spc_x + C
rst = A = B . spc_y + C <eos>
2705
src = C の B 番 目 を A の tree の A の n に B を加えた 値 から 1 を 引 いた 値 番 目 にする
trg = A . tree [ A . n + B - 1 ] = C [ B ]
rst = A . tree [ A . n + B - 1 ] = C [ B ] <eos>
2706
src = A に B の C の C から 1 を 引 いた 値 番目の D から E を 引 いた 値 番 目 を加えた 値が B の C の C から 1 を 引 いた 値 番目の D 番 目 より 大きい とき 、
trg = if A + B . C [ C - 1 ] [ D - E ] > B . C [ C - 1 ] [ D ] :
rst = if A + B [ C - 1 ] [ D - E ] > B [ C - 1 ] [ D ] : <eos>
2707
src = A に A を 掛 け た 値を B で 割 った 余 り を A とする
trg = A = A * A % B
rst = A = ( A * A ) % B <eos>
2708
src = 入力された 文字列を J で 分割 した 字句 列 の 各要素 を I とし 、 I の 浮動小数点数 の 列 を 展開 し 、 それぞれ A 、 B 、 C 、 D 、 E 、 F 、 G 、 H とする
trg = A , B , C , D , E , F , G , H = [ float ( I ) for I in input ( ) . split ( J ) ]
rst = A , B , C , D , E , F , G , H = [ float ( I ) for I in input ( ) . split ( J ) ] <eos>
2709
src = A の 末 尾 に B を C が D に含まれる かどうか で 割 った 余 り を追加する
trg = A . append ( B % ( C in D ) )
rst = A . append ( B % C in D ) <eos>
2710
src = 無限 の 整数 列 を A に B を加えた 値 だけ 増加 させる
trg = count += ( A + B )
rst = count += A + B <eos>
2711
src = A の 末 尾 に B に B から 1 を 引 いた 値を 掛 け た 値を 2 で 割 った 値の 整数値 を追加する
trg = A . append ( int ( B * ( B - 1 ) / 2 ) )
rst = A . append ( int ( B * ( B - 1 ) / 2 ) ) <eos>
2712
src = A の B 番目の 2 番 目 かつ A の C 番目の 2 番目の とき 、
trg = if A [ B ] [ 2 ] and A [ C ] [ 2 ] :
rst = if A [ B ] [ 2 ] and A [ C ] [ 2 ] : <eos>
2713
src = dijkstra ( A )
trg = dijkstra ( A )
rst = dijkstra ( A ) <eos>
2714
src = A 、 B に dfs ( C | ( 1 < < D ) , E + F [ D ] , G ) を加えた 値の 最小 値を A とする
trg = A = min ( A , B + dfs ( C | ( 1 << D ) , E + F [ D ] , G ) )
rst = A = min ( A , B + dfs ( C | ( 1 << D ) , E + F [ D ] , G ) ) <eos>
2715
src = A を 文字コード 6 5 に B を加えた 値の 文字 だけ 増加 させる
trg = A += chr ( 65 + B )
rst = A += chr ( 65 + B ) <eos>
2716
src = A が 100 と 等 しく または B が 100 と 等 しく または C が 100 と 等 しい とき 、
trg = if A == 100 or B == 100 or C == 100 :
rst = if A == 100 or B == 100 or C == 100 : <eos>
2717
src = B から 、 つまり ネ イ ピ ア 数 を 引 いた 値を A とする
trg = A = B - e
rst = A = B - e <eos>
2718
src = D を A の B に C に C に 1 を加えた 値を 掛 け た 値 を加えた 値 番 目 にする
trg = A [ B + C * ( C + 1 ) ] = D
rst = A [ B + C * ( C + 1 ) ] = D <eos>
2719
src = A を 6 に B を 掛 け た 値 だけ 減少 させる
trg = A -= 6 * B
rst = A -= 6 * B <eos>
2720
src = 0 から 6 未 満 までの 数 列 の 各要素 を B とし 、 B の 列 を A の number にする
trg = A . number = [ B for B in range ( 6 ) ]
rst = A . number = [ B for B in range ( 6 ) ] <eos>
2721
src = A が 、 つまり 空 列 と 等 しい とき 、
trg = if A == [ ] :
rst = if A == [ ] : <eos>
2722
src = insert ( [ None , None , int ( A [ 0 ] ) , None ] )
trg = insert ( [ None , None , int ( A [ 0 ] ) , None ] )
rst = insert ( [ None , None , int ( A [ 0 ] ) , None ) <eos>
2723
src = 入力された 文字列を 空白 で 分割 した 字句 列 を 展開 し 、 それぞれ A 、 B 、 C とする
trg = A , B , C = input ( ) . split ( )
rst = A , B , C = input ( ) . split ( ) <eos>
2724
src = ( C ) からなる 列 に D を加えた 値 、 D に ( E ) からなる 列 を加えた 値の 要素を それぞれ 組 にした 列 を 順に A 、 B として 、 繰り返す
trg = for A , B in zip ( [ C ] + D , D + [ E ] ) :
rst = for A , B in zip ( [ C ] + D , D + [ E ] ) : <eos>
2725
src = A を 書式 として B 、 ネ イ ピ ア 数 、 C で 整 形 した 文字列 を出力する
trg = print ( A . format ( B , e , C ) )
rst = print ( A . format ( B , e , C ) ) <eos>
2726
src = B の y 座標 から C の y 座標 を 引 いた 値を A の y 座標 にする
trg = A . y = B . y - C . y
rst = A . y = B . y - C . y <eos>
2727
src = A が 4 と 等 しい とき 、
trg = if A == 4 :
rst = if A == 4 : <eos>
2728
src = A の 平 方 根 が B より 小さい とき 、
trg = if math . sqrt ( A ) < B :
rst = if A . sqrt ( B ) < B : <eos>
2729
src = A が B から 1 を 引 いた 値 より 小さく かつ C の A 番目の D 番 目 が 0 と 等 しく かつ E の A に 1 を加えた 値 番目の D 番 目 でない とき 、
trg = if A < B - 1 and C [ A ] [ D ] == 0 and not E [ A + 1 ] [ D ] :
rst = if A < B - 1 and C [ A ] [ D ] == 0 and not E [ A + 1 ] [ D ] : <eos>
2730
src = ( < __ main __ . Cammaobjectat 0 x 10 a 1 b 7 a 90 > ) の集合 の長さ が 1 と 等 しい かどうか を A とする
trg = A = len ( { [ B for C , B in D ] } ) == 1
rst = A = len ( { [ ( B [ C + 1 ] - D ) % E == D } ) <eos>
2731
src = A に B を 掛 け た 値に C の D 番目の E 番 目 を加えた 値を A とする
trg = A = A * B + C [ D ] [ E ]
rst = A = A * B + C [ D ] [ E ] <eos>
2732
src = A の bel の B に 1 を加えた 値 番目の C 番 目 に A の stl の B に 1 を加えた 値 番目の C に 1 を加えた 値 番 目 を D で 割 った 余 り を加えた 値を A の bel の B に 1 を加えた 値 番目の C に 1 を加えた 値 番 目 にする
trg = A . bel [ B + 1 ] [ C + 1 ] = A . bel [ B + 1 ] [ C ] + A . stl [ B + 1 ] [ C + 1 ] % D
rst = A . bel [ B + 1 ] [ C + 1 ] = A . bel [ B + 1 ] [ C ] + A . stl [ B + 1 ] [ C + 1 ] % D <eos>
2733
src = A . min ( B , C ) を出力する
trg = print ( A . min ( B , C ) )
rst = print ( A . min ( B , C ) ) <eos>
2734
src = 0 から C に D を加えた 値 から 1 を 引 いた 値 未 満 までの 数 列 の 各要素 を E とし 、 0 から C に D を加えた 値 から 1 を 引 いた 値 未 満 までの 数 列 の 各要素 を B とし 、 1 の 列 の 列 を A とする
trg = A = [ [ 1 for B in range ( C + D - 1 ) ] for E in range ( C + D - 1 ) ]
rst = A = [ [ 1 for B in range ( C + D - 1 ) ] for E in range ( C + D - 1 ) ] <eos>
2735
src = calc _ hash ( B * 2 + C * 2 , B * 2 + C * 3 , C ) を A とする
trg = A = calc_hash ( B * 2 + C * 2 , B * 2 + C * 3 , C )
rst = A = calc_hash ( B * 2 + C * 2 , B * 2 + C * 3 , C ) <eos>
2736
src = add _ team ( 0 , 1 )
trg = add_team ( 0 , 1 )
rst = _add ( 0 , 1 ) <eos>
2737
src = A の 末 尾 に B 内の 1 の 出現 回数 を追加する
trg = A . append ( B . count ( 1 ) )
rst = A . append ( B . count ( 1 ) ) <eos>
2738
src = A の root を A の hldtop の A の root 番 目 にする
trg = A . hldtop [ A . root ] = A . root
rst = A . hldtop [ A . root ] = A . root <eos>
2739
src = sys の stdin の 各要素 を B とし 、 B の 列 の 各要素 を A とし 、 classify ( Decimal ( A ) ) を出力する の 列
trg = [ print ( classify ( Decimal ( A ) ) ) for A in [ B for B in sys . stdin ] ]
rst = [ print ( <unk> ( A ) ) for A in [ B for B in sys . stdin ] ] <eos>
2740
src = B の C 番目の D から C を 引 いた 値 番 目 を E で 割 った 余 り を A とする
trg = A = B [ C ] [ D - C ] % E
rst = A = B [ C ] [ D - C ] % E <eos>
2741
src = B の C 番目の D 番 目 から B の E -1 番目の D 番 目 を 引 いた 値 から B の C 番目の F から 1 を 引 いた 値 番 目 を 引 いた 値に B の E から 1 を 引 いた 値 番目の F から 1 を 引 いた 値 番 目 を加えた 値を A の 1 番 目 にする
trg = A [ 1 ] = B [ C ] [ D ] - B [ E - 1 ] [ D ] - B [ C ] [ F - 1 ] + B [ E - 1 ] [ F - 1 ]
rst = A [ 1 ] = B [ C ] [ D ] - B [ E - 1 ] [ D ] - B [ C ] [ F - 1 ] + B [ E - 1 ] [ F - 1 ] <eos>
2742
src = 1 、 0 を A 、 B とする
trg = A , B = 1 , 0
rst = A , B = 1 , 0 <eos>
2743
src = B の nums を 深く コピー した結果 を A とする
trg = A = deepcopy ( B . nums )
rst = A = copy . nums <eos>
2744
src = ( ( 0 、 0 ) の 組 、 ( 1 、 0 ) の 組 、 ( 0 、 1 ) の 組 、 ( 1 、 1 ) の 組 ) の 組 を A とする
trg = A = ( ( 0 , 0 ) , ( 1 , 0 ) , ( 0 , 1 ) , ( 1 , 1 ) )
rst = A = ( ( 0 , 0 ) , ( 1 , 0 ) , ( 0 , 1 ) , ( 1 , 1 ) ) <eos>
2745
src = D に 1 を加えた 値を A の B と C の 排 他 論理 和 番 目 にする
trg = A [ B ^ C ] = D + 1
rst = A [ B ^ C ] = D + 1 <eos>
2746
src = A の len ( B ) から 1 を 引 いた 値 番目の C の長さ から 1 を 引 いた 値 番 目 を 1 0000 0000 7 で 割 った 余 り を出力する
trg = print ( A [ len ( B ) - 1 ] [ len ( C ) - 1 ] % 1000000007 )
rst = print ( A [ len ( B ) - 1 ] [ C - len ( C ) - 1 ] % 1000000007 ) <eos>
2747
src = 空白 文字 を 代わり の 行 末 として 0 を出力する
trg = print ( 0 , end = ' ' )
rst = print ( 0 , end = ' ' ) <eos>
2748
src = B を A の C 番 目 にする
trg = A [ C ] = B
rst = A [ C ] = B <eos>
2749
src = D の 両 端 から 空白 改行 を取り 除 いた 文字列を 空白 文字 で 分割 した 字句 列 の 各要素 を C とし 、 C の 整数値 の 列 を 展開 し 、 それぞれ A 、 B とする
trg = A , B = [ int ( C ) for C in D . strip ( ) . split ( ' ' ) ]
rst = A , B = [ int ( C ) for C in D . strip ( ) . split ( ' ' ) ] <eos>
2750
src = 1 から B の 先頭に 1 を加えた 値 未 満 までの 数 列 を 順に A として 、 繰り返す
trg = for A in range ( 1 , B [ 0 ] + 1 ) :
rst = for A in range ( 1 , B [ 0 ] + 1 ) : <eos>
2751
src = 辞書 の A の B 番 目 番 目 が 1 と 等 しい とき 、
trg = if dict [ A [ B ] ] == 1 :
rst = if dict [ A [ B ] ] == 1 : <eos>
2752
src = A . dump ( B [ 0 ] , B [ 1 ] )
trg = A . dump ( B [ 0 ] , B [ 1 ] )
rst = A . dump ( B [ 0 ] , B [ 1 ] ) <eos>
2753
src = A が 無限大 の とき -1 、 そうでなければ A を出力する
trg = print ( - 1 if isinf ( A ) else A )
rst = print ( - 1 if math . isinf ( A ) else A ) <eos>
2754
src = C 、 D から C を 引 いた 値の 最小 値 、 C 、 D から C を 引 いた 値の 最大 値を A 、 B とする
trg = A , B = min ( C , D - C ) , max ( C , D - C )
rst = A , B = min ( C , D - C ) , max ( C , D - C ) <eos>
2755
src = B の tree に対応する 値 、 も し 存在 し なければ C を A とする
trg = A = B . tree . get ( C )
rst = A = B . tree . get ( C ) <eos>
2756
src = A が B に C を 掛 け た 値 より 大きい とき 、
trg = if A > B * C :
rst = if A > B * C : <eos>
2757
src = A の 全て が 英 大文字 の とき 、
trg = if A . isupper ( ) :
rst = if A . islower ( ) : <eos>
2758
src = A を ( B の key ) からなる 列 だけ 増加 させる
trg = A += [ B . key ]
rst = A += [ B . key ] <eos>
2759
src = A の B 番 目 から 、 つまり 末 尾 までの 部分 列 を返す
trg = return A [ B : ]
rst = return A [ B : ] <eos>
2760
src = 改行 せずに A の B に 4 から C を 引 いた 値 を加えた 値 番 目 を出力する
trg = print ( A [ B + ( 4 - C ) ] , end = '' )
rst = print ( A [ B + ( 4 - C ) ] , end = '' ) <eos>
2761
src = B の長さ から C を 引 いた 値 から 2 を 引 いた 値を A とする
trg = A = len ( B ) - C - 2
rst = A = len ( B ) - C - 2 <eos>
2762
src = A から B を 引 いた 値の 2 乗 が C 以下の とき 、
trg = if ( A - B ) ** 2 <= C :
rst = if ( A - B ) ** 2 <= C : <eos>
2763
src = ( - B ) からなる 列 の C に 3 に D を 掛 け た 値 を加えた 値 回 分 の 列 を A とする
trg = A = [ - B ] * ( C + 3 * D )
rst = A = [ - B ] * ( C + 3 * D ) <eos>
2764
src = A の head を 1 だけ 増加 させる
trg = A . head += 1
rst = A . head += 1 <eos>
2765
src = 1 を 開始 番号 として accumulate ( C ) に 番号 付 した 組 の 列 を 順に A 、 B として 、 繰り返す
trg = for A , B in enumerate ( accumulate ( C ) , start = 1 ) :
rst = for A , B in enumerate ( accumulate ( C ) , start = 1 ) : <eos>
2766
src = A を binarysearch ( B , C [ D ] , E ) だけ 増加 させる
trg = A += binarysearch ( B , C [ D ] , E )
rst = A += <unk> ( B , C [ D ] , E ) <eos>
2767
src = A が B と 等 しく なく または C が B と 等 しく ない とき 、
trg = if A != B or C != B :
rst = if A != B or C != B : <eos>
2768
src = A に 60 に B を 掛 け た 値 を加えた 値 から C に D を加えた 値に E を 掛 け た 値に C を加えた 値を 引 いた 値を ネ イ ピ ア 数 とする
trg = e = ( A + 60 * B ) - ( ( C + D ) * E + C )
rst = e = A + 60 * B - ( C + D ) * E + C <eos>
2769
src = A の d の 3 番 目 、 A の d の 5 番 目 、 A の d の 2 番 目 、 A の d の先頭 を A の d の先頭 、 A の d の 3 番 目 、 A の d の 5 番 目 、 A の d の 2 番 目 とする
trg = A . d [ 0 ] , A . d [ 3 ] , A . d [ 5 ] , A . d [ 2 ] = A . d [ 3 ] , A . d [ 5 ] , A . d [ 2 ] , A . d [ 0 ]
rst = A . d [ 0 ] , A . d [ 3 ] , A . d [ 5 ] , A . d [ 2 ] = A . d [ 3 ] , A . d [ 5 ] , A . d [ 2 ] , A
2770
src = A が B の sink と 等 しく ない とき 、
trg = if A is B . sink :
rst = if A != B . sink : <eos>
2771
src = A の par の B 番 目 が 0 より 小さい とき 、
trg = if A . par [ B ] < 0 :
rst = if A . par [ B ] < 0 : <eos>
2772
src = A の先頭 が B と 等 しい とき 、
trg = if A [ 0 ] == B :
rst = if A [ 0 ] == B : <eos>
2773
src = range ( 10 ) の 各要素 を B とし 、 B の 列 の C 個 までの コン ビ ネ ー ション の 各要素 を A とし 、 A の 総 和 が D と 等 しい とき の 1 の 列 の 総 和 を出力する
trg = print ( sum ( [ 1 for A in itertools . combinations ( [ B for B in range ( 10 ) ] , C ) if sum ( A ) == D ] ) )
rst = print ( sum ( [ 1 for B in itertools . combinations ( range ( 10 ) , C ) if sum ( [ A == D ] ) == B ] ) ) <eos>
2774
src = A の value が B の value と 等 しい かどうか を返す
trg = return A . value == B . value
rst = return A . value == B . value <eos>
2775
src = combi ( A , 20 )
trg = combi ( A , 20 )
rst = combi ( A , 20 ) <eos>
2776
src = A の B から 1 を 引 いた 値 番目の 末 尾 に ( C から 1 を 引 いた 値 、 D ) からなる 列 を追加する
trg = A [ B - 1 ] . append ( [ C - 1 , D ] )
rst = A [ B - 1 ] . append ( [ C - 1 , D ] ) <eos>
2777
src = A の 文字列 の 、 つまり 先頭 から B に 2 を加えた 値 までの 部分 列 を A とする
trg = A = str ( A ) [ : B + 2 ]
rst = A = str ( A ) [ : B + 2 ] <eos>
2778
src = 空 列 を A の _ nodes にする
trg = A . _nodes = [ ]
rst = A . _nodes = [ ] <eos>
2779
src = 2 を 底 とする input () の 整数値 に 1 を加えた 値の 対 数の 整数値 を出力する
trg = print ( int ( math . log ( int ( input ( ) ) + 1 , 2 ) ) )
rst = print ( int ( math . log2 ( input ( ) ) + 1 ) ) <eos>
2780
src = ( ( B ) からなる 列 の 0 から A の V 未 満 までの 数 列 の 各要素 を C とし 、 A の V の 列 回 分 の 列 ) からなる 列 を A の distance にする
trg = A . distance = [ [ B ] * [ A . V for C in range ( A . V ) ] ]
rst = A . distance = [ [ B ] * [ A . V for C in range ( A . V ) ] ] <eos>
2781
src = ソート された 順序 を 保 った まま C から B の D 番 目 を 引 いた 値を B に 挿入 できる 最後の 位置 を A とする
trg = A = bisect . bisect ( B , C - B [ D ] , D + 2 )
rst = A = bisect . bisect_right ( B , C - B [ D ] ) <eos>
2782
src = A . push _ back ( B [ 0 ] )
trg = A . push_back ( B [ 0 ] )
rst = A . <unk> ( B [ 0 ] ) <eos>
2783
src = ( 、 つまり 未 定 値 ) からなる 列 の B 回 分 の 列 を A とする
trg = A = [ None ] * B
rst = A = [ None ] * B <eos>
2784
src = heappush ( A , ( 0 , 0 , B , C , 0 ) )
trg = heappush ( A , ( 0 , 0 , B , C , 0 ) )
rst = heappush ( A , ( 0 , 0 , B , C , 0 ) ) <eos>
2785
src = A の先頭 が 0 と 等 しく ない とき 、
trg = if A [ 0 ] != 0 :
rst = if A [ 0 ] != 0 : <eos>
2786
src = fix ( int ( B ) * C ) を A とする
trg = A = fix ( int ( B ) * C )
rst = A = fix ( int ( B ) * C ) <eos>
2787
src = A 、 B が 1 と 等 しい とき c ( C ) 、 そうでなければ s ( C ) の 最大 値を A とする
trg = A = max ( A , c ( C ) if B == 1 else s ( C ) )
rst = A = max ( A , c ( C ) if B == 1 else s ( C ) ) <eos>
2788
src = 25 5 、 0 、 25 5 を A 、 B 、 C とする
trg = A , B , C = 255 , 0 , 255
rst = A , B , C = 255 , 0 , 255 <eos>
2789
src = paint ( A , B + 2 , C + 2 ) を A とする
trg = A = paint ( A , B + 2 , C + 2 )
rst = A = paint ( A , B + 2 , C + 2 ) <eos>
2790
src = A が B より 小さく かつ C の A 番 目 が C の A から 1 を 引 いた 値 番 目 に 1 を加えた 値 と 等 しい 間 、 次 を 繰り返す
trg = while A < B and C [ A ] == C [ A - 1 ] + 1 :
rst = while A < B and C [ A ] == C [ A - 1 ] + 1 : <eos>
2791
src = A の 末 尾 に ( B に 1 を加えた 値 、 C 、 D から 1 を 引 いた 値 ) の 組 を追加する
trg = A . append ( ( B + 1 , C , D - 1 ) )
rst = A . append ( ( B + 1 , C , D - 1 ) ) <eos>
2792
src = 1 から B の dp の長さ 未 満 までの 数 列 を 順に A として 、 繰り返す
trg = for A in range ( 1 , len ( B . dp ) ) :
rst = for A in range ( 1 , len ( B . dp ) ) : <eos>
2793
src = B から C から B を 引 いた 値を 引 いた 値を A とする
trg = A = B - ( C - B )
rst = A = B - ( C - B ) <eos>
2794
src = A . propagate ( ( B -1 ) > > C )
trg = A . propagate ( ( B - 1 ) >> C )
rst = A . <unk> ( ( B - 1 ) >> C ) <eos>
2795
src = A の 末 尾 に ( 0 、 B 、 1 、 0 ) の 組 を追加する
trg = A . append ( ( 0 , B , 1 , 0 ) )
rst = A . append ( ( 0 , B , 1 , 0 ) ) <eos>
2796
src = A . set _ range ( B , C , D )
trg = A . set_range ( B , C , D )
rst = A . set_range ( B , C , D ) <eos>
2797
src = A の B から C を 引 いた 値 番目の とき 、
trg = if A [ B - C ] :
rst = if A [ B - C ] : <eos>
2798
src = 区切り なしで A 、 B 、 C 、 B 、 D を出力する
trg = print ( A , B , C , B , D , sep = '' )
rst = print ( A , B , C , B , D , sep = '' ) <eos>
2799
src = 2 に A を 掛 け た 値 から 1 を 引 いた 値が B 以下の 間 、 次 を 繰り返す
trg = while 2 * A - 1 <= B :
rst = while 2 * A - 1 <= B : <eos>
2800
src = D の 整数値 を A の B の 順序 数 から C を 引 いた 値 番 目 にする
trg = A [ ord ( B ) - C ] = int ( D )
rst = A [ ord ( B ) - C ] = int ( D ) <eos>
2801
src = run _ length ( A . strip () ) を出力する
trg = print ( run_length ( A . strip ( ) ) )
rst = print ( <unk> ( A . strip ( ) ) ) <eos>
2802
src = 2 から 10 未 満 までの 数 列 を 順に A として 、 繰り返す
trg = for A in range ( 2 , 10 ) :
rst = for A in range ( 2 , 10 ) : <eos>
2803
src = 改行 せずに A を 英 大文字 に変換し た 文字列 を出力する
trg = print ( A . upper ( ) , end = '' )
rst = print ( A . upper ( ) , end = '' ) <eos>
2804
src = generate _ prime _ numbers ( num _ max = B ) を 順に A として 、 繰り返す
trg = for A in generate_prime_numbers ( num_max = B ) :
rst = for A in <unk> ( B ) : <eos>
2805
src = 0 から 4 未 満 までの 数 列 の 各要素 を C とし 、 0 から 13 未 満 までの 数 列 の 各要素 を B とし 、 、 つまり 偽 の 列 の 列 を A とする
trg = A = [ [ False for B in range ( 13 ) ] for C in range ( 4 ) ]
rst = A = [ [ False for B in range ( 13 ) ] for C in range ( 4 ) ] <eos>
2806
src = copy の 4 番 目 を A の 5 番 目 にする
trg = A [ 5 ] = copy [ 4 ]
rst = A [ 5 ] = copy [ 4 ] <eos>
2807
src = A が 1989 0 10 8 以上の とき 、
trg = if A >= 19890108 :
rst = if A >= <unk> : <eos>
2808
src = ( A ) からなる 列 の集合 が B の 部分 集合 の とき 、
trg = if set ( [ A ] ) . issubset ( B ) :
rst = if set ( [ A ] ) . set ( B ) : <eos>
2809
src = ( ( 0 、 -1 ) の 組 、 ( 1 、 0 ) の 組 、 ( 0 、 1 ) の 組 、 ( -1 、 0 ) の 組 ) からなる 列 を A とする
trg = A = [ ( 0 , - 1 ) , ( 1 , 0 ) , ( 0 , 1 ) , ( - 1 , 0 ) ]
rst = A = [ ( 0 , - 1 ) , ( 1 , 0 ) , ( 0 , 1 ) , ( - 1 , 0 ) ] <eos>
2810
src = 入力された 文字列を 空白 で 分割 した 字句 列 の 各要素 に 浮動小数点数 を適用した 列 を 展開 し 、 それぞれ 、 つまり ネ イ ピ ア 数 、 A とする
trg = e , A = map ( float , input ( ) . split ( ) )
rst = e , A = map ( float , input ( ) . split ( ) ) <eos>
2811
src = ( B ) からなる 列 の C に D に 1 を加えた 値を 掛 け た 値に 2 を加えた 値 回 分 の 列 を A とする
trg = A = [ B ] * ( C * ( D + 1 ) + 2 )
rst = A = [ B ] * ( C * ( D + 1 ) + 2 ) <eos>
2812
src = 1 e 9 を A とする
trg = A = 1e9
rst = A = 1e-9 <eos>
2813
src = 0 から 7 未 満 までの 数 列 の 各要素 を B とし 、 B の 列 を A とする
trg = A = [ B for B in range ( 7 ) ]
rst = A = [ B for B in range ( 7 ) ] <eos>
2814
src = A . search ( B , C ) を返す
trg = return A . search ( B , C )
rst = return A . search ( B , C ) <eos>
2815
src = 改行 せずに A を 書式 として B の C 番 目 で 整 形 した 文字列 を出力する
trg = print ( A . format ( B [ C ] ) , end = '' )
rst = print ( A . format ( B [ C ] ) , end = '' ) <eos>
2816
src = A が B の C の FORESIDE 番 目 と 等 しい とき 、
trg = if A == B [ C . FORESIDE ] :
rst = if A == B [ C . <unk> ] : <eos>
2817
src = ( A 、 B に 1 を加えた 値 ) の 組 が C に 含まれ ない とき 、
trg = if ( A , B + 1 ) not in C :
rst = if ( A , B + 1 ) not in C : <eos>
2818
src = C の先頭 を取り 出した 値を A の B 番 目 にする
trg = A [ B ] = C . pop ( )
rst = A [ B ] = C . pop ( ) <eos>
2819
src = A の 末 尾 に 偽 を追加する
trg = A . append ( False )
rst = A . append ( False ) <eos>
2820
src = palindrome ( B , C ) を A とする
trg = A = palindrome ( B , C )
rst = A = <unk> ( B , C ) <eos>
2821
src = ( C 、 D ) からなる 列 を A の B 番目の c にする
trg = A [ B ] . c = [ C , D ]
rst = A [ B ] . c = [ C , D ] <eos>
2822
src = 0 から E 未 満 までの 数 列 の 各要素 を D とし 、 readline () を 空白 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 の 列 を 順に A 、 B 、 C として 、 繰り返す
trg = for A , B , C in ( [ map ( int , readline ( ) . split ( ) ) for D in range ( E ) ] ) :
rst = for A , B , C in [ map ( int , readline ( ) . split ( ) ) for D in range ( E ) ] : <eos>
2823
src = AhoCorasick () を A とする
trg = A = AhoCorasick ( )
rst = A = <unk> ( ) <eos>
2824
src = Point ( 0.0 , 0.0 ) 、 Point ( 0.0 , 0.0 ) 、 Point ( 0.0 , 0.0 ) を A 、 B 、 C とする
trg = A , B , C = Point ( 0.0 , 0.0 ) , Point ( 0.0 , 0.0 ) , Point ( 0.0 , 0.0 )
rst = A , B , C = Point ( 0.0 , 0.0 ) , Point ( 0.0 , 0.0 ) , Point ( 0.0 , 0.0 ) <eos>
2825
src = A の 0 番 目 が B に 含まれ かつ A の 1 番 目 が C に含まれる とき 、
trg = if A [ 0 ] in B and A [ 1 ] in C :
rst = if A [ 0 ] in B and A [ 1 ] in C : <eos>
2826
src = C の 各要素 を A とし 、 A の 、 つまり 先頭 から B 番 目 までの 部分 列 の 列 の集合 の長さ が D と 等 しい とき 、
trg = if len ( set ( [ A [ : B ] for A in C ] ) ) == D :
rst = if len ( set ( [ A [ : B ] for A in C ] ) ) == D : <eos>
2827
src = A の 1 番 目 、 A の 5 番 目 、 A の 2 番 目 、 A の 3 番 目 、 A の先頭 、 A の 4 番 目 を A の先頭 、 A の 1 番 目 、 A の 2 番 目 、 A の 3 番 目 、 A の 4 番 目 、 A の 5 番 目 とする
trg = A [ 0 ] , A [ 1 ] , A [ 2 ] , A [ 3 ] , A [ 4 ] , A [ 5 ] = A [ 1 ] , A [ 5 ] , A [ 2 ] , A [ 3 ] , A [ 0 ] , A [ 4 ]
rst = A [ 0 ] , A [ 1 ] , A [ 2 ] , A [ 3 ] , A [ 4 ] , A [ 5 ] = A [ 1 ] , A [ 5 ] , A [ 2 ] , A [ 3 ] ,
2828
src = 真 を A の 3 番目の B の 整数値 から 1 を 引 いた 値 番 目 にする
trg = A [ 3 ] [ int ( B ) - 1 ] = True
rst = A [ 3 ] [ int ( B ) - 1 ] = True <eos>
2829
src = array モジュール を用いる
trg = import array
rst = import array <eos>
2830
src = A に 2 を 掛 け た 値が B より 小さい とき 、
trg = if A * 2 < B :
rst = if A * 2 < B : <eos>
2831
src = 無限 の 整数 列 を A の長さ から 1 を 引 いた 値 から B を 引 いた 値 だけ 増加 させる
trg = count += ( len ( A ) - 1 ) - B
rst = count += len ( A ) - 1 - B <eos>
2832
src = datetime を A とする
trg = A = datetime ( B , C , D )
rst = A = datetime ( B , C ) <eos>
2833
src = 真 を A の 7 に B から C を 引 いた 値 を加えた 値 番 目 にする
trg = A [ 7 + ( B - C ) ] = True
rst = A [ 7 + ( B - C ) ] = True <eos>
2834
src = 0 を A の ( B 、 0 ) の 組 番 目 にする
trg = A [ ( B , 0 ) ] = 0
rst = A [ ( B , 0 ) ] = 0 <eos>
2835
src = A を dfs ( B + 1, C ) だけ 増加 させる
trg = A += dfs ( B + 1 , C )
rst = A += dfs ( B + 1 , C ) <eos>
2836
src = A から B を 引 いた 値が 0 より 小さく または A から B を 引 いた 値が C から D を 引 いた 値 より 大きく または B が D より 大きい とき 、
trg = if A - B < 0 or A - B > C - D or B > D :
rst = if A - B < 0 or A - B > C - D or B > D : <eos>
2837
src = B から check ( C , D ) を 引 いた 値を A とする
trg = A = B - check ( C , D )
rst = A = B - check ( C , D ) <eos>
2838
src = A の 2 番目の 文字列を A の 2 番 目 にする
trg = A [ 2 ] = str ( A [ 2 ] )
rst = A [ 2 ] = str ( A [ 2 ] ) <eos>
2839
src = 1 から 13 未 満 までの 数 列 を 順に A として 、 繰り返す
trg = for A in range ( 1 , 13 ) :
rst = for A in range ( 1 , 13 ) : <eos>
2840
src = calc _ LCM ( A , B ) を A とする
trg = A = calc_LCM ( A , B )
rst = A = <unk> ( A , B ) <eos>
2841
src = A の B 番 目 から C を 引 いた 値の 絶対 値が 0.5 より 大きい とき 、
trg = if abs ( A [ B ] - C ) > 0.5 :
rst = if abs ( A [ B ] - C ) > 0.5 : <eos>
2842
src = 0 から D 未 満 までの 数 列 の 各要素 を C とし 、 1 を B だけ 左 シフト した 値 から 1 を 引 いた 値の 列 を A とする
trg = A = [ ( 1 << B ) - 1 for C in range ( D ) ]
rst = A = [ 1 << ( B ) - 1 for C in range ( D ) ] <eos>
2843
src = A の -1 番 目 が 0 以上の とき 、
trg = if A [ - 1 ] >= 0 :
rst = if A [ - 1 ] >= 0 : <eos>
2844
src = ( 、 つまり 未 定 値 ) からなる 列 の B に 2 を加えた 値 回 分 の 列 を A とする
trg = A = [ None ] * ( B + 2 )
rst = A = [ None ] * ( B + 2 ) <eos>
2845
src = A が B に 含まれ なければならない
trg = assert A in B
rst = assert A in B <eos>
2846
src = A が 0 より 大きく または B の C 番目の とき 、
trg = if A > 0 or B [ C ] :
rst = if A > 0 or B [ C ] : <eos>
2847
src = A を 書式 として B の先頭 の先頭 、 time で 整 形 した 文字列 を出力する
trg = print ( A . format ( B [ 0 ] [ 0 ] , time ) )
rst = print ( A . format ( B [ 0 ] [ 0 ] , time ) ) <eos>
2848
src = ( ( B , D [ E ] に 番号 付 した 組 の 列 の 各要素 を C 、 B とし 、 C の 列 ) ) からなる 辞書 の長さ を A とする
trg = A = len ( { v : [ C for C , B in enumerate ( D [ E ] ) ] } )
rst = A = { <unk> <unk> : [ len ( B ) for C , B in enumerate ( D [ E ] ) ] } <eos>
2849
src = A の next の next を A の next にする
trg = A . next = A . next . next
rst = A . next = A . next . next <eos>
2850
src = B の C の 2 番 目 番 目 に B の C の 3 番 目 番 目 を加えた 値を A とする
trg = A = B [ C [ 2 ] ] + B [ C [ 3 ] ]
rst = A = B [ C [ 2 ] ] + B [ C [ 3 ] ] <eos>
2851
src = B に 5 を 掛 け た 値を A の 2 番 目 にする
trg = A [ 2 ] = B * 5
rst = A [ 2 ] = B * 5 <eos>
2852
src = A が 0 より 大きく かつ B の A から 1 を 引 いた 値 番 目 が 、 つまり 空白 文字 と 等 しい 間 、 次 を 繰り返す
trg = while A > 0 and B [ A - 1 ] == ' ' :
rst = while A > 0 and B [ A - 1 ] == ' ' : <eos>
2853
src = ネ イ ピ ア 数 、 ネ イ ピ ア 数 を A の B 番目の C 番 目 、 A の C 番目の B 番 目 とする
trg = A [ B ] [ C ] , A [ C ] [ B ] = e , e
rst = A [ B ] [ C ] , A [ C ] [ B ] = e , e <eos>
2854
src = A を B の C 番目の 整数値 に 6 から C を 引 いた 値を 掛 け た 値 だけ 増加 させる
trg = A += int ( B [ C ] ) * ( 6 - C )
rst = A += int ( B [ C ] ) * ( 6 - C ) <eos>
2855
src = A を 10 から B を 引 いた 値に 1 を加えた 値を 2 で 割 った 商 だけ 増加 させる
trg = A += ( 10 - B + 1 ) // 2
rst = A += ( 10 - B + 1 ) // 2 <eos>
2856
src = A を B に C の D 番 目 を 掛 け た 値の 整数値 だけ 増加 させる
trg = A += int ( B * C [ D ] )
rst = A += int ( B * C [ D ] ) <eos>
2857
src = A を B に 2 を 掛 け た 値に C に 2 を 掛 け た 値 を加えた 値 だけ 増加 させる
trg = A += B * 2 + C * 2
rst = A += B * 2 + C * 2 <eos>
2858
src = analyze _ map ( B ) を A とする
trg = A = analyze_map ( B )
rst = A = <unk> ( B ) <eos>
2859
src = A の north を返す
trg = return A . north
rst = return A . north <eos>
2860
src = 0 < = A が B より 小さく なく または 0 < = C が D より 小さく なく または E の A 番目の C 番 目 または F が G の A 番目の C 番 目 と 等 しく ない とき 、
trg = if not 0 <= A < B or not 0 <= C < D or E [ A ] [ C ] or F != G [ A ] [ C ] :
rst = if not 0 <= A < B or not 0 <= C < D or E [ A ] [ C ] != F or G [ A ] [ C ] != G : <eos>
2861
src = 1 から B から 2 を 引 いた 値 未 満 までの 数 列 を 順に A として 、 繰り返す
trg = for A in range ( 1 , B - 2 ) :
rst = for A in range ( 1 , B - 2 ) : <eos>
2862
src = 0 を A の B から 1 を 引 いた 値 番目の C に 1 を加えた 値 番 目 にする
trg = A [ B - 1 ] [ C + 1 ] = 0
rst = A [ B - 1 ] [ C + 1 ] = 0 <eos>
2863
src = A の 末 尾 に ( B に 1 を加えた 値 、 C に 1 を加えた 値 、 2 ) の 組 を追加する
trg = A . append ( ( B + 1 , C + 1 , 2 ) )
rst = A . append ( ( B + 1 , C + 1 , 2 ) ) <eos>
2864
src = 2.0 0000 0
trg = 2.000000
rst = 10000000 <eos>
2865
src = leftend ( B ) を A とする
trg = A = leftend ( B )
rst = A = <unk> ( B ) <eos>
2866
src = A . show _ status ()
trg = A . show_status ( )
rst = A . <unk> ( ) <eos>
2867
src = ( 0 ) からなる 列 の 60 に 60 を 掛 け た 値に 24 を 掛 け た 値に 1 を加えた 値 回 分 の 列 を time とする
trg = time = [ 0 ] * ( 60 * 60 * 24 + 1 )
rst = time = [ 0 ] * ( 60 * 60 + 1 ) <eos>
2868
src = A の B 番 目 から 、 つまり 末 尾 までの 部分 列 が C の 、 つまり 先頭 から D 番 目 までの 部分 列 と 等 しい とき 、
trg = if A [ B : ] == C [ : D ] :
rst = if A [ B : ] == C [ : D ] : <eos>
2869
src = A から 1 を 引 いた 値を 5 で 割 った 余 り を返す
trg = return ( A - 1 ) % 5
rst = return ( A - 1 ) % 5 <eos>
2870
src = solve ( 0 ) 、 solve (1) の 最小 値 を出力する
trg = print ( min ( solve ( 0 ) , solve ( 1 ) ) )
rst = print ( min ( solve ( 0 ) , solve ( 1 ) ) ) <eos>
2871
src = heapreplace ( C . _ cacheq , ( time . clock () , D ) ) を 展開 し 、 それぞれ A 、 B とする
trg = A , B = heapreplace ( C . _cacheq , ( time . clock ( ) , D ) )
rst = A , B = <unk> ( C . _cacheq , next ( time . <unk> ( ) , D ) ) <eos>
2872
src = koch _ curve ( B [ 3 ] , B [ 4 ] , C -1 ) を A とする
trg = A = koch_curve ( B [ 3 ] , B [ 4 ] , C - 1 )
rst = A = koch_curve ( B [ 3 ] , B [ 4 ] , C - 1 ) <eos>
2873
src = A を get _ pro ( B , C ) だけ 増加 させる
trg = A += get_pro ( B , C )
rst = A += <unk> ( B , C ) <eos>
2874
src = ( A 、 os . path ) からなる 列 を返す
trg = return [ A , path ]
rst = return [ A , path ] <eos>
2875
src = A に B の C 番目の 整数値 を加えた 値を A とする
trg = A = A + int ( B [ C ] )
rst = A = A + int ( B [ C ] ) <eos>
2876
src = 1 に B の 各要素 を A とし 、 A が 0 より 大きい とき の A の 列 の長さ を加えた 値 を出力する
trg = print ( 1 + len ( [ A for A in B if A > 0 ] ) )
rst = print ( 1 + len ( [ A for A in B if A > 0 ] ) ) <eos>
2877
src = B の とき 7 200 から C を 引 いた 値 、 そうでなければ 7 200 から C を 引 いた 値に 3 を 掛 け た 値を A とする
trg = A = 7200 - C if B else ( 7200 - C ) * 3
rst = A = ( C - 200 ) if B else ( C - 200 ) * 200 <eos>
2878
src = check ( input () )
trg = check ( input ( ) )
rst = check ( input ( ) ) <eos>
2879
src = B を A の 0 番 目 にする
trg = A [ 0 ] = B
rst = A [ 0 ] = B <eos>
2880
src = A の B 番目の 1 番 目 が C 以下の とき 、
trg = if A [ B ] [ 1 ] <= C :
rst = if A [ B ] [ 1 ] <= C : <eos>
2881
src = C の 各要素 を B とし 、 B の 浮動小数点数 の 列 を A とする
trg = A = [ float ( B ) for B in C ]
rst = A = [ float ( B ) for B in C ] <eos>
2882
src = A . preprint ( A . root )
trg = A . preprint ( A . root )
rst = A . <unk> ( A . root ) <eos>
2883
src = B を A の W にする
trg = A . W = B
rst = A . W = B <eos>
2884
src = 入力された 文字列を 空白 で 分割 した 字句 列 の 各要素 を B とし 、 ( B の先頭 、 B の先頭 を 除 いた 部分 列 の 整数値 ) の 組 の 列 を A とする
trg = A = [ ( B [ 0 ] , int ( B [ 1 : ] ) ) for B in input ( ) . split ( ) ]
rst = A = [ ( B [ 1 : ] , int ( B [ 1 : ] ) ) for B in input ( ) . split ( ) ] <eos>
2885
src = B の 4 番 目 から B の 1 番 目 を 引 いた 値を A とする
trg = A = B [ 4 ] - B [ 1 ]
rst = A = B [ 4 ] - B [ 1 ] <eos>
2886
src = A と B の 排 他 論理 和 が 0 以上の とき 、
trg = if A ^ B >= 0 :
rst = if A ^ B >= 0 : <eos>
2887
src = solve ( 0 , A , B ) の とき 、
trg = if solve ( 0 , A , B ) :
rst = if solve ( 0 , A , B ) : <eos>
2888
src = A と B の 排 他 論理 和 の 2 進 数 文字列 の 2 番 目 から 、 つまり 末 尾 までの 部分 列 を 長さ 7 になる ように ' 0 ' 左 詰 め した 文字列 を返す
trg = return bin ( A ^ B ) [ 2 : ] . zfill ( 7 )
rst = return bin ( A ^ B ) [ 2 : ] . zfill ( 7 ) <eos>
2889
src = - A に B を 掛 け た 値に C を 掛 け た 値 から D に E を 掛 け た 値に F を 掛 け た 値を 引 いた 値 から G に H を 掛 け た 値に I を 掛 け た 値を 引 いた 値
trg = - A * B * C - D * E * F - G * H * I
rst = - ( A * B * C - D * E * F - G * H - I ) / I <eos>
2890
src = A の B 番 目 で なく かつ C の B 番 目 が D より 小さい とき 、
trg = if ( not A [ B ] ) and ( C [ B ] < D ) :
rst = if not A [ B ] and C [ B ] < D : <eos>
2891
src = A を 空白 文字 を 間 に 入れ て C の 、 つまり 先頭 から D 番 目 までの 部分 列 の 各要素 を B とし 、 B の 文字列 の 列 を 連結 した 文字列 に 空白 文字 を加えた 値 だけ 増加 させる
trg = A += ' ' . join ( [ str ( B ) for B in C [ : D ] ] ) + ' '
rst = A += ' ' . join ( [ str ( B ) for B in C [ : D ] ] ) + ' ' . join ( [ str ( B ) for B in C [ : D ] ] ) <eos>
2892
src = D の ( B 、 C から 1 を 引 いた 値 ) の 組 番 目 を A の ( B 、 C から 1 を 引 いた 値 ) の 組 番 目 にする
trg = A [ ( B , C - 1 ) ] = D [ ( B , C - 1 ) ]
rst = A [ ( B , C - 1 ) ] = D [ ( B , C - 1 ) ] <eos>
2893
src = change ( A , B ) を出力する
trg = print ( change ( A , B ) )
rst = print ( change ( A , B ) ) <eos>
2894
src = 1 から B の 最大 値に 1 を加えた 値 未 満 までの 数 列 を 順に A として 、 繰り返す
trg = for A in range ( 1 , max ( B ) + 1 ) :
rst = for A in range ( 1 , max ( B ) + 1 ) : <eos>
2895
src = op ( merge ( C [ B ] , D [ B ] ) , A [ E ] ) を A の B 番 目 にする
trg = A [ B ] = op ( merge ( C [ B ] , D [ B ] ) , A [ E ] )
rst = A [ B ] = op ( C [ B ] , D [ B ] , A [ E ] ) <eos>
2896
src = C を A の B 番目の sib にする
trg = A [ B ] . sib = C
rst = A [ B ] . sib = C <eos>
2897
src = B に 1 を加えた 値 から 2 に B を 掛 け た 値に 1 を加えた 値 未 満 までの 数 列 を 順に A として 、 繰り返す
trg = for A in range ( B + 1 , 2 * B + 1 ) :
rst = for A in range ( B + 1 , 2 * B + 1 ) : <eos>
2898
src = A が ( 1 、 1 、 1 、 2 ) からなる 列 と 等 しい とき 、
trg = if A == [ 1 , 1 , 1 , 2 ] :
rst = if A == [ 1 , 1 , 1 , 1 , 2 ] : <eos>
2899
src = 入力された 文字列を 空白 文字 で 分割 した 字句 列 の 各要素 を B とし 、 B の 整数値 から 1 を 引 いた 値の 列 を A とする
trg = A = [ int ( B ) - 1 for B in input ( ) . split ( ' ' ) ]
rst = A = [ int ( B ) - 1 for B in input ( ) . split ( ' ' ) ] <eos>
2900
src = 0 が A 以下 かどうか が B より 小さく かつ 0 が C 以下 かどうか が D より 小さい 間 、 次 を 繰り返す
trg = while 0 <= A < B and 0 <= C < D :
rst = while 0 <= A < B and 0 <= C < D : <eos>
2901
src = ( < __ main __ . Cammaobjectat 0 x 10 a 1 db 7 30 > ) の集合 を A とする
trg = A = { B }
rst = A = { [ tuple ( map ( int , input ( ) . split ( ) ) ) for B in range ( C ) ] } <eos>
2902
src = - B の先頭 の C 番 目 を A とする
trg = A = - B [ 0 ] [ C ]
rst = A = - B [ 0 ] [ C ] <eos>
2903
src = B を A の head の next の prev にする
trg = A . head . next . prev = B
rst = A . head . next . prev = B <eos>
2904
src = ( 5 、 7 、 5 、 7 、 7 ) の 組 を A とする
trg = A = ( 5 , 7 , 5 , 7 , 7 )
rst = A = ( 5 , 7 , 5 , 7 , 7 ) <eos>
2905
src = ( 10 0.0 、 0.0 ) からなる 列 を A とする
trg = A = [ 100.0 , 0.0 ]
rst = A = [ 10 , 0.0 ] <eos>
2906
src = B の 、 つまり 先頭 から C を 2 で 割 った 商 までの 部分 列 を A とする
trg = A = B [ : C // 2 ]
rst = A = B [ : C // 2 ] <eos>
2907
src = A に B の C 番目の 整数値 から D を 引 いた 値の 2 乗 を加えた 値を A とする
trg = A = A + ( int ( B [ C ] ) - D ) ** 2
rst = A = A + ( int ( B [ C ] ) - D ) ** 2 <eos>
2908
src = B が C に含まれる かどうか を A とする
trg = A = B in C
rst = A = ( B in C ) <eos>
2909
src = -1 を 現在の 日 時 とする
trg = now = - 1
rst = now = - 1 <eos>
2910
src = A の B 番 目 から B に 2 を加えた 値 までの 部分 列 を削除する
trg = del A [ B : B + 2 ]
rst = del A [ B : B + 2 ] <eos>
2911
src = 入力された 文字列を 空白 文字 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 を 展開 し 、 それぞれ A 、 B とする
trg = A , B = map ( int , input ( ) . split ( ' ' ) )
rst = A , B = map ( int , input ( ) . split ( ' ' ) ) <eos>
2912
src = input () を 空白 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 を ソート した 列 を 展開 して を出力する
trg = print ( * sorted ( map ( int , input ( ) . split ( ) ) ) )
rst = print ( * sorted ( map ( int , input ( ) . split ( ) ) ) ) <eos>
2913
src = C に D を 掛 け た 値に E を 掛 け た 値 から F に G を 掛 け た 値に H を 掛 け た 値を 引 いた 値 、 D に F を 掛 け た 値に E を 掛 け た 値を A 、 B とする
trg = A , B = C * D * E - F * G * H , D * F * E
rst = A , B = ( C * D * E - F * G * H * H ) , F * D * E <eos>
2914
src = 0 < = A が B より 小さく なく または 0 < = C が D より 小さく なく または E の C 番目の A 番 目 が 0 と 等 しく または F の C 番目の A 番 目 が 1 と 等 しい とき 、
trg = if not 0 <= A < B or not 0 <= C < D or E [ C ] [ A ] == 0 or F [ C ] [ A ] == 1 :
rst = if not 0 <= A < B or not 0 <= C < D or E [ C ] [ A ] == 0 or F [ C ] [ A ] == 1 : <eos>
2915
src = A の B の 1 番 目 番目の 末 尾 に B の先頭 を追加する
trg = A [ B [ 1 ] ] . append ( B [ 0 ] )
rst = A [ B [ 1 ] ] . append ( B [ 0 ] ) <eos>
2916
src = B の C 番 目 に D の E 番 目 を加えた 値 、 B の E 番 目 に D の C 番 目 を加えた 値の 最小 値に 1 を加えた 値を A とする
trg = A = min ( B [ C ] + D [ E ] , B [ E ] + D [ C ] ) + 1
rst = A = min ( B [ C ] + D [ E ] , B [ E ] + D [ C ] + 1 ) <eos>
2917
src = ( ( -1 ) からなる 列 の 0 から 3 未 満 までの 数 列 の 各要素 を B とし 、 3 の 列 回 分 の 列 ) からなる 列 を A とする
trg = A = [ [ - 1 ] * [ 3 for B in range ( 3 ) ] ]
rst = A = [ [ - 1 ] * [ 3 for B in range ( 3 ) ] ] <eos>
2918
src = A に 1 から 1 を B の先頭 で 割 った 値を 引 いた 値を 掛 け た 値を A とする
trg = A = A * ( 1 - 1 / B [ 0 ] )
rst = A = A * ( 1 - 1 / B [ 0 ] ) <eos>
2919
src = A を 書式 として B . get _ top _ value () で 整 形 した 文字列 を出力する
trg = print ( A . format ( B . get_top_value ( ) ) )
rst = print ( A . format ( B . <unk> ( ) ) ) <eos>
2920
src = 入力された 文字列を 空白 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 の リストを 展開 し 、 それぞれ 、 つまり ネ イ ピ ア 数 、 A 、 B とする
trg = e , A , B = list ( map ( int , input ( ) . split ( ) ) )
rst = e , A , B = list ( map ( int , input ( ) . split ( ) ) ) <eos>
2921
src = A を B の 2 番 目 に 10 を 掛 け た 値 だけ 減少 させる
trg = A -= B [ 2 ] * 10
rst = A -= B [ 2 ] * 10 <eos>
2922
src = x を パラメータ として ( - B の 1 番 目 、 x の先頭 ) の 組 を返す関数 を キー として A を ソート した 列 を A とする
trg = A = sorted ( A , key = lambda B : ( - B [ 1 ] , B [ 0 ] ) )
rst = A = sorted ( A , key = lambda B : ( - B [ 1 ] , B [ 0 ] ) ) <eos>
2923
src = A の B 番 目 が C 以下 かどうか が A の B に 1 を加えた 値 番 目 より 小さい とき 、
trg = if A [ B ] <= C < A [ B + 1 ] :
rst = if A [ B ] <= C < A [ B + 1 ] : <eos>
2924
src = A 、 solve ( B , C - 1, D -1 ) の 最大 値を A とする
trg = A = max ( A , solve ( B , C - 1 , D - 1 ) )
rst = A = max ( A , solve ( B , C - 1 , D - 1 ) ) <eos>
2925
src = B の data と B の masks の C 番目の 論理 積 を A とする
trg = A = B . data & B . masks [ C ]
rst = A = B . data & B . masks [ C ] <eos>
2926
src = A の level の B 番 目 が -1 と 等 しい とき 、
trg = if A . level [ B ] == - 1 :
rst = if A . level [ B ] == - 1 : <eos>
2927
src = next _ survive ( A ) と B の 論理 積 を A とする
trg = A = next_survive ( A ) & B
rst = A = <unk> ( A ) & B <eos>
2928
src = x 、 y を パラメータ として A から B を 引 いた 値の 2 乗 に C から D を 引 いた 値の 2 乗 を加えた 値の 平 方 根 を返す関数 を返す
trg = return lambda A , C : sqrt ( ( A - B ) ** 2 + ( C - D ) ** 2 )
rst = return lambda B , C : math . sqrt ( ( A - B ) ** 2 + ( C - D ) ** 2 ) <eos>
2929
src = E の graph の E の pos の F 番目の 先頭 番目の E の pos の F 番目の 1 番 目 番 目 を 展開 し 、 それぞれ A 、 B 、 C 、 D とする
trg = A , B , C , D = E . graph [ E . pos [ F ] [ 0 ] ] [ E . pos [ F ] [ 1 ] ]
rst = A , B , C , D = E . graph [ E . pos [ F ] [ 0 ] ] [ E . pos [ F ] [ 1 ] ] <eos>
2930
src = A の sizes の B 番 目 を A の sizes の C 番 目 だけ 増加 させる
trg = A . sizes [ B ] += A . sizes [ C ]
rst = A . <unk> [ B ] += A . <unk> [ C ] <eos>
2931
src = A の 0 番 目 が A の 1 番 目 から A の 2 番 目 を 引 いた 値の 絶対 値 以下の とき 、
trg = if A [ 0 ] <= math . fabs ( A [ 1 ] - A [ 2 ] ) :
rst = if abs ( A [ 0 ] <= A [ 1 ] - A [ 2 ] ) : <eos>
2932
src = A の 先頭に B の 1 番 目 を 掛 け た 値 から B の 先頭に A の 1 番 目 を 掛 け た 値を 引 いた 値を返す
trg = return A [ 0 ] * B [ 1 ] - B [ 0 ] * A [ 1 ]
rst = return A [ 0 ] * B [ 1 ] - B [ 0 ] * A [ 1 ] <eos>
2933
src = A の 、 つまり ネ イ ピ ア 数 番 目 に B に C を 掛 け た 値 を加えた 値を A の 、 つまり ネ イ ピ ア 数 番 目 にする
trg = A [ e ] = A [ e ] + B * C
rst = A [ e ] = A [ e ] + B * C <eos>
2934
src = A が B より 小さく または C が D より 小さい とき 、
trg = if A < B or C < D :
rst = if A < B or C < D : <eos>
2935
src = Point ( 0.0 , 0.0 ) を A とする
trg = A = Point ( 0.0 , 0.0 )
rst = A = Point ( 0.0 , 0.0 ) <eos>
2936
src = A の B 番目の C に 1 を加えた 値 番 目 、 D に 1 を加えた 値の 最大 値を A の B 番目の C に 1 を加えた 値 番 目 にする
trg = A [ B ] [ C + 1 ] = max ( A [ B ] [ C + 1 ] , D + 1 )
rst = A [ B ] [ C + 1 ] = max ( A [ B ] [ C + 1 ] , D + 1 ) <eos>
2937
src = fmap [ t ] ( * B ) を A とする
trg = A = fmap[t] ( * B )
rst = A = <unk> ( * B ) <eos>
2938
src = A の B 番 目 が 0 と 等 しく ない とき 、
trg = if A [ B ] != 0 :
rst = if A [ B ] != 0 : <eos>
2939
src = A が 27 と 等 しい とき 、
trg = if A == 27 :
rst = if A == 27 : <eos>
2940
src = ( A の先頭 、 B 、 C 、 D 、 A の 1 番 目 ) からなる 列 を返す
trg = return ( [ A [ 0 ] , B , C , D , A [ 1 ] ] )
rst = return [ A [ 0 ] , B , C , D , A [ 1 ] ] <eos>
2941
src = A [ B ] の C 番 目 に A [ B + 1 ] の C -1 番 目 を加えた 値に A の B + 1 番目の C 番 目 を加えた 値に A の B に 2 を加えた 値 番目の C から 1 を 引 いた 値 番 目 を加えた 値が 4 と 等 しい とき 、
trg = if A [ B ] [ C ] + A [ B + 1 ] [ C - 1 ] + A [ B + 1 ] [ C ] + A [ B + 2 ] [ C - 1 ] == 4 :
rst = if A [ B ] [ C ] + A [ B + 1 ] [ C - 1 ] + A [ B + 1 ] [ C + A [ B - 2 ] [ C - 1 ] == 4 : <eos>
2942
src = A の B 番 目 かつ C の B 番 目 でない とき 、
trg = if A [ B ] and not C [ B ] :
rst = if A [ B ] and not C [ B ] : <eos>
2943
src = 入力された 文字列を 空白 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 のリスト 、 入力された 文字列を 空白 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 のリスト 、 集合 を A 、 B 、 C とする
trg = A , B , C = list ( map ( int , input ( ) . split ( ) ) ) , list ( map ( int , input ( ) . split ( ) ) ) , set ( )
rst = A , B , C = list ( map ( int , input ( ) . split ( ) ) ) , list ( map ( int , input ( ) . split ( ) ) ) <eos>
2944
src = 入力された 文字列 の 両 端 から 空白 改行 を取り 除 いた 文字列を A の 0 番 目 にする
trg = A [ 0 ] = input ( ) . strip ( )
rst = A [ 0 ] = input ( ) . strip ( ) <eos>
2945
src = B の 総 和 から C を 引 いた 値を A とする
trg = A = sum ( B ) - C
rst = A = sum ( B ) - C <eos>
2946
src = 0 から 2 に C を 掛 け た 値 未 満 までの 数 列 の 各要素 を B とし 、 、 つまり 空 列 の 列 を A とする
trg = A = [ [ ] for B in range ( 2 * C ) ]
rst = A = [ [ ] for B in range ( 2 * C ) ] <eos>
2947
src = A の root ( B ) 番 目 を ネ イ ピ ア 数 とする
trg = e = A [ root ( B ) ]
rst = e = A [ root ( B ) ] <eos>
2948
src = A 、 B の C 番目の D 番 目 に B の D 番目の D に 1 を加えた 値 番 目 を加えた 値の 最大 値を A とする
trg = A = max ( A , B [ C ] [ D ] + B [ D ] [ D + 1 ] )
rst = A = max ( A , B [ C ] [ D ] + B [ D ] [ D + 1 ] ) <eos>
2949
src = B の 整数値 から C の 整数値 を 引 いた 値の 文字列を 長さ 4 になる ように ' 0 ' 左 詰 め した 文字列を A とする
trg = A = str ( int ( B ) - int ( C ) ) . zfill ( 4 )
rst = A = str ( int ( B ) - int ( C ) ) . zfill ( 4 ) <eos>
2950
src = A の B 番目の children の 末 尾 に C を追加する
trg = A [ B ] . children . append ( C )
rst = A [ B ] . children . append ( C ) <eos>
2951
src = A の長さ かつ B の A の 末 尾 番 目 が 0 以上の 間 、 次 を 繰り返す
trg = while len ( A ) and B [ A [ - 1 ] ] >= 0 :
rst = while len ( A ) and B [ A [ - 1 ] ] >= 0 : <eos>
2952
src = 0 が A から 1 を 引 いた 値 以下 かどうか が B より 小さく かつ 0 が C 以下 かどうか が D より 小さく かつ E の C 番目の A から 1 を 引 いた 値 番 目 が F と 等 しい とき 、
trg = if 0 <= A - 1 < B and 0 <= C < D and E [ C ] [ A - 1 ] == F :
rst = if 0 <= A - 1 < B and 0 <= C < D and E [ C ] [ A - 1 ] == F : <eos>
2953
src = B . itemgetter (1) を key として A の 最大 値 の先頭 を出力する
trg = print ( max ( A , key = B . itemgetter ( 1 ) ) [ 0 ] )
rst = print ( max ( A . key , key = B . itemgetter ( 1 ) ) [ 0 ] ) <eos>
2954
src = 0.0 を A の B 番目の 0 番 目 にする
trg = A [ B ] [ 0 ] = 0.0
rst = A [ B ] [ 0 ] = 0.0 <eos>
2955
src = A の B 番 目 が C と 等 しい かどうか を返す
trg = return A [ B ] == C
rst = return A [ B ] == C <eos>
2956
src = A の next が 、 つまり 未 定 値 と 等 しい とき 、
trg = if A . next is not None :
rst = if A . next == None : <eos>
2957
src = F の G から H を 引 いた 値 番 目 を E とする
trg = E = F [ G - H ]
rst = E = F [ G - H ] <eos>
2958
src = 文字コード A の 1 と 等 しい 要素 の最初の 位置 に 6 5 を加えた 値の 文字 を出力する
trg = print ( chr ( A . index ( 1 ) + 65 ) )
rst = print ( chr ( A . index ( 1 ) + 65 ) ) <eos>
2959
src = ( ( 99 99 99 99 ) からなる 列 の 0 から D の長さ 未 満 までの 数 列 の 各要素 を C とし 、 B を 100 で 割 った 商 に 1 を加えた 値の 列 回 分 の 列 ) からなる 列 を A とする
trg = A = [ [ 99999999 ] * [ ( B // 100 + 1 ) for C in range ( len ( D ) ) ] ]
rst = A = [ [ <unk> ] * [ ( B // 100 + 1 ) for C in range ( len ( D ) ) ] ] <eos>
2960
src = B から 、 つまり ネ イ ピ ア 数 未 満 までの 数 列 を 順に A として 、 繰り返す
trg = for A in range ( B , e ) :
rst = for A in range ( B , e ) : <eos>
2961
src = cross ( B - C , B - D ) を A とする
trg = A = cross ( B - C , B - D )
rst = A = cross ( B - C , B - D ) <eos>
2962
src = C の 各要素 を A とし 、 ( A - B ) * * 2 の 列 の 総 和 を D で 割 った 値の 平 方 根 を出力する
trg = print ( math . sqrt ( sum ( [ ( A - B ) ** 2 for A in C ] ) / D ) )
rst = print ( math . sqrt ( sum ( [ ( A - B ) ** 2 for A in C ] ) / D ) ) <eos>
2963
src = 改行 せずに " { } " を出力する
trg = print ( {i} , end = '' )
rst = print ( <unk> , end = '' ) <eos>
2964
src = 2000 0000 00 を A とする
trg = A = 2000000000
rst = A = <unk> <eos>
2965
src = A を r _ a ( B ) から r _ a ( C ) を 引 いた 値 だけ 増加 させる
trg = A += r_a ( B ) - r_a ( C )
rst = A += r_a ( B ) - r_a ( C ) <eos>
2966
src = D に 番号 付 した 組 の 列 の 各要素 を B 、 C とし 、 A を 書式 として B に 1 を加えた 値 、 C で 整 形 した 文字列 を出力する の 列
trg = [ print ( A . format ( B + 1 , C ) ) for B , C in enumerate ( D ) ]
rst = [ print ( A . format ( B + 1 , C ) ) for B , C in enumerate ( D ) ] <eos>
2967
src = 1 を A の B に C を加えた 値 番目の D に E を加えた 値 番 目 にする
trg = A [ B + C ] [ D + E ] = 1
rst = A [ B + C ] [ D + E ] = 1 <eos>
2968
src = A を 7 で 割 った 余 り が 0 と 等 しい とき 、
trg = if A % 7 == 0 :
rst = if A % 7 == 0 : <eos>
2969
src = A の B に 2 を加えた 値 番 目 が C と 等 しい とき 、
trg = if A [ B + 2 ] == C :
rst = if A [ B + 2 ] == C : <eos>
2970
src = 0 が A 以下 かどうか が 60 に B を 掛 け た 値 より 小さい とき 、
trg = if 0 <= A < 60 * B :
rst = if 0 <= A < 60 * B : <eos>
2971
src = _ dfs ( A , set () ) を返す
trg = return _dfs ( A , set ( ) )
rst = return <unk> ( A , set ( ) ) <eos>
2972
src = dfs ( 0 , 0 , A [ 0 ] [ 0 ] , -1 )
trg = dfs ( 0 , 0 , A [ 0 ] [ 0 ] , - 1 )
rst = dfs ( 0 , 0 , A [ 0 ] [ 0 ] , - 1 ) <eos>
2973
src = 2 に A に B を加えた 値を 掛 け た 値 を出力する
trg = print ( 2 * ( A + B ) )
rst = print ( 2 * ( A + B ) ) <eos>
2974
src = A の 末 尾 に walk _ postorder ( B , B [ C ] . left ) を追加する
trg = A . append ( walk_postorder ( B , B [ C ] . left ) )
rst = A . append ( walk_postorder ( B , B [ C ] . left ) ) <eos>
2975
src = F に C の D に 1 を加えた 値 番 目 を加えた 値を E とする
trg = E = F + C [ D + 1 ]
rst = E = F + C [ D + 1 ] <eos>
2976
src = C の 各 値を n を パラメータ として n が B に含まれる かどうか を返す関数 で フィルタ ー した 列 の リストを A とする
trg = A = list ( filter ( lambda D : D in B , C ) )
rst = A = list ( filter ( lambda B : B in C . n , C . n ) ) <eos>
2977
src = A の 4 番 目 が A の 2 番 目 以下 かどうか が A の先頭 から A の 4 番 目 を 引 いた 値 以下 かつ A の 4 番 目 が A の 3 番 目 以下 かどうか が A の 1 番 目 から A の 4 番 目 を 引 いた 値 以下の とき 、
trg = if A [ 4 ] <= A [ 2 ] <= A [ 0 ] - A [ 4 ] and A [ 4 ] <= A [ 3 ] <= A [ 1 ] - A [ 4 ] :
rst = if A [ 4 ] <= A [ 2 ] <= A [ 0 ] - A [ 4 ] and A [ 3 ] <= A [ 4 ] <= A [ 1 ] - A [ 3 ] : <eos>
2978
src = A の長さ の とき 、 つまり 改行 文字 を 間 に 入れ て A の 各要素 に 整数 を適用した 列 を 連結 した 文字列 、 そうでなければ B を出力する
trg = print ( '\n' . join ( map ( str , A ) ) if len ( A ) else B )
rst = print ( '\n' . join ( map ( str , A ) ) if len ( A ) else B ) <eos>
2979
src = A に B を 掛 け た 値に C を 掛 け た 値に D を 掛 け た 値が 0 より 小さい とき 、
trg = if A * B * C * D < 0 :
rst = if A * B * C * D < 0 : <eos>
2980
src = 0 から 6 未 満 までの 数 列 の 各要素 を B とし 、 、 つまり 入力された 文字列 の 整数値 の 列 を A とする
trg = A = [ int ( input ( ) ) for B in range ( 6 ) ]
rst = A = [ int ( input ( ) ) for B in range ( 6 ) ] <eos>
2981
src = A が B の 末 尾 より 大きい とき 、
trg = if A > B [ - 1 ] :
rst = if A > B [ - 1 ] : <eos>
2982
src = B から C を 引 いた 値 、 A の 最大 値を A とする
trg = A = max ( B - C , A )
rst = A = max ( B - C , A ) <eos>
2983
src = A の先頭 と A の 1 番 目 を 入れ替え る
trg = A [ 0 ] , A [ 1 ] = A [ 1 ] , A [ 0 ]
rst = A [ 0 ] , A [ 1 ] = A [ 1 ] , A [ 0 ] <eos>
2984
src = intersect ( A , B , C , D , E , F , G , H ) の とき 、
trg = if intersect ( A , B , C , D , E , F , G , H ) :
rst = if intersect ( A , B , C , D , E , F , G , H ) : <eos>
2985
src = ( 25 、 10 、 5 、 1 ) からなる 列 を A とする
trg = A = [ 25 , 10 , 5 , 1 ]
rst = A = [ 25 , 10 , 5 , 1 ] <eos>
2986
src = ( B に C の 0 番 目 に D を 掛 け た 値 を加えた 値 、 E に C の 1 番 目 に D を 掛 け た 値 を加えた 値 ) の 組 を A とする
trg = A = ( B + C [ 0 ] * D , E + C [ 1 ] * D )
rst = A = ( B + C [ 0 ] * D , E + C [ 1 ] * D ) <eos>
2987
src = A を D の 各要素 を C とし 、 B に C を 掛 け た 値の 列 だけ 増加 させる
trg = A += [ B * C for C in D ]
rst = A += [ B * C for C in D ] <eos>
2988
src = 0 を A の official _ house の B 番目の C 番目の D 番 目 にする
trg = A . official_house [ B ] [ C ] [ D ] = 0
rst = A . official_house [ B ] [ C ] [ D ] = 0 <eos>
2989
src = -- A を B で 割 った 商 に C を 掛 け た 値 を出力する
trg = print ( - ( - A // B ) * C )
rst = print ( - ( - A // B ) * C ) <eos>
2990
src = A の 末 尾 に B を追加する
trg = A . append ( B )
rst = A . append ( B ) <eos>
2991
src = A の 絶対 値が 1 より 大きい かどうか を返す
trg = return abs ( A ) > 1
rst = return abs ( A ) > 1 <eos>
2992
src = A を B の C に 1 を加えた 値 番目の D 番 目 だけ 増加 させる
trg = A += B [ C + 1 ] [ D ]
rst = A += B [ C + 1 ] [ D ] <eos>
2993
src = rotate _ vector ( A , B ) を A とする
trg = A = rotate_vector ( A , B )
rst = A = vector_minus ( A , B ) <eos>
2994
src = B から 2000 を 引 いた 値 から 2001 未 満 までの 数 列 を 順に A として 、 繰り返す
trg = for A in range ( B - 2000 , 2001 ) :
rst = for A in range ( B - 2000 , 2001 ) : <eos>
2995
src = A の M の B 番目の C 番 目 が D より 小さい とき 、
trg = if A . M [ B ] [ C ] < D :
rst = if A . M [ B ] [ C ] < D : <eos>
2996
src = solve ( 4 , B ) を A とする
trg = A = solve ( 4 , B )
rst = A = solve ( 4 , B ) <eos>
2997
src = A の B 番 目 に C を追加した 集 ま り
trg = A [ B ] . add ( C )
rst = A [ B ] . add ( C ) <eos>
2998
src = A の 5 番 目 から 、 つまり 末 尾 までの 部分 列 を A とする
trg = A = A [ 5 : ]
rst = A = A [ 5 : ] <eos>
2999
src = 0 が A に 含まれ なく または 0 が B に 含まれ ない とき 、
trg = if 0 not in A or 0 not in B :
rst = if 0 not in A or 0 not in B : <eos>
3000
src = ( 0 ) からなる 列 の 7 回 分 の 列 を A とする
trg = A = [ 0 ] * 7
rst = A = [ 0 ] * 7 <eos>
3001
src = ( ( 1 、 2 、 3 、 4 、 5 、 6 ) からなる 列 、 4 ) の 組
trg = ( [ 1 , 2 , 3 , 4 , 5 , 6 ] , 4 )
rst = ( [ 1 , 2 , 3 , 4 , 5 , 6 ] , 4 , 5 , 6 ) <eos>
3002
src = A の B と C の 排 他 論理 和 の ビット 長 番目の 末 尾 に D を追加する
trg = A [ ( B ^ C ) . bit_length ( ) ] . append ( D )
rst = A [ B ^ C . bit_length ( ) ] . append ( D ) <eos>
3003
src = get ( A , B ) から get ( A , C ) を 引 いた 値の とき 、
trg = if get ( A , B ) - get ( A , C ) :
rst = if get ( A , B ) - get ( A , C ) : <eos>
3004
src = C の 文字列を A の B 番 目 にする
trg = A [ B ] = str ( C )
rst = A [ B ] = str ( C ) <eos>
3005
src = 未 定 値を A の B 番目の 0 番 目 にする
trg = A [ B ] [ 0 ] = None
rst = A [ B ] [ 0 ] = None <eos>
3006
src = update ( 2 , [ ( - 1, -1 ) , ( 1, -1 ) , ( - 1, 1 ) , ( 1, 1 ) ] )
trg = update ( 2 , [ ( - 1 , - 1 ) , ( 1 , - 1 ) , ( - 1 , 1 ) , ( 1 , 1 ) ] )
rst = update ( 2 , [ ( - 1 , - 1 ) , ( - 1 , 1 ) , ( - 1 , 1 ) , ( 1 , 1 ) ] ) <eos>
3007
src = A を 4 分 の 一 にする
trg = A //= 4
rst = A /= 4 <eos>
3008
src = - A から B を 引 いた 値が 0 より 大きい とき 、
trg = if - A - B > 0 :
rst = if - A - B > 0 : <eos>
3009
src = B の 整数値 を C で 割 った 余 り を A とする
trg = A = int ( B ) % C
rst = A = int ( B ) % C <eos>
3010
src = E に F を加えた 値を A の B に C を加えた 値 番目の D 番 目 にする
trg = A [ B + C ] [ D ] = E + F
rst = A [ B + C ] [ D ] = E + F <eos>
3011
src = 0 から 7 未 満 までの 数 列 の 各要素 を B とし 、 、 つまり 空 列 の 列 を A とする
trg = A = [ [ ] for B in range ( 7 ) ]
rst = A = [ [ ] for B in range ( 7 ) ] <eos>
3012
src = A が 、 つまり ネ イ ピ ア 数 と 等 しい かどうか が 0 と 等 しい とき 、
trg = if A == e == 0 :
rst = if A == e == 0 : <eos>
3013
src = ( B の C 番 目 、 D の C 番 目 ) の 組 を A とする
trg = A = ( B [ C ] , D [ C ] )
rst = A = ( B [ C ] , D [ C ] ) <eos>
3014
src = ( 、 つまり 偽 ) からなる 列 の 5 3 回 分 の 列 を A とする
trg = A = [ False ] * 53
rst = A = [ False ] * 53 <eos>
3015
src = A 内の [MASK] の 出現 回数 を返す
trg = return A . count
rst = return A . count <eos>
3016
src = - A に B を 掛 け た 値に C を加えた 値に D に ネ イ ピ ア 数 を 掛 け た 値 を加えた 値 を出力する
trg = print ( - A * B + C + D * e )
rst = print ( - A * B + C + D * e ) <eos>
3017
src = C に 1 を加えた 値 、 D 、 E において 正規表現 B が 最初 にマッチする 位置 を A とする
trg = A = search ( B , C + 1 , D , E )
rst = A = search ( B , C + 1 , D , E ) <eos>
3018
src = 0 を A の C 番 目 にする
trg = A [ C ] = 0
rst = A [ C ] = 0 <eos>
3019
src = check ()
trg = check ( )
rst = check ( ) <eos>
3020
src = A が 0 より 小さく かつ B の C 番 目 が 2 と 等 しく または A が 0 より 大きく かつ B の C 番 目 が 0 と 等 しい とき 、
trg = if ( A < 0 and B [ C ] == 2 ) or ( A > 0 and B [ C ] == 0 ) :
rst = if ( A < 0 and B [ C ] == 2 ) or ( A > 0 and B [ C ] == 0 ) : <eos>
3021
src = B を 2 で 割 った 値の 整数値 、 C の 最小 値を A とする
trg = A = min ( int ( B / 2 ) , C )
rst = A = min ( int ( B / 2 ) , C ) <eos>
3022
src = calc ( B , C ) を A とする
trg = A = calc ( B , C )
rst = A = calc ( B , C ) <eos>
3023
src = A から A を B で 割 った 商 に B を 掛 け た 値を 引 いた 値が 、 つまり ネ イ ピ ア 数 以下 または A から ( A / / B + 1 ) に B を 掛 け た 値を 引 いた 値の 絶対 値が 、 つまり ネ イ ピ ア 数 以下の とき 、
trg = if A - ( A // B * B ) <= e or abs ( A - ( ( A // B + 1 ) * B ) ) <= e :
rst = if abs ( A - A // B ) <= B or abs ( e - A // B ) <= 1 : <eos>
3024
src = A の 末 尾 に item ( int ( input () ) , B ) を追加する
trg = A . append ( item ( int ( input ( ) ) , B ) )
rst = A . append ( item ( int ( input ( ) ) , B ) ) <eos>
3025
src = 1 が A から B を 引 いた 値 以下の とき 、
trg = if 1 <= A - B :
rst = if 1 <= A - B : <eos>
3026
src = perm ( B . lt ) を A とする
trg = A = perm ( B . lt )
rst = A = <unk> ( B . lt ) <eos>
3027
src = A の 絶対 値が B より 小さい とき 、
trg = if abs ( A ) < B :
rst = if abs ( A ) < B : <eos>
3028
src = ( A から B を 引 いた 値の 2 乗 に C から D を 引 いた 値の 2 乗 を加えた 値が E に F を加えた 値の 2 乗 より 小さい かどうか 、 E 、 F ) の 組 を返す
trg = return ( ( A - B ) ** 2 + ( C - D ) ** 2 < ( E + F ) ** 2 , E , F )
rst = return ( ( A - B ) ** 2 + ( C - D ) ** 2 < ( E + F ) ** 2 , E , F ) <eos>
3029
src = A の 末 尾 に ( B に 1 を加えた 値 、 C 、 D 、 E ) の 組 を追加する
trg = A . append ( ( B + 1 , C , D , E ) )
rst = A . append ( ( B + 1 , C , D , E ) ) <eos>
3030
src = A の 末 尾 に conv 2 ( conv 1 ( B ) + conv 1 ( C ) ) を追加する
trg = A . append ( conv2 ( conv1 ( B ) + conv1 ( C ) ) )
rst = A . append ( conv ( ( 1 ( B ) + 1 ) ) ) <eos>
3031
src = A の B に C を加えた 値 番 目 が A の B 番 目 に D を加えた 値 より 小さい とき 、
trg = if A [ B + C ] < A [ B ] + D :
rst = if A [ B + C ] < A [ B ] + D : <eos>
3032
src = B の val の C 番 目 を A とする
trg = A = B . val [ C ]
rst = A = B . val [ C ] <eos>
3033
src = pos ( A [ B ] [ 1 ] )
trg = pos ( A [ B ] [ 1 ] )
rst = pos ( A [ B ] [ 1 ] ) <eos>
3034
src = C を A の table の B 番 目 にする
trg = A . table [ B ] = C
rst = A . table [ B ] = C <eos>
3035
src = A が 、 つまり 無限 の 整数 列 以下の とき 、
trg = if A <= count :
rst = if A <= count : <eos>
3036
src = 0 から 100 1 未 満 までの 数 列 を 順に A として 、 繰り返す
trg = for A in range ( 1001 ) :
rst = for A in range ( 1001 ) : <eos>
3037
src = 空白 文字 を 代わり の 行 末 として 空白 文字 を 間 に 入れ て A の 、 つまり 先頭 から B 番 目 までの 部分 列 の 各要素 に 整数 を適用した 列 を 連結 した 文字列 を出力する
trg = print ( ' ' . join ( map ( str , A [ : B ] ) ) , end = ' ' )
rst = print ( ' ' . join ( map ( str , A [ : B ] ) ) , end = ' ' ) <eos>
3038
src = B と C の D 番 目 を 割 った とき の ( 商 を 展開 し 、 それぞれ A 、 B とする
trg = A , B = divmod ( B , C [ D ] )
rst = A , B = divmod ( B , C [ D ] ) <eos>
3039
src = ( ( B , 24 ) 、 ( C , 21 ) 、 ( D , 18 ) 、 ( E , 15 ) 、 ( F , 12 ) 、 ( G , 9 ) 、 ( H , 6 ) 、 ( I , 3 ) 、 ( J , 2 ) 、 ( K , 1 ) 、 ( L , -1 ) 、 ( M , -2 ) 、 ( N , -3 ) 、 (
trg = A = { "yotta" : 24 , "zetta" : 21 , "exa" : 18 , "peta" : 15 , "tera" : 12 , "giga" : 9 , "mega" : 6 , "kilo" : 3 , "hecto" : 2 , "deca" : 1 , "deci" : - 1 , "centi" : - 2 , "milli" : - 3 , "micro" : - 6 , "nano" : - 9 , "pico" : - 12 , "femto" : - 15 , "ato" :
rst = for A , B , C in re . combinations_with_replacement ( ( B , 24 ) , ( C , D ) , ( E , F ) , ( G , H ) , ( F , 9 , G ) , ( H , J ) , (
3040
src = A の B から 1 を 引 いた 値 番 目 に 1 を加えた 値が A の B 番 目 と 等 しい とき 、
trg = if A [ B - 1 ] + 1 == A [ B ] :
rst = if A [ B - 1 ] + 1 == A [ B ] : <eos>
3041
src = D を A の C 番 目 とする を A の B 番 目 にする
trg = A [ B ] = A [ C ] = D
rst = A [ B ] = A [ C ] = D <eos>
3042
src = A と ( < __ main __ . Cammaobjectat 0 x 10 a 4 f 1 be 0 > ) の集合 の 論理 和 を A とする
trg = A = A | { B , C }
rst = A = A | { B , C } <eos>
3043
src = dfs ( A [ 0 ] )
trg = dfs ( A [ 0 ] )
rst = dfs ( A [ 0 ] ) <eos>
3044
src = 入力された 文字列を 空白 で 分割 した 字句 列 の 各要素 を F とし 、 F の 整数値 の 列 を 展開 し 、 それぞれ A 、 B 、 C 、 D 、 E とする
trg = A , B , C , D , E = [ int ( F ) for F in input ( ) . split ( ) ]
rst = A , B , C , D , E = [ int ( F ) for F in input ( ) . split ( ) ] <eos>
3045
src = A を 入力された 文字列 だけ 増加 させる
trg = A += input ( )
rst = A += input ( ) <eos>
3046
src = A 、 B の C に 1 を加えた 値 から 、 つまり 末 尾 までの 部分 列 の 最大 値 から B の C 番 目 を 引 いた 値の 最大 値を A とする
trg = A = max ( A , max ( B [ C + 1 : ] ) - B [ C ] )
rst = A = max ( A , B [ C + 1 : ] ) - max ( B [ C ] ) <eos>
3047
src = A の 、 つまり ネ イ ピ ア 数 から 1 を 引 いた 値 番目の 末 尾 に B を追加する
trg = A [ e - 1 ] . append ( B )
rst = A [ e - 1 ] . append ( B ) <eos>
3048
src = A の B の C と 等 しい 要素 の最初の 位置 番 目 を 1 だけ 減少 させる
trg = A [ B . index ( C ) ] -= 1
rst = A [ B . index ( C ) ] -= 1 <eos>
3049
src = B を 書式 として C 、 0 で 整 形 した 文字列を A とする
trg = A = B . format ( C , 0 )
rst = A = B . format ( C , 0 ) <eos>
3050
src = 入力された 文字列を 空白 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 のリスト に 16 を 掛 け た 値を A とする
trg = A = list ( map ( int , input ( ) . split ( ) ) ) * 16
rst = A = list ( map ( int , input ( ) . split ( ) ) ) * 16 <eos>
3051
src = paint ( B , C ) 、 A の 最小 値を A とする
trg = A = min ( paint ( B , C ) , A )
rst = A = min ( paint ( B , C ) , A ) <eos>
3052
src = ( 0 ) からなる 列 の 20 2 回 分 の 列 、 ( 0 ) からなる 列 の 20 2 回 分 の 列 を A 、 B とする
trg = A , B = [ 0 ] * 202 , [ 0 ] * 202
rst = A , B = [ 0 ] * 62 , [ 0 ] * 20 <eos>
3053
src = C を 順に A 、 B 、 B として 、 繰り返す
trg = for A , B , B in C :
rst = for A , B , B in C : <eos>
3054
src = B の x 座標 を A の x 座標 にする
trg = A . x = B . x
rst = A . x = B . x <eos>
3055
src = A が 1 と 等 しい とき B 、 そうでなければ A が 2 と 等 しい とき C 、 そうでなければ D を出力する
trg = print ( B if A == 1 else ( C if A == 2 else D ) )
rst = print ( B if A == 1 else ( C == 2 else D ) ) <eos>
3056
src = D の C 番目の 7 から B を 引 いた 値 番 目 を A の B 番目の C 番 目 にする
trg = A [ B ] [ C ] = D [ C ] [ 7 - B ]
rst = A [ B ] [ C ] = D [ C ] [ 7 - B ] <eos>
3057
src = ( ( 0 , B ) 、 ( 1, C ) 、 ( 2 , D ) 、 ( 3 , E ) 、 ( 4 , F ) 、 ( 5 , G ) 、 ( 6 , H ) ) からなる 辞書 を A とする
trg = A = { 0 : B , 1 : C , 2 : D , 3 : E , 4 : F , 5 : G , 6 : H }
rst = A = { 0 : B , 1 : C , 2 : D , 3 : E , 4 : F , 5 : G , 6 : H } <eos>
3058
src = 17 を A とする
trg = A = 17
rst = A = 17 <eos>
3059
src = 2 から B に 2 を加えた 値 未 満 までの 数 列 を 順に A として 、 繰り返す
trg = for A in range ( 2 , B + 2 ) :
rst = for A in range ( 2 , B + 2 ) : <eos>
3060
src = B の先頭 を 除 いた 部分 列 の 逆 順 を 順に A として 、 繰り返す
trg = for A in B [ 1 : ] [ : : - 1 ] :
rst = for A in B [ 1 : ] [ : : - 1 ] : <eos>
3061
src = 1 に A が B に含まれる かどうか を 掛 け た 値 を出力する
trg = print ( 1 * ( A in B ) )
rst = print ( 1 * ( A in B ) ) <eos>
3062
src = A の B から 1 を 引 いた 値 番目の C 番 目 でない とき 、
trg = if not A [ B - 1 ] [ C ] :
rst = if not A [ B - 1 ] [ C ] : <eos>
3063
src = 0 が A から B を 引 いた 値 以下 かどうか が C 以下 かどうか を返す
trg = return 0 <= ( A - B ) <= C
rst = return 0 <= A - B <= C <eos>
3064
src = B と C の 論理 和 と 0 b 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 の 論理 積 を A とする
trg = A = ( B | C ) & 0b11111111111111111111111111111111
rst = A = ( B & C ) & 0b11111111111111111111111111111111 <eos>
3065
src = A を B に 100 を 掛 け た 値 だけ 増加 させる
trg = A += B * 100
rst = A += B * 100 <eos>
3066
src = B を A の nodeid にする
trg = A . nodeid = B
rst = A . nodeid = B <eos>
3067
src = A が B から 1 を 引 いた 値 より 小さく かつ C の A 番目の 2 番 目 が C の A に 1 を加えた 値 番目の 2 番 目 と 等 しい 間 、 次 を 繰り返す
trg = while A < B - 1 and C [ A ] [ 2 ] == C [ A + 1 ] [ 2 ] :
rst = while A < B - 1 and C [ A ] [ 2 ] == C [ A + 1 ] [ 2 ] : <eos>
3068
src = A の B と 等 しい 要素 の最初の 位置 を返す
trg = return A . index ( B )
rst = return A . index ( B ) <eos>
3069
src = A が B と 等 しく または A が 1 と 等 しい とき 、
trg = if A == B or A == 1 :
rst = if A == B or A == 1 : <eos>
3070
src = A の 末 尾 に ( B 、 C 、 1 ) の 組 を追加する
trg = A . append ( ( B , C , 1 ) )
rst = A . append ( ( B , C , 1 ) ) <eos>
3071
src = 0 から 20 未 満 までの 数 列 の 各要素 を B とし 、 2 の B 乗 の 列 を A とする
trg = A = [ 2 ** B for B in range ( 20 ) ]
rst = A = [ 2 ** B for B in range ( 20 ) ] <eos>
3072
src = paint ( A , B + 1 )
trg = paint ( A , B + 1 )
rst = paint ( A , B + 1 ) <eos>
3073
src = A の weight の B 番 目 を A の weight の A の par の B 番 目 番 目 だけ 増加 させる
trg = A . weight [ B ] += A . weight [ A . par [ B ] ]
rst = A . weight [ B ] += A . weight [ A . par [ B ] ] <eos>
3074
src = paint ( A + 2 , B )
trg = paint ( A + 2 , B )
rst = paint ( A + 2 , B ) <eos>
3075
src = trans ( A ) を A とする
trg = A = trans ( A )
rst = A = <unk> ( A ) <eos>
3076
src = 0 から 5 1 未 満 までの 数 列 を 順に A として 、 繰り返す
trg = for A in range ( 51 ) :
rst = for A in range ( 51 ) : <eos>
3077
src = 0 から D 未 満 までの 数 列 の 各要素 を C とし 、 E の C 番 目 でない とき の B の C 番目の 列 を A とする
trg = A = [ B [ C ] for C in range ( D ) if not E [ C ] ]
rst = A = [ B [ C ] for C in range ( D ) if not E [ C ] ] <eos>
3078
src = 0 から 6 未 満 までの 数 列 の 各要素 を C とし 、 B の C 番目の 整数値 の 列 を A とする
trg = A = [ int ( B [ C ] ) for C in range ( 6 ) ]
rst = A = [ int ( B [ C ] ) for C in range ( 6 ) ] <eos>
3079
src = namedtuple ( B , [ C , D , E ] ) を A とする
trg = A = namedtuple ( B , [ C , D , E ] )
rst = A = namedtuple ( B , [ C , D , E ] ) <eos>
3080
src = bublleSort ( C ) を 展開 し 、 それぞれ A 、 B とする
trg = A , B = bublleSort ( C )
rst = A , B = <unk> ( C ) <eos>
3081
src = A を B の C に 1 を加えた 値 番目の 整数値 分 の 一 にする
trg = A /= int ( B [ C + 1 ] )
rst = A /= int ( B [ C + 1 ] ) <eos>
3082
src = B に C を加えた 値 、 D の 最小 値を A とする
trg = A = min ( B + C , D )
rst = A = min ( B + C , D ) <eos>
3083
src = B の 3 番 目 を 順に A として 、 繰り返す
trg = for A in B [ 3 ] :
rst = for A in B [ 3 ] : <eos>
3084
src = 1 を A の B に 1 を加えた 値 番目の B 番 目 とする を A の B 番目の B に 1 を加えた 値 番 目 にする
trg = A [ B ] [ B + 1 ] = A [ B + 1 ] [ B ] = 1
rst = A [ B ] [ B + 1 ] = A [ B + 1 ] [ B ] = 1 <eos>
3085
src = - B に 1 を加えた 値 から C に D を加えた 値 から B を 引 いた 値に 1 を加えた 値 未 満 までの 数 列 を 順に A として 、 繰り返す
trg = for A in range ( - B + 1 , C + D - B + 1 ) :
rst = for A in range ( - B + 1 , C + D - B + 1 ) : <eos>
3086
src = 0 を A の _ currentIndex にする
trg = A . _currentIndex = 0
rst = A . _currentIndex = 0 <eos>
3087
src = A の 、 つまり 先頭 から B の 1 番 目 までの 部分 列 に A の B の 1 番 目 から B [ 2 ] に 1 を加えた 値 までの 部分 列 の 逆 順 を加えた 値に A の B の 2 番 目 に 1 を加えた 値 から 、 つまり 末 尾 までの 部分 列 を加えた 値を A とする
trg = A = A [ : B [ 1 ] ] + A [ B [ 1 ] : B [ 2 ] + 1 ] [ : : - 1 ] + A [ B [ 2 ] + 1 : ]
rst = A = A [ : B [ 1 ] ] + A [ B [ 1 : B [ 2 ] + 1 ] [ : : - 1 ] + A [ B [ 2 ] : <eos>
3088
src = A の 末 尾 に A の B から 1 を 引 いた 値 番 目 を追加する
trg = A . append ( A [ B - 1 ] )
rst = A . append ( A [ B - 1 ] ) <eos>
3089
src = 0 から C 未 満 までの 数 列 の 各要素 を B とし 、 0 から C 未 満 までの 数 列 の 各要素 を B とし 、 0 の 列 の 列 を A とする
trg = A = [ [ 0 for B in range ( C ) ] for B in range ( C ) ]
rst = A = [ [ 0 for B in range ( C ) ] for B in range ( C ) ] <eos>
3090
src = B に C を加えた 値 から D を 引 いた 値に 1 を加えた 値 から D 未 満 までの 数 列 を 順に A として 、 繰り返す
trg = for A in range ( B + C - D + 1 , D ) :
rst = for A in range ( B + C - D + 1 , D ) : <eos>
3091
src = 入力された 文字列を 空白 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 に 番号 付 した 組 の 列 の 各要素 を C 、 B とし 、 ( B 、 C 、 未 定 値 ) からなる 列 の 列 を A とする
trg = A = [ [ B , C , None ] for C , B in enumerate ( map ( int , input ( ) . split ( ) ) ) ]
rst = A = [ [ B , C , None ] for C , B in enumerate ( map ( int , input ( ) . split ( ) ) ) ] <eos>
3092
src = A 内の - B と 等 しい 要素を 取り除く
trg = A . remove ( - ( B ) )
rst = A . remove ( - B ) <eos>
3093
src = 10 に A を 掛 け た 値に 9 を加えた 値を A とする
trg = A = 10 * A + 9
rst = A = 10 * A + 9 <eos>
3094
src = B の C から D の E 番 目 を 引 いた 値 番 目 に F の E 番 目 を加えた 値 、 A の 最大 値を A とする
trg = A = max ( B [ C - D [ E ] ] + F [ E ] , A )
rst = A = max ( B [ C - D [ E ] ] + F [ E ] , F ) <eos>
3095
src = 空白 文字 を 代わり の 行 末 として A の 4 から B を 引 いた 値 番 目 を出力する
trg = print ( A [ 4 - B ] , end = ' ' )
rst = print ( A [ 4 - B ] , end = ' ' ) <eos>
3096
src = C の B 番目の D 番 目 に 空文字列 を 間 に 入れ て E を 連結 した 文字列 を加えた 値を A の B 番 目 から 、 つまり 末 尾 までの 部分 列 にする
trg = A [ B : ] = C [ B ] [ D ] + '' . join ( E )
rst = A [ B : ] = C [ B ] [ D ] + '' . join ( E ) <eos>
3097
src = 0 から F 未 満 までの 数 列 の 各要素 を E とし 、 ( ( B ) からなる 列 の 0 から D 未 満 までの 数 列 の 各要素 を C とし 、 4 の 列 回 分 の 列 ) からなる 列 の 列 を A とする
trg = A = [ [ [ B ] * [ 4 for C in range ( D ) ] ] for E in range ( F ) ]
rst = A = [ [ [ B ] * [ 4 for C in range ( D ) ] ] for E in range ( F ) ] <eos>
3098
src = D の先頭 の 整数値 、 D の 1 番目の 浮動小数点数 、 D の 2 番目の 整数値 を A 、 B 、 C とする
trg = A , B , C = int ( D [ 0 ] ) , float ( D [ 1 ] ) , int ( D [ 2 ] )
rst = A , B , C = int ( D [ 0 ] ) , float ( D [ 1 ] ) , int ( D [ 2 ] ) <eos>
3099
src = 0 から D に 1 を加えた 値 未 満 までの 数 列 の 各要素 を C とし 、 B の C 番目の C 番目の 列 の 最小 値を A とする
trg = A = min ( [ B [ C ] [ C ] for C in range ( D + 1 ) ] )
rst = A = min ( [ B [ C ] for C in range ( D + 1 ) ] ) <eos>
3100
src = A . right . flip _ color ()
trg = A . right . flip_color ( )
rst = A . right . <unk> ( ) <eos>
3101
src = get _ quad ( A , B ) を出力する
trg = print ( get_quad ( A , B ) )
rst = print ( <unk> ( A , B ) ) <eos>
3102
src = A を ( 3 、 7 ) からなる 列 の B の A 番 目 が C と 等 しい かどうか 番 目 だけ 増加 させる
trg = A += [ 3 , 7 ] [ B [ A ] == C ]
rst = A += [ 3 , 7 ] [ B [ A ] == C ] <eos>
3103
src = A の先頭 の A の先頭 の 最大 値 と 等 しい 要素 の最初の 位置 を出力する
trg = print ( A [ 0 ] . index ( max ( A [ 0 ] ) ) )
rst = print ( A [ 0 ] . index ( max ( A [ 0 ] ) ) ) <eos>
3104
src = A と B の 共通 部分 の とき 、
trg = if A . intersection ( B ) :
rst = if A . intersection ( B ) : <eos>
3105
src = C を A の hldnxt の B 番 目 にする
trg = A . hldnxt [ B ] = C
rst = A . hldnxt [ B ] = C <eos>
3106
src = B に対応する 値を 展開 し 、 それぞれ A 、 time とする
trg = A , time = B . get ( )
rst = A , time = B . get ( ) <eos>
3107
src = F を ソート した 列 を 順に A 、 B 、 C 、 D 、 E として 、 繰り返す
trg = for A , B , C , D , E in sorted ( F ) :
rst = for A , B , C , D , E in sorted ( F ) : <eos>
3108
src = B . Node ( C , D , D . next ) を A とする
trg = A = B . Node ( C , D , D . next )
rst = A = B . Node ( C , D , D . next ) <eos>
3109
src = Decimal ( str ( A ) ) . quantize ( Decimal ( B ) , rounding = C ) を出力する
trg = print ( Decimal ( str ( A ) ) . quantize ( Decimal ( B ) , rounding = C ) )
rst = print ( Decimal ( str ( A ) ) . quantize ( Decimal ( B ) , rounding = C ) ) <eos>
3110
src = B の 1 番 目 を A とする
trg = A = B [ 1 ]
rst = A = B [ 1 ] <eos>
3111
src = A を 書式 として 、 つまり 空白 文字 を 間 に 入れ て C . preorder () の 各要素 を B とし 、 B の 文字列 の 列 を 連結 した 文字列 で 整 形 した 文字列 を出力する
trg = print ( A . format ( ' ' . join ( [ str ( B ) for B in C . preorder ( ) ] ) ) )
rst = print ( A . format ( ' ' . join ( [ str ( B ) for B in C . preorder ( ) ] ) ) ) <eos>
3112
src = Node ( B ) を A の left にする
trg = A . left = Node ( B )
rst = A . left = Node ( B ) <eos>
3113
src = plist ( A )
trg = plist ( A )
rst = <unk> ( A ) <eos>
3114
src = A の B 番 目 から 、 つまり 末 尾 までの 部分 列 を 1 だけ 増加 させる
trg = A [ B : ] += 1
rst = A [ B : ] += 1 <eos>
3115
src = A の 1 番 目 と 1 の 論理 積 かつ A の 2 番 目 と 1 の 論理 積 の とき 、
trg = if ( A [ 1 ] & 1 ) and ( A [ 2 ] & 1 ) :
rst = if A [ 1 ] & 1 and A [ 2 ] & 1 : <eos>
3116
src = A . _ delete _ max ( A . root ) を A の root にする
trg = A . root = A . _delete_max ( A . root )
rst = A . root = A . <unk> ( A . root ) <eos>
3117
src = ( 、 つまり 空文字列 ) からなる 列 の A 回 分 の 列 を C とする
trg = C = [ '' ] * A
rst = C = [ '' ] * A <eos>
3118
src = 10 0000 の 2 乗 を A とする
trg = A = 100000 ** 2
rst = A = 100000 ** 2 <eos>
3119
src = D を A の B 番 目 から C 番 目 までの 部分 列 にする
trg = A [ B : C ] = D
rst = A [ B : C ] = D <eos>
3120
src = readline () を 空白 で 分割 した 字句 列 の 各要素 に 浮動小数点数 を適用した 列 を 展開 し 、 それぞれ A 、 B 、 C 、 D 、 E 、 F とする
trg = A , B , C , D , E , F = map ( float , readline ( ) . split ( ) )
rst = A , B , C , D , E , F = map ( float , readline ( ) . split ( ) ) <eos>
3121
src = A の d の 2 番 目 、 A の d の 3 番 目 、 A の d の 5 番 目 、 A の d の 4 番 目 を A の d の 4 番 目 、 A の d の 2 番 目 、 A の d の 3 番 目 、 A の d の 5 番 目 とする
trg = A . d [ 4 ] , A . d [ 2 ] , A . d [ 3 ] , A . d [ 5 ] = A . d [ 2 ] , A . d [ 3 ] , A . d [ 5 ] , A . d [ 4 ]
rst = A . d [ 4 ] , A . d [ 2 ] , A . d [ 5 ] , A . d [ 3 ] = A . d [ 2 ] , A . d [ 3 ] , A . d [ 5 ] , A
3122
src = A の B 番 目 から A の C から 1 を 引 いた 値 番 目 を 引 いた 値 を出力する
trg = print ( A [ B ] - A [ C - 1 ] )
rst = print ( A [ B ] - A [ C - 1 ] ) <eos>
3123
src = A . has _ right () でない とき 、
trg = if not A . has_right ( ) :
rst = if not A . <unk> ( ) : <eos>
3124
src = ( B ) からなる 列 に ( -1 ) からなる 列 の 400 0000 回 分 の 列 を加えた 値を A とする
trg = A = [ B ] + [ - 1 ] * 4000000
rst = A = [ B ] + [ - 1 ] * <unk> <eos>
3125
src = A * B から C * D を 引 いた 値の 絶対 値が 1 e -10 より 小さい とき E 、 そうでなければ F を出力する
trg = print ( E if abs ( A * B - C * D ) < 1e-10 else F )
rst = print ( E if abs ( A * B - C * D ) < 1e-10 else F ) <eos>
3126
src = dfs ( A , B )
trg = dfs ( A , B )
rst = dfs ( A , B ) <eos>
3127
src = preorder _ tree _ walk ( A , A [ B ] . left _ node _ no , C )
trg = preorder_tree_walk ( A , A [ B ] . left_node_no , C )
rst = preorder_tree_walk ( A , A [ B ] . left_node_no , C ) <eos>
3128
src = closest _ pair _ distance ( B . copy () ) を A とする
trg = A = closest_pair_distance ( B . copy ( ) )
rst = A = closest_pair_distance ( B . copy ( ) ) <eos>
3129
src = A の 末 尾 に B の 整数値 に 1 を加えた 値を 10 で 割 った 余 り の 文字列 を追加する
trg = A . append ( str ( ( int ( B ) + 1 ) % 10 ) )
rst = A . append ( str ( ( int ( B ) + 1 ) % 10 ) ) <eos>
3130
src = B の C 番目の 3 番 目 を 順に A として 、 繰り返す
trg = for A in B [ C ] [ 3 ] :
rst = for A in B [ C ] [ 3 ] : <eos>
3131
src = A 、 無限 の 整数 列 を出力する
trg = print ( A , count )
rst = print ( A , count ) <eos>
3132
src = A を 順に ネ イ ピ ア 数 として 、 繰り返す
trg = for e in A :
rst = for e in A : <eos>
3133
src = B の tail を A の tail にする
trg = A . tail = B . tail
rst = A . tail = B . tail <eos>
3134
src = 86 400 を A とする
trg = A = 86400
rst = A = 800 <eos>
3135
src = 2 に A を 掛 け た 値が B と 等 しい とき 、
trg = if 2 * A == B :
rst = if 2 * A == B : <eos>
3136
src = A の 末 尾 に ( 1 、 0 、 0 ) の 組 を追加する
trg = A . append ( ( 1 , 0 , 0 ) )
rst = A . append ( ( 1 , 0 , 0 ) ) <eos>
3137
src = 0 から 4 未 満 までの 数 列 の 各要素 を B とし 、 readline () を 空白 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 の 列 を A とする
trg = A = ( [ map ( int , readline ( ) . split ( ) ) for B in range ( 4 ) ] )
rst = A = [ map ( int , readline ( ) . split ( ) ) for B in range ( 4 ) ] <eos>
3138
src = A の 末 尾 に B を ( C 、 D の C 番 目 ) の 組 で 割 った 余 り を追加する
trg = A . append ( B % ( C , D [ C ] ) )
rst = A . append ( B % ( C , D [ C ] ) ) <eos>
3139
src = B . max _ flow ( 0 , C -1 ) を A とする
trg = A = B . max_flow ( 0 , C - 1 )
rst = A = B . max_flow ( 0 , C - 1 ) <eos>
3140
src = getSum ( B , C , 0 , 1, D ) を A とする
trg = A = getSum ( B , C , 0 , 1 , D )
rst = A = getSum ( B , C , 0 , 1 , D ) <eos>
3141
src = A の B 番 目 を C の先頭 だけ 増加 させる
trg = A [ B ] += C [ 0 ]
rst = A [ B ] += C [ 0 ] <eos>
3142
src = ( ( B , E . ascii _ uppercase に F を加えた 値 、 0 から 32 未 満 までの 数 列 の 要素を それぞれ 組 にした 列 の 各要素 を B 、 D とし 、 C を 書式 として D で 整 形 した 文字列 の 列 ) ) からなる 辞書 を A とする
trg = A = { i : [ C . format ( D ) for B , D in zip ( E . ascii_uppercase + F , range ( 32 ) ) ] }
rst = A = { <unk> : [ B . format ( C , D ) for B , D in zip ( [ range ( 32 ) for F in range ( 32 ) ] } <eos>
3143
src = A の 絶対 値が 1 e - 9 より 小さく かつ B の 絶対 値が 1 e - 9 より 小さい とき 、
trg = if abs ( A ) < 1e-9 and abs ( B ) < 1e-9 :
rst = if abs ( A ) < 1e-9 and abs ( B ) < 1e-9 : <eos>
3144
src = 2 の 2 を 底 とする B の長さ の 対 数の 切り 上げ 整数値 乗 を A とする
trg = A = 2 ** math . ceil ( math . log ( len ( B ) , 2 ) )
rst = A = 2 ** math . ceil ( math . log ( len ( B ) , 2 ) ) <eos>
3145
src = A を poly _ area ( B , len ( B ) ) で 割 った 余 り を出力する
trg = print ( A % poly_area ( B , len ( B ) ) )
rst = print ( A % <unk> ( B , len ( B ) ) ) <eos>
3146
src = 0 から 32 未 満 までの 数 列 を 順に A として 、 繰り返す
trg = for A in range ( 32 ) :
rst = for A in range ( 32 ) : <eos>
3147
src = x を パラメータ として x の先頭 を返す関数 を キー として C の キー と 値 の集まり を ソート した 列 を 順に A 、 B として 、 繰り返す
trg = for A , B in sorted ( C . items ( ) , key = lambda D : D [ 0 ] ) :
rst = for A , B in sorted ( C . items ( ) , key = lambda E : D [ 0 ] ) : <eos>
3148
src = ( ( -1 ) からなる 列 の 0 から B * 2 に 1 を加えた 値 未 満 までの 数 列 の 各要素 を C とし 、 B に 2 を 掛 け た 値に 1 を加えた 値の 列 回 分 の 列 ) からなる 列 を A とする
trg = A = [ [ - 1 ] * [ ( B * 2 + 1 ) for C in range ( B * 2 + 1 ) ] ]
rst = A = [ [ - 1 ] * [ ( B * 2 + 1 ) for C in range ( B * 2 + 1 ) ] ] <eos>
3149
src = ( ( 0 ) からなる 列 の 0 から B に 1 を加えた 値 未 満 までの 数 列 の 各要素 を C とし 、 B に 1 を加えた 値の 列 回 分 の 列 ) からなる 列 を A の _ nodes にする
trg = A . _nodes = [ [ 0 ] * [ ( B + 1 ) for C in range ( B + 1 ) ] ]
rst = A . _nodes = [ [ 0 ] * [ ( B + 1 ) for C in range ( B + 1 ) ] ] <eos>
3150
src = A の B の先頭 番 目 を B の先頭 を 除 いた 部分 列 だけ 増加 させる
trg = A [ B [ 0 ] ] += B [ 1 : ]
rst = A [ B [ 0 ] ] += B [ 1 : ] <eos>
3151
src = A に B を 掛 け た 値に C に D を 掛 け た 値 を加えた 値を返す
trg = return A * B + C * D
rst = return A * B + C * D <eos>
3152
src = BinaryIndexedTree ( B ) を A の bit 1 にする
trg = A . bit1 = BinaryIndexedTree ( B )
rst = A . bit1 = BinaryIndexedTree ( B ) <eos>
3153
src = A から B を 引 いた 値に C から D を 引 いた 値を 掛 け た 値 から E から B を 引 いた 値に F から D を 引 いた 値を 掛 け た 値を 引 いた 値を返す
trg = return ( A - B ) * ( C - D ) - ( E - B ) * ( F - D )
rst = return ( A - B ) * ( C - D ) - ( E - B ) * ( F - D ) <eos>
3154
src = A . parent . get _ depth () に 1 を加えた 値を A の depth にする
trg = A . depth = A . parent . get_depth ( ) + 1
rst = A . depth = A . parent . _depth + 1 <eos>
3155
src = ( 0 ) からなる 列 の 4 回 分 の 列 を A とする
trg = A = [ 0 ] * 4
rst = A = [ 0 ] * 4 <eos>
3156
src = A が ( ( 0 、 0 ) の 組 、 ( 1 、 0 ) の 組 、 ( 2 、 0 ) の 組 、 ( 3 、 0 ) の 組 ) からなる 列 と 等 しい とき 、
trg = if A == [ ( 0 , 0 ) , ( 1 , 0 ) , ( 2 , 0 ) , ( 3 , 0 ) ] :
rst = if A == [ ( 0 , 0 ) , ( 1 , 0 ) , ( 2 , 0 ) , ( 0 , 3 ) ] : <eos>
3157
src = 1 を A の B から C を 引 いた 値 番目の D に C を加えた 値 番 目 にする
trg = A [ B - C ] [ D + C ] = 1
rst = A [ B - C ] [ D + C ] = 1 <eos>
3158
src = A . get _ d 2 ( B , C ) を出力する
trg = print ( A . get_d2 ( B , C ) )
rst = print ( A . <unk> ( B , C ) ) <eos>
3159
src = A の A [ B ] の parent 番目の left が B と 等 しく なく かつ A の A [ B ] の parent 番目の left が C と 等 しく ない とき 、
trg = if A [ A [ B ] . parent ] . left != B and A [ A [ B ] . parent ] . left != C :
rst = if A [ A [ B ] . parent ] . left != B and A [ A [ A . parent ] . parent ] . left != C : <eos>
3160
src = ( B の 2 番 目 、 B の 1 番 目 、 B の 5 番 目 、 B の先頭 、 B の 4 番 目 、 B の 3 番 目 ) からなる 列 を A の dice にする
trg = A . dice = [ B [ 2 ] , B [ 1 ] , B [ 5 ] , B [ 0 ] , B [ 4 ] , B [ 3 ] ]
rst = A . dice = [ B [ 2 ] , B [ 1 ] , B [ 5 ] , B [ 0 ] , B [ 4 ] , B [ 3 ] ] <eos>
3161
src = A の B 番目の C 番 目 が 、 つまり 無限大 と 等 しく ない とき 、
trg = if A [ B ] [ C ] != inf :
rst = if A [ B ] [ C ] != inf : <eos>
3162
src = 空 辞書 、 空 辞書 、 空 辞書 を A 、 B 、 C とする
trg = A , B , C = { } , { } , { }
rst = A , B , C = { } , { } <eos>
3163
src = D を A の B に C を加えた 値 番目の 0 番 目 にする
trg = A [ B + C ] [ 0 ] = D
rst = A [ B + C ] [ 0 ] = D <eos>
3164
src = - C を A の 1 番目の B 番 目 にする
trg = A [ 1 ] [ B ] = - C
rst = A [ 1 ] [ B ] = - C <eos>
3165
src = 0 から 10 未 満 までの 数 列 の 各要素 を D とし 、 0 から 10 未 満 までの 数 列 の 各要素 を C とし 、 B の 列 の 列 を A とする
trg = A = [ [ B for C in range ( 10 ) ] for D in range ( 10 ) ]
rst = A = [ [ B for C in range ( 10 ) ] for D in range ( 10 ) ] <eos>
3166
src = A の 5 番 目 を 1 だけ 増加 させる
trg = A [ 5 ] += 1
rst = A [ 5 ] += 1 <eos>
3167
src = A が 少なくとも ひとつ は 真 でない とき 、
trg = if not any ( A ) :
rst = if not any ( A ) : <eos>
3168
src = ( E ) からなる 列 、 ( F ) からなる 列 、 ( F を E で 割 った 商 ) からなる 列 、 ( F を E で 割 った 余 り ) からなる 列 を A 、 B 、 C 、 D とする
trg = A , B , C , D = [ E ] , [ F ] , [ F // E ] , [ F % E ]
rst = A , B , C , D = [ E ] , [ F ] , [ F // E , F ] , [ E % F , E ] <eos>
3169
src = A の B に 1 を加えた 値 番目の C 番 目 でない とき 、
trg = if not A [ B + 1 ] [ C ] :
rst = if not A [ B + 1 ] [ C ] : <eos>
3170
src = ( -2 、 -2 、 -2 、 -1 、 0 、 1 、 -1 、 0 、 1 、 2 、 2 、 2 ) からなる 列 を A とする
trg = A = [ - 2 , - 2 , - 2 , - 1 , 0 , 1 , - 1 , 0 , 1 , 2 , 2 , 2 ]
rst = A = [ - 2 , - 2 , - 1 , 0 , 1 , 0 , 1 , - 1 , 0 , 1 , 2 , 2 ] <eos>
3171
src = A の B に C を加えた 値 番目の D に E を加えた 値 番 目 が 1 と 等 しく かつ F の B に C を加えた 値 番目の D に E を加えた 値 番 目 でない とき 、
trg = if A [ B + C ] [ D + E ] == 1 and not F [ B + C ] [ D + E ] :
rst = if A [ B + C ] [ D + E ] == 1 and not F [ B + C ] [ D + E ] : <eos>
3172
src = 空白 文字 を A の B を 5 で 割 った 商 でない 番目の C 番 目 にする
trg = A [ not B // 5 ] [ C ] = ' '
rst = A [ B // 5 ] [ C ] = not ' ' <eos>
3173
src = 1 50 0000 を A とする
trg = A = 1500000
rst = A = <unk> <eos>
3174
src = B の C 番目の 0 番 目 に D の E 番 目 に F を加えた 値に D の E 番 目 が F より 大きい かどうか を 掛 け た 値 を加えた 値を A とする
trg = A = B [ C ] [ 0 ] + ( D [ E ] + F ) * ( D [ E ] > F )
rst = A = B [ C ] [ 0 ] + ( D [ E ] + F ) * ( D [ E ] > F ) <eos>
3175
src = 1 を 3 で 割 った 値の B 乗 を A の 0 番 目 にする
trg = A [ 0 ] = ( 1 / 3 ) ** B
rst = A [ 0 ] = ( 1 / 3 ) ** B <eos>
3176
src = 改行 せずに 空白 文字 を出力する
trg = print ( ' ' , end = '' )
rst = print ( ' ' , end = '' ) <eos>
3177
src = B から B に C を加えた 値 未 満 までの 数 列 を 順に A として 、 繰り返す
trg = for A in range ( B , B + C ) :
rst = for A in range ( B , B + C ) : <eos>
3178
src = add ( A , ( - B * C , D ) ) を A とする
trg = A = add ( A , ( - B * C , D ) )
rst = A = add ( A , ( - B * C , D ) ) <eos>
3179
src = ( ( ネ イ ピ ア 数 , C を ソート した 列 に 番号 付 した 組 の 列 の 各要素 を B 、 ネ イ ピ ア 数 とし 、 B に 1 を加えた 値の 列 ) ) からなる 辞書 を A とする
trg = A = { e : [ B + 1 for B , e in enumerate ( sorted ( C ) ) ] }
rst = A = { v : [ e + B for B , e in enumerate ( sorted ( C ) ) ] } <eos>
3180
src = 無限 の 整数 列 を A の B に 1 を加えた 値 番 目 が 0 より 大きい とき A の B に 1 を加えた 値 番 目 に C を 掛 け た 値 、 そうでなければ A の B に 1 を加えた 値 番 目 に D を 掛 け た 値 だけ 減少 させる
trg = count -= A [ B + 1 ] * C if A [ B + 1 ] > 0 else A [ B + 1 ] * D
rst = count -= A [ B + 1 ] * C if A [ B + 1 ] > 0 else A [ B + 1 ] * D <eos>
3181
src = A に ( 4 * B * B - A * A ) の . 5 乗 を 掛 け た 値に 2 に B を 掛 け た 値に ( ( B + C ) * * 2 - B * B ) の . 5 乗 を 掛 け た 値 を加えた 値を 4 で 割 った 値 を出力する
trg = print ( ( A * ( 4 * B * B - A * A ) ** .5 + 2 * B * ( ( B + C ) ** 2 - B * B ) ** .5 ) / 4 )
rst = print ( A * ( 4 * B ** B - A ** .5 ) + .5 * B * ( B * ( C ** 2 - B ** 2 ) / 5 ) ** .5 ) <eos>
3182
src = A の B 番 目 と 2 の 論理 積 の とき 、
trg = if A [ B ] & 2 :
rst = if A [ B ] & 2 : <eos>
3183
src = app ( ( A [ 0 ] , A [ 1 ] , B [ 0 ] , B [ 1 ] ) )
trg = app ( ( A [ 0 ] , A [ 1 ] , B [ 0 ] , B [ 1 ] ) )
rst = app ( ( ( A [ 0 ] , A [ 1 ] , B [ 0 ] , B [ 1 ] ) ) ) <eos>
3184
src = B の 4 個 までの 重複 コン ビ ネ ー ション を A とする
trg = A = combinations_with_replacement ( B , 4 )
rst = A = itertools . combinations_with_replacement ( B , 4 ) <eos>
3185
src = A を 書式 として B に C に 2 を 掛 け た 値 を加えた 値 で 整 形 した 文字列 を出力する
trg = print ( A . format ( B + C * 2 ) )
rst = print ( A . format ( B + C * 2 ) ) <eos>
3186
src = C の先頭 の 1 番 目 、 C の 1 番目の 1 番 目 に 1 を加えた 値を A 、 B とする
trg = A , B = C [ 0 ] [ 1 ] , C [ 1 ] [ 1 ] + 1
rst = A , B = C [ 0 ] [ 1 ] , C [ 1 ] [ 1 ] + 1 <eos>
3187
src = Dinic ( B ) を A とする
trg = A = Dinic ( B )
rst = A = Dinic ( B ) <eos>
3188
src = B の C から 1 を 引 いた 値 番目の D から E の C 番 目 を 引 いた 値 番 目 に E の C 番 目 を加えた 値を A とする
trg = A = B [ C - 1 ] [ D - E [ C ] ] + E [ C ]
rst = A = B [ C - 1 ] [ D - E [ C ] ] + E [ C ] <eos>
3189
src = B の 末 尾 の先頭 を A とする
trg = A = B [ - 1 ] [ 0 ]
rst = A = B [ - 1 ] [ 0 ] <eos>
3190
src = C の先頭 、 ( C の先頭 ) からなる 列 、 C の先頭 を 除 いた 部分 列 を A 、 B 、 C とする
trg = A , B , C = C [ 0 ] , [ C [ 0 ] ] , C [ 1 : ]
rst = A , B , C = C [ 0 ] , [ C [ 0 ] ] , C [ 1 : ] <eos>
3191
src = 入力された 文字列を 空白 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 の リストを ネ イ ピ ア 数 とする
trg = e = list ( map ( int , input ( ) . split ( ) ) )
rst = e = list ( map ( int , input ( ) . split ( ) ) ) <eos>
3192
src = A の list の 4 番 目 、 A の list の 5 番 目 、 A の list の 1 番 目 、 A の list の先頭 を A の list の先頭 、 A の list の 4 番 目 、 A の list の 5 番 目 、 A の list の 1 番 目 とする
trg = A . list [ 0 ] , A . list [ 4 ] , A . list [ 5 ] , A . list [ 1 ] = A . list [ 4 ] , A . list [ 5 ] , A . list [ 1 ] , A . list [ 0 ]
rst = A . list [ 0 ] , A . list [ 1 ] , A . list [ 5 ] , A . list [ 4 ] = A . list [ 4 ] , A . list [ 5 ] , A . list [ 1 ] , A
3193
src = B . _ find _ min ( C ) を A とする
trg = A = B . _find_min ( C )
rst = A = B . _find_min ( C ) <eos>
3194
src = 入力された 文字列を 空白 で 分割 した 字句 列 の 各要素 に x を パラメータ として x の 整数値 を返す関数 を適用した 列 の 組 を A とする
trg = A = tuple ( map ( lambda B : int ( B ) , input ( ) . split ( ) ) )
rst = A = tuple ( map ( lambda B : int ( B ) , input ( ) . split ( ) ) ) <eos>
3195
src = 入力された 文字列 の 整数値 の 間 、 次 を 繰り返す
trg = while int ( input ( ) ) :
rst = while int ( input ( ) ) : <eos>
3196
src = get _ t ( B - C , D - E , F - C , G - E ) を追加し て A を拡張する
trg = A . extend ( get_t ( B - C , D - E , F - C , G - E ) )
rst = A . extend ( <unk> ( B - C , D - E , F - C , G - E ) ) <eos>
3197
src = B を C だけ 左 シフト した 値を A とする
trg = A = B << C
rst = A = B << C <eos>
3198
src = 入力された 文字列を 空白 文字 で 分割 した 字句 列 の 各要素 を B とし 、 B の 整数値 の 列 を 無限 に 繰り返し た 列 を A とする
trg = A = cycle ( [ int ( B ) for B in input ( ) . split ( ' ' ) ] )
rst = A = cycle ( [ int ( B ) for B in input ( ) . split ( ' ' ) ] ) <eos>
3199
src = 0 でなければならない
trg = assert 0
rst = assert 0 <eos>
3200
src = A の edges の B の src 番目の 末 尾 に B を追加する
trg = A . edges [ B . src ] . append ( B )
rst = A . edges [ B . src ] . append ( B ) <eos>
3201
src = find ( A , int ( B [ 0 ] ) )
trg = find ( A , int ( B [ 0 ] ) )
rst = find ( A , int ( B [ 0 ] ) ) <eos>
3202
src = A の 総 和 を 60 で 割 った 余 り を出力する
trg = print ( sum ( A ) % 60 )
rst = print ( sum ( A ) % 60 ) <eos>
3203
src = A を ソート した 列 を 展開 して を出力する
trg = print ( * sorted ( A ) )
rst = print ( * sorted ( A ) ) <eos>
3204
src = 0 、 3 を出力する
trg = print ( 0 , 3 )
rst = print ( 0 , 3 ) <eos>
3205
src = 空文字列 を 間 に 入れ て A の 逆 順 を 連結 した 文字列 の 整数値 から 、 つまり 空文字列 を 間 に 入れ て A を 連結 した 文字列 の 整数値 を 引 いた 値 を出力する
trg = print ( int ( '' . join ( A [ : : - 1 ] ) ) - int ( '' . join ( A ) ) )
rst = print ( int ( '' . join ( A [ : : - 1 ] ) ) - int ( '' . join ( A ) ) ) <eos>
3206
src = 10 を B とする を A とする
trg = A = B = 10
rst = A = B = 10 <eos>
3207
src = 4 に B を 掛 け た 値に 3 を加えた 値に 4 に 3 に 4 * ( B + 1 ) / / 14 60 9 7 に 1 を加えた 値を 掛 け た 値を 4 で 割 った 商 を 掛 け た 値 を加えた 値を A とする
trg = A = 4 * B + 3 + 4 * ( 3 * ( 4 * ( B + 1 ) // 146097 + 1 ) // 4 )
rst = A = 4 * B + 3 * ( 4 + B * ( math . strip ( ) // 9 + 1 ) // 4 ) <eos>
3208
src = bst _ preorder ( A . right )
trg = bst_preorder ( A . right )
rst = <unk> ( A . right ) <eos>
3209
src = 1 を A の先頭 の先頭 の 0 番 目 にする
trg = A [ 0 ] [ 0 ] [ 0 ] = 1
rst = A [ 0 ] [ 0 ] [ 0 ] = 1 <eos>
3210
src = B の 絶対 値 と C の 絶対 値の 最大 公 約 数 を A とする
trg = A = gcd ( abs ( B ) , abs ( C ) )
rst = A = gcd ( abs ( B ) , abs ( C ) ) <eos>
3211
src = B の ord の 両 端 キュー を A とする
trg = A = deque ( B . ord )
rst = A = deque ( B . ord ) <eos>
3212
src = ( 1 、 0 、 2 ) の 組 を返す
trg = return ( 1 , 0 , 2 )
rst = return ( 1 , 0 , 2 ) <eos>
3213
src = 0 から C に 1 を加えた 値 未 満 までの 数 列 の 各要素 を B とし 、 B の 列 を A の par にする
trg = A . par = [ B for B in range ( C + 1 ) ]
rst = A . par = [ B for B in range ( C + 1 ) ] <eos>
3214
src = Node ( B , C ) を A とする
trg = A = Node ( B , C )
rst = A = Node ( B , C ) <eos>
3215
src = 0 から C に 1 を加えた 値 未 満 までの 数 列 の 各要素 を B とし 、 A 、 B の 総 和 の 列 を出力する
trg = print ( [ A . sum ( B ) for B in range ( C + 1 ) ] )
rst = print ( sum ( [ sum ( A , B ) for B in range ( C + 1 ) ] ) ) <eos>
3216
src = A が 3 と 等 しく ない とき 、
trg = if A != 3 :
rst = if A != 3 : <eos>
3217
src = 空 列 が A と 等 しい とき 、
trg = if [ ] == A :
rst = if [ ] == A : <eos>
3218
src = A の -1 に B を 掛 け た 値 番目の 文字列 を出力する
trg = print ( str ( A [ - 1 * B ] ) )
rst = print ( A [ - 1 * B ] ) <eos>
3219
src = B に対応する 値 、 も し 存在 し なければ C 、 -1 を A とする
trg = A = B . get ( C , - 1 )
rst = A = B . get ( C , - 1 ) <eos>
3220
src = A の d の先頭 、 A の d の 1 番 目 、 A の d の 5 番 目 、 A の d の 4 番 目 を A の d の 4 番 目 、 A の d の先頭 、 A の d の 1 番 目 、 A の d の 5 番 目 とする
trg = A . d [ 4 ] , A . d [ 0 ] , A . d [ 1 ] , A . d [ 5 ] = A . d [ 0 ] , A . d [ 1 ] , A . d [ 5 ] , A . d [ 4 ]
rst = A . d [ 4 ] , A . d [ 5 ] , A . d [ 1 ] , A . d [ 0 ] , A . d [ 5 ] = A . d [ 0 ] , A . d [ 1 ] , A
3221
src = B を 空白 で 分割 した 字句 列 を 順に A として 、 繰り返す
trg = for A in B . split ( ) :
rst = for A in B . split ( ) : <eos>
3222
src = ( A 、 B 、 C と D の 最大 公 約 数 ) の 組 を返す
trg = return ( A , B , gcd ( C , D ) )
rst = return ( A , B , C , math . gcd ( D ) ) <eos>
3223
src = 入力された 文字列を 空白 文字 で 分割 した 字句 列 の 各要素 に 浮動小数点数 を適用した 列 を 展開 し 、 それぞれ A 、 B 、 C 、 D 、 E 、 F とする
trg = A , B , C , D , E , F = map ( float , input ( ) . split ( ' ' ) )
rst = A , B , C , D , E , F = map ( float , input ( ) . split ( ' ' ) ) <eos>
3224
src = A に B を加えた 値の 2 乗 から A から B を 引 いた 値の 2 乗 を 引 いた 値の 1 を 2 で 割 った 値 乗 を返す
trg = return ( ( A + B ) ** 2 - ( A - B ) ** 2 ) ** ( 1 / 2 )
rst = return ( A + B ) ** 2 - ( A - B ) ** 2 ) ** ( 1 / 2 ) <eos>
3225
src = ( B が C と 等 しく ない とき B 、 そうでなければ E の 各要素 を B とし 、 D の 列 ) からなる 列 を A とする
trg = A = [ B if B != C else [ D for B in E ] ]
rst = A = [ ( B if B != C else [ D for B in E ] ] <eos>
3226
src = ( 0 、 1 、 0 、 1 、 1 、 0 、 1 、 0 、 0 、 1 、 0 、 1 、 1 、 0 、 1 、 0 ) の 組 を A とする
trg = A = ( 0 , 1 , 0 , 1 , 1 , 0 , 1 , 0 , 0 , 1 , 0 , 1 , 1 , 0 , 1 , 0 )
rst = A = ( 0 , 1 , 0 , 1 , 1 , 0 , 1 , 0 , 1 , 0 , 1 , 0 , 0 , 1 , 0 , 0 , 1 , 0 , 0 , 0 ) ) <eos>
3227
src = A の B 番目の 末 尾 に ( B に 1 を加えた 値 、 C ) の 組 を追加する
trg = A [ B ] . append ( ( B + 1 , C ) )
rst = A [ B ] . append ( ( B + 1 , C ) ) <eos>
3228
src = get _ childs ( B ) を A とする
trg = A = get_childs ( B )
rst = A = <unk> ( B ) <eos>
3229
src = A を B の n だけ 増加 させる
trg = A += B . n
rst = A += B . n <eos>
3230
src = A の 1 番目の B 番 目 が C と 等 しい とき 、
trg = if A [ 1 ] [ B ] == C :
rst = if A [ 1 ] [ B ] == C : <eos>
3231
src = 空文字列 、 空白 文字 を 間 に 入れ て B . preorder () の 各要素 を A とし 、 A の key の 文字列 の 列 を 連結 した 文字列 を出力する
trg = print ( '' , ' ' . join ( [ str ( A . key ) for A in B . preorder ( ) ] ) )
rst = print ( '' , ' ' . join ( [ str ( A . key ) for A in B . preorder ( ) ] ) ) <eos>
3232
src = A を 500 で 割 った 余 り が 0 と 等 しい とき 、
trg = if A % 500 == 0 :
rst = if A % 500 == 0 : <eos>
3233
src = " { } { } { } { } { } " を出力する
trg = print ( {elem[0]} {elem[1]} {elem[2]} {elem[3]} {elem[4]} )
rst = print ( <unk> <unk> <unk> <unk> <unk> ) <eos>
3234
src = C の 各要素 を B とし 、 B が D 以下の とき の B の 列 を A とする
trg = A = [ B for B in C if B <= D ]
rst = A = [ B for B in C if B <= D ] <eos>
3235
src = B に C を加えた 値 から 1 を 引 いた 値を C で 割 った 商 を A とする
trg = A = ( B + C - 1 ) // C
rst = A = ( B + C - 1 ) // C <eos>
3236
src = B 、 C において 正規表現 A が 最初 にマッチする 位置
trg = search ( A , B , C )
rst = search ( A , B , C ) <eos>
3237
src = A の 日付 が B の 日付 より 小さい とき 、
trg = if A . date < B . date :
rst = if A . date < B . date : <eos>
3238
src = C の 各要素 を B とし 、 B の 総 和 の 列 を A とする
trg = A = [ sum ( B ) for B in C ]
rst = A = sum ( [ B for B in C ] ) <eos>
3239
src = A の 末 尾 に B に C から D を 引 いた 値 を加えた 値 を追加する
trg = A . append ( B + ( C - D ) )
rst = A . append ( B + ( C - D ) ) <eos>
3240
src = A に 2 を 掛 け た 値が B 以下 かつ A に 2 を 掛 け た 値が C 以下 かつ A に 2 を 掛 け た 値が D 以下の とき 、
trg = if A * 2 <= B and A * 2 <= C and A * 2 <= D :
rst = if A * 2 <= B and A * 2 <= C and C * A <= D : <eos>
3241
src = B の C の先頭 と 等 しい 要素 の最初の 位置 を A とする
trg = A = B . index ( C [ 0 ] )
rst = A = B . index ( C [ 0 ] ) <eos>
3242
src = A を prod ( B ) だけ 増加 させる
trg = A += prod ( B )
rst = A += prod ( B ) <eos>
3243
src = A に 1 を加えた 値が B より 小さく かつ C の A * 2 + 1 番目の D 番 目 が 0 と 等 しく かつ E の A に 1 を加えた 値 番目の D 番 目 が F に 1 を加えた 値 より 大きい とき 、
trg = if A + 1 < B and C [ A * 2 + 1 ] [ D ] == 0 and E [ A + 1 ] [ D ] > F + 1 :
rst = if A + 1 < B and C [ A * 2 + 1 ] [ D ] == 0 and E [ A + 1 ] [ D ] > F + 1 : <eos>
3244
src = ( 0 ) からなる 列 の 32 回 分 の 列 を A とする
trg = A = [ 0 ] * 32
rst = A = [ 0 ] * 32 <eos>
3245
src = E の 両 端 から 空白 改行 を取り 除 いた 文字列を F で 分割 した 字句 列 の 各要素 を D とし 、 C の D 番目の 列 を 展開 し 、 それぞれ A 、 B とする
trg = A , B = [ C [ D ] for D in E . strip ( ) . split ( F ) ]
rst = A , B = [ C [ D ] for D in E . strip ( ) . split ( F ) ] <eos>
3246
src = B を r として 1 から B に 1 を加えた 値 未 満 までの 数 列 の 各要素 に 整数 を適用した 列 の 順 列 を 順に A として 、 繰り返す
trg = for A in permutations ( map ( str , range ( 1 , B + 1 ) ) , r = B ) :
rst = for A in permutations ( map ( str , range ( 1 , B + 1 ) ) , r = B ) : <eos>
3247
src = A に 1 を加えた 値が B より 小さい とき 、
trg = if A + 1 < B :
rst = if A + 1 < B : <eos>
3248
src = C の 各要素 を B とし 、 B を 空白 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 の 組 の 列 を A とする
trg = A = [ tuple ( map ( int , B . split ( ) ) ) for B in C ]
rst = A = [ tuple ( map ( int , B . split ( ) ) ) for B in C ] <eos>
3249
src = 1 を A の B の C 番目の 先頭 から 1 を 引 いた 値 番目の B の C 番目の D に 2 を加えた 値 番 目 から 1 を 引 いた 値 番 目 にする
trg = A [ B [ C ] [ 0 ] - 1 ] [ B [ C ] [ D + 2 ] - 1 ] = 1
rst = A [ B [ C ] [ 0 ] - 1 ] [ B [ C ] [ D + 2 ] - 1 ] = 1 <eos>
3250
src = A に B を 掛 け た 値 、 C に 0 、 B - D の 最大 値に E を 掛 け た 値 を加えた 値の 最小 値 を出力する
trg = print ( min ( A * B , C + max ( 0 , B - D ) * E ) )
rst = print ( min ( A * B , C + max ( 0 , B - D ) * E ) ) <eos>
3251
src = B の位置 A から C を 探 して 見つかった 位置 を A とする
trg = A = B . find ( C , A )
rst = A = B . find ( C , A ) <eos>
3252
src = -3 、 3 、 B の 1 番 目 から B の 2 番 目 を 引 いた 値の 最小 値の 最大 値を A とする
trg = A = max ( - 3 , min ( 3 , B [ 1 ] - B [ 2 ] ) )
rst = A = max ( - 3 , B [ 1 ] - B [ 2 ] ) <eos>
3253
src = A の 0 番 目 を B の 0 番 目 に C を 掛 け た 値 だけ 増加 させる
trg = A [ 0 ] += B [ 0 ] * C
rst = A [ 0 ] += B [ 0 ] * C <eos>
3254
src = A を B を C で 割 った 値に D を 掛 け た 値 だけ 増加 させる
trg = A += B / C * D
rst = A += B / C * D <eos>
3255
src = A の B 番 目 が 0 より 大きい とき 、
trg = if A [ B ] > 0 :
rst = if A [ B ] > 0 : <eos>
3256
src = A を C の 両 端 から D を取り 除 いた 文字列を 英 小文字 に変換し た 文字列を 空白 で 分割 した 字句 列 の 各要素 に w を パラメータ として w が B と 等 しい かどうか を返す関数 を適用した 列 の 総 和 だけ 増加 させる
trg = A += sum ( map ( lambda E : E == B , C . strip ( D ) . lower ( ) . split ( ) ) )
rst = A += sum ( map ( lambda B : B . find ( C . strip ( ) . split ( ) == B . w , C . strip ( ) ) ) <eos>
3257
src = merge _ sort ( C ) を ( A 、 B ) の 組 とする
trg = ( A , B ) = merge_sort ( C )
rst = ( A , B ) = merge_sort ( C ) <eos>
3258
src = ( (1) からなる 列 の 0 から D に 4 を加えた 値 未 満 までの 数 列 の 各要素 を C とし 、 B に 4 を加えた 値の 列 回 分 の 列 ) からなる 列 を A とする
trg = A = [ [ 1 ] * [ ( B + 4 ) for C in range ( D + 4 ) ] ]
rst = A = [ [ 1 ] * [ ( B + 4 ) for C in range ( D + 4 ) ] ] <eos>
3259
src = time は グローバル変数 とする
trg = global time
rst = global time <eos>
3260
src = D の B を取り 出した 値
trg = D . pop ( B )
rst = D . pop ( B . pop ( ) ) <eos>
3261
src = B の 2 乗 に C の 2 乗 を加えた 値 から 2 に B を 掛 け た 値に C を 掛 け た 値に math . pi * D を 1 80 で 割 った 値の 余 弦 を 掛 け た 値を 引 いた 値の 平 方 根 を A とする
trg = A = math . sqrt ( B ** 2 + C ** 2 - 2 * B * C * math . cos ( math . pi * D / 180 ) )
rst = A = sqrt ( B ** 2 + C ** 2 - 2 * B * C * cos ( math . pi / 180 ) ) <eos>
3262
src = A . s _ roll ()
trg = A . s_roll ( )
rst = A . <unk> ( ) <eos>
3263
src = A を 4 だけ 増加 させる
trg = A += 4
rst = A += 4 <eos>
3264
src = A を 9 . 8 で 割 った 値を返す
trg = return A / 9.8
rst = return A / 9.8 <eos>
3265
src = B を 3 60 で 割 った 商 を 20 で 割 った 余 り を A の 2 番 目 にする
trg = A [ 2 ] = B // 360 % 20
rst = A [ 2 ] = B // 360 % 20 <eos>
3266
src = B . GetNodes () の長さ を A とする
trg = A = len ( B . GetNodes ( ) )
rst = A = len ( B . GetNodes ( ) ) <eos>
3267
src = A . print ( B , C )
trg = A . print ( B , C )
rst = A . print ( B , C ) <eos>
3268
src = A の official _ house の B 番目の C 番目の D 番 目 を E だけ 減少 させる
trg = A . official_house [ B ] [ C ] [ D ] -= E
rst = A . official_house [ B ] [ C ] [ D ] -= E <eos>
3269
src = A の B 番 目 内の A の B 番目の C 番目の 出現 回数 が 1 と 等 しい とき 、
trg = if A [ B ] . count ( A [ B ] [ C ] ) == 1 :
rst = if A [ B ] . count ( A [ B ] [ C ] ) == 1 : <eos>
3270
src = C の D に 2 を 掛 け た 値に 2 を加えた 値 番 目 を 展開 し 、 それぞれ A 、 B とする
trg = A , B = C [ D * 2 + 2 ]
rst = A , B = C [ D * 2 + 2 ] <eos>
3271
src = 空文字列 、 空白 文字 を 間 に 入れ て A . root . prewalk () の 各要素 に 整数 を適用した 列 を 連結 した 文字列 を出力する
trg = print ( '' , ' ' . join ( map ( str , A . root . prewalk ( ) ) ) )
rst = print ( '' , ' ' . join ( map ( str , A . root . prewalk ( ) ) ) ) <eos>
3272
src = A が B 以下 かどうか が A の 2 乗 に 1 を加えた 値の . 5 乗 より 小さい とき 、
trg = if A <= B < ( A ** 2 + 1 ) ** .5 :
rst = if A <= B < ( A ** 2 + 1 ) ** .5 : <eos>
3273
src = 逆 順に 入力された 文字列を 空白 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 を ソート した 列 を A とする
trg = A = sorted ( map ( int , input ( ) . split ( ) ) , reverse = True )
rst = A = sorted ( map ( int , input ( ) . split ( ) ) , reverse = True ) <eos>
3274
src = A を B から C を 引 いた 値に D に E を加えた 値を 掛 け た 値 だけ 増加 させる
trg = A += ( B - C ) * ( D + E )
rst = A += ( B - C ) * ( D + E ) <eos>
3275
src = answer () を A とする
trg = A = answer ( )
rst = A = <unk> ( ) <eos>
3276
src = B の C に 1 を加えた 値 番 目 から B の C 番 目 を 引 いた 値を 2 で 割 った 商 を A とする
trg = A = ( B [ C + 1 ] - B [ C ] ) // 2
rst = A = ( B [ C + 1 ] - B [ C ] ) // 2 <eos>
3277
src = A に B の 0 番 目 を加えた 値に B の 1 番目の 文字列 を加えた 値に 空白 文字 を加えた 値を A とする
trg = A = A + B [ 0 ] + str ( B [ 1 ] ) + ' '
rst = A = A + B [ 0 ] + str ( B [ 1 ] ) + ' ' <eos>
3278
src = B の C 番 目 から C に 3 を加えた 値 までの 部分 列 の集合 を A とする
trg = A = set ( B [ C : C + 3 ] )
rst = A = set ( B [ C : C + 3 ] ) <eos>
3279
src = B に 10 の - 5 乗 を 掛 け た 値を A とする
trg = A = B * 10 ** - 5
rst = A = B * 10 ** ( - 5 ) <eos>
3280
src = A の bit 1 に B に 1 を加えた 値 、 C に B に 1 を加えた 値を 掛 け た 値 を追加した 集 ま り
trg = A . bit1 . add ( B + 1 , C * ( B + 1 ) )
rst = A . bit1 . add ( B + 1 , C + B * ( 1 ) ) <eos>
3281
src = 0 から C 未 満 までの 数 列 の 各要素 を B とし 、 readline () の 両 端 から 空白 改行 を取り 除 いた 文字列 の 列 を A とする
trg = A = [ readline ( ) . strip ( ) for B in range ( C ) ]
rst = A = [ readline ( ) . strip ( ) for B in range ( C ) ] <eos>
3282
src = A の code が B の code と 等 しい かどうか を返す
trg = return A . code == B . code
rst = return A . code == B . code <eos>
3283
src = A を B に 1 を加えた 値 で 割 った 余 り が 0 と 等 しい とき 、
trg = if A % ( B + 1 ) == 0 :
rst = if A % ( B + 1 ) == 0 : <eos>
3284
src = A の B に 3 を 掛 け た 値 から B * 3 に 3 を加えた 値 までの 部分 列 内の C の 出現 回数 が 3 と 等 しく または A の B 番 目 から 、 つまり 末 尾 までの 3 間隔 による 部分 列 内の C の 出現 回数 が 3 と 等 しい とき 、
trg = if A [ B * 3 : B * 3 + 3 ] . count ( C ) == 3 or A [ B : : 3 ] . count ( C ) == 3 :
rst = if A [ B * 3 : B * B + 3 ] . count ( C ) == 3 or A [ B : : 3 ] . count ( C ) == 3 : <eos>
3285
src = 空文字列 を 間 に 入れ て 0 から D 未 満 までの 数 列 の 各要素 を B とし 、 A の ( B + C ) を 2 で 割 った 余 り 番目の 列 を 連結 した 文字列 を出力する
trg = print ( '' . join ( [ A [ ( B + C ) % 2 ] for B in range ( D ) ] ) )
rst = print ( '' . join ( [ A [ ( B + C ) % 2 ] for B in range ( D ) ] ) ) <eos>
3286
src = date ( 2004 , B , C ) の 週 を A とする
trg = A = date ( 2004 , B , C ) . weekday ( )
rst = A = date ( 2004 , B , C ) . weekday ( ) <eos>
3287
src = str ( A + 1 ) に B を加えた 値に C + 1 の 文字列 を加えた 値に D を加えた 値に A に 1 を加えた 値に C に 1 を加えた 値を 掛 け た 値の 文字列 を加えた 値 を出力する
trg = print ( str ( A + 1 ) + B + str ( C + 1 ) + D + str ( ( A + 1 ) * ( C + 1 ) ) )
rst = print ( str ( A + 1 ) + B + str ( C + 1 ) + D + str ( A + 1 ) * ( C + 1 ) ) <eos>
3288
src = A を 26 で 割 った 余 り にする
trg = A %= 26
rst = A %= 26 <eos>
3289
src = A の先頭 が A の 1 番 目 より 小さく かつ A の 1 番 目 が A の 2 番 目 より 小さい とき 、
trg = if A [ 0 ] < A [ 1 ] and A [ 1 ] < A [ 2 ] :
rst = if A [ 0 ] < A [ 1 ] and A [ 1 ] < A [ 2 ] : <eos>
3290
src = id _ lower _ search ( A , B , 0 , A . index ( 0 ) , None , C )
trg = id_lower_search ( A , B , 0 , A . index ( 0 ) , None , C )
rst = <unk> ( A , B , 0 , A . index ( 0 ) , None , C ) <eos>
3291
src = A 内の 1 の 出現 回数 が B より 小さい 間 、 次 を 繰り返す
trg = while A . count ( 1 ) < B :
rst = while A . count ( 1 ) < B : <eos>
3292
src = merge _ sort ( A [ : ] , 0 , len ( A ) , B ) を 展開 し 、 それぞれ A 、 B とする
trg = A , B = merge_sort ( A [ : ] , 0 , len ( A ) , B )
rst = A , B = merge_sort ( A [ : ] , 0 , len ( A ) , B ) <eos>
3293
src = C の D 番 目 から 、 つまり 末 尾 までの 部分 列 の 逆 順 を A の B 番 目 にする
trg = A [ B ] = C [ D : ] [ : : - 1 ]
rst = A [ B ] = C [ D : ] [ : : - 1 ] <eos>
3294
src = ( 0 ) からなる 列 の input () の 整数値 回 分 の 列 の 各要素 を B とし 、 、 つまり 入力された 文字列 の 整数値 の 列 を ソート した 列 の 、 つまり 先頭 から 4 番 目 までの 部分 列 を A とする
trg = A = sorted ( [ int ( input ( ) ) for B in [ 0 ] * int ( input ( ) ) ] ) [ : 4 ]
rst = A = sorted ( [ int ( input ( ) ) for B in [ 0 ] * int ( input ( ) ) ] ) [ : 4 ] <eos>
3295
src = A の limit が 0 より 大きい 間 、 次 を 繰り返す
trg = while A . limit > 0 :
rst = while A . limit > 0 : <eos>
3296
src = A が B の長さ と 等 しく ない とき 、
trg = if A != len ( B ) :
rst = if A != len ( B ) : <eos>
3297
src = time を A の B 番 目 から 、 つまり 現在の 日 時 を 引 いた 値を C で 割 った 値 だけ 増加 させる
trg = time += ( A [ B ] - now ) / C
rst = time += ( A [ B ] - now ) / C <eos>
3298
src = F に G に D を 掛 け た 値 を加えた 値を E とする
trg = E = F + G * D
rst = E = F + G * D <eos>
3299
src = A から B を 引 いた 値に C から D を 引 いた 値を 掛 け た 値に E から F を 引 いた 値に G から H を 引 いた 値を 掛 け た 値 を加えた 値の 絶対 値が 1. e -10 より 小さい とき 、
trg = if abs ( ( A - B ) * ( C - D ) + ( E - F ) * ( G - H ) ) < 1.e-10 :
rst = if abs ( ( A - B ) * ( C - D ) + ( E - F ) * ( G - H ) ) < 1e-10 : <eos>
3300
src = ネ イ ピ ア 数が A と 等 しく ない とき 、
trg = if e != A :
rst = if e != A : <eos>
3301
src = B の 2 番 目 から 2 に C を加えた 値 までの 部分 列 を 順に A として 、 繰り返す
trg = for A in B [ 2 : 2 + C ] :
rst = for A in B [ 2 : 2 + C ] : <eos>
3302
src = B の先頭 の 1 番 目 から C の先頭 の 1 番 目 を 引 いた 値に D の先頭 の 1 番 目 から E の先頭 の 1 番 目 を 引 いた 値を 掛 け た 値を A とする
trg = A = ( B [ 0 ] [ 1 ] - C [ 0 ] [ 1 ] ) * ( D [ 0 ] [ 1 ] - E [ 0 ] [ 1 ] )
rst = A = ( B [ 0 ] [ 1 ] - C [ 0 ] [ 1 ] ) * ( D [ 0 ] [ 1 ] - E [ 0 ] [ 0 ] [ 1 ] ) <eos>
3303
src = B の real から B の imag を 引 いた 値を A とする
trg = A = B . real - B . imag
rst = A = B . real - B . imag <eos>
3304
src = " { } x { } = { } " を出力する
trg = print ( {i}x{j}={i*j} )
rst = print ( <unk> <unk> <unk> <unk> ) <eos>
3305
src = A の B の 整数値 に [MASK] を挿入する
trg = A . insert ( int ( B ) )
rst = A . insert ( int ( B ) ) <eos>
3306
src = dfs ( B | ( 1 < < C ) , C , tuple ( D ) ) を A とする
trg = A = dfs ( B | ( 1 << C ) , C , tuple ( D ) )
rst = A = dfs ( B | ( 1 << C ) , C , tuple ( D ) ) <eos>
3307
src = A が B と 等 しく または C が D と 等 しい とき 、
trg = if A == B or C == D :
rst = if A == B or C == D : <eos>
3308
src = B を 9 だけ 左 シフト した 値に C を 5 だけ 左 シフト した 値 を加えた 値に D を加えた 値を A とする
trg = A = ( B << 9 ) + ( C << 5 ) + D
rst = A = ( B << 9 ) + ( C << 5 ) + D <eos>
3309
src = 1 から B を 3 で 割 った 商 に 1 を加えた 値 未 満 までの 数 列 を 順に A として 、 繰り返す
trg = for A in range ( 1 , B // 3 + 1 ) :
rst = for A in range ( 1 , ( B // 3 ) + 1 ) : <eos>
3310
src = 0 から 8 から B を 引 いた 値に 1 を加えた 値 未 満 までの 数 列 を 順に A として 、 繰り返す
trg = for A in range ( 8 - B + 1 ) :
rst = for A in range ( 8 - B + 1 ) : <eos>
3311
src = C の 、 つまり 先頭 から D 番 目 までの 部分 列 を A の B 番 目 にする
trg = A [ B ] = C [ : D ]
rst = A [ B ] = C [ : D ] <eos>
3312
src = 4 が B に含まれる とき 7 、 そうでなければ 3 が B に 含まれ かつ 2 が B に含まれる とき 6 、 そうでなければ 3 が B に含まれる とき 4 、 そうでなければ B . count ( 2 ) が 2 と 等 しい とき 3 、 そうでなければ 2 を A とする
trg = A = 7 if 4 in B else ( 6 if 3 in B and 2 in B else ( 4 if 3 in B else ( 3 if B . count ( 2 ) == 2 else 2 ) ) )
rst = A = 7 if 4 in B else ( B in 2 and B in 63 if B in 3 else ( B . count if B in 2 else 2 ) ) == 3 else 2 <eos>
3313
src = A の B 番 目 が A の B に 1 を加えた 値 番 目 より 大きい とき 、
trg = if A [ B ] > A [ B + 1 ] :
rst = if A [ B ] > A [ B + 1 ] : <eos>
3314
src = B の C に 1 を加えた 値 番目の D から 1 を 引 いた 値 番 目 を A とする
trg = A = B [ C + 1 ] [ D - 1 ]
rst = A = B [ C + 1 ] [ D - 1 ] <eos>
3315
src = 0 が A 以下 かどうか が B より 小さく なく または 0 が C 以下 かどうか が D より 小さく なく または E の C 番目の A 番 目 が F と 等 しい とき 、
trg = if not 0 <= A < B or not 0 <= C < D or E [ C ] [ A ] == F :
rst = if not 0 <= A < B or not 0 <= C < D or E [ C ] [ A ] == F : <eos>
3316
src = A の B 番目の C に D を加えた 値 番目の とき 、
trg = if A [ B ] [ C + D ] :
rst = if A [ B ] [ C + D ] : <eos>
3317
src = A を B の ラ ジ アン の 正 弦 に C を 掛 け た 値 だけ 増加 させる
trg = A += math . sin ( math . radians ( B ) ) * C
rst = A += math . sin ( math . radians ( B ) ) * C <eos>
3318
src = A の 末 尾 に ( 0 、 B 、 C ) の 組 を追加する
trg = A . append ( ( 0 , B , C ) )
rst = A . append ( ( 0 , B , C ) ) <eos>
3319
src = A 、 B から E の 各要素 を D とし 、 C [ D ] の 列 の 最小 値を 引 いた 値に F から E の 各要素 を D とし 、 G [ D ] の 列 の 最小 値を 引 いた 値を 掛 け た 値の 最大 値を A とする
trg = A = max ( A , ( ( B - min ( [ C [ D ] for D in E ] ) ) * ( F - min ( [ G [ D ] for D in E ] ) ) ) )
rst = A = max ( A , ( B - min ( [ C [ D ] for D in [ E for D in F ] ] ) ) * ( D [ G ] ) ) <eos>
3320
src = A の B から 1 を 引 いた 値 番目の C から 1 を 引 いた 値 番 目 に A の B 番目の C 番 目 を加えた 値を A の B 番目の C 番 目 にする
trg = A [ B ] [ C ] = A [ B - 1 ] [ C - 1 ] + A [ B ] [ C ]
rst = A [ B ] [ C ] = A [ B - 1 ] [ C - 1 ] + A [ B ] [ C ] <eos>
3321
src = A の B の C の 整数値 番 目 と 等 しい 要素 の最初の 位置 に 1 を加えた 値 を出力する
trg = print ( A . index ( B [ int ( C ) ] ) + 1 )
rst = print ( A . index ( B [ int ( C ) ] ) + 1 ) <eos>
3322
src = 空 列 を A の primes にする
trg = A . primes = [ ]
rst = A . primes = [ ] <eos>
3323
src = ( A の 3 番 目 、 A の 1 番 目 、 A の先頭 、 A の 5 番 目 、 A の 4 番 目 、 A の 2 番 目 ) からなる 列 を返す
trg = return [ A [ 3 ] , A [ 1 ] , A [ 0 ] , A [ 5 ] , A [ 4 ] , A [ 2 ] ]
rst = return [ A [ 3 ] , A [ 1 ] , A [ 0 ] , A [ 5 ] , A [ 4 ] , A [ 2 ] ] <eos>
3324
src = A を 60 に B を 掛 け た 値 だけ 減少 させる
trg = A -= 60 * B
rst = A -= 60 * B <eos>
3325
src = B に C に 2 を 掛 け た 値 を加えた 値を 3 で 割 った 値を D とする
trg = D = ( B + C * 2 ) / 3
rst = D = ( B + C * 2 ) / 3 <eos>
3326
src = A 内の B に 26 を加えた 値 と 等 しい 要素を 取り除く
trg = A . remove ( B + 26 )
rst = A . remove ( B + 26 ) <eos>
3327
src = A 、 ネ イ ピ ア 数 に B の 0 番 目 を加えた 値に B の 1 番 目 を加えた 値の 最大 値を A とする
trg = A = max ( A , e + B [ 0 ] + B [ 1 ] )
rst = A = max ( A , e + B [ 0 ] + B [ 1 ] ) <eos>
3328
src = heappush ( A , ( 0 , B , C , D ) )
trg = heappush ( A , ( 0 , B , C , D ) )
rst = heappush ( A , ( 0 , B , C , D ) ) <eos>
3329
src = A を 逆 順に する
trg = A . reverse ( )
rst = A . reverse ( ) <eos>
3330
src = fill ( A , B )
trg = fill ( A , B )
rst = fill ( A , B ) <eos>
3331
src = B の 最小 値に 1 を加えた 値を A とする
trg = A = min ( B ) + 1
rst = A = min ( B ) + 1 <eos>
3332
src = 0 を A の ( 0 、 0 ) の 組 番 目 にする
trg = A [ ( 0 , 0 ) ] = 0
rst = A [ ( 0 , 0 ) ] = 0 <eos>
3333
src = HashMap () を A とする
trg = A = HashMap ( )
rst = A = <unk> ( ) <eos>
3334
src = G _ choice ( A )
trg = G_choice ( A )
rst = <unk> ( A ) <eos>
3335
src = extgcd ( B , C % B , D , E ) を A とする
trg = A = extgcd ( B , C % B , D , E )
rst = A = extgcd ( B , C % B , D , E ) <eos>
3336
src = A が B を 2 で 割 った 値 より 大きい とき 、
trg = if A > B / 2 :
rst = if A > B / 2 : <eos>
3337
src = 1 、 1 、 1 を A の B 番 目 、 A の C 番 目 、 A の D 番 目 とする
trg = A [ B ] , A [ C ] , A [ D ] = 1 , 1 , 1
rst = A [ B ] , A [ C ] , A [ D ] = 1 , 1 , 1 <eos>
3338
src = paint ( A , B + 1, C ) を A とする
trg = A = paint ( A , B + 1 , C )
rst = A = paint ( A , B + 1 , C ) <eos>
3339
src = ( B の 1 番目の 整数値 、 0 、 1 ) からなる 列 を A とする
trg = A = [ int ( B [ 1 ] ) , 0 , 1 ]
rst = A = [ int ( B [ 1 ] ) , 0 , 1 ] <eos>
3340
src = A の B 番 目 が 、 つまり 真 と 等 しく ない とき 、
trg = if A [ B ] is True :
rst = if A [ B ] is True : <eos>
3341
src = A 、 dfs ( 0 , B , 0 ) の 最小 値を A とする
trg = A = min ( A , dfs ( 0 , B , 0 ) )
rst = A = min ( A , dfs ( 0 , B , 0 ) ) <eos>
3342
src = 空 列 の 両 端 キュー を A とする
trg = A = deque ( [ ] )
rst = A = deque ( [ ] ) <eos>
3343
src = A を B の C から 1 を 引 いた 値 番目の 最大 値 で 割 った 余 り を出力する
trg = print ( A % max ( B [ C - 1 ] ) )
rst = print ( A % max ( B [ C - 1 ] ) ) <eos>
3344
src = _ in _ walk ( A . nodes [ B ] . right _ child )
trg = _in_walk ( A . nodes [ B ] . right_child )
rst = <unk> ( A . nodes [ B ] . right_child ) <eos>
3345
src = ソート された 順序 を 保 った まま C に D を加えた 値を A から E に 1 を加えた 値 まで の範囲 で B に 挿入 できる 位置 から 1 を 引 いた 値を A とする
trg = A = bisect_right ( B , C + D , A , E + 1 ) - 1
rst = A = bisect_left ( B , C + D , A , E + 1 ) - 1 <eos>
3346
src = A を 1 を B から 1 を 引 いた 値 だけ 左 シフト した 値 と の 論理 和 にする
trg = A |= 1 << ( B - 1 )
rst = A |= 1 << ( B - 1 ) <eos>
3347
src = A を B に f ( C ) を 掛 け た 値 だけ 増加 させる
trg = A += B * f ( C )
rst = A += B * f ( C ) <eos>
3348
src = B に C を 掛 け た 値に D を 掛 け た 値を 2.0 で 割 った 値を A とする
trg = A = B * C * D / 2.0
rst = A = B * C * D / 2.0 <eos>
3349
src = par ( A [ B ] ) を A の B 番 目 にする
trg = A [ B ] = par ( A [ B ] )
rst = A [ B ] = par ( A [ B ] ) <eos>
3350
src = B の nodes の キー の集まり を ソート した 列 を 順に A として 、 繰り返す
trg = for A in sorted ( B . nodes . keys ( ) ) :
rst = for A in sorted ( B . nodes . keys ( ) ) : <eos>
3351
src = B の C 番 目 を 深く コピー した結果 を A とする
trg = A = copy . deepcopy ( B [ C ] )
rst = A = copy . heap <eos>
3352
src = B の val を A の val にする
trg = A . val = B . val
rst = A . val = B . val <eos>
3353
src = A . down ( B [ 0 ] )
trg = A . down ( B [ 0 ] )
rst = A . <unk> ( B [ 0 ] ) <eos>
3354
src = A の pip の 3 番 目 、 A の pip の先頭 、 A の pip の 5 番 目 、 A の pip の 2 番 目 を A の pip の先頭 、 A の pip の 2 番 目 、 A の pip の 3 番 目 、 A の pip の 5 番 目 とする
trg = A . pip [ 0 ] , A . pip [ 2 ] , A . pip [ 3 ] , A . pip [ 5 ] = A . pip [ 3 ] , A . pip [ 0 ] , A . pip [ 5 ] , A . pip [ 2 ]
rst = A . pip [ 0 ] , A . pip [ 2 ] , A . pip [ 3 ] , A . pip [ 5 ] = A . pip [ 3 ] , A . pip [ 0 ] , A . pip [ 5 ] , A
3355
src = ( ( B , C の 先頭に [MASK] を追加する ) 、 ( D , C 内の [MASK] と 等 しい 要素を 取り除く ) 、 ( E , C の popleft ) 、 ( F , C の先頭 を取り 出した 値 ) ) からなる 辞書 を A とする
trg = A = { 'insert' : C . appendleft , 'delete' : C . remove , 'deleteFirst' : C . popleft , 'deleteLast' : C . pop }
rst = A = { '+' : C . val , '-' : C . format , '*' : C . format , '/' : C . pop ( ) } <eos>
3356
src = B に C を加えた 値を D の size で 割 った 余 り を A とする
trg = A = ( B + C ) % D . size
rst = A = ( B + C ) % D . size <eos>
3357
src = matpow ( A , B , C - D , E ) を A とする
trg = A = matpow ( A , B , C - D , E )
rst = A = <unk> ( A , B , C - D , E ) <eos>
3358
src = 0 から B を 2 で 割 った 商 に 1 を加えた 値 未 満 までの 数 列 を 順に A として 、 繰り返す
trg = for A in range ( B // 2 + 1 ) :
rst = for A in range ( B // 2 + 1 ) : <eos>
3359
src = wa ( A ) を出力する
trg = print ( wa ( A ) )
rst = print ( <unk> ( A ) ) <eos>
3360
src = 0 から C 未 満 までの 数 列 の 各要素 を B とし 、 、 つまり 無限大 の 列 を A とする
trg = A = [ inf for B in range ( C ) ]
rst = A = [ inf for B in range ( C ) ] <eos>
3361
src = A の ハッシュ 値を返す
trg = return hash ( A )
rst = return hash ( A ) <eos>
3362
src = B が 1000 より 大きい とき A に 2 に B から 9 99 を 引 いた 値を 掛 け た 値に B から 1000 を 引 いた 値を 掛 け た 値 を加えた 値 、 そうでなければ 0 を A とする
trg = A = A + 2 * ( B - 999 ) * ( B - 1000 ) if B > 1000 else 0
rst = A = A * ( 2 * ( B - 99999 B - 1000 ) ) + 0 <eos>
3363
src = swap ( tuple ( map ( int , input () . split ( A ) ) ) )
trg = swap ( tuple ( map ( int , input ( ) . split ( A ) ) ) )
rst = swap ( tuple ( map ( int , input ( ) . split ( ) ) ) ) <eos>
3364
src = A の f の B 番 目 が 9 と 等 しい とき 、
trg = if A . f [ B ] == 9 :
rst = if A . f [ B ] == 9 : <eos>
3365
src = A の B に C を加えた 値 番 目 を C だけ 減少 させる
trg = A [ B + C ] -= C
rst = A [ B + C ] -= C <eos>
3366
src = A が B の C 番目の D 番 目 より 小さい とき 、
trg = if A < B [ C ] [ D ] :
rst = if A < B [ C ] [ D ] : <eos>
3367
src = operator モジュール を用いる
trg = from operator import A
rst = import import import import making_n <eos>
3368
src = is _ intersected ( A , B , C , D ) の とき 、
trg = if is_intersected ( A , B , C , D ) :
rst = if <unk> ( A , B , C , D ) : <eos>
3369
src = 入力された 文字列を 空白 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 を 展開 し 、 それぞれ A 、 B 、 ネ イ ピ ア 数 、 C 、 D とする
trg = A , B , e , C , D = map ( int , input ( ) . split ( ) )
rst = A , B , e , C , D = map ( int , input ( ) . split ( ) ) <eos>
3370
src = -1 に B の 浮動小数点数 を 掛 け た 値を A とする
trg = A = - 1 * float ( B )
rst = A = - 1 * float ( B ) <eos>
3371
src = D の 1 番目の 各要素 を C とし 、 D の 0 番目の 列 の 各要素 を B とし 、 B に C を加えた 値の 列 を A とする
trg = A = [ B + C for B in [ D [ 0 ] for C in D [ 1 ] ] ]
rst = A = [ B + C for B in [ D [ 0 ] for C in D [ 1 ] ] ] <eos>
3372
src = B から 読み 込 んだ 一行 を 空白 で 分割 した 字句 列 に ( C 、 C ) からなる 列 を加えた 値を A とする
trg = A = B . readline ( ) . split ( ) + [ C , C ]
rst = A = B . readline ( ) . split ( ) + [ C , C ] <eos>
3373
src = B に 1 を加えた 値 から B に C を加えた 値に 1 を加えた 値 未 満 までの 数 列 を 順に A として 、 繰り返す
trg = for A in range ( B + 1 , B + C + 1 ) :
rst = for A in range ( B + 1 , B + C + 1 ) : <eos>
3374
src = A の cnt _ mp の B 番目の C 番目の D 番 目 を 1 だけ 減少 させる
trg = A . cnt_mp [ B ] [ C ] [ D ] -= 1
rst = A . cnt_mp [ B ] [ C ] [ D ] -= 1 <eos>
3375
src = 無限 の 整数 列 が A 以下の 間 、 次 を 繰り返す
trg = while count <= A :
rst = while count <= A : <eos>
3376
src = D の 両 端 から 空白 改行 を取り 除 いた 文字列 の 各要素 を C とし 、 B の C 番目の 列 を A とする
trg = A = [ B [ C ] for C in D . strip ( ) ]
rst = A = [ B [ C ] for C in D . strip ( ) ] <eos>
3377
src = A の 2 番 目 かつ A の先頭 で なく または A の 1 番目の とき 、
trg = if A [ 2 ] and ( ( not A [ 0 ] ) or A [ 1 ] ) :
rst = if ( not A [ 2 ] and A [ 0 ] ) or ( not A [ 1 ] ) : <eos>
3378
src = ( D を E で 割 った 商 、 F を E で 割 った 商 ) の 組 を A の B 番目の C 番 目 にする
trg = A [ B ] [ C ] = ( D // E , F // E )
rst = A [ B ] [ C ] = ( D // E , F // E ) <eos>
3379
src = B の 文字列を 長さ C になる ように ' 0 ' 左 詰 め した 文字列 の リストを A とする
trg = A = list ( str ( B ) . zfill ( C ) )
rst = A = list ( str ( B ) . zfill ( C ) ) <eos>
3380
src = A . heappush ( B [ C [ 1 ]] , - C [ 2 ] )
trg = A . heappush ( B [ C [ 1 ] ] , - C [ 2 ] )
rst = A . heappush ( B [ C [ 1 ] ] , - C [ 2 ] ) <eos>
3381
src = A の B 番目の C 番 目 が D と 等 しく なく かつ A の C 番目の E 番 目 が D と 等 しく ない とき 、
trg = if A [ B ] [ C ] != D and A [ C ] [ E ] != D :
rst = if A [ B ] [ C ] != D and A [ C ] [ E ] != D : <eos>
3382
src = super () . __ init __ ( A , B )
trg = super ( ) . __init__ ( A , B )
rst = super ( ) . __init__ ( A , B ) <eos>
3383
src = B の 平 方 根 の 整数値 に 1 を加えた 値を A とする
trg = A = int ( math . sqrt ( B ) ) + 1
rst = A = int ( math . sqrt ( B ) ) + 1 <eos>
3384
src = A の B 番 目 が 0 より 大きい 間 、 次 を 繰り返す
trg = while ( A [ B ] > 0 ) :
rst = while A [ B ] > 0 : <eos>
3385
src = 100 0000 0000 0000 を A とする
trg = A = 100000000000000
rst = A = <unk> <eos>
3386
src = B の C 番目の 0 番 目 に 1 を加えた 値を A とする
trg = A = B [ C ] [ 0 ] + 1
rst = A = B [ C ] [ 0 ] + 1 <eos>
3387
src = A の 末 尾 に B の to を追加する
trg = A . append ( B . to )
rst = A . append ( B . to ) <eos>
3388
src = ( A 、 B 、 C 、 無限 の 整数 列 ) の 組 を返す
trg = return ( A , B , C , count )
rst = return ( A , B , C , count ) <eos>
3389
src = 18 68 に B を加えた 値 から 1 を 引 いた 値を A とする
trg = A = 1868 + B - 1
rst = A = 1868 + B - 1 <eos>
3390
src = bubble _ sort ( C ) を ( A 、 B ) の 組 とする
trg = ( A , B ) = bubble_sort ( C )
rst = ( A , B ) = bubble_sort ( C ) <eos>
3391
src = B の 2 番 目 から 、 つまり 末 尾 までの 部分 列 を追加し て A を拡張する
trg = A . extend ( B [ 2 : ] )
rst = A . extend ( B [ 2 : ] ) <eos>
3392
src = find ( A . root , B ) の とき 、
trg = if find ( A . root , B ) :
rst = if find ( A . root , B ) : <eos>
3393
src = B の back を A とする
trg = A = B . back
rst = A = B . back <eos>
3394
src = 100 . 0000 0000 、 0 . 0000 0000 を出力する
trg = print ( 100.00000000 , 0.00000000 )
rst = print ( <unk> , 0.0000 ) <eos>
3395
src = C の 文字列 の 各要素 を B とし 、 B の 整数値 の 列 を A とする
trg = A = [ int ( B ) for B in str ( C ) ]
rst = A = [ int ( B ) for B in str ( C ) ] <eos>
3396
src = A の 2 番 目 を B の 1 番 目 に B の 7 番 目 を 掛 け た 値 だけ 減少 させる
trg = A [ 2 ] -= B [ 1 ] * B [ 7 ]
rst = A [ 2 ] -= B [ 1 ] * B [ 7 ] <eos>
3397
src = 0 を A の penalty にする
trg = A . penalty = 0
rst = A . south = 0 <eos>
3398
src = B に 30 を 掛 け た 値に C を 60 で 割 った 値に 30 を 掛 け た 値 を加えた 値を A とする
trg = A = B * 30 + ( C / 60 * 30 )
rst = A = B * 30 + C / 60 * 30 <eos>
3399
src = A を dfs ( B + 1, C , D ) に D を 掛 け た 値を E で 割 った 余 り だけ 増加 させる
trg = A += dfs ( B + 1 , C , D ) * D % E
rst = A += dfs ( B + 1 , C , D ) * D % E <eos>
3400
src = C の B 番 目 を A の bin 5 ( 26 + B ) 番 目 にする
trg = A [ bin5 ( 26 + B ) ] = C [ B ]
rst = A . bin ( B ) [ 5 + 26 ] = C [ B ] <eos>
