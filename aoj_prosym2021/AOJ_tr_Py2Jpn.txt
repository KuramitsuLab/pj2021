BLEU score = 91.21
epoch = 85
image = 4

| Train Loss: 0.035 | Train PPL:   1.036 |
| Val. Loss: 0.154 |  Val. PPL:   1.167 |
| Test Loss: 0.154 | Test PPL:   1.167 |

0
src = A , B = read_list ( int )
trg = read _ list ( int ) を 展開 し 、 それぞれ A 、 B とする
rst = euler _ <unk> ( int ( 36 <unk> ) を 展開 し 、 それぞれ A 、 B とする <eos>
1
src = A [ int ( B ) ] = [ int ( C ) for C in D ]
trg = D の 各要素 を C とし 、 C の 整数値 の 列 を A の B の 整数値 番 目 にする
rst = D の 各要素 を C とし 、 C の 整数値 の 列 を A の B の 整数値 番 目 にする <eos>
2
src = A = fibonacci ( 3 + 2 * B , C ) * fibonacci ( D + 1 - 2 * B , C ) % C
trg = fibonacci ( 3 + 2 * B , C ) に fibonacci ( D + 1 -2 * B , C ) を 掛 け た 値を C で 割 った 余 り を A とする
rst = fibonacci ( 3 + 2 * B , C ) に fibonacci ( D + 1 -2 * B , C ) を 掛 け た 値を C で 割 った 余 り を A とする <eos>
3
src = for A in range ( 1 , 6 ) :
trg = 1 から 6 未 満 までの 数 列 を 順に A として 、 繰り返す
rst = 1 から 6 未 満 までの 数 列 を 順に A として 、 繰り返す <eos>
4
src = if A . count ( B [ 1 ] ) :
trg = A 内の B の 1 番目の 出現 回数 の とき 、
rst = A 内の B の 1 番目の 出現 回数 の とき 、 <eos>
5
src = A = B // 100 + C // 30 * 5
trg = B を 100 で 割 った 商 に C を 30 で 割 った 商 に 5 を 掛 け た 値 を加えた 値を A とする
rst = B を 100 で 割 った 商 に C を 30 で 割 った 商 に 5 を 掛 け た 値 を加えた 値を A とする <eos>
6
src = A = A [ : B + 1 ] + A [ B + 2 : ]
trg = A の 、 つまり 先頭 から B に 1 を加えた 値 までの 部分 列 に A の B に 2 を加えた 値 から 、 つまり 末 尾 までの 部分 列 を加えた 値を A とする
rst = A の 、 つまり 先頭 から B に 1 を加えた 値 までの 部分 列 に A の B に 2 を加えた 値 から 、 つまり 末 尾 までの 部分 列 を加えた 値を A とする <eos>
7
src = if A [ B [ 1 ] ] == [ ] :
trg = A の B の 1 番 目 番 目 が 、 つまり 空 列 と 等 しい とき 、
rst = A の B の 1 番 目 番 目 が 、 つまり 空 列 と 等 しい とき 、 <eos>
8
src = if e [ 1 ] > 0 :
trg = ネ イ ピ ア 数の 1 番 目 が 0 より 大きい とき 、
rst = ネ イ ピ ア 数の 1 番 目 が 0 より 大きい とき 、 <eos>
9
src = A = ( B - 30 ) // 2
trg = B から 30 を 引 いた 値を 2 で 割 った 商 を A とする
rst = B から 30 を 引 いた 値を 2 で 割 った 商 を A とする <eos>
10
src = A = jump_candidate ( B )
trg = jump _ candidate ( B ) を A とする
rst = <unk> ( B ) を A とする <eos>
11
src = if floor ( A * ( 1 + B / 100 ) + 0.00001 ) != C :
trg = A に 1 に B / 100 を加えた 値を 掛 け た 値に 0 . 0000 1 を加えた 値の 切り 捨 て 整数値 が C と 等 しく ない とき 、
rst = A に 1 に B / 100 を加えた 値を 掛 け た 値に 0 . 0000 1 を加えた 値の 切り 捨 て 整数値 が C と 等 しく ない とき 、 <eos>
12
src = print ( 100 , 0.0 )
trg = 100 、 0.0 を出力する
rst = 100 、 0.0 を出力する <eos>
13
src = print ( A , B , C )
trg = A 、 B 、 C を出力する
rst = A 、 B 、 C を出力する <eos>
14
src = A = [ [ 0 for B in range ( len ( C ) ) ] for B in range ( len ( D ) ) ]
trg = 0 から D の長さ 未 満 までの 数 列 の 各要素 を B とし 、 0 から C の長さ 未 満 までの 数 列 の 各要素 を B とし 、 0 の 列 の 列 を A とする
rst = 0 から D の長さ 未 満 までの 数 列 の 各要素 を B とし 、 0 から C の長さ 未 満 までの 数 列 の 各要素 を B とし 、 0 の 列 の 列 を A とする <eos>
15
src = A = [ [ B ] * [ C . n for D in range ( C . n ) ] ]
trg = ( ( B ) からなる 列 の 0 から C の n 未 満 までの 数 列 の 各要素 を D とし 、 C の n の 列 回 分 の 列 ) からなる 列 を A とする
rst = ( ( B ) からなる 列 の 0 から C の n 未 満 までの 数 列 の 各要素 を D とし 、 C の n の 列 回 分 の 列 ) からなる 列 を A とする <eos>
16
src = A = intersection01 ( 0 , 0 , B , C , D , E , F )
trg = intersection 01 ( 0 , 0 , B , C , D , E , F ) を A とする
rst = <unk> ( 0 , 0 , B , C , D , E , F ) を A とする <eos>
17
src = A [ 2 ] -= 2
trg = A の 2 番 目 を 2 だけ 減少 させる
rst = A の 2 番 目 を 2 だけ 減少 させる <eos>
18
src = while A == 1 :
trg = A が 1 と 等 しい 間 、 次 を 繰り返す
rst = A が 1 と 等 しい 間 、 次 を 繰り返す <eos>
19
src = if ( A [ B [ 1 ] ] , B [ 0 ] ) < ( A [ C [ 1 ] ] , C [ 0 ] ) :
trg = ( A の B の 1 番 目 番 目 、 B の先頭 ) の 組 が ( A の C の 1 番 目 番 目 、 C の先頭 ) の 組 より 小さい とき 、
rst = ( A の B の 1 番 目 、 B の先頭 ) の 組 が ( A の C の 1 番 目 番 目 、 C の先頭 ) の 組 より 小さい とき 、 <eos>
20
src = if A [ B ] . c [ 0 ] != - 1 :
trg = A の B 番目の c の先頭 が -1 と 等 しく ない とき 、
rst = A の B 番目の c の 0 番 目 が -1 と 等 しく ない とき 、 <eos>
21
src = f ( A , B )
trg = f ( A , B )
rst = f ( A , B ) <eos>
22
src = A = [ - 1 ] * 1001
trg = ( -1 ) からなる 列 の 100 1 回 分 の 列 を A とする
rst = ( -1 ) からなる 列 の 100 1 回 分 の 列 を A とする <eos>
23
src = + calc ( A - 1 , B - C , D , E )
trg = calc ( A - 1, B - C , D , E ) に [MASK] を加えた 値
rst = calc ( A - 1, B - C , D , E ) に [MASK] を加えた 値 <eos>
24
src = if A . _is_red ( B . left ) :
trg = A . _ is _ red ( B . left ) の とき 、
rst = A . _ is _ red ( B . left ) の とき 、 <eos>
25
src = A [ B ] [ C ] = ( D == E )
trg = D が E と 等 しい かどうか を A の B 番目の C 番 目 にする
rst = D が E と 等 しい かどうか を A の B 番目の C 番 目 にする <eos>
26
src = A . insert ( len ( A ) , [ B for C in range ( D ) ] )
trg = A の A の長さ に 0 から D 未 満 までの 数 列 の 各要素 を C とし 、 B の 列 を挿入する
rst = A の A の長さ に 0 から D 未 満 までの 数 列 の 各要素 を C とし 、 B の 列 を挿入する <eos>
27
src = heappush ( A , [ B + C , 1 , D , [ E , F ] ] )
trg = heappush ( A , [ B + C , 1, D , [ E , F ]])
rst = heappush ( A , [ B + C , 1, D , [ E , F ] ) <eos>
28
src = A = SPFA ( B , C , D )
trg = SPFA ( B , C , D ) を A とする
rst = <unk> ( B , C , D ) を A とする <eos>
29
src = A = rotate_dice ( A , e )
trg = rotate _ dice ( A , e ) を A とする
rst = rotate _ dice ( A , e ) を A とする <eos>
30
src = A . r = B
trg = B を A の r にする
rst = B を A の r にする <eos>
31
src = A [ B ] = C = root ( D )
trg = root ( D ) を C とする を A の B 番 目 にする
rst = root ( D ) を C とする を A の B 番 目 にする <eos>
32
src = print ( ' ' . join ( [ A for A in str ( sorted ( B [ max ( B . keys ( ) ) ] ) [ 0 ] ) ] ) )
trg = 空白 文字 を 間 に 入れ て sorted ( B [ max ( B . keys () ) ] ) の先頭 の 文字列 の 各要素 を A とし 、 A の 列 を 連結 した 文字列 を出力する
rst = 空白 文字 を 間 に 入れ て B の キー の集まり の 最大 値の 各要素 を A とし 、 A の 列 を ソート した 列 の先頭 の 文字列 を出力する <eos>
33
src = A = list ( set ( B ) ^ set ( C ) )
trg = B の集合 と C の集合 の 排 他 論理 和 の リストを A とする
rst = B の集合 と C の集合 の 排 他 論理 和 の リストを A とする <eos>
34
src = if A < B [ C ] and A < B [ D ] :
trg = A が B の C 番 目 より 小さく かつ A が B の D 番 目 より 小さい とき 、
rst = A が B の C 番 目 より 小さく かつ A が B の D 番 目 より 小さい とき 、 <eos>
35
src = if A <= B + C :
trg = A が B に C を加えた 値 以下の とき 、
rst = A が B に C を加えた 値 以下の とき 、 <eos>
36
src = dfs ( A [ 1 ] , B + 1 )
trg = dfs ( A [ 1 ] , B + 1 )
rst = dfs ( A [ 1 ] , B + 1 ) <eos>
37
src = A = B * C * 2 + C ** 2
trg = B に C を 掛 け た 値に 2 を 掛 け た 値に C の 2 乗 を加えた 値を A とする
rst = B に C を 掛 け た 値に 2 を 掛 け た 値に C の 2 乗 を加えた 値を A とする <eos>
38
src = matmul ( A , B , C , D )
trg = matmul ( A , B , C , D )
rst = matmul ( A , B , C , D ) <eos>
39
src = A = dfs ( B , C , D , E , float ( F ) )
trg = dfs ( B , C , D , E , float ( F ) ) を A とする
rst = dfs ( B , C , D , E , ( F ) ) を A とする <eos>
40
src = A = A // 5
trg = A を 5 で 割 った 商 を A とする
rst = A を 5 で 割 った 商 を A とする <eos>
41
src = A += D if B == C else E - D
trg = A を B が C と 等 しい とき D 、 そうでなければ E から D を 引 いた 値 だけ 増加 させる
rst = A を B が C と 等 しい とき D 、 そうでなければ E から D を 引 いた 値 だけ 増加 させる <eos>
42
src = A [ B + 1 ] [ C - D [ B ] ] += A [ B ] [ C ]
trg = A の B に 1 を加えた 値 番目の C から D の B 番 目 を 引 いた 値 番 目 を A の B 番目の C 番 目 だけ 増加 させる
rst = A の B に 1 を加えた 値 番目の C から D の B 番 目 を 引 いた 値 番 目 を A の B 番目の C 番 目 だけ 増加 させる <eos>
43
src = print ( A . format ( B [ C ] [ 0 ] ) )
trg = A を 書式 として B の C 番目の 先頭 で 整 形 した 文字列 を出力する
rst = A を 書式 として B の C 番目の 先頭 で 整 形 した 文字列 を出力する <eos>
44
src = while A != B . id [ A ] :
trg = A が B の id の A 番 目 と 等 しく ない 間 、 次 を 繰り返す
rst = A が B の id の A 番 目 と 等 しく ない 間 、 次 を 繰り返す <eos>
45
src = A = abs ( cross ( B , ( C - D , E - F ) ) ) / length ( B )
trg = cross ( B , ( C - D , E - F ) ) の 絶対 値を length ( B ) で 割 った 値を A とする
rst = cross ( B , ( C - D , E - F ) ) の 絶対 値を length ( B ) で 割 った 値を A とする <eos>
46
src = if ( A [ B ] >= C ) and ( D > 0 ) :
trg = A の B 番 目 が C 以上 かつ D が 0 より 大きい とき 、
rst = A の B 番 目 が C 以上 かつ D が 0 より 大きい とき 、 <eos>
47
src = A -= A // 10 * 10
trg = A を A を 10 で 割 った 商 に 10 を 掛 け た 値 だけ 減少 させる
rst = A を A を 10 で 割 った 商 に 10 を 掛 け た 値 だけ 減少 させる <eos>
48
src = A . hldid [ B ] = C
trg = C を A の hldid の B 番 目 にする
rst = C を A の hldid の B 番 目 にする <eos>
49
src = A = [ chr ( B ) for B in range ( 65 , 65 + 26 ) ]
trg = 6 5 から 6 5 に 26 を加えた 値 未 満 までの 数 列 の 各要素 を B とし 、 、 つまり 文字コード B の 文字 の 列 を A とする
rst = 6 5 から 6 5 に 26 を加えた 値 未 満 までの 数 列 の 各要素 を B とし 、 、 つまり 文字コード B の 文字 の 列 を A とする <eos>
50
src = if A . find ( B ) :
trg = A の先頭 から B を 探 して 見つかった 位置 の とき 、
rst = A の先頭 から B を 探 して 見つかった 位置 の とき 、 <eos>
51
src = print ( [ A , B ] [ f ( C , D ) or f ( C [ 1 : ] , D ) ] )
trg = ( A 、 B ) からなる 列 の f ( C , D ) または f ( C [ 1 : ] , D ) 番 目 を出力する
rst = ( A 、 B ) からなる 列 の f ( C , D ) または f ( C , D ) 番 目 から 、 つまり 末 尾 までの 部分 列 を出力する <eos>
52
src = A = [ - 1 ] * ( 50 * 50 )
trg = ( -1 ) からなる 列 の 50 に 50 を 掛 け た 値 回 分 の 列 を A とする
rst = ( -1 ) からなる 列 の 50 に 50 を 掛 け た 値 回 分 の 列 を A とする <eos>
53
src = print ( ( A - B - C ) // ( D - 2 ) )
trg = A から B を 引 いた 値 から C を 引 いた 値を D から 2 を 引 いた 値 で 割 った 商 を出力する
rst = A から B を 引 いた 値 から C を 引 いた 値を D から 2 を 引 いた 値 で 割 った 商 を出力する <eos>
54
src = if A [ B ] == C . WHITE :
trg = A の B 番 目 が C の WHITE と 等 しい とき 、
rst = A の B 番 目 が C の WHITE と 等 しい とき 、 <eos>
55
src = A . size = B
trg = B を A の size にする
rst = B を A の size にする <eos>
56
src = path [ A ] += B
trg = os . path の A 番 目 を B だけ 増加 させる
rst = os . path の A 番 目 を B だけ 増加 させる <eos>
57
src = A , B , C , D = readline ( ) . strip ( ) . split ( )
trg = readline () の 両 端 から 空白 改行 を取り 除 いた 文字列を 空白 で 分割 した 字句 列 を 展開 し 、 それぞれ A 、 B 、 C 、 D とする
rst = readline () の 両 端 から 空白 改行 を取り 除 いた 文字列を 空白 で 分割 した 字句 列 を 展開 し 、 それぞれ A 、 B 、 C 、 D とする <eos>
58
src = A [ B [ 1 ] ] += 1
trg = A の B の 1 番 目 番 目 を 1 だけ 増加 させる
rst = A の B の 1 番 目 番 目 を 1 だけ 増加 させる <eos>
59
src = A = B = Counter ( )
trg = [MASK] の 辞書 カウンタ を B とする を A とする
rst = [MASK] の 辞書 カウンタ を B とする <eos>
60
src = print ( A , B - 1925 , C , D )
trg = A 、 B から 19 25 を 引 いた 値 、 C 、 D を出力する
rst = A 、 B から 19 25 を 引 いた 値 、 C 、 D を出力する <eos>
61
src = A |= 2
trg = A を 2 と の 論理 和 にする
rst = A を 2 と の 論理 和 にする <eos>
62
src = sys . setrecursionlimit ( 4000 )
trg = sys . setrecursionlimit ( 400 0 )
rst = sys . setrecursionlimit ( 400 0 ) <eos>
63
src = A , B = equal_range ( C , D )
trg = equal _ range ( C , D ) を 展開 し 、 それぞれ A 、 B とする
rst = solve _ int ( C , D ) を 展開 し 、 それぞれ A 、 B とする <eos>
64
src = if A [ 0 ] % A [ 1 ] == 0 :
trg = A の 0 番 目 を A の 1 番 目 で 割 った 余 り が 0 と 等 しい とき 、
rst = A の 0 番 目 を A の 1 番 目 で 割 った 余 り が 0 と 等 しい とき 、 <eos>
65
src = A = [ d[i] ( A [ B ] , C ) for B in range ( 2 ) ]
trg = 0 から 2 未 満 までの 数 列 の 各要素 を B とし 、 d [ i ] ( A [ B ] , C ) の 列 を A とする
rst = 0 から 2 未 満 までの 数 列 の 各要素 を B とし 、 <unk> ( A [ B ] , C ) の 列 を A とする <eos>
66
src = import statistics
trg = statistics モジュール を用いる
rst = <unk> モジュール を用いる <eos>
67
src = A [ 2 * B + 1 ] += C
trg = A の 2 に B を 掛 け た 値に 1 を加えた 値 番 目 を C だけ 増加 させる
rst = A の 2 に B を 掛 け た 値に 1 を加えた 値 番 目 を C だけ 増加 させる <eos>
68
src = A , B = C [ D - 1 ] [ - 1 ]
trg = C の D から 1 を 引 いた 値 番目の 末 尾 を 展開 し 、 それぞれ A 、 B とする
rst = C の D から 1 を 引 いた 値 番目の 末 尾 を 展開 し 、 それぞれ A 、 B とする <eos>
69
src = A = B * ( 12 - len ( A ) ) + A
trg = B に 12 から A の長さ を 引 いた 値に A を加えた 値を 掛 け た 値を A とする
rst = B に 12 から A の長さ を 引 いた 値を 掛 け た 値に A を加えた 値を A とする <eos>
70
src = A = [ sum ( B [ C ] ) for C in range ( D ) ]
trg = 0 から D 未 満 までの 数 列 の 各要素 を C とし 、 B の C 番目の 総 和 の 列 を A とする
rst = 0 から D 未 満 までの 数 列 の 各要素 を C とし 、 B の C 番目の 総 和 の 列 を A とする <eos>
71
src = if not check ( A , B ) :
trg = check ( A , B ) でない とき 、
rst = check ( A , B ) でない とき 、 <eos>
72
src = if len ( [ A for A in B if A >= C ] ) >= C :
trg = B の 各要素 を A とし 、 A が C 以上の とき の A の 列 の長さ が C 以上の とき 、
rst = B の 各要素 を A とし 、 A が C 以上の とき の A の 列 の長さ が C 以上の とき 、 <eos>
73
src = A = B [ ( C + 1 ) % D ] - E
trg = B の C に 1 を加えた 値を D で 割 った 余 り 番 目 から E を 引 いた 値を A とする
rst = B の C に 1 を加えた 値を D で 割 った 余 り 番 目 から E を 引 いた 値を A とする <eos>
74
src = A = len ( B ) + 1
trg = B の長さ に 1 を加えた 値を A とする
rst = B の長さ に 1 を加えた 値を A とする <eos>
75
src = if A == 0 and B [ C ] == False :
trg = A が 0 と 等 しく かつ B の C 番 目 が 、 つまり 偽 と 等 しい とき 、
rst = A が 0 と 等 しく かつ B の C 番 目 が 、 つまり 偽 と 等 しい とき 、 <eos>
76
src = A [ tuple ( B ) ] += 1
trg = A の B の 組 番 目 を 1 だけ 増加 させる
rst = A の B の 組 番 目 を 1 だけ 増加 させる <eos>
77
src = A . append ( B . prev . val )
trg = A の 末 尾 に B の prev の val を追加する
rst = A の 末 尾 に B の prev の val を追加する <eos>
78
src = if A != B . tail :
trg = A が B の tail と 等 しく ない とき 、
rst = A が B の tail と 等 しく ない とき 、 <eos>
79
src = A = sum ( [ B ** 3 for B in C ] ) ** ( 1 / 3 )
trg = C の 各要素 を B とし 、 B の 3 乗 の 列 の 総 和 の 1 を 3 で 割 った 値 乗 を A とする
rst = C の 各要素 を B とし 、 B の 3 乗 の 列 の 総 和 の 1 を 3 で 割 った 値 乗 を A とする <eos>
80
src = if A [ B - 8 ] and A [ B - 6 ] and A [ B - 2 ] and A [ B ] :
trg = A の B から 8 を 引 いた 値 番 目 かつ A の B から 6 を 引 いた 値 番 目 かつ A の B から 2 を 引 いた 値 番 目 かつ A の B 番目の とき 、
rst = A の B から 8 を 引 いた 値 番 目 かつ A の B から 6 を 引 いた 値 番 目 かつ A の B から 2 を 引 いた 値 番 目 かつ A の B 番目の とき 、 <eos>
81
src = A [ B - 1 ] = A [ B - 3 ]
trg = A の B から 3 を 引 いた 値 番 目 を A の B から 1 を 引 いた 値 番 目 にする
rst = A の B から 3 を 引 いた 値 番 目 を A の B から 1 を 引 いた 値 番 目 にする <eos>
82
src = A = ( [ ' ' . join ( map ( str , B ) ) for B in A ] )
trg = A の 各要素 を B とし 、 、 つまり 空白 文字 を 間 に 入れ て B の 各要素 に 整数 を適用した 列 を 連結 した 文字列 の 列 を A とする
rst = A の 各要素 を B とし 、 、 つまり 空白 文字 を 間 に 入れ て B の 各要素 に 整数 を適用した 列 を 連結 した 文字列 の 列 を A とする <eos>
83
src = A . D [ B ] = A . D [ C ] + 1
trg = A の D の C 番 目 に 1 を加えた 値を A の D の B 番 目 にする
rst = A の D の C 番 目 に 1 を加えた 値を A の D の B 番 目 にする <eos>
84
src = A . ms [ B ] = 0
trg = 0 を A の ms の B 番 目 にする
rst = 0 を A の ms の B 番 目 にする <eos>
85
src = print ( A + 1988 )
trg = A に 1988 を加えた 値 を出力する
rst = A に 1988 を加えた 値 を出力する <eos>
86
src = A . board = _solve ( A . board , 0 , 0 )
trg = _ solve ( A . board , 0 , 0 ) を A の board にする
rst = _ solve ( A . board , 0 , 0 ) を A の board にする <eos>
87
src = A [ B [ 0 ] ] = [ B [ 2 : ] , None , None ]
trg = ( B の 2 番 目 から 、 つまり 末 尾 までの 部分 列 、 未 定 値 、 未 定 値 ) からなる 列 を A の B の先頭 番 目 にする
rst = ( B の 2 番 目 から 、 つまり 未 定 値 、 未 定 値 、 未 定 値 ) からなる 列 を A の B の先頭 番 目 にする <eos>
88
src = for A in range ( len ( B . graph ) ) :
trg = 0 から B の graph の長さ 未 満 までの 数 列 を 順に A として 、 繰り返す
rst = 0 から B の graph の長さ 未 満 までの 数 列 を 順に A として 、 繰り返す <eos>
89
src = for A , e in zip ( B , C [ D ] ) :
trg = B 、 C の D 番目の 要素を それぞれ 組 にした 列 を 順に A 、 ネ イ ピ ア 数 として 、 繰り返す
rst = B 、 C の D 番目の 要素を それぞれ 組 にした 列 を 順に A 、 ネ イ ピ ア 数 として 、 繰り返す <eos>
90
src = e = input ( )
trg = 入力された 文字列を ネ イ ピ ア 数 とする
rst = 入力された 文字列を ネ イ ピ ア 数 とする <eos>
91
src = print ( cs ( A , 0 , B ) )
trg = cs ( A , 0 , B ) を出力する
rst = cs ( A , 0 , B ) を出力する <eos>
92
src = if A < 8 :
trg = A が 8 より 小さい とき 、
rst = A が 8 より 小さい とき 、 <eos>
93
src = A += 90 * 2 ** ( B - 1 )
trg = A を 90 に 2 の B から 1 を 引 いた 値 乗 を 掛 け た 値 だけ 増加 させる
rst = A を 90 に 2 の B から 1 を 引 いた 値 乗 を 掛 け た 値 だけ 増加 させる <eos>
94
src = A = [ int ( B ) for B in list ( str ) ]
trg = 整数 のリスト の 各要素 を B とし 、 B の 整数値 の 列 を A とする
rst = 整数 のリスト の 各要素 を B とし 、 B の 整数値 の 列 を A とする <eos>
95
src = query_add ( A , B )
trg = query _ add ( A , B )
rst = <unk> ( A , B ) <eos>
96
src = if not A . readline ( ) :
trg = A から 読み 込 んだ 一行 でない とき 、
rst = A から 読み 込 んだ 一行 でない とき 、 <eos>
97
src = A [ B ] = A [ B ] [ 1 : ]
trg = A の B 番目の 先頭 を 除 いた 部分 列 を A の B 番 目 にする
rst = A の B 番目の 先頭 を 除 いた 部分 列 を A の B 番 目 にする <eos>
98
src = if A > B or A <= 0 :
trg = A が B より 大きく または A が 0 以下の とき 、
rst = A が B より 大きく または A が 0 以下の とき 、 <eos>
99
src = A = [ 0 ] * ( B ^ 1 ) + [ C ] + [ 0 ] + [ 1 ] * D
trg = ( 0 ) からなる 列 の B と 1 の 排 他 論理 和 に ( C ) からなる 列 を加えた 値に ( 0 ) からなる 列 を加えた 値に (1) からなる 列 の D 回 分 の 列 を加えた 値 回 分 の 列 を A とする
rst = ( 0 ) からなる 列 の B と 1 の 排 他 論理 和 に ( C ) からなる 列 を加えた 値に ( 0 ) からなる 列 の D 回 分 の 列 を加えた 値 回 分 の 列 を加えた 値 回 分 の 列 を A とする <eos>
100
src = A = [ - 1 ] * ( B + C + 2 )
trg = ( -1 ) からなる 列 の B に C を加えた 値に 2 を加えた 値 回 分 の 列 を A とする
rst = ( -1 ) からなる 列 の B に C を加えた 値に 2 を加えた 値 回 分 の 列 を A とする <eos>
101
src = print ( A . format ( bit ( B ) , ' ' . join ( [ str ( C ) for C in B ] ) ) )
trg = A を 書式 として bit ( B ) 、 空白 文字 を 間 に 入れ て B の 各要素 を C とし 、 C の 文字列 の 列 を 連結 した 文字列 で 整 形 した 文字列 を出力する
rst = A を 書式 として B で 整 形 した 文字列 、 空白 文字 を 間 に 入れ て B の 各要素 を C とし 、 C の 文字列 の 列 を 連結 した 文字列 を出力する <eos>
102
src = while A - 1 :
trg = A から 1 を 引 いた 値の 間 、 次 を 繰り返す
rst = A から 1 を 引 いた 値の 間 、 次 を 繰り返す <eos>
103
src = print ( C if sugoroku ( A , B ) else D )
trg = sugoroku ( A , B ) の とき C 、 そうでなければ D を出力する
rst = diff _ check _ all ( A , B ) の とき C 、 そうでなければ D を出力する <eos>
104
src = A = B = C = D
trg = D を C を B とする とする を A とする
rst = D を C を B とする とする を A とする <eos>
105
src = if le ( A , B ) and le ( C , B ) :
trg = le ( A , B ) かつ le ( C , B ) の とき 、
rst = <unk> ( A , B ) かつ is _ to _ load ( C , B ) の とき 、 <eos>
106
src = return ( calc ( A , B , C ) , D )
trg = ( calc ( A , B , C ) 、 D ) の 組 を返す
rst = ( calc ( A , B , C ) 、 D ) の 組 を返す <eos>
107
src = return '\n' . join ( [ A . format ( B , C . members ( B ) ) for B in C . roots ( ) ] )
trg = 改行 文字 を 間 に 入れ て C . roots () の 各要素 を B とし 、 A を 書式 として B 、 C . members ( B ) で 整 形 した 文字列 の 列 を 連結 した 文字列 を返す
rst = 改行 文字 を 間 に 入れ て C の 各要素 を B とし 、 A を 書式 として B 、 C . <unk> _ cost ( B ) の 列 を 連結 した 文字列 の 列 を 連結 した 文字列 を返す <eos>
108
src = A = ( B - C ) // 2 + 1
trg = B から C を 引 いた 値を 2 で 割 った 商 に 1 を加えた 値を A とする
rst = B から C を 引 いた 値を 2 で 割 った 商 に 1 を加えた 値を A とする <eos>
109
src = assert A [ B ] [ C ] != - 1 and A [ D ] [ E ] != - 1
trg = A の B 番目の C 番 目 が -1 と 等 しく なく かつ A の D 番目の E 番 目 が -1 と 等 しく なく なければならない
rst = A の B 番目の C 番 目 が -1 と 等 しく なく かつ A の D 番目の E 番 目 が -1 と 等 しく ない かどうか <eos>
110
src = A = A [ 3 : ] + A [ 0 : 3 ]
trg = A の 3 番 目 から 、 つまり 末 尾 までの 部分 列 に A の 、 つまり 先頭 から 3 番 目 までの 部分 列 を加えた 値を A とする
rst = A の 3 番 目 から 、 つまり 末 尾 までの 部分 列 に A の 、 つまり 先頭 から 3 番 目 までの 部分 列 を加えた 値を A とする <eos>
111
src = sys . setrecursionlimit ( 2 * 10 ** 5 )
trg = sys . setrecursionlimit ( 2 * 10 * * 5 )
rst = sys . setrecursionlimit ( 2 * * 5 ) <eos>
112
src = if 0 <= A <= 7 and 0 <= B <= 7 and C [ B ] [ A ] == D :
trg = 0 が A 以下 かどうか が 7 以下 かつ 0 が B 以下 かどうか が 7 以下 かつ C の B 番目の A 番 目 が D と 等 しい とき 、
rst = 0 が A 以下 かどうか が 7 以下 かつ 0 が B 以下 かどうか が 7 以下 かつ C の B 番目の A 番 目 が D と 等 しい とき 、 <eos>
113
src = A += 90
trg = A を 90 だけ 増加 させる
rst = A を 90 だけ 増加 させる <eos>
114
src = if not A <= B :
trg = A が B 以下 でない とき 、
rst = A が B 以下 でない とき 、 <eos>
115
src = if A . x == 0 :
trg = A の x 座標 が 0 と 等 しい とき 、
rst = A の x 座標 が 0 と 等 しい とき 、 <eos>
116
src = for A in range ( max ( B , 0 ) , min ( C , D ) + 1 ) :
trg = B 、 0 の 最大 値 から C 、 D の 最小 値に 1 を加えた 値 未 満 までの 数 列 を 順に A として 、 繰り返す
rst = B 、 0 の 最大 値 から C 、 D の 最小 値に 1 を加えた 値 未 満 までの 数 列 を 順に A として 、 繰り返す <eos>
117
src = print ( A + B + str ( C . count ( A ) ) )
trg = A に B を加えた 値に C 内の A の 出現 回数 の 文字列 を加えた 値 を出力する
rst = A に B を加えた 値に C 内の A の 出現 回数 の 文字列 を加えた 値 を出力する <eos>
118
src = A . append ( get_distance_sp ( B , C , D ) )
trg = A の 末 尾 に get _ distance _ sp ( B , C , D ) を追加する
rst = A の 末 尾 に <unk> ( B , C , D ) を追加する <eos>
119
src = A = B . get_lf ( C )
trg = B . get _ lf ( C ) を A とする
rst = B . <unk> _ from ( C ) を A とする <eos>
120
src = A [ B - 1 : C - 2 ] = D [ B + 1 : C ]
trg = D の B に 1 を加えた 値 から C 番 目 までの 部分 列 を A の B から 1 を 引 いた 値 から C から 2 を 引 いた 値 までの 部分 列 にする
rst = D の B に 1 を加えた 値 から C 番 目 までの 部分 列 を A の B から 1 を 引 いた 値 から C から 2 を 引 いた 値 までの 部分 列 にする <eos>
121
src = for A , B , C in zip ( range ( 2 , D + 1 ) , E , F ) :
trg = 2 から D に 1 を加えた 値 未 満 までの 数 列 、 E 、 F の 要素を それぞれ 組 にした 列 を 順に A 、 B 、 C として 、 繰り返す
rst = 2 から D に 1 を加えた 値 未 満 までの 数 列 、 E 、 F の 要素を それぞれ 組 にした 列 を 順に A 、 B 、 C として 、 繰り返す <eos>
122
src = A . prev , A . next = B . prev , B
trg = B の prev 、 B を A の prev 、 A の next とする
rst = B の prev 、 B を A の prev 、 A の next とする <eos>
123
src = A = B . _nodes [ C ] . index ( 1 , A + 1 )
trg = B の _ nodes の C 番目の A に 1 を加えた 値 から の範囲 内で の 1 と 等 しい 要素 の最初の 位置 を A とする
rst = B の _ nodes の C 番目の 1 と 等 しい 要素 の最初の 位置 を A とする <eos>
124
src = E = F [ D + 1 ]
trg = F の D に 1 を加えた 値 番 目 を E とする
rst = F の D に 1 を加えた 値 番 目 を E とする <eos>
125
src = while ( A + 1 ) ** 3 <= B :
trg = A に 1 を加えた 値の 3 乗 が B 以下の 間 、 次 を 繰り返す
rst = A に 1 を加えた 値の 3 乗 が B 以下の 間 、 次 を 繰り返す <eos>
126
src = A , B , C , D , E = F . heappop ( G )
trg = F . heappop ( G ) を 展開 し 、 それぞれ A 、 B 、 C 、 D 、 E とする
rst = F . heappop ( G ) を 展開 し 、 それぞれ A 、 B 、 C 、 D 、 E とする <eos>
127
src = A [ 3 ] and prop ( A )
trg = A の 3 番 目 かつ prop ( A )
rst = A の 3 番 目 かつ prop ( A ) <eos>
128
src = if A [ 0 ] != 1 :
trg = A の 0 番 目 が 1 と 等 しく ない とき 、
rst = A の 0 番 目 が 1 と 等 しく ない とき 、 <eos>
129
src = A = dot ( B [ 1 ] - B [ 0 ] , C [ 1 ] - C [ 0 ] )
trg = dot ( B [ 1 ]- B [ 0 ] , C [ 1 ]- C [ 0 ] ) を A とする
rst = dot ( B [ 1 ]- B [ 0 ] , C [ 1 ]- C [ 0 ] ) を A とする <eos>
130
src = A = A [ : - 1 ]
trg = A の 末 尾 を 除 いた 部分 列 を A とする
rst = A の 末 尾 を 除 いた 部分 列 を A とする <eos>
131
src = A [ B - 1 ] [ C [ D + 2 ] - 1 ] = 1
trg = 1 を A の B から 1 を 引 いた 値 番目の C の D に 2 を加えた 値 番 目 から 1 を 引 いた 値 番 目 にする
rst = 1 を A の B から 1 を 引 いた 値 番目の C の D に 2 を加えた 値 番 目 から 1 を 引 いた 値 番 目 にする <eos>
132
src = A . append ( ' ' . join ( str ( B ) if B < C else [ D for B in E [ F ] ] ) )
trg = A の 末 尾 に 空白 文字 を 間 に 入れ て B が C より 小さい とき B の 文字列 、 そうでなければ E の F 番目の 各要素 を B とし 、 D の 列 を 連結 した 文字列 を追加する
rst = A の 末 尾 に 空白 文字 を 間 に 入れ て E の F 番目の 各要素 を B とし 、 B が C より 小さい とき D の 文字列 、 そうでなければ E の 列 を 連結 した 文字列 を追加する <eos>
133
src = for A in range ( min ( 5 , B + 1 ) ) :
trg = 0 から 5 、 B に 1 を加えた 値の 最小 値 未 満 までの 数 列 を 順に A として 、 繰り返す
rst = 0 から 5 、 B に 1 を加えた 値の 最小 値 未 満 までの 数 列 を 順に A として 、 繰り返す <eos>
134
src = A += B . get_weight ( C )
trg = A を B . get _ weight ( C ) だけ 増加 させる
rst = A を B . get _ weight ( C ) だけ 増加 させる <eos>
135
src = A , B , C , D = map ( int , readline ( ) . split ( ) )
trg = readline () を 空白 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 を 展開 し 、 それぞれ A 、 B 、 C 、 D とする
rst = readline () を 空白 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 を 展開 し 、 それぞれ A 、 B 、 C 、 D とする <eos>
136
src = A = min ( A , minimum_cost ( B + 1 , C , D , E - 1 , F , G , H , I ) )
trg = A 、 minimum _ cost ( B + 1, C , D , E - 1, F , G , H , I ) の 最小 値を A とする
rst = A 、 minimum _ cost ( B + 1, C , D , E - 1, F , G , H , I ) の 最小 値を A とする <eos>
137
src = A += B [ 1 ]
trg = A を B の 1 番 目 だけ 増加 させる
rst = A を B の 1 番 目 だけ 増加 させる <eos>
138
src = return A * B [ C ] - D * ( B [ C ] + E )
trg = A に B の C 番 目 を 掛 け た 値 から D に B の C 番 目 に E を加えた 値を 掛 け た 値を 引 いた 値を返す
rst = A に B の C 番 目 を 掛 け た 値 から D に B の C 番 目 に E を加えた 値を 掛 け た 値を 引 いた 値を返す <eos>
139
src = insert ( A [ 1 ] , A [ 2 ] )
trg = insert ( A [ 1 ] , A [ 2 ] )
rst = insert ( A [ 1 ] , A [ 2 ] ) <eos>
140
src = for A in B . split ( ' ' ) :
trg = B を 空白 文字 で 分割 した 字句 列 を 順に A として 、 繰り返す
rst = B を 空白 文字 で 分割 した 字句 列 を 順に A として 、 繰り返す <eos>
141
src = A = B . get ( C , [ ] )
trg = B に対応する 値 、 も し 存在 し なければ C 、 空 列 を A とする
rst = B に対応する 値 、 も し 存在 し なければ C 、 空 列 を A とする <eos>
142
src = A [ B ] [ int ( C ) - 1 ] = 1
trg = 1 を A の B 番目の C の 整数値 から 1 を 引 いた 値 番 目 にする
rst = 1 を A の B 番目の C の 整数値 から 1 を 引 いた 値 番 目 にする <eos>
143
src = update ( A , B [ C ] [ D ] , D , C )
trg = update ( A , B [ C ] [ D ] , D , C )
rst = update ( A , B [ C ] [ D ] , D , C ) <eos>
144
src = print ( A . format ( B / C + D , E / C + D ) )
trg = A を 書式 として B を C で 割 った 値に D を加えた 値 、 E を C で 割 った 値に D を加えた 値 で 整 形 した 文字列 を出力する
rst = A を 書式 として B を C で 割 った 値に D を加えた 値 、 E を C で 割 った 値に D を加えた 値 で 整 形 した 文字列 を出力する <eos>
145
src = A [ B - 1 ] -= 1
trg = A の B から 1 を 引 いた 値 番 目 を 1 だけ 減少 させる
rst = A の B から 1 を 引 いた 値 番 目 を 1 だけ 減少 させる <eos>
146
src = A = B * C + D
trg = B に C を 掛 け た 値に D を加えた 値を A とする
rst = B に C を 掛 け た 値に D を加えた 値を A とする <eos>
147
src = return divide ( [ A , B ] + C + [ D ] )
trg = divide ( [ A , B ] + C + [ D ] ) を返す
rst = divide ( [ A , B ] + C + [ D ] ) を返す <eos>
148
src = A [ - 4 ] = len ( B )
trg = B の長さ を A の - 4 番 目 にする
rst = B の長さ を A の - 4 番 目 にする <eos>
149
src = for A in range ( 17 ) :
trg = 0 から 17 未 満 までの 数 列 を 順に A として 、 繰り返す
rst = 0 から 17 未 満 までの 数 列 を 順に A として 、 繰り返す <eos>
150
src = print ( A . count ( B - 3 ) )
trg = A 内の B から 3 を 引 いた 値の 出現 回数 を出力する
rst = A 内の B から 3 を 引 いた 値の 出現 回数 を出力する <eos>
151
src = A , B = C [ 0 ] - D [ 0 ] , C [ 1 ] - D [ 1 ]
trg = C の先頭 から D の先頭 を 引 いた 値 、 C の 1 番 目 から D の 1 番 目 を 引 いた 値を A 、 B とする
rst = C の 0 番 目 から D の先頭 を 引 いた 値 、 C の 1 番 目 から D の 1 番 目 を 引 いた 値を A 、 B とする <eos>
152
src = A = [ [ None ] * [ ( B + 2 ) for C in range ( D + 2 ) ] ]
trg = ( ( 、 つまり 未 定 値 ) からなる 列 の 0 から D に 2 を加えた 値 未 満 までの 数 列 の 各要素 を C とし 、 B に 2 を加えた 値の 列 回 分 の 列 ) からなる 列 を A とする
rst = ( ( 、 つまり 未 定 値 ) からなる 列 の 0 から D に 2 を加えた 値 未 満 までの 数 列 の 各要素 を C とし 、 B に 2 を加えた 値の 列 回 分 の 列 ) からなる 列 を A とする <eos>
153
src = print ( pow ( A , B , 1_000_000_007 ) )
trg = A の B 乗 に対する 1 _ 00 0 _ 00 0 _ 00 7 の 剰 余 を出力する
rst = A の B 乗 に対する 1 の 剰 余 を出力する <eos>
154
src = A , B = _cost ( 0 , 0 , 0 )
trg = _ cost ( 0 , 0 , 0 ) を 展開 し 、 それぞれ A 、 B とする
rst = circle _ tangent _ points ( 0 , 0 ) を 展開 し 、 それぞれ A 、 B とする <eos>
155
src = if sum ( time [ A : B ] ) == 0 :
trg = time の A 番 目 から B 番 目 までの 部分 列 の 総 和 が 0 と 等 しい とき 、
rst = time の A 番 目 から B 番 目 までの 部分 列 の 総 和 が 0 と 等 しい とき 、 <eos>
156
src = if A & B [ C ] == A :
trg = A と B の C 番目の 論理 積 が A と 等 しい とき 、
rst = A と B の C 番目の 論理 積 が A と 等 しい とき 、 <eos>
157
src = append ( A [ - 1 ] + int ( input ( ) ) )
trg = append ( A [ -1 ] + int ( input () ) )
rst = append ( A [ -1 ] + int ( input () ) ) <eos>
158
src = if abs ( A - B ) > C :
trg = A から B を 引 いた 値の 絶対 値が C より 大きい とき 、
rst = A から B を 引 いた 値の 絶対 値が C より 大きい とき 、 <eos>
159
src = A [ B ] [ C ] = [ D for D in range ( B ) if ( C & ( 1 << D ) ) == 0 ]
trg = 0 から B 未 満 までの 数 列 の 各要素 を D とし 、 C と 1 を D だけ 左 シフト した 値の 論理 積 が 0 と 等 しい とき の D の 列 を A の B 番目の C 番 目 にする
rst = 0 から B 未 満 までの 数 列 の 各要素 を D とし 、 C と 1 を D だけ 左 シフト した 値の 論理 積 が 0 と 等 しい とき の D の 列 を A の B 番目の C 番 目 にする <eos>
160
src = A = int ( '' . join ( sorted ( B ) [ : : - 1 ] ) )
trg = 空文字列 を 間 に 入れ て B を ソート した 列 の 逆 順 を 連結 した 文字列 の 整数値 を A とする
rst = 空文字列 を 間 に 入れ て B を ソート した 列 の 逆 順 を 連結 した 文字列 の 整数値 を A とする <eos>
161
src = count += int ( A / 10 )
trg = 無限 の 整数 列 を A を 10 で 割 った 値の 整数値 だけ 増加 させる
rst = 無限 の 整数 列 を A を 10 で 割 った 値の 整数値 だけ 増加 させる <eos>
162
src = if A [ B ] - 2 == A [ B + 1 ] :
trg = A の B 番 目 から 2 を 引 いた 値が A の B に 1 を加えた 値 番 目 と 等 しい とき 、
rst = A の B 番 目 から 2 を 引 いた 値が A の B に 1 を加えた 値 番 目 と 等 しい とき 、 <eos>
163
src = search ( A , B , C - 1 , D )
trg = B 、 C から 1 を 引 いた 値 、 D において 正規表現 A が 最初 にマッチする 位置
rst = B 、 C から 1 を 引 いた 値 、 D において 正規表現 A が 最初 にマッチする 位置 <eos>
164
src = A = conv_avacus ( B )
trg = conv _ avacus ( B ) を A とする
rst = <unk> ( B ) を A とする <eos>
165
src = A [ B [ C ] [ D ] ] [ D ] = E [ C ] [ D ]
trg = E の C 番目の D 番 目 を A の B の C 番目の D 番 目 番目の D 番 目 にする
rst = E の C 番目の D 番 目 を A の B の C 番目の D 番 目 番目の D 番 目 にする <eos>
166
src = print ( under ( A , B ) , over ( A , B ) )
trg = under ( A , B ) 、 over ( A , B ) を出力する
rst = under ( A , B ) 、 <unk> ( A , B ) を出力する <eos>
167
src = A = B [ C ] * 2 - 10 + D
trg = B の C 番 目 に 2 を 掛 け た 値 から 10 を 引 いた 値に D を加えた 値を A とする
rst = B の C 番 目 に 2 を 掛 け た 値 から 10 を 引 いた 値に D を加えた 値を A とする <eos>
168
src = A = B . sum ( C - 1 )
trg = B 、 C から 1 を 引 いた 値の 総 和 を A とする
rst = B 、 C から 1 を 引 いた 値の 総 和 を A とする <eos>
169
src = A = dfs0 ( B , C , D )
trg = dfs 0 ( B , C , D ) を A とする
rst = dfs 0 ( B , C , D ) を A とする <eos>
170
src = A = [ int ( B ) - 1 for B in list ( C ) ]
trg = C のリスト の 各要素 を B とし 、 B の 整数値 から 1 を 引 いた 値の 列 を A とする
rst = C のリスト の 各要素 を B とし 、 B の 整数値 から 1 を 引 いた 値の 列 を A とする <eos>
171
src = if A [ B + 1 ] - A [ B ] > C :
trg = A の B に 1 を加えた 値 番 目 から A の B 番 目 を 引 いた 値が C より 大きい とき 、
rst = A の B に 1 を加えた 値 番 目 から A の B 番 目 を 引 いた 値が C より 大きい とき 、 <eos>
172
src = print ( A [ - 2 ] )
trg = A の -2 番 目 を出力する
rst = A の -2 番 目 を出力する <eos>
173
src = A = solve1 ( B , C . primes )
trg = solve 1 ( B , C . primes ) を A とする
rst = solve 1 ( B , C . primes ) を A とする <eos>
174
src = solve ( A , B , C + 1 , D )
trg = solve ( A , B , C + 1, D )
rst = solve ( A , B , C + 1, D ) <eos>
175
src = while now != A :
trg = 現在の 日 時 が A と 等 しく ない 間 、 次 を 繰り返す
rst = 現在の 日 時 が A と 等 しく ない 間 、 次 を 繰り返す <eos>
176
src = if A [ B ] [ C ] < 0 :
trg = A の B 番目の C 番 目 が 0 より 小さい とき 、
rst = A の B 番目の C 番 目 が 0 より 小さい とき 、 <eos>
177
src = return A [ ( B + 1 ) % len ( A ) ] - A [ B ]
trg = A の B に 1 を加えた 値を A の長さ で 割 った 余 り 番 目 から A の B 番 目 を 引 いた 値を返す
rst = A の B に 1 を加えた 値を A の長さ で 割 った 余 り 番 目 から A の B 番 目 を 引 いた 値を返す <eos>
178
src = A = { [ B ** 2 % C for B in range ( 1 , C ) ] }
trg = ( < __ main __ . Cammaobjectat 0 x 10 9 e 5 fc 70 > ) の集合 を A とする
rst = ( < __ main __ . Cammaobjectat 0 x 10 a 1 b 7 a 30 > ) の集合 を A とする <eos>
179
src = for A in range ( B . N , 1 << ( B . N - 1 ) . bit_length ( ) ) :
trg = B の N から 1 を B の N から 1 を 引 いた 値の ビット 長 だけ 左 シフト した 値 未 満 までの 数 列 を 順に A として 、 繰り返す
rst = B の N から 1 を ( B . N から 1 を 引 いた 値 ) の 組 の ビット 長 を 順に A として 、 繰り返す <eos>
180
src = A = B // _pow ( 10 , 28 )
trg = B を _ pow ( 10 , 28 ) で 割 った 商 を A とする
rst = B を _ pow ( 10 , 28 ) で 割 った 商 を A とする <eos>
181
src = B = C - D - E + 1
trg = C から D を 引 いた 値 から E を 引 いた 値に 1 を加えた 値を B とする
rst = C から D を 引 いた 値 から E を 引 いた 値に 1 を加えた 値を B とする <eos>
182
src = ( 0 , 0 )
trg = ( 0 、 0 ) の 組
rst = ( 0 、 0 ) の 組 <eos>
183
src = A = ( 1 , 5 , 3 , 6 , 2 , 4 )
trg = ( 1 、 5 、 3 、 6 、 2 、 4 ) の 組 を A とする
rst = ( 1 、 5 、 3 、 6 、 2 、 4 ) の 組 を A とする <eos>
184
src = A [ min ( B - 1 , C - B ) ] [ D - 1 ] ^= 1
trg = A の B から 1 を 引 いた 値 、 C から B を 引 いた 値の 最小 値 番目の D から 1 を 引 いた 値 番 目 を 1 と の 排 他 的 論理 和 にする
rst = A の B から 1 を 引 いた 値 、 C から B を 引 いた 値の 最小 値 番目の D から 1 を 引 いた 値 番 目 を 1 と の 排 他 的 論理 和 にする <eos>
185
src = A . death_list . append ( ( B , C , D ) )
trg = A の death _ list の 末 尾 に ( B 、 C 、 D ) の 組 を追加する
rst = A の list の 末 尾 に ( B 、 C 、 D ) の 組 を追加する <eos>
186
src = if set ( [ A [ sum ( [ ( not e & B ) << C for C , e in D ] ) ] for B in E ] ) == F :
trg = E の 各要素 を B とし 、 A の [ ( note & B ) < < CforC , einD ] の 総 和 番目の 列 の集合 が F と 等 しい とき 、
rst = E の 各要素 を B とし 、 A の D の 各要素 を C 、 ネ イ ピ ア 数 とし 、 つまり ネ イ ピ ア 数 と B の 論理 積 を C だけ 左 シフト した 値の 列 の 総 和 の 列 の集合 と 等 しい
187
src = A . dice_w ( )
trg = A . dice _ w ()
rst = A . <unk> () <eos>
188
src = if is_parallel ( A , B ) :
trg = is _ parallel ( A , B ) の とき 、
rst = is _ parallel ( A , B ) の とき 、 <eos>
189
src = A [ B [ 0 ] [ 0 ] ] = C = 1
trg = 1 を C とする を A の B の先頭 の先頭 番 目 にする
rst = 1 を C とする を A の B の先頭 番目の 0 番 目 にする <eos>
190
src = if A == 2 * B :
trg = A が 2 に B を 掛 け た 値 と 等 しい とき 、
rst = A が 2 に B を 掛 け た 値 と 等 しい とき 、 <eos>
191
src = print ( str ( A [ - 1 * B ] ) + ' ' , end = '' )
trg = 改行 せずに A の -1 に B を 掛 け た 値 番目の 文字列 に 空白 文字 を加えた 値 を出力する
rst = 改行 せずに A の -1 に B を 掛 け た 値の 文字列 に 空白 文字 を加えた 値 を出力する <eos>
192
src = A = [ ( - 2 , 1 ) , ( - 1 , 1 ) , ( - 1 , 2 ) , ( 0 , 1 ) , ( 0 , 2 ) , ( 0 , 3 ) , ( 1 , 1 ) , ( 1 , 2 ) , ( 2 , 1 ) ]
trg = ( ( -2 、 1 ) の 組 、 ( -1 、 1 ) の 組 、 ( -1 、 2 ) の 組 、 ( 0 、 1 ) の 組 、 ( 0 、 2 ) の 組 、 ( 0 、 3 ) の 組 、 ( 1 、 1 ) の 組 、 ( 1 、 2 ) の 組 、 ( 2 、 1 ) の 組 ) からなる 列 を A とする
rst = ( ( -2 、 1 ) の 組 、 ( -1 、 1 ) の 組 、 ( -1 、 2 ) の 組 、 ( 0 、 1 ) の 組 、 ( 0 、 2 ) の 組 、 ( 1 、 1 ) の 組 、 (
193
src = return 360 - A
trg = 3 60 から A を 引 いた 値を返す
rst = 3 60 から A を 引 いた 値を返す <eos>
194
src = A . data [ 0 ] = A . INITIAL_VALUE
trg = A の INITIAL _ VALUE を A の data の 0 番 目 にする
rst = A の INITIAL _ VALUE を A の data の 0 番 目 にする <eos>
195
src = dfs ( A )
trg = dfs ( A )
rst = dfs ( A ) <eos>
196
src = A = B - C [ : : - 1 ] . index ( D ) - 1
trg = B から C の 逆 順 の D と 等 しい 要素 の最初の 位置 を 引 いた 値 から 1 を 引 いた 値を A とする
rst = B から C の 、 つまり 先頭 から 、 つまり 末 尾 までの -1 間隔 による 部分 列 の D と 等 しい 要素 の最初の 位置 を 引 いた 値 から 1 を 引 いた 値を A とする <eos>
197
src = if not 0 <= A < B or not 0 <= C < D or E [ A ] [ C ] != - F :
trg = 0 が A 以下 かどうか が B より 小さく なく または 0 が C 以下 かどうか が D より 小さく なく または E の A 番目の C 番 目 が - F と 等 しく ない とき 、
rst = 0 が A 以下 かどうか が B より 小さく なく または 0 が C 以下 かどうか が D より 小さく なく または E の A 番目の C 番 目 が -1 と 等 しく ない とき 、 <eos>
198
src = A = min ( A + B , C + B )
trg = A に B を加えた 値 、 C に B を加えた 値の 最小 値を A とする
rst = A に B を加えた 値 、 C に B を加えた 値の 最小 値を A とする <eos>
199
src = if A . day == 13 and A . weekday ( ) == 4 :
trg = A の day が 13 と 等 しく かつ A の 週 が 4 と 等 しい とき 、
rst = A の year が 13 と 等 しく かつ A の 週 が 4 と 等 しい とき 、 <eos>
200
src = A . dp . append ( [ int ( ( B == 0 ) ) for B in C ] )
trg = A の dp の 末 尾 に C の 各要素 を B とし 、 B が 0 と 等 しい かどうか の 整数値 の 列 を追加する
rst = A の dp の 末 尾 に C の 各要素 を B とし 、 B が 0 と 等 しい かどうか の 整数値 の 列 を追加する <eos>
201
src = A . warshall_floyd ( B )
trg = A . warshall _ floyd ( B )
rst = A . warshall _ floyd ( B ) <eos>
202
src = for A , B , B in C [ 1 ] :
trg = C の 1 番 目 を 順に A 、 B 、 B として 、 繰り返す
rst = C の 1 番 目 を 順に A 、 B 、 B として 、 繰り返す <eos>
203
src = A . stack [ A . tail ] = B
trg = B を A の stack の A の tail 番 目 にする
rst = B を A の stack の A の tail 番 目 にする <eos>
204
src = A = [ 35.5 , 37.5 , 40 , 43 , 50 , 55 , 70 ]
trg = ( 3 5 . 5 、 3 7 . 5 、 40 、 4 3 、 50 、 5 5 、 70 ) からなる 列 を A とする
rst = ( 3 5 50 、 3 1 e 、 6 、 5 、 3 、 15 4 、 196 、 2 24 7 ) からなる 列 を A とする <eos>
205
src = if compare_cards ( A [ B ] , A [ C ] ) :
trg = compare _ cards ( A [ B ] , A [ C ] ) の とき 、
rst = <unk> ( A [ B ] , A [ C ] ) の とき 、 <eos>
206
src = A = B [ 1 : 3 ]
trg = B の 1 番 目 から 3 番 目 までの 部分 列 を A とする
rst = B の 1 番 目 から 3 番 目 までの 部分 列 を A とする <eos>
207
src = A = B = C . popleft ( )
trg = C . popleft () を B とする を A とする
rst = C . popleft () を B とする を A とする <eos>
208
src = if A - len ( B ) < C - D :
trg = A から B の長さ を 引 いた 値が C から D を 引 いた 値 より 小さい とき 、
rst = A から B の長さ を 引 いた 値が C から D を 引 いた 値 より 小さい とき 、 <eos>
209
src = A = ( B * C - D * E ) / ( B - E )
trg = B に C を 掛 け た 値 から D に E を 掛 け た 値を 引 いた 値を B から E を 引 いた 値 で 割 った 値を A とする
rst = B に C を 掛 け た 値 から D に E を 掛 け た 値を 引 いた 値を B から E を 引 いた 値 で 割 った 値を A とする <eos>
210
src = A , B , C , D , E , F = [ D ( G ) for G in input ( ) . split ( H ) ]
trg = 入力された 文字列を H で 分割 した 字句 列 の 各要素 を G とし 、 D ( G ) の 列 を 展開 し 、 それぞれ A 、 B 、 C 、 D 、 E 、 F とする
rst = 入力された 文字列を H で 分割 した 字句 列 の 各要素 を G とし 、 D の 列 を 展開 し 、 それぞれ A 、 B 、 C 、 D 、 E 、 F とする <eos>
211
src = A . remove ( min ( A ) )
trg = A 内の A の 最小 値 と 等 しい 要素を 取り除く
rst = A 内の A の 最小 値 と 等 しい 要素を 取り除く <eos>
212
src = return A in B . tree
trg = A が B の tree に含まれる かどうか を返す
rst = A が B の tree に含まれる かどうか を返す <eos>
213
src = A . q . append ( B )
trg = A の q の 末 尾 に B を追加する
rst = A の q の 末 尾 に B を追加する <eos>
214
src = if A % 2 > 0 :
trg = A を 2 で 割 った 余 り が 0 より 大きい とき 、
rst = A を 2 で 割 った 余 り が 0 より 大きい とき 、 <eos>
215
src = A = min ( A , abs ( ( B - C ) * ( D + 1 ) + ( E - F ) ) )
trg = A 、 B から C を 引 いた 値に D に 1 を加えた 値を 掛 け た 値に E から F を 引 いた 値 を加えた 値の 絶対 値の 最小 値を A とする
rst = A 、 B から C を 引 いた 値に D に 1 を加えた 値を 掛 け た 値に E から F を 引 いた 値の 絶対 値 を加えた 値の 最小 値を A とする <eos>
216
src = A . depth = A . parent . depth + 1
trg = A の parent の depth に 1 を加えた 値を A の depth にする
rst = A の parent の depth に 1 を加えた 値を A の depth にする <eos>
217
src = if A . par [ B ] < A . par [ C ] :
trg = A の par の B 番 目 が A の par の C 番 目 より 小さい とき 、
rst = A の par の B 番 目 が A の par の C 番 目 より 小さい とき 、 <eos>
218
src = A . extend ( B [ : - 1 ] )
trg = B の 末 尾 を 除 いた 部分 列 を追加し て A を拡張する
rst = B の 末 尾 を 除 いた 部分 列 を追加し て A を拡張する <eos>
219
src = A . set_root ( B )
trg = A . set _ root ( B )
rst = A . <unk> ( B ) <eos>
220
src = A = QueueNode ( B )
trg = QueueNode ( B ) を A とする
rst = <unk> ( B ) を A とする <eos>
221
src = return search ( A , B , C , D , 0 )
trg = B 、 C 、 D 、 0 において 正規表現 A が 最初 にマッチする 位置 を返す
rst = B 、 C 、 D 、 0 において 正規表現 A が 最初 にマッチする 位置 を返す <eos>
222
src = write ( '' . join ( A ) )
trg = write ( ' ' . join ( A ) )
rst = write ( ' ' . join ( A ) ) <eos>
223
src = A = sorted ( set ( list ( map ( int , input ( ) . split ( ) ) ) ) )
trg = input () を 空白 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 のリスト の集合 を ソート した 列 を A とする
rst = input () を 空白 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 のリスト の集合 を ソート した 列 を A とする <eos>
224
src = A = [ B , C , B , C , B ]
trg = ( B 、 C 、 B 、 C 、 B ) からなる 列 を A とする
rst = ( B 、 C 、 B 、 C 、 B ) からなる 列 を A とする <eos>
225
src = A [ B [ C [ D ] ] - 1 ] = C [ D ]
trg = C の D 番 目 を A の B の C の D 番 目 番 目 から 1 を 引 いた 値 番 目 にする
rst = C の D 番 目 を A の B の C の D 番 目 から 1 を 引 いた 値 番 目 から 1 を 引 いた 値 番 目 にする <eos>
226
src = for A in range ( B + 1 , B + C ) :
trg = B に 1 を加えた 値 から B に C を加えた 値 未 満 までの 数 列 を 順に A として 、 繰り返す
rst = B に 1 を加えた 値 から B に C を加えた 値 未 満 までの 数 列 を 順に A として 、 繰り返す <eos>
227
src = heappush ( A , ( B + C , D ) )
trg = heappush ( A , ( B + C , D ) )
rst = heappush ( A , ( B + C , D ) ) <eos>
228
src = A [ B ] [ C - D ] = 0
trg = 0 を A の B 番目の C から D を 引 いた 値 番 目 にする
rst = 0 を A の B 番目の C から D を 引 いた 値 番 目 にする <eos>
229
src = print ( A . format ( B + 0.0 ) )
trg = A を 書式 として B に 0.0 を加えた 値 で 整 形 した 文字列 を出力する
rst = A を 書式 として B に 0.0 を加えた 値 で 整 形 した 文字列 を出力する <eos>
230
src = A = dt ( B , C , D )
trg = dt ( B , C , D ) を A とする
rst = <unk> ( B , C , D ) を A とする <eos>
231
src = A = ( B * ( B - C ) * ( B - D ) * ( B - D ) ) ** 0.5
trg = B に B から C を 引 いた 値を 掛 け た 値に B から D を 引 いた 値を 掛 け た 値に B から D を 引 いた 値を 掛 け た 値の 0.5 乗 を A とする
rst = B に B から C を 引 いた 値を 掛 け た 値に B から D を 引 いた 値を 掛 け た 値に B から D を 引 いた 値を 掛 け た 値の 0.5 乗 を A とする <eos>
232
src = return A . weights [ B ] - A . weights [ C ]
trg = A の weights の B 番 目 から A の weights の C 番 目 を 引 いた 値を返す
rst = A の weights の B 番 目 から A の weights の C 番 目 を 引 いた 値を返す <eos>
233
src = if A & 0b0011 == 0 :
trg = A と 0 b 00 11 の 論理 積 が 0 と 等 しい とき 、
rst = A と 0 b 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 の 論理 積 が 0 と 等 しい とき 、 <eos>
234
src = for A in range ( 1 , int ( ( B + 1 ) / 2 ) + 1 ) :
trg = 1 から B に 1 を加えた 値を 2 で 割 った 値の 整数値 に 1 を加えた 値 未 満 までの 数 列 を 順に A として 、 繰り返す
rst = 1 から B に 1 を加えた 値を 2 で 割 った 値の 整数値 に 1 を加えた 値 未 満 までの 数 列 を 順に A として 、 繰り返す <eos>
235
src = print ( A . index ( B ) )
trg = A の B と 等 しい 要素 の最初の 位置 を出力する
rst = A の B と 等 しい 要素 の最初の 位置 を出力する <eos>
236
src = A [ B ] = C - D + 1
trg = C から D を 引 いた 値に 1 を加えた 値を A の B 番 目 にする
rst = C から D を 引 いた 値に 1 を加えた 値を A の B 番 目 にする <eos>
237
src = A [ B ] [ C ] = A [ B ] [ C ] + 1
trg = A の B 番目の C 番 目 に 1 を加えた 値を A の B 番目の C 番 目 にする
rst = A の B 番目の C 番 目 に 1 を加えた 値を A の B 番目の C 番 目 にする <eos>
238
src = A = A or search ( B , C , D , E + B if E + B < 5 else None , not F )
trg = A または C 、 D 、 E に B を加えた 値が 5 より 小さい とき E に B を加えた 値 、 そうでなければ 、 つまり 未 定 値 、 F でない において 正規表現 B が 最初 にマッチする 位置 を A とする
rst = A または C 、 D 、 E に B を加えた 値が 5 より 小さい とき E に B を加えた 値 、 そうでなければ 、 つまり 未 定 値 、 F でない において 正規表現 B が 最初 にマッチする 位置 を A とする <eos>
239
src = pi = 3.141592653589793238
trg = 3.1 4 15 9 26 5 3 5 89 79 32 38 を 円 周 率 とする
rst = 3.1 4 15 9 26 5 3 5 89 7 を 円 周 率 とする <eos>
240
src = A . lt [ B ] . par = None
trg = 未 定 値を A の lt の B 番目の par にする
rst = 未 定 値を A の lt の B 番目の par にする <eos>
241
src = if not A and B >= C :
trg = A で なく かつ B が C 以上の とき 、
rst = A で なく かつ B が C 以上の とき 、 <eos>
242
src = print ( reduce ( A , ( [ pow ( B , C ) - pow ( B , C - 1 ) for B , C in Counter ( prime_factor ( int ( readline ( ) ) ) ) . items ( ) ] ) ) )
trg = prime _ factor ( int ( readline () ) ) の 辞書 カウンタ の キー と 値 の集まり の 各要素 を B 、 C とし 、 B の C 乗 から B の C -1 乗 を 引 いた 値の 列 を A で 集約 した 列 を出力する
rst = readline () の 整数値 の 各要素 を B とし 、 pow ( B , C ) から ( B , C -1 ) を 引 いた 値の 2 進 数 文字列 の 列 を 初期値 として A で 集約 した 列 を出力する <eos>
243
src = for A , B in C . primeFactorization . items ( ) :
trg = C の primeFactorization の キー と 値 の集まり を 順に A 、 B として 、 繰り返す
rst = C の primeFactorization の キー と 値 の集まり を 順に A 、 B として 、 繰り返す <eos>
244
src = if A [ B ] + C < A [ D ] :
trg = A の B 番 目 に C を加えた 値が A の D 番 目 より 小さい とき 、
rst = A の B 番 目 に C を加えた 値が A の D 番 目 より 小さい とき 、 <eos>
245
src = Rummy ( A , B )
trg = Rummy ( A , B )
rst = <unk> ( A , B ) <eos>
246
src = for e in A [ 2 : ] :
trg = A の 2 番 目 から 、 つまり 末 尾 までの 部分 列 を 順に ネ イ ピ ア 数 として 、 繰り返す
rst = A の 2 番 目 から 、 つまり 末 尾 までの 部分 列 を 順に ネ イ ピ ア 数 として 、 繰り返す <eos>
247
src = if A % 10 == B % 10 :
trg = A を 10 で 割 った 余 り が B を 10 で 割 った 余 り と 等 しい とき 、
rst = A を 10 で 割 った 余 り が B を 10 で 割 った 余 り と 等 しい とき 、 <eos>
248
src = A . append ( B + ' ' + str ( C ) )
trg = A の 末 尾 に B に 空白 文字 を加えた 値に C の 文字列 を加えた 値 を追加する
rst = A の 末 尾 に B に 空白 文字 を加えた 値に C の 文字列 を加えた 値 を追加する <eos>
249
src = A = zip ( B [ 0 : C + 1 ] , B [ 1 : C + 2 ] )
trg = B の 、 つまり 先頭 から C に 1 を加えた 値 までの 部分 列 、 B の 1 番 目 から C に 2 を加えた 値 までの 部分 列 の 要素を それぞれ 組 にした 列 を A とする
rst = B の 、 つまり 先頭 から C に 1 を加えた 値 までの 部分 列 、 B の 1 番 目 から C に 2 を加えた 値 までの 部分 列 の 要素を それぞれ 組 にした 列 を A とする <eos>
250
src = A = distance_ss ( B , C , D , E )
trg = distance _ ss ( B , C , D , E ) を A とする
rst = <unk> ( B , C , D , E ) を A とする <eos>
251
src = if A [ B ] [ 0 ] < A [ C ] [ 0 ] and A [ B ] [ 1 ] < A [ C ] [ 1 ] and D [ C ] > E :
trg = A の B 番目の 0 番 目 が A の C 番目の 0 番 目 より 小さく かつ A の B 番目の 1 番 目 が A の C 番目の 1 番 目 より 小さく かつ D の C 番 目 が E より 大きい とき 、
rst = A の B 番目の 0 番 目 が A の C 番目の 0 番 目 より 小さく かつ A の B 番目の 1 番 目 が A の C 番目の 1 番 目 より 小さく かつ D の C 番目の 1 番 目 が E より 大きい とき 、 <eos>
252
src = A = [ B for B in range ( 1 , 11 ) ]
trg = 1 から 11 未 満 までの 数 列 の 各要素 を B とし 、 B の 列 を A とする
rst = 1 から 11 未 満 までの 数 列 の 各要素 を B とし 、 B の 列 を A とする <eos>
253
src = A = A * 2 - pi
trg = A に 2 を 掛 け た 値 から 、 つまり 円 周 率 を 引 いた 値を A とする
rst = A に 2 を 掛 け た 値 から 、 つまり 円 周 率 を 引 いた 値を A とする <eos>
254
src = A [ B : C + 1 ] = reversed ( D [ B : C + 1 ] )
trg = D の B 番 目 から C に 1 を加えた 値 までの 部分 列 を 反 転 した 列 を A の B 番 目 から C に 1 を加えた 値 までの 部分 列 にする
rst = D の B 番 目 から C に 1 を加えた 値 までの 部分 列 を 反 転 した 列 を A の B 番 目 から C に 1 を加えた 値 までの 部分 列 にする <eos>
255
src = A . append ( ( B [ 0 ] , B [ 1 ] + 1 ) )
trg = A の 末 尾 に ( B の先頭 、 B の 1 番 目 に 1 を加えた 値 ) の 組 を追加する
rst = A の 末 尾 に ( B の先頭 、 B の 1 番 目 に 1 を加えた 値 ) の 組 を追加する <eos>
256
src = if A [ B ] [ C ] - D [ B ] [ C ] > max ( E [ C ] , 0 ) :
trg = A の B 番目の C 番 目 から D の B 番目の C 番 目 を 引 いた 値が E の C 番 目 、 0 の 最大 値 より 大きい とき 、
rst = A の B 番目の C 番 目 から D の B 番目の C 番 目 を 引 いた 値が E の C 番 目 、 0 の 最大 値 より 大きい とき 、 <eos>
257
src = print ( A [ B - 2 ] [ 0 ] )
trg = A の B から 2 を 引 いた 値 番目の 先頭 を出力する
rst = A の B から 2 を 引 いた 値 番目の 先頭 を出力する <eos>
258
src = A . distance = [ None for B in range ( A . n ) ]
trg = 0 から A の n 未 満 までの 数 列 の 各要素 を B とし 、 、 つまり 未 定 値の 列 を A の distance にする
rst = 0 から A の n 未 満 までの 数 列 の 各要素 を B とし 、 、 つまり 未 定 値の 列 を A の distance にする <eos>
259
src = if A == - 1 or B < A :
trg = A が -1 と 等 しく または B が A より 小さい とき 、
rst = A が -1 と 等 しく または B が A より 小さい とき 、 <eos>
260
src = print ( A . solve ( B , C , 0 , 0 , 1 , 0 ) )
trg = A . solve ( B , C , 0 , 0 , 1, 0 ) を出力する
rst = A . solve ( B , C , 0 , 0 , 1, 0 ) を出力する <eos>
261
src = print ( int ( A / ( B - 2 ) ) )
trg = A を B から 2 を 引 いた 値 で 割 った 値の 整数値 を出力する
rst = A を B から 2 を 引 いた 値 で 割 った 値の 整数値 を出力する <eos>
262
src = A . top -= 1
trg = A の top を 1 だけ 減少 させる
rst = A の top を 1 だけ 減少 させる <eos>
263
src = A = B [ 24 ]
trg = B の 24 番 目 を A とする
rst = B の 24 番 目 を A とする <eos>
264
src = time . sort ( )
trg = time を ソート する
rst = time を ソート する <eos>
265
src = A [ B ] , C [ B ] , D [ B ] = map ( int , input ( ) . split ( ) )
trg = 入力された 文字列を 空白 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 を 展開 し 、 それぞれ A の B 番 目 、 C の B 番 目 、 D の B 番 目 とする
rst = 入力された 文字列を 空白 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 を 展開 し 、 それぞれ A の B 番 目 、 C の B 番 目 、 D の B 番 目 とする <eos>
266
src = A = B % 12
trg = B を 12 で 割 った 余 り を A とする
rst = B を 12 で 割 った 余 り を A とする <eos>
267
src = A = set ( B )
trg = B の集合 を A とする
rst = B の集合 を A とする <eos>
268
src = A = A and search ( B , [ C for C in D if C != E ] , F , E + 1 , 0 )
trg = A かつ D の 各要素 を C とし 、 C が E と 等 しく ない とき の C の 列 、 F 、 E に 1 を加えた 値 、 0 において 正規表現 B が 最初 にマッチする 位置 を A とする
rst = A かつ D の 各要素 を C とし 、 C が E と 等 しく ない とき の D の 列 、 そうでなければ F 、 E に 1 を加えた 値 、 0 において 正規表現 B が 最初 にマッチする 位置 を A とする <eos>
269
src = if A != B and C [ A ] == D [ B ] :
trg = A が B と 等 しく なく かつ C の A 番 目 が D の B 番 目 と 等 しい とき 、
rst = A が B と 等 しく なく かつ C の A 番 目 が D の B 番 目 と 等 しい とき 、 <eos>
270
src = time [ tosec ( A ) ] += 1
trg = time の tosec ( A ) 番 目 を 1 だけ 増加 させる
rst = time の right _ triangle ( A ) 番 目 を 1 だけ 増加 させる <eos>
271
src = A += B . lazy [ C ]
trg = A を B の lazy の C 番 目 だけ 増加 させる
rst = A を B の lazy の C 番 目 だけ 増加 させる <eos>
272
src = A [ B ] = e = C ^ ( D & 1 )
trg = C と D と 1 の 論理 積 の 排 他 論理 和 を ネ イ ピ ア 数 とする を A の B 番 目 にする
rst = C と D と 1 の 論理 積 の 排 他 論理 和 を ネ イ ピ ア 数 とする を A の B 番 目 にする <eos>
273
src = A = [ None ] * 2020
trg = ( 、 つまり 未 定 値 ) からなる 列 の 2020 回 分 の 列 を A とする
rst = ( 、 つまり 未 定 値 ) からなる 列 の 2020 回 分 の 列 を A とする <eos>
274
src = A = [ [ inf for B in range ( C ) ] for B in range ( C ) ]
trg = 0 から C 未 満 までの 数 列 の 各要素 を B とし 、 0 から C 未 満 までの 数 列 の 各要素 を B とし 、 、 つまり 無限大 の 列 の 列 を A とする
rst = 0 から C 未 満 までの 数 列 の 各要素 を B とし 、 0 から C 未 満 までの 数 列 の 各要素 を B とし 、 、 つまり 無限大 の 列 の 列 を A とする <eos>
275
src = return [ 1 , ( A [ 0 ] , B [ 0 ] , C [ 0 ] , D [ 0 ] ) ]
trg = ( 1 、 ( A の先頭 、 B の先頭 、 C の先頭 、 D の先頭 ) の 組 ) からなる 列 を返す
rst = ( 1 、 ( A の先頭 、 B の先頭 、 C の先頭 、 D の先頭 ) の 組 ) からなる 列 を返す <eos>
276
src = A . start = Node ( val = B , prev = None , next = None )
trg = Node ( val = B , prev = None , next = None ) を A の start にする
rst = Node ( val = B , prev = None , next = None ) を A の start にする <eos>
277
src = if A > 36 :
trg = A が 36 より 大きい とき 、
rst = A が 36 より 大きい とき 、 <eos>
278
src = A . zeros = set ( range ( B ) )
trg = 0 から B 未 満 までの 数 列 の集合 を A の zeros にする
rst = 0 から B 未 満 までの 数 列 の集合 を A の zeros にする <eos>
279
src = A = B . y + C . y
trg = B の y 座標 に C の y 座標 を加えた 値を A とする
rst = B の y 座標 に C の y 座標 を加えた 値を A とする <eos>
280
src = A += ( 2 - 3 ) * B
trg = A を 2 から 3 を 引 いた 値に B を 掛 け た 値 だけ 増加 させる
rst = A を 2 から 3 を 引 いた 値に B を 掛 け た 値 だけ 増加 させる <eos>
281
src = A [ B ] [ C ] += A [ B - 1 ] [ C - 1 ]
trg = A の B 番目の C 番 目 を A の B から 1 を 引 いた 値 番目の C から 1 を 引 いた 値 番 目 だけ 増加 させる
rst = A の B 番目の C 番 目 を A の B から 1 を 引 いた 値 番目の C から 1 を 引 いた 値 番 目 だけ 増加 させる <eos>
282
src = A . append ( sum ( map ( int , input ( ) . split ( ) ) ) )
trg = A の 末 尾 に 入力された 文字列を 空白 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 の 総 和 を追加する
rst = A の 末 尾 に 入力された 文字列を 空白 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 の 総 和 を追加する <eos>
283
src = A [ B ] . insert ( C , D )
trg = A の B 番目の C に D を挿入する
rst = A の B 番目の C に D を挿入する <eos>
284
src = A [ - 1 ] -= B [ now ]
trg = A の -1 番 目 を B の 、 つまり 現在の 日 時 番 目 だけ 減少 させる
rst = A の -1 番 目 を B の 、 つまり 現在の 日 時 番 目 だけ 減少 させる <eos>
285
src = A = int ( B [ C ] / ( 10 * 365 ) + 1 )
trg = B の C 番 目 を 10 に 36 5 を 掛 け た 値 で 割 った 値に 1 を加えた 値の 整数値 を A とする
rst = B の C 番 目 を 10 に 36 5 を 掛 け た 値 で 割 った 値の 整数値 に 1 を加えた 値を A とする <eos>
286
src = print ( A [ B ] . name , end = '' )
trg = 改行 せずに A の B 番目の name を出力する
rst = 改行 せずに A の B 番目の name を出力する <eos>
287
src = A . nodes = [ 0 for B in range ( pow ( 2 , A . height + 1 ) - 1 ) ]
trg = 0 から 2 の A . height に 1 を加えた 値 乗 から 1 を 引 いた 値 未 満 までの 数 列 の 各要素 を B とし 、 0 の 列 を A の nodes にする
rst = 0 から 2 の A の height に 1 を加えた 値 未 満 までの 数 列 の 各要素 を B とし 、 0 の 列 を A の nodes にする <eos>
288
src = if A == 1 or A % 2 == 0 :
trg = A が 1 と 等 しく または A を 2 で 割 った 余 り が 0 と 等 しい とき 、
rst = A が 1 と 等 しく または A を 2 で 割 った 余 り が 0 と 等 しい とき 、 <eos>
289
src = A = min ( B [ e ] , C - D )
trg = B の 、 つまり ネ イ ピ ア 数 番 目 、 C から D を 引 いた 値の 最小 値を A とする
rst = B の 、 つまり ネ イ ピ ア 数 番 目 、 C から D を 引 いた 値の 最小 値を A とする <eos>
290
src = if A [ 0 ] . islower ( ) :
trg = A の先頭 の 全て が 英 小文字 の とき 、
rst = A の先頭 の 全て が 英 小文字 の とき 、 <eos>
291
src = A , B = term ( )
trg = term () を 展開 し 、 それぞれ A 、 B とする
rst = term () を 展開 し 、 それぞれ A 、 B とする <eos>
292
src = if A >= 5 or A <= - 1 :
trg = A が 5 以上 または A が -1 以下の とき 、
rst = A が 5 以上 または A が -1 以下の とき 、 <eos>
293
src = [ print ( math . ceil ( float ( e ) ** 2 / 98 ) + 1 ) for e in sys . stdin ]
trg = sys の stdin の 各要素 を ネ イ ピ ア 数 とし 、 float ( e ) * * 2 を 98 で 割 った 値の 切り 上げ 整数値 に 1 を加えた 値 を出力する の 列
rst = sys の stdin の 各要素 を ネ イ ピ ア 数 とし 、 ( e の 浮動小数点数 の 2 乗 を 98 で 割 った 値の 切り 上げ 整数値 に 1 を加えた 値 を出力する の 列 <eos>
294
src = A [ B ] , C [ B ] , D [ B ] = map ( int , readline ( ) . split ( ) )
trg = readline () を 空白 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 を 展開 し 、 それぞれ A の B 番 目 、 C の B 番 目 、 D の B 番 目 とする
rst = readline () を 空白 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 を 展開 し 、 それぞれ A の B 番 目 、 C の B 番 目 、 D の B 番 目 とする <eos>
295
src = return cross2 ( A , B ) ** 2 / dist1 ( A )
trg = cross 2 ( A , B ) の 2 乗 を dist 1 ( A ) で 割 った 値を返す
rst = cross 2 ( A , B ) の 2 乗 を dist 1 ( A ) で 割 った 値を返す <eos>
296
src = A = 2000 * B
trg = 2000 に B を 掛 け た 値を A とする
rst = 2000 に B を 掛 け た 値を A とする <eos>
297
src = A = B [ 4 ]
trg = B の 4 番 目 を A とする
rst = B の 4 番 目 を A とする <eos>
298
src = A = B * ( C - D ) - D * ( E - B )
trg = B に C から D を 引 いた 値を 掛 け た 値 から D に E から B を 引 いた 値を 掛 け た 値を 引 いた 値を A とする
rst = B に C から D を 引 いた 値を 掛 け た 値 から D に E から B を 引 いた 値を 掛 け た 値を 引 いた 値を A とする <eos>
299
src = if A + B == C :
trg = A に B を加えた 値が C と 等 しい とき 、
rst = A に B を加えた 値が C と 等 しい とき 、 <eos>
300
src = A [ B ] [ C ] += A [ B - 1 ] [ C - D [ B ] ]
trg = A の B 番目の C 番 目 を A の B から 1 を 引 いた 値 番目の C から D の B 番 目 を 引 いた 値 番 目 だけ 増加 させる
rst = A の B 番目の C 番 目 を A の B から 1 を 引 いた 値 番目の C から D の B 番 目 を 引 いた 値 番 目 だけ 増加 させる <eos>
301
src = A |= B
trg = A を B と の 論理 和 にする
rst = A を B と の 論理 和 にする <eos>
302
src = A = B [ - 1 ] [ 1 ]
trg = B の 末 尾 の 1 番 目 を A とする
rst = B の 末 尾 の 1 番 目 を A とする <eos>
303
src = A , B = bubble_sort ( A )
trg = bubble _ sort ( A ) を 展開 し 、 それぞれ A 、 B とする
rst = bubble _ sort ( A ) を 展開 し 、 それぞれ A 、 B とする <eos>
304
src = if A == 0 and B == 0 and C == 0 and D == 0 and E == 0 and F == 0 :
trg = A == 0 かつ B == 0 かつ C が 0 と 等 しく かつ D が 0 と 等 しく かつ E が 0 と 等 しく かつ F が 0 と 等 しい とき 、
rst = A が 0 と 等 しく かつ B が 0 と 等 しく かつ C が 0 と 等 しく かつ D が 0 と 等 しく かつ E が 0 と 等 しく かつ F が 0 と 等 しい とき 、 <eos>
305
src = A = [ MaxPQ ( ) for B in range ( C ) ]
trg = 0 から C 未 満 までの 数 列 の 各要素 を B とし 、 MaxPQ () の 列 を A とする
rst = 0 から C 未 満 までの 数 列 の 各要素 を B とし 、 <unk> () の 列 を A とする <eos>
306
src = for A in sorted ( set ( B ) ) :
trg = B の集合 を ソート した 列 を 順に A として 、 繰り返す
rst = B の集合 を ソート した 列 を 順に A として 、 繰り返す <eos>
307
src = path [ e ] = 0
trg = 0 を os . path の 、 つまり ネ イ ピ ア 数 番 目 にする
rst = 0 を os . path の 、 つまり ネ イ ピ ア 数 番 目 にする <eos>
308
src = print ( A [ B ] [ 7 - C ] , end = '' )
trg = 改行 せずに A の B 番目の 7 から C を 引 いた 値 番 目 を出力する
rst = 改行 せずに A の B 番目の 7 から C を 引 いた 値 番 目 を出力する <eos>
309
src = return [ A for A , B in enumerate ( C . parents ) if B < 0 ]
trg = C の parents に 番号 付 した 組 の 列 の 各要素 を A 、 B とし 、 B が 0 より 小さい とき の A の 列 を返す
rst = C の parents の 各要素 を A 、 B とし 、 B が 0 より 小さい とき の A の 列 を返す <eos>
310
src = A = traversal ( B )
trg = traversal ( B ) を A とする
rst = <unk> ( B ) を A とする <eos>
311
src = if isinstance ( A , collections . Iterable ) and not isinstance ( A , ( str , B ) ) :
trg = A は collections の Iterable 型 かつ A は ( 、 つまり 整数 、 B ) の 組 型 でない とき 、
rst = A は 、 つまり 整数型 の とき 、 <eos>
312
src = A . append ( int ( str ( B [ 2 ] ) + str ( B [ 1 ] ) ) )
trg = A の 末 尾 に B の 2 番目の 文字列 に B の 1 番目の 文字列 を加えた 値の 整数値 を追加する
rst = A の 末 尾 に B の 2 番目の 文字列 に B の 1 番目の 文字列 を加えた 値の 整数値 を追加する <eos>
313
src = print ( str ( A ) . rjust ( 4 ) , end = '' )
trg = 改行 せずに str ( A ) . rjust ( 4 ) を出力する
rst = 改行 せずに str ( A ) . rjust ( 4 ) を出力する <eos>
314
src = A = B [ 0 : C - 3 ]
trg = B の 、 つまり 先頭 から C から 3 を 引 いた 値 までの 部分 列 を A とする
rst = B の 、 つまり 先頭 から C から 3 を 引 いた 値 までの 部分 列 を A とする <eos>
315
src = A = A * 2 / sqrt ( 3 )
trg = A に 2 を 掛 け た 値を 3 の 平 方 根 で 割 った 値を A とする
rst = A に 2 を 掛 け た 値を 3 の 平 方 根 で 割 った 値を A とする <eos>
316
src = A , B , C = 1 , D , D
trg = 1 、 D 、 D を A 、 B 、 C とする
rst = 1 、 D 、 D を A 、 B 、 C とする <eos>
317
src = print ( 1911 + A )
trg = 19 11 に A を加えた 値 を出力する
rst = 19 11 に A を加えた 値 を出力する <eos>
318
src = A [ B ] [ C ] = min ( A [ B ] [ C ] , D )
trg = A の B 番目の C 番 目 、 D の 最小 値を A の B 番目の C 番 目 にする
rst = A の B 番目の C 番 目 、 D の 最小 値を A の B 番目の C 番 目 にする <eos>
319
src = while A * B <= C :
trg = A に B を 掛 け た 値が C 以下の 間 、 次 を 繰り返す
rst = A に B を 掛 け た 値が C 以下の 間 、 次 を 繰り返す <eos>
320
src = if A * B % 2 :
trg = A に B を 掛 け た 値を 2 で 割 った 余 り の とき 、
rst = A に B を 掛 け た 値を 2 で 割 った 余 り の とき 、 <eos>
321
src = A = hypot ( B - C , D - E )
trg = B から C を 引 いた 値 と D から E を 引 いた 値の ノ ル ム を A とする
rst = B から C を 引 いた 値 と D から E を 引 いた 値の ノ ル ム を A とする <eos>
322
src = A . add_edge ( 2 * B , 2 * B + 1 , 1 , 0 )
trg = A . add _ edge ( 2 * B , 2 * B + 1, 1, 0 )
rst = A . add _ edge ( 2 * B , 2 * B + 1, 1, 0 ) <eos>
323
src = if A - B [ C - 1 ] < D :
trg = A から B の C から 1 を 引 いた 値 番 目 を 引 いた 値が D より 小さい とき 、
rst = A から B の C から 1 を 引 いた 値 番 目 を 引 いた 値が D より 小さい とき 、 <eos>
324
src = A = sum ( [ B [ C ] [ 0 ] for C in range ( D ) if C != E and F [ G [ C ] ] ] )
trg = 0 から D 未 満 までの 数 列 の 各要素 を C とし 、 C が E と 等 しく なく かつ F の G の C 番 目 番目の とき の B の C 番目の 0 番目の 列 の 総 和 を A とする
rst = 0 から D 未 満 までの 数 列 の 各要素 を C とし 、 C が E と 等 しく なく かつ F の C 番目の とき の B の C 番目の 0 番目の 列 の 総 和 を A とする <eos>
325
src = A . update_depth ( )
trg = A . update _ depth ()
rst = A . <unk> () <eos>
326
src = while A + B <= 300 :
trg = A に B を加えた 値が 300 以下の 間 、 次 を 繰り返す
rst = A に B を加えた 値が 300 以下の 間 、 次 を 繰り返す <eos>
327
src = A = [ 9900001 ] * B
trg = ( 99 0000 1 ) からなる 列 の B 回 分 の 列 を A とする
rst = ( 3 1 e 9 ) からなる 列 の B 回 分 の 列 を A とする <eos>
328
src = A , B , C = int ( A ) , int ( B ) , int ( C )
trg = A の 整数値 、 B の 整数値 、 C の 整数値 を A 、 B 、 C とする
rst = A の 整数値 、 B の 整数値 、 C の 整数値 を A 、 B 、 C とする <eos>
329
src = for A in range ( B * B , 10001 , B ) :
trg = B に B を 掛 け た 値 から 1000 1 未 満 までの B 間隔 の 数 列 を 順に A として 、 繰り返す
rst = B に B を 掛 け た 値 から 1000 1 未 満 までの B 間隔 の 数 列 を 順に A として 、 繰り返す <eos>
330
src = A = [ ( 0 , 0 ) , ( - 1 , 1 ) , ( 0 , 1 ) , ( 1 , 1 ) , ( - 2 , 2 ) , ( - 1 , 2 ) , ( 0 , 2 ) , ( 1 , 2 ) , ( 2 , 2 ) , ( - 1 , 3 ) , ( 0 , 3 ) , ( 1 , 3 ) , (
trg = ( ( 0 、 0 ) の 組 、 ( -1 、 1 ) の 組 、 ( 0 、 1 ) の 組 、 ( 1 、 1 ) の 組 、 ( -2 、 2 ) の 組 、 ( -1 、 2 ) の 組 、 ( 0 、 2 ) の 組 、 ( 1 、 2 ) の 組 、 ( 2 、 2 ) の 組 、 ( -1 、 3 ) の 組
rst = ( ( 0 、 0 ) の 組 、 ( -1 、 1 ) の 組 、 ( 0 、 1 ) の 組 、 ( 1 、 1 ) の 組 、 ( 2 、 1 ) の 組 、 ( 0 、 2 ) の 組 、 (
331
src = if e == 4 :
trg = ネ イ ピ ア 数が 4 と 等 しい とき 、
rst = ネ イ ピ ア 数が 4 と 等 しい とき 、 <eos>
332
src = A . table = [ 0 ] * A . offset * 2
trg = ( 0 ) からなる 列 の A の offset に 2 を 掛 け た 値 回 分 の 列 を A の table にする
rst = ( 0 ) からなる 列 の A の offset に 2 を 掛 け た 値 回 分 の 列 を A の table にする <eos>
333
src = A . face = [ A . face [ 2 ] , A . face [ 1 ] , A . face [ 5 ] , A . face [ 0 ] , A . face [ 4 ] , A . face [ 3 ] ]
trg = ( A の face の 2 番 目 、 A の face の 1 番 目 、 A の face の 5 番 目 、 A の face の先頭 、 A の face の 4 番 目 、 A の face の 3 番 目 ) からなる 列 を A の face にする
rst = ( A の face の 2 番 目 、 A の face の 1 番 目 、 A の face の 5 番 目 、 A の face の先頭 、 A の face の 4 番 目 、 A の face の 3 番 目 ) からなる 列 を A
334
src = A = ( B * ( C + D - B ) * E + C * ( D + B - C ) * F + D * ( B + C - D ) * G ) / ( 16 * H ** 2 )
trg = B に ( C + D - B ) を 掛 け た 値に E を 掛 け た 値に C に ( D + B - C ) を 掛 け た 値に F を 掛 け た 値 を加えた 値に D に B + C から D を 引 いた 値を 掛 け た 値に G を 掛 け た 値 を加えた 値を 16 に H の 2 乗 を 掛 け た 値 で 割 った 値を
rst = B に C に D を加えた 値 から B を 引 いた 値を 掛 け た 値に E を 掛 け た 値に C に D を 掛 け た 値 を加えた 値に B に C を 掛 け た 値 から D に B を 掛 け た 値を
335
src = A , B , e = list ( map ( int , input ( ) . split ( ' ' ) ) )
trg = 入力された 文字列を 空白 文字 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 の リストを 展開 し 、 それぞれ A 、 B 、 ネ イ ピ ア 数 とする
rst = 入力された 文字列を 空白 文字 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 の リストを 展開 し 、 それぞれ A 、 B 、 ネ イ ピ ア 数 とする <eos>
336
src = A = factorial ( len ( B ) // 2 )
trg = B の長さ を 2 で 割 った 商 の 階乗 を A とする
rst = B の長さ を 2 で 割 った 商 の 階乗 を A とする <eos>
337
src = A = Dfs ( B )
trg = Dfs ( B ) を A とする
rst = <unk> ( B ) を A とする <eos>
338
src = A = int ( B [ : : - 1 ] )
trg = B の 逆 順 の 整数値 を A とする
rst = B の 逆 順 の 整数値 を A とする <eos>
339
src = print ( minkowsuki ( A , B , 2 ) )
trg = minkowsuki ( A , B , 2 ) を出力する
rst = minkowsuki ( A , B , 2 ) を出力する <eos>
340
src = if A % 3 == 0 or str ( A ) . count ( B ) != 0 :
trg = A を 3 で 割 った 余 り が 0 と 等 しく または A の 文字列 内の B の 出現 回数 が 0 と 等 しく ない とき 、
rst = A を 3 で 割 った 余 り が 0 と 等 しく または A の 文字列 内の B の 出現 回数 が 0 と 等 しく ない とき 、 <eos>
341
src = assert A . root is not None
trg = A の root が 、 つまり 未 定 値 と 等 しく なければならない
rst = A の root が 、 つまり 未 定 値 と 等 しく なければならない <eos>
342
src = A . count = 0
trg = 0 を A 内の [MASK] の 出現 回数 にする
rst = 0 を A 内の [MASK] の 出現 回数 にする <eos>
343
src = A = - B * C - D * E - 2 * F
trg = - B に C を 掛 け た 値 から D に E を 掛 け た 値を 引 いた 値 から 2 に F を 掛 け た 値を 引 いた 値を A とする
rst = - B に C を 掛 け た 値 から D に E を 掛 け た 値を 引 いた 値 から 2 に F を 掛 け た 値を 引 いた 値を A とする <eos>
344
src = A . pip [ 0 ] , A . pip [ 1 ] , A . pip [ 4 ] , A . pip [ 5 ] = A . pip [ 4 ] , A . pip [ 0 ] , A . pip [ 5 ] , A . pip [ 1 ]
trg = A の pip の 4 番 目 、 A の pip の先頭 、 A の pip の 5 番 目 、 A の pip の 1 番 目 を A の pip の先頭 、 A の pip の 1 番 目 、 A の pip の 4 番 目 、 A の pip の 5 番 目 とする
rst = A の pip の 4 番 目 、 A の pip の 5 番 目 、 A の pip の先頭 、 A の pip の 1 番 目 を A の pip の先頭 、 A の pip の 1 番 目 、 A の pip の 4 番 目 、
345
src = A = expr ( )
trg = expr () を A とする
rst = expr () を A とする <eos>
346
src = A = lambda B : B [ 1 ] / ( B [ 2 ] ** 2 )
trg = i を パラメータ として i の 1 番 目 を i の 2 番目の 2 乗 で 割 った 値を返す 関数を A とする
rst = x を パラメータ として x の 1 番 目 を B の 2 番目の 2 乗 で 割 った 値を返す 関数を A とする <eos>
347
src = A += B >> 1
trg = A を B を 1 だけ 右 シフト した 値 だけ 増加 させる
rst = A を B を 1 だけ 右 シフト した 値 だけ 増加 させる <eos>
348
src = if ( A < 0 or 10000 < A ) :
trg = A が 0 より 小さく または 1 0000 が A より 小さい とき 、
rst = A が 0 より 小さく または 1 0000 が A より 小さい とき 、 <eos>
349
src = remove_team ( A )
trg = remove _ team ( A )
rst = <unk> ( A ) <eos>
350
src = A = solve ( B - 1 , C - D )
trg = solve ( B - 1, C - D ) を A とする
rst = solve ( B - 1, C - D ) を A とする <eos>
351
src = if A [ pi ] > A [ pi - B ] + 1 :
trg = A の 、 つまり 円 周 率 番 目 が A の 、 つまり 円 周 率 から B を 引 いた 値 番 目 に 1 を加えた 値 より 大きい とき 、
rst = A の 、 つまり 円 周 率 番 目 が A の 、 つまり 円 周 率 から B を 引 いた 値 番 目 に 1 を加えた 値 より 大きい とき 、 <eos>
352
src = tree_walk ( tree_walk ( 0 ) , 1 )
trg = tree _ walk ( tree _ walk ( 0 ) , 1 )
rst = <unk> ( 0 ) 、 1 ) の 組 <eos>
353
src = while A < B and C [ A ] . isalpha ( ) :
trg = A が B より 小さく かつ C の A 番 目 が 全て アルファベット の 間 、 次 を 繰り返す
rst = A が B より 小さく かつ C の A 番 目 が 全て アルファベット の 間 、 次 を 繰り返す <eos>
354
src = for A , B in [ ( - 1 , - 1 ) , ( - 1 , 1 ) , ( 1 , - 1 ) , ( 1 , 1 ) ] :
trg = ( ( -1 、 -1 ) の 組 、 ( -1 、 1 ) の 組 、 ( 1 、 -1 ) の 組 、 ( 1 、 1 ) の 組 ) からなる 列 を 順に A 、 B として 、 繰り返す
rst = ( ( -1 、 -1 ) の 組 、 ( -1 、 1 ) の 組 、 ( 1 、 1 ) の 組 、 ( 1 、 1 ) の 組 ) からなる 列 を 順に A 、 B として 、 繰り返す <eos>
355
src = A [ 0 ] , A [ 1 ] , A [ 5 ] , A [ 4 ] = A [ 4 ] , A [ 0 ] , A [ 1 ] , A [ 5 ]
trg = A の 4 番 目 、 A の先頭 、 A の 1 番 目 、 A の 5 番 目 を A の先頭 、 A の 1 番 目 、 A の 5 番 目 、 A の 4 番 目 とする
rst = A の 4 番 目 、 A の先頭 、 A の 1 番 目 を A の先頭 、 A の 1 番 目 、 A の 5 番 目 、 A の 4 番 目 とする <eos>
356
src = [ 4 , 2 , 1 , 19 , 9 ]
trg = ( 4 、 2 、 1 、 19 、 9 ) からなる 列
rst = ( 4 、 2 、 1 、 19 、 9 ) からなる 列 <eos>
357
src = for A , B in enumerate ( zip ( C , D , E , F ) ) :
trg = C 、 D 、 E 、 F の 要素を それぞれ 組 にした 列 に 番号 付 した 組 の 列 を 順に A 、 B として 、 繰り返す
rst = C 、 D 、 E 、 F の 要素を それぞれ 組 にした 列 に 番号 付 した 組 の 列 を 順に A 、 B として 、 繰り返す <eos>
358
src = if A [ B ] + C [ B ] [ D ] < A [ D ] :
trg = A の B 番 目 に C の B 番目の D 番 目 を加えた 値が A の D 番 目 より 小さい とき 、
rst = A の B 番 目 に C の B 番目の D 番 目 を加えた 値が A の D 番 目 より 小さい とき 、 <eos>
359
src = A , B = sum ( map ( int , C [ 2 : 5 ] ) ) , sum ( map ( int , C [ 5 : 7 ] ) )
trg = C の 2 番 目 から 5 番 目 までの 部分 列 の 各要素 に 整数 を適用した 列 の 総 和 、 C の 5 番 目 から 7 番 目 までの 部分 列 の 各要素 に 整数 を適用した 列 の 総 和 を A 、 B とする
rst = C の 2 番 目 から 5 番 目 までの 部分 列 の 各要素 に 整数 を適用した 列 の 総 和 、 C の 5 番 目 から 7 番 目 までの 部分 列 の 総 和 を A 、 B とする <eos>
360
src = A = distance ( B [ C ] , D [ E ] )
trg = distance ( B [ C ] , D [ E ] ) を A とする
rst = distance ( B [ C ] , D [ E ] ) を A とする <eos>
361
src = A = run ( A )
trg = run ( A ) を A とする
rst = run ( A ) を A とする <eos>
362
src = A = Vector ( B - C , D - E )
trg = Vector ( B - C , D - E ) を A とする
rst = Vector ( B - C , D - E ) を A とする <eos>
363
src = A = min ( A , B [ C ] [ 0 ] , B [ C ] [ - 1 ] )
trg = A 、 B の C 番目の 先頭 、 B の C 番目の 末 尾 の 最小 値を A とする
rst = A 、 B の C 番目の 先頭 、 B の C 番目の 末 尾 の 最小 値を A とする <eos>
364
src = A += ( B - C [ D ] ) * E [ D ]
trg = A を B から C の D 番 目 を 引 いた 値に E の D 番 目 を 掛 け た 値 だけ 増加 させる
rst = A を B から C の D 番 目 を 引 いた 値に E の D 番 目 を 掛 け た 値 だけ 増加 させる <eos>
365
src = A = { 0 }
trg = ( < __ main __ . Cammaobjectat 0 x 10 a 20 32 b 0 > ) の集合 を A とする
rst = ( < __ main __ . Cammaobjectat 0 x 10 a 1 db 9 a 0 > ) の集合 を A とする <eos>
366
src = A = [ B . format ( C , D ) for C , D in A ]
trg = A の 各要素 を C 、 D とし 、 B を 書式 として C 、 D で 整 形 した 文字列 の 列 を A とする
rst = A の 各要素 を C 、 D とし 、 B を 書式 として C 、 D で 整 形 した 文字列 の 列 を A とする <eos>
367
src = A = [ B [ C : C + 2 ] for C in range ( len ( B ) - 2 , - 1 , - 2 ) ]
trg = B の長さ から 2 を 引 いた 値 から -1 未 満 までの -2 間隔 の 数 列 の 各要素 を C とし 、 B の C 番 目 から C に 2 を加えた 値 までの 部分 列 の 列 を A とする
rst = 0 から B の長さ から 2 を 引 いた 値 未 満 までの 数 列 の 各要素 を C とし 、 B の C 番 目 から C に 2 を加えた 値 までの 部分 列 の 列 を A とする <eos>
368
src = A . append ( E if B [ C ] == B [ D ] else F )
trg = A の 末 尾 に B の C 番 目 が B の D 番 目 と 等 しい とき E 、 そうでなければ F を追加する
rst = A の 末 尾 に B の C 番 目 が B の D 番 目 と 等 しい とき E 、 そうでなければ F を追加する <eos>
369
src = A [ B [ 0 ] ] = deque ( )
trg = [MASK] の 両 端 キュー を A の B の先頭 番 目 にする
rst = [MASK] の 両 端 キュー を A の B の先頭 番 目 にする <eos>
370
src = A = lambda D : ( D ** 2 + B ) % C
trg = x を パラメータ として x の 2 乗 に B を加えた 値を C で 割 った 余 り を返す関数 を A とする
rst = i を パラメータ として B の 2 乗 に B を加えた 値を C で 割 った 余 り を返す関数 を A とする <eos>
371
src = B = 5
trg = 5 を B とする
rst = 5 を B とする <eos>
372
src = A = 2 + B . N0 + C
trg = 2 に B の N 0 を加えた 値に C を加えた 値を A とする
rst = 2 に B の N を加えた 値に C を加えた 値を A とする <eos>
373
src = A += B [ C [ D + 1 ] ] - B [ C [ D ] ]
trg = A を B の C の D に 1 を加えた 値 番 目 番 目 から B の C の D 番 目 番 目 を 引 いた 値 だけ 増加 させる
rst = A を B の C の D に 1 を加えた 値 番 目 番 目 から B の C の D 番 目 番 目 を 引 いた 値 だけ 増加 させる <eos>
374
src = A . extend ( [ int ( B ) ] )
trg = ( B の 整数値 ) からなる 列 を追加し て A を拡張する
rst = ( B の 整数値 ) からなる 列 を追加し て A を拡張する <eos>
375
src = A . rightChild = B
trg = B を A の rightChild にする
rst = B を A の <unk> にする <eos>
376
src = A += _search ( B , C + 1 , D , E )
trg = A を _ search ( B , C + 1, D , E ) だけ 増加 させる
rst = A を _ search ( B , C + 1, D , E ) だけ 増加 させる <eos>
377
src = A . append ( ( ( 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 ) , 0 ) )
trg = A の 末 尾 に ( ( 0 、 1 、 2 、 3 、 4 、 5 、 6 、 7 ) の 組 、 0 ) の 組 を追加する
rst = A の 末 尾 に ( 0 、 1 、 2 、 3 、 4 、 5 、 6 、 7 、 0 ) の 組 を追加する <eos>
378
src = A , B , C , D , e , E = map ( int , input ( ) . split ( ) )
trg = 入力された 文字列を 空白 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 を 展開 し 、 それぞれ A 、 B 、 C 、 D 、 ネ イ ピ ア 数 、 E とする
rst = 入力された 文字列を 空白 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 を 展開 し 、 それぞれ A 、 B 、 C 、 D 、 ネ イ ピ ア 数 、 E とする <eos>
379
src = A = [ [ - 1 , 0 ] , [ 1 , 0 ] , [ 0 , 0 ] , [ 0 , - 1 ] , [ 0 , 1 ] ]
trg = ( ( -1 、 0 ) からなる 列 、 ( 1 、 0 ) からなる 列 、 ( 0 、 0 ) からなる 列 、 ( 0 、 -1 ) からなる 列 、 ( 0 、 1 ) からなる 列 ) からなる 列 を A とする
rst = ( ( -1 、 0 ) からなる 列 、 ( 1 、 0 ) からなる 列 、 ( 0 、 0 、 -1 ) からなる 列 、 ( 0 、 1 ) からなる 列 ) からなる 列 を A とする <eos>
380
src = print ( LIS ( A ) )
trg = LIS ( A ) を出力する
rst = <unk> ( A ) を出力する <eos>
381
src = A = str ( B % 10000 ) + C [ D ] + A
trg = B を 1 0000 で 割 った 余 り の 文字列 に C の D 番 目 を加えた 値に A を加えた 値を A とする
rst = B を 1 0000 で 割 った 余 り の 文字列 に C の D 番 目 を加えた 値に A を加えた 値を A とする <eos>
382
src = A . end = Node ( val = B , prev = None , next = None )
trg = Node ( val = B , prev = None , next = None ) を A の end にする
rst = Node ( val = B , prev = None , next = None ) を A の end にする <eos>
383
src = B = 6
trg = 6 を B とする
rst = 6 を B とする <eos>
384
src = while A [ 0 ] == B :
trg = A の先頭 が B と 等 しい 間 、 次 を 繰り返す
rst = A の 0 番 目 が B と 等 しい 間 、 次 を 繰り返す <eos>
385
src = A [ B ] = C = D + E / F
trg = D に E を F で 割 った 値 を加えた 値を C とする を A の B 番 目 にする
rst = D に E を F で 割 った 値 を加えた 値を C とする を A の B 番 目 にする <eos>
386
src = A = B = C = None
trg = 未 定 値を C を B とする とする を A とする
rst = 未 定 値を C を B とする を A とする <eos>
387
src = for A in range ( 3 * B , 1000000 , 2 * B ) :
trg = 3 に B を 掛 け た 値 から 100 0000 未 満 までの 2 に B を 掛 け た 値 間隔 の 数 列 を 順に A として 、 繰り返す
rst = 3 に B を 掛 け た 値 から 100 0000 未 満 までの 2 に B を 掛 け た 値 間隔 の 数 列 を 順に A として 、 繰り返す <eos>
388
src = A = ( ( - 1 , 0 ) , ( - 1 , - 1 ) , ( 0 , - 1 ) , ( 1 , - 1 ) , ( 1 , 0 ) , ( 1 , 1 ) , ( 0 , 1 ) , ( - 1 , 1 ) )
trg = ( ( -1 、 0 ) の 組 、 ( -1 、 -1 ) の 組 、 ( 0 、 -1 ) の 組 、 ( 1 、 -1 ) の 組 、 ( 1 、 0 ) の 組 、 ( 1 、 1 ) の 組 、 ( 0 、 1 ) の 組 、 ( -1 、 1 ) の 組 ) の 組 を A とする
rst = ( ( -1 、 0 ) の 組 、 ( -1 、 -1 ) の 組 、 ( 0 、 -1 ) の 組 、 ( 1 、 0 ) の 組 、 ( 1 、 1 ) の 組 、 ( 0 、 1 ) の 組 、 (
389
src = A = B [ C [ - 1 ] ] [ 1 ]
trg = B の C の 末 尾 番目の 1 番 目 を A とする
rst = B の C の 末 尾 の 1 番 目 番 目 を A とする <eos>
390
src = A = sorted ( A , key = lambda B : B [ 1 ] * 100 + B [ 3 ] , reverse = True )
trg = w を パラメータ として B の 1 番 目 に 100 を 掛 け た 値に w の 3 番 目 を加えた 値を返す 関数を キー として 逆 順に A を ソート した 列 を A とする
rst = x を パラメータ として x の 1 番 目 に 100 を 掛 け た 値に B の 3 番 目 を加えた 値を返す 関数を キー として 逆 順に A を ソート した 列 を A とする <eos>
391
src = A = atan2 ( - B , - C )
trg = atan 2 ( - B , - C ) を A とする
rst = atan 2 ( - B , - C ) を A とする <eos>
392
src = if A [ B ] [ 1 ] < A [ B - 1 ] [ 1 ] :
trg = A の B 番目の 1 番 目 が A の B から 1 を 引 いた 値 番目の 1 番 目 より 小さい とき 、
rst = A の B 番目の 1 番 目 が A の B から 1 を 引 いた 値 番目の 1 番 目 より 小さい とき 、 <eos>
393
src = A = LinkList ( )
trg = LinkList () を A とする
rst = <unk> () を A とする <eos>
394
src = A = [ ( B - C ) ** 2 for B in D ]
trg = D の 各要素 を B とし 、 B から C を 引 いた 値の 2 乗 の 列 を A とする
rst = D の 各要素 を B とし 、 B から C を 引 いた 値の 2 乗 の 列 を A とする <eos>
395
src = A [ 3 ] = None
trg = 未 定 値を A の 3 番 目 にする
rst = 未 定 値を A の 3 番 目 にする <eos>
396
src = A [ B - 1 ] [ C - 1 ] = - 1 if A [ B - 1 ] [ C - 1 ] == - 1 else 1
trg = A の B から 1 を 引 いた 値 番目の C から 1 を 引 いた 値 番 目 が -1 と 等 しい とき -1 、 そうでなければ 1 を A の B から 1 を 引 いた 値 番目の C から 1 を 引 いた 値 番 目 にする
rst = A の B から 1 を 引 いた 値 番目の C から 1 を 引 いた 値 番 目 が -1 と 等 しい とき -1 、 そうでなければ 1 を A の B から 1 を 引 いた 値 番目の C から 1 を 引 いた 値 番 目 にする
397
src = A = deque ( map ( B , A ) )
trg = A の 各要素 に B を適用した 列 の 両 端 キュー を A とする
rst = A の 各要素 に B を適用した 列 の 両 端 キュー を A とする <eos>
398
src = A = B . index ( e )
trg = B の 、 つまり ネ イ ピ ア 数 と 等 しい 要素 の最初の 位置 を A とする
rst = B の 、 つまり ネ イ ピ ア 数 と 等 しい 要素 の最初の 位置 を A とする <eos>
399
src = A = min ( B [ C ] + D [ E - C - 2 ] [ C + 1 ] , D [ E - C - 2 ] [ C ] + B [ E ] )
trg = B の C 番 目 に D の E - C から 2 を 引 いた 値 番目の C に 1 を加えた 値 番 目 を加えた 値 、 D の E - C から 2 を 引 いた 値 番目の C 番 目 に B の E 番 目 を加えた 値の 最小 値を A とする
rst = B の C 番 目 に D の E から C を 引 いた 値 から 2 を 引 いた 値 番目の C に 1 を加えた 値 番 目 を加えた 値 、 D の E から C を 引 いた 値 番目の B の E 番 目 に D の
400
src = A = { 'E' : ( 3 , 1 , 0 , 5 , 4 , 2 ) , 'N' : ( 1 , 5 , 2 , 3 , 0 , 4 ) , 'S' : ( 4 , 0 , 2 , 3 , 5 , 1 ) , 'W' : ( 2 , 1 , 5 , 0 , 4 , 3 ) }
trg = ( ( B , ( 3 、 1 、 0 、 5 、 4 、 2 ) の 組 ) 、 ( C , ( 1 、 5 、 2 、 3 、 0 、 4 ) の 組 ) 、 ( D , ( 4 、 0 、 2 、 3 、 5 、 1 ) の 組 ) 、 ( E , ( 2 、 1 、 5 、 0 、 4 、 3 ) の 組 )
rst = ( ( 3 , ( 3 、 1 、 0 、 5 、 4 ) の 組 ) 、 ( D , ( 2 、 1 、 5 、 2 、 3 、 0 、 4 、 5 ) の 組 ) 、 ( E , ( 3 、 1
401
src = A [ B ] += C [ B % 12 ]
trg = A の B 番 目 を C の B を 12 で 割 った 余 り 番 目 だけ 増加 させる
rst = A の B 番 目 を C の B を 12 で 割 った 余 り 番 目 だけ 増加 させる <eos>
402
src = A = [ [ - 1 for B in range ( C * 2 ) ] for D in range ( C * 2 ) ]
trg = 0 から C に 2 を 掛 け た 値 未 満 までの 数 列 の 各要素 を D とし 、 0 から C に 2 を 掛 け た 値 未 満 までの 数 列 の 各要素 を B とし 、 -1 の 列 の 列 を A とする
rst = 0 から C に 2 を 掛 け た 値 未 満 までの 数 列 の 各要素 を D とし 、 0 から C に 2 を 掛 け た 値 未 満 までの 数 列 の 各要素 を B とし 、 -1 の 列 の 列 の 列 を
403
src = print ( A . format ( B * cos ( C ) - D * sin ( C ) + E , D * cos ( C ) + B * sin ( C ) + F ) )
trg = A を 書式 として B に cos ( C ) を 掛 け た 値 から D に sin ( C ) を 掛 け た 値を 引 いた 値に E を加えた 値 、 D に cos ( C ) を 掛 け た 値に B に sin ( C ) を 掛 け た 値 を加えた 値に F を加えた 値 で 整 形 した 文字列 を出力する
rst = A を 書式 として B に C の 余 弦 を 掛 け た 値 から D に C の 正 弦 を 掛 け た 値を 引 いた 値に E に D の 余 弦 を 掛 け た 値 を加えた 値に B に C の 正 弦 を
404
src = A = [ [ ] for B in range ( C * D ) ]
trg = 0 から C に D を 掛 け た 値 未 満 までの 数 列 の 各要素 を B とし 、 、 つまり 空 列 の 列 を A とする
rst = 0 から C に D を 掛 け た 値 未 満 までの 数 列 の 各要素 を B とし 、 、 つまり 空 列 の 列 を A とする <eos>
405
src = A , B = 0 , C [ 0 ]
trg = 0 、 C の先頭 を A 、 B とする
rst = 0 、 C の先頭 を A 、 B とする <eos>
406
src = if A [ B [ 1 ] ] [ B [ 0 ] ] != 0 :
trg = A の B の 1 番 目 番目の B の先頭 番 目 が 0 と 等 しく ない とき 、
rst = A の B の 1 番 目 番目の B の先頭 番 目 が 0 と 等 しく ない とき 、 <eos>
407
src = print ( isstable ( A . split ( ) , B , C ) )
trg = isstable ( A . split () , B , C ) を出力する
rst = <unk> _ <unk> ( A . split () , B , C ) を出力する <eos>
408
src = A = B // 20 * 20
trg = B を 20 で 割 った 商 に 20 を 掛 け た 値を A とする
rst = B を 20 で 割 った 商 に 20 を 掛 け た 値を A とする <eos>
409
src = A = [ event ( B + 1 , int ( input ( ) ) ) for B in range ( C ) ]
trg = 0 から C 未 満 までの 数 列 の 各要素 を B とし 、 event ( B + 1, int ( input () ) ) の 列 を A とする
rst = 0 から C 未 満 までの 数 列 の 各要素 を B とし 、 <unk> ( B + 1, input () ) の 整数値 の 列 を A とする <eos>
410
src = if A in B * 2 :
trg = A が B に 2 を 掛 け た 値 に含まれる とき 、
rst = A が B に 2 を 掛 け た 値 に含まれる とき 、 <eos>
411
src = A += B . pop ( 0 ) . lower ( )
trg = A を B の 0 を取り 出した 値を 英 小文字 に変換し た 文字列 だけ 増加 させる
rst = A を B の 0 を取り 出した 値を 英 小文字 に変換し た 文字列 だけ 増加 させる <eos>
412
src = A = Counter ( B [ C ] )
trg = B の C 番目の 辞書 カウンタ を A とする
rst = B の C 番目の 辞書 カウンタ を A とする <eos>
413
src = return Vector ( A . x - B . x , A . y - B . y )
trg = Vector ( A . x - B . x , A . y - B . y ) を返す
rst = Vector ( A . x - B . x , A . y - B . y ) を返す <eos>
414
src = print ( A , B . format ( C // 100 , C % 100 ) )
trg = A 、 B を 書式 として C を 100 で 割 った 商 、 C を 100 で 割 った 余 り で 整 形 した 文字列 を出力する
rst = A 、 B を 書式 として C を 100 で 割 った 商 、 C を 100 で 割 った 余 り で 整 形 した 文字列 を出力する <eos>
415
src = return A . val [ B ]
trg = A の val の B 番 目 を返す
rst = A の val の B 番 目 を返す <eos>
416
src = A = list ( map ( lambda B : str ( len ( B ) ) , A . split ( ' ' ) ) )
trg = A を 空白 文字 で 分割 した 字句 列 の 各要素 に x を パラメータ として B の長さ の 文字列 を返す関数 を適用した 列 の リストを A とする
rst = A を 空白 文字 で 分割 した 字句 列 の 各要素 に x を パラメータ として B の長さ の 文字列 を返す関数 を適用した 列 の リストを A とする <eos>
417
src = A = conv ( B [ C ] )
trg = conv ( B [ C ] ) を A とする
rst = conv ( B [ C ] ) を A とする <eos>
418
src = A = A + pow ( B , 3 )
trg = A に B の 3 乗 を加えた 値を A とする
rst = A に B の 3 乗 を加えた 値を A とする <eos>
419
src = A [ B . HEIGHT ] = height ( A )
trg = height ( A ) を A の B の HEIGHT 番 目 にする
rst = height ( A ) を A の B の HEIGHT 番 目 にする <eos>
420
src = A . append ( int ( input ( ) ) // 10 )
trg = A の 末 尾 に 入力された 文字列 の 整数値 を 10 で 割 った 商 を追加する
rst = A の 末 尾 に 入力された 文字列 の 整数値 を 10 で 割 った 商 を追加する <eos>
421
src = for A in range ( 16 ) :
trg = 0 から 16 未 満 までの 数 列 を 順に A として 、 繰り返す
rst = 0 から 16 未 満 までの 数 列 を 順に A として 、 繰り返す <eos>
422
src = A . append ( count )
trg = A の 末 尾 に 無限 の 整数 列 を追加する
rst = A の 末 尾 に 無限 の 整数 列 を追加する <eos>
423
src = A , B = divmod ( A , 3 )
trg = A と 3 を 割 った とき の ( 商 を 展開 し 、 それぞれ A 、 B とする
rst = A と 3 を 割 った とき の ( 商 を 展開 し 、 それぞれ A 、 B とする <eos>
424
src = A += max ( B [ C ] - D [ ( C + E ) % 8 ] , 0 )
trg = A を B の C 番 目 から D の C に E を加えた 値を 8 で 割 った 余 り 番 目 を 引 いた 値 、 0 の 最大 値 だけ 増加 させる
rst = A を B の C 番 目 から D の C に E を加えた 値を 引 いた 値を 8 で 割 った 余 り 番 目 、 0 の 最大 値 だけ 増加 させる <eos>
425
src = if time < A :
trg = time が A より 小さい とき 、
rst = time が A より 小さい とき 、 <eos>
426
src = if 0 <= A - B and ( not ( A - B < C < A ) ) :
trg = 0 が A から B を 引 いた 値 以下 かつ A から B を 引 いた 値が C より 小さい かどうか が A より 小さく ない とき 、
rst = 0 が A から B を 引 いた 値 以下 かつ A から B を 引 いた 値が C より 小さい かどうか が A より 小さく ない とき 、 <eos>
427
src = A . append ( ( B , C + e . weight ) )
trg = A の 末 尾 に ( B 、 C に ネ イ ピ ア 数の weight を加えた 値 ) の 組 を追加する
rst = A の 末 尾 に ( B 、 C に ネ イ ピ ア 数の weight を加えた 値 ) の 組 を追加する <eos>
428
src = A [ B ] [ C ] = max ( A [ B ] [ C ] , A [ B + D [ C ] [ 1 ] ] [ C + 1 ] + D [ C ] [ 0 ] )
trg = A の B 番目の C 番 目 、 A の B に D [ C ] [ 1 ] を加えた 値 番目の C に 1 を加えた 値 番 目 に D の C 番目の 先頭 を加えた 値の 最大 値を A の B 番目の C 番 目 にする
rst = A の B 番目の C 番 目 、 A の B に D を加えた 値 番目の C に 1 を加えた 値 番目の C 番 目 に D の先頭 を加えた 値の 最大 値を A の B 番目の C 番 目 にする <eos>
429
src = A . append ( ( 1 + B , C ) )
trg = A の 末 尾 に ( 1 に B を加えた 値 、 C ) の 組 を追加する
rst = A の 末 尾 に ( 1 に B を加えた 値 、 C ) の 組 を追加する <eos>
430
src = count += A [ B ] [ C ]
trg = 無限 の 整数 列 を A の B 番目の C 番 目 だけ 増加 させる
rst = 無限 の 整数 列 を A の B 番目の C 番 目 だけ 増加 させる <eos>
431
src = A = B [ C ] [ D - 2 ]
trg = B の C 番目の D から 2 を 引 いた 値 番 目 を A とする
rst = B の C 番目の D から 2 を 引 いた 値 番 目 を A とする <eos>
432
src = A = re . compile ( B )
trg = B を 正規表現 に コンパイル した結果 を A とする
rst = re を 正規表現 B に <unk> ッ <unk> する を A とする <eos>
433
src = check ( A , B + 1 , C )
trg = check ( A , B + 1, C )
rst = check ( A , B + 1, C ) <eos>
434
src = A = max ( A , ( B + C ) // ( D + ( E + 1 ) * F ) )
trg = A 、 B に C を加えた 値を D に E に 1 を加えた 値に F を 掛 け た 値 を加えた 値 で 割 った 商 の 最大 値を A とする
rst = A 、 B に C を加えた 値を D に E に 1 を加えた 値に F を 掛 け た 値 を加えた 値 で 割 った 商 の 最大 値を A とする <eos>
435
src = sys . setrecursionlimit ( 2000000 )
trg = sys . setrecursionlimit ( 200 0000 )
rst = sys . setrecursionlimit ( 200 0000 ) <eos>
436
src = A , B , C = [ int ( D ) for D in E . split ( F ) ]
trg = E を F で 分割 した 字句 列 の 各要素 を D とし 、 D の 整数値 の 列 を 展開 し 、 それぞれ A 、 B 、 C とする
rst = E を F で 分割 した 字句 列 の 各要素 を D とし 、 D の 整数値 の 列 を 展開 し 、 それぞれ A 、 B 、 C とする <eos>
437
src = A [ 0 ] = 0
trg = 0 を A の 0 番 目 にする
rst = 0 を A の 0 番 目 にする <eos>
438
src = A = [ B * C for C in range ( D + 1 ) ]
trg = 0 から D に 1 を加えた 値 未 満 までの 数 列 の 各要素 を C とし 、 B に C を 掛 け た 値の 列 を A とする
rst = 0 から D に 1 を加えた 値 未 満 までの 数 列 の 各要素 を C とし 、 B に C を 掛 け た 値の 列 を A とする <eos>
439
src = A = prime ( 10000 )
trg = prime ( 1 0000 ) を A とする
rst = prime ( 1 0000 ) を A とする <eos>
440
src = if A - B * C >= 0 :
trg = A から B に C を 掛 け た 値を 引 いた 値が 0 以上の とき 、
rst = A から B に C を 掛 け た 値を 引 いた 値が 0 以上の とき 、 <eos>
441
src = A . table [ B ] = A . query ( A . table [ 2 * B ] , A . table [ 2 * B + 1 ] )
trg = A . query ( A . table [ 2 * B ] , A . table [ 2 * B + 1 ] ) を A の table の B 番 目 にする
rst = A . query ( A . table [ 2 * B ] , A . table [ 2 * B + 1 ] ) を A の table の B 番 目 にする <eos>
442
src = A . add_edge ( B + C , B + D + 1 , 1 , 0 )
trg = A . add _ edge ( B + C , B + D + 1, 1, 0 )
rst = A . add _ edge ( B + C , B + D + 1, 1, 0 ) <eos>
443
src = A , B = map ( int , readline ( ) . split ( C ) )
trg = readline () を C で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 を 展開 し 、 それぞれ A 、 B とする
rst = readline () を C で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 を 展開 し 、 それぞれ A 、 B とする <eos>
444
src = if A [ 0 ] == 0 and A [ 1 ] == 0 and A [ 2 ] == 0 :
trg = A の先頭 が 0 と 等 しく かつ A の 1 番 目 が 0 と 等 しく かつ A の 2 番 目 が 0 と 等 しい とき 、
rst = A の 0 番 目 が 0 と 等 しく かつ A の 1 番 目 が 0 と 等 しく かつ A の 2 番 目 が 0 と 等 しい とき 、 <eos>
445
src = A = min ( 19 , B )
trg = 19 、 B の 最小 値を A とする
rst = 19 、 B の 最小 値を A とする <eos>
446
src = path . append ( [ [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] , [ ] ] )
trg = os . path の 末 尾 に ( ( 0 、 1 、 2 、 3 、 4 、 5 、 6 、 7 、 8 、 9 ) からなる 列 、 空 列 ) からなる 列 を追加する
rst = os . path の 末 尾 に ( ( 0 、 1 、 2 、 3 、 4 、 5 、 6 、 7 、 8 ) からなる 列 、 空 列 ) からなる 列 を追加する <eos>
447
src = if A < 1 :
trg = A が 1 より 小さい とき 、
rst = A が 1 より 小さい とき 、 <eos>
448
src = A [ B ] [ 0 ] = int ( A [ B ] [ 0 ] )
trg = A の B 番目の 先頭 の 整数値 を A の B 番目の 0 番 目 にする
rst = A の B 番目の 先頭 の 整数値 を A の B 番目の 0 番 目 にする <eos>
449
src = if not 0 <= A < B or not 0 <= C < B :
trg = 0 が A 以下 かどうか が B より 小さく なく または 0 が C 以下 かどうか が B より 小さく ない とき 、
rst = 0 が A 以下 かどうか が B より 小さく なく または 0 が C 以下 かどうか が B より 小さく ない とき 、 <eos>
450
src = heappush ( A , ( B , time , C , D , E ) )
trg = heappush ( A , ( B , time , C , D , E ) )
rst = heappush ( A , ( B , time , C , D , E ) ) <eos>
451
src = A [ find ( B ) ] = find ( C )
trg = find ( C ) を A の find ( B ) 番 目 にする
rst = find ( C ) を A の find ( B ) 番 目 にする <eos>
452
src = print ( {v}: {combi} if A else B )
trg = A の とき " { } : { } " 、 そうでなければ B を出力する
rst = A の とき <unk> 、 そうでなければ B を出力する <eos>
453
src = if any ( [ A [ B - 1 ] [ C ] == D for C in E [ e ] ] ) and any ( [ A [ F - 1 ] [ G ] == D for G in E [ H ] ] ) :
trg = E の 、 つまり ネ イ ピ ア 数 番目の 各要素 を C とし 、 A [ B -1 ] の C 番 目 が D と 等 しい かどうか の 列 が 少なくとも ひとつ は 真 かつ E の H 番目の 各要素 を G とし 、 A [ F -1 ] の G 番 目 が D と 等 しい かどうか の 列 が 少なくとも ひとつ は 真 の とき 、
rst = E の 、 つまり ネ イ ピ ア 数 番目の 各要素 を D とし 、 A の B -1 番目の C 番 目 が D と 等 しく かつ G の H 番目の 列 が 少なくとも ひとつ は 真 の とき 、 <eos>
454
src = A = ( ( B - C ) ** 2 + ( D - E ) ** 2 ) ** .5 / F
trg = B から C を 引 いた 値の 2 乗 に D から E を 引 いた 値の 2 乗 を加えた 値の . 5 乗 を F で 割 った 値を A とする
rst = B から C を 引 いた 値の 2 乗 に D から E を 引 いた 値の 2 乗 を加えた 値の . 5 乗 を F で 割 った 値を A とする <eos>
455
src = while A - B > 1 :
trg = A から B を 引 いた 値が 1 より 大きい 間 、 次 を 繰り返す
rst = A から B を 引 いた 値が 1 より 大きい 間 、 次 を 繰り返す <eos>
456
src = A = scaler ( 2 , B )
trg = scaler ( 2 , B ) を A とする
rst = scaler ( 2 , B ) を A とする <eos>
457
src = A = vc ( B , C )
trg = vc ( B , C ) を A とする
rst = vc ( B , C ) を A とする <eos>
458
src = H = C + I * F / G
trg = C に I に F を 掛 け た 値を G で 割 った 値 を加えた 値を H とする
rst = C に I に F を 掛 け た 値を G で 割 った 値 を加えた 値を H とする <eos>
459
src = A = B . compute ( )
trg = B . compute () を A とする
rst = B . compute () を A とする <eos>
460
src = A = _miny ( B . right , C , D + 1 )
trg = _ miny ( B . right , C , D + 1 ) を A とする
rst = _ miny ( B . right , C , D + 1 ) を A とする <eos>
461
src = if A == B or C [ B ] < D :
trg = A が B と 等 しく または C の B 番 目 が D より 小さい とき 、
rst = A が B と 等 しく または C の B 番 目 が D より 小さい とき 、 <eos>
462
src = for A in sorted ( B & C ) :
trg = B と C の 論理 積 を ソート した 列 を 順に A として 、 繰り返す
rst = B と C の 論理 積 を ソート した 列 を 順に A として 、 繰り返す <eos>
463
src = if A < B and A != C :
trg = A が B より 小さく かつ A が C と 等 しく ない とき 、
rst = A が B より 小さく かつ A が C と 等 しく ない とき 、 <eos>
464
src = A . status = [ ]
trg = 空 列 を A の status にする
rst = 空 列 を A の status にする <eos>
465
src = A , B , C = list ( map ( int , D . split ( ' ' ) ) )
trg = D を 空白 文字 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 の リストを 展開 し 、 それぞれ A 、 B 、 C とする
rst = D を 空白 文字 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 の リストを 展開 し 、 それぞれ A 、 B 、 C とする <eos>
466
src = if A [ B - C ] [ D - E ] != F :
trg = A の B から C を 引 いた 値 番目の D から E を 引 いた 値 番 目 が F と 等 しく ない とき 、
rst = A の B から C を 引 いた 値 番目の D から E を 引 いた 値 番 目 が F と 等 しく ない とき 、 <eos>
467
src = if A < B * B :
trg = A が B に B を 掛 け た 値 より 小さい とき 、
rst = A が B に B を 掛 け た 値 より 小さい とき 、 <eos>
468
src = A . faces [ B ] = C [ D ]
trg = C の D 番 目 を A の faces の B 番 目 にする
rst = C の D 番 目 を A の faces の B 番 目 にする <eos>
469
src = A [ ( B , C ) : ] = ( D , E )
trg = ( D 、 E ) の 組 を A の ( B 、 C ) の 組 から 、 つまり 末 尾 までの 部分 列 にする
rst = ( D 、 E ) の 組 を A の ( B 、 C ) の 組 から 、 つまり 末 尾 までの 部分 列 にする <eos>
470
src = return bfs ( A , B )
trg = bfs ( A , B ) を返す
rst = bfs ( A , B ) を返す <eos>
471
src = A = [ float ( B ) for C in range ( D ) ]
trg = 0 から D 未 満 までの 数 列 の 各要素 を C とし 、 B の 浮動小数点数 の 列 を A とする
rst = 0 から D 未 満 までの 数 列 の 各要素 を C とし 、 B の 浮動小数点数 の 列 を A とする <eos>
472
src = A [ B ] [ C ] = max ( A [ B - 1 ] [ C ] , A [ B - 1 ] [ C - 1 ] ) + A [ B ] [ C ]
trg = A の B から 1 を 引 いた 値 番目の C 番 目 、 A の B から 1 を 引 いた 値 番目の C から 1 を 引 いた 値 番目の 最大 値に A の B 番目の C 番 目 を加えた 値を A の B 番目の C 番 目 にする
rst = A の B から 1 を 引 いた 値 番目の C 番 目 、 A の B から 1 を 引 いた 値 番目の C から 1 を 引 いた 値 番目の 最大 値に A の B 番目の C 番 目 を加えた 値を A の B 番目の C 番 目
473
src = A , B , C , D , E , F , G , H = I [ J ]
trg = I の J 番 目 を 展開 し 、 それぞれ A 、 B 、 C 、 D 、 E 、 F 、 G 、 H とする
rst = I の J 番 目 を 展開 し 、 それぞれ A 、 B 、 C 、 D 、 E 、 F 、 G 、 H とする <eos>
474
src = D = A - B
trg = A から B を 引 いた 値を D とする
rst = A から B を 引 いた 値を D とする <eos>
475
src = for A in range ( 1 , 2 * B ) :
trg = 1 から 2 に B を 掛 け た 値 未 満 までの 数 列 を 順に A として 、 繰り返す
rst = 1 から 2 に B を 掛 け た 値 未 満 までの 数 列 を 順に A として 、 繰り返す <eos>
476
src = A . add ( tuple ( B . node ) )
trg = A に B の node の 組 を追加した 集 ま り
rst = A に B の node の 組 を追加した 集 ま り <eos>
477
src = A , B , C , D = parse ( 1 , 0 , E [ F ] , ( E + E ) [ F + 1 : F + G ] )
trg = parse ( 1, 0 , E [ F ] , ( E + E ) [ F + 1 : F + G ] ) を 展開 し 、 それぞれ A 、 B 、 C 、 D とする
rst = parse ( 1, 0 , E [ F ] , ( E + E ) [ F + 1 : F + 1 ] ) を 展開 し 、 それぞれ A 、 B 、 C 、 D とする <eos>
478
src = A = B * C * math . sin ( math . radians ( D ) ) / 2
trg = B に C を 掛 け た 値に D の ラ ジ アン の 正 弦 を 掛 け た 値を 2 で 割 った 値を A とする
rst = B に C を 掛 け た 値に D の ラ ジ アン の 正 弦 を 掛 け た 値を 2 で 割 った 値を A とする <eos>
479
src = A = [ ( B [ C ] [ D ] , C , D ) ]
trg = ( ( B の C 番目の D 番 目 、 C 、 D ) の 組 ) からなる 列 を A とする
rst = ( ( B の C 番目の D 番 目 、 C 、 D ) の 組 ) からなる 列 を A とする <eos>
480
src = A . put ( [ 0 , 0 , 0 ] )
trg = A . put ( [ 0 , 0 , 0 ] )
rst = A . put ( [ 0 , 0 , 0 ) <eos>
481
src = if ord ( A [ B ] ) >= 48 and ord ( A [ B ] ) <= 57 :
trg = A の B 番目の 順序 数が 4 8 以上 かつ A の B 番目の 順序 数が 5 7 以下の とき 、
rst = A の B 番目の 順序 数が 4 8 以上 かつ A の B 番目の 順序 数が 4 8 以下の とき 、 <eos>
482
src = A = [ 0 ] * 6
trg = ( 0 ) からなる 列 の 6 回 分 の 列 を A とする
rst = ( 0 ) からなる 列 の 6 回 分 の 列 を A とする <eos>
483
src = if A + B < ( C + D ) / 2 :
trg = A に B を加えた 値が C に D を加えた 値を 2 で 割 った 値 より 小さい とき 、
rst = A に B を加えた 値が C に D を加えた 値を 2 で 割 った 値 より 小さい とき 、 <eos>
484
src = A = 32 - A
trg = 32 から A を 引 いた 値を A とする
rst = 32 から A を 引 いた 値を A とする <eos>
485
src = A = [ - 1 , 0 , 1 , 2 ]
trg = ( -1 、 0 、 1 、 2 ) からなる 列 を A とする
rst = ( -1 、 0 、 1 、 2 ) からなる 列 を A とする <eos>
486
src = A += B [ C ] * ( B [ C ] - 1 ) // 2
trg = A を B の C 番 目 に B の C 番 目 から 1 を 引 いた 値を 掛 け た 値を 2 で 割 った 商 だけ 増加 させる
rst = A を B の C 番 目 に B の C 番 目 から 1 を 引 いた 値を 掛 け た 値を 2 で 割 った 商 だけ 増加 させる <eos>
487
src = A = B + C + 2
trg = B に C を加えた 値に 2 を加えた 値を A とする
rst = B に C を加えた 値に 2 を加えた 値を A とする <eos>
488
src = return abs ( A )
trg = A の 絶対 値を返す
rst = A の 絶対 値を返す <eos>
489
src = A = B + C * 3 + 1
trg = B に C に 3 を 掛 け た 値 を加えた 値に 1 を加えた 値を A とする
rst = B に C に 3 を 掛 け た 値 を加えた 値に 1 を加えた 値を A とする <eos>
490
src = A . push ( int ( B ) )
trg = A . push ( int ( B ) )
rst = A . push ( int ( B ) ) <eos>
491
src = for A in range ( B + 1 - C , B ) :
trg = B に 1 を加えた 値 から C を 引 いた 値 から B 未 満 までの 数 列 を 順に A として 、 繰り返す
rst = B に 1 を加えた 値 から C を 引 いた 値 から B 未 満 までの 数 列 を 順に A として 、 繰り返す <eos>
492
src = A . append ( list ( input ( ) . split ( ) ) )
trg = A の 末 尾 に 入力された 文字列を 空白 で 分割 した 字句 列 のリスト を追加する
rst = A の 末 尾 に 入力された 文字列を 空白 で 分割 した 字句 列 のリスト を追加する <eos>
493
src = A . append ( [ 0 ] * ( B + 2 ) )
trg = A の 末 尾 に ( 0 ) からなる 列 の B に 2 を加えた 値 回 分 の 列 を追加する
rst = A の 末 尾 に ( 0 ) からなる 列 の B に 2 を加えた 値 回 分 の 列 を追加する <eos>
494
src = else = 7
trg = 7 を そうでなければ 、 とする
rst = 7 を そうでなければ 、 とする <eos>
495
src = return A [ B . index ( C ) ]
trg = A の B の C と 等 しい 要素 の最初の 位置 番 目 を返す
rst = A の B の C と 等 しい 要素 の最初の 位置 番 目 を返す <eos>
496
src = if A [ B ] <= C or D [ 1 ] == 0 :
trg = A の B 番 目 が C 以下 または D の 1 番 目 が 0 と 等 しい とき 、
rst = A の B 番 目 が C 以下 または D の 1 番 目 が 0 と 等 しい とき 、 <eos>
497
src = A = - 1000000000
trg = -10 0000 0000 を A とする
rst = -10 0000 0000 を A とする <eos>
498
src = A = ( B - C * 1000 ) // 500
trg = B から C に 1000 を 掛 け た 値を 引 いた 値を 500 で 割 った 商 を A とする
rst = B から C に 1000 を 掛 け た 値を 引 いた 値を 500 で 割 った 商 を A とする <eos>
499
src = A [ B ] [ C ] = sum ( [ A [ B - 1 ] [ C - D ] for D in E [ B - 1 ] if D <= C ] )
trg = E の B から 1 を 引 いた 値 番目の 各要素 を D とし 、 D が C 以下の とき の A の B から 1 を 引 いた 値 番目の C から D を 引 いた 値 番目の 列 の 総 和 を A の B 番目の C 番 目 にする
rst = E の B から 1 を 引 いた 値 番 目 が D 以下の とき の E の B から 1 を 引 いた 値 番目の C から D を 引 いた 値 番目の 列 の 総 和 を A の B 番目の C 番 目 にする <eos>
500
src = if A * 2 > 7 :
trg = A に 2 を 掛 け た 値が 7 より 大きい とき 、
rst = A に 2 を 掛 け た 値が 7 より 大きい とき 、 <eos>
501
src = A = [ ( B , C + D ) for B , C , D in A ]
trg = A の 各要素 を B 、 C 、 D とし 、 ( B 、 C に D を加えた 値 ) の 組 の 列 を A とする
rst = A の 各要素 を B 、 C 、 D とし 、 ( B 、 C に D を加えた 値 ) の 組 の 列 を A とする <eos>
502
src = B = convert ( B )
trg = convert ( B ) を B とする
rst = convert ( B ) を B とする <eos>
503
src = return A . fct [ B ] * A . inv [ C ] * A . inv [ B - C ] % A . mod
trg = A の fct の B 番 目 に A の inv の C 番 目 を 掛 け た 値に A の inv の B から C を 引 いた 値 番 目 を 掛 け た 値を A の mod で 割 った 余 り を返す
rst = A の fct の B 番 目 に A の inv の C 番 目 を 掛 け た 値に A の inv の B から C を 引 いた 値 番 目 を 掛 け た 値を A の mod で 割 った 余 り を返す <eos>
504
src = A += ' ' + str ( B . official_house [ C ] [ D ] [ E ] )
trg = A を 空白 文字 に B . official _ house の C 番目の D 番目の E 番目の 文字列 を加えた 値 だけ 増加 させる
rst = A を 空白 文字 に B の official _ house の C 番目の D 番目の E 番目の 文字列 を加えた 値 だけ 増加 させる <eos>
505
src = if A < time [ 1 ] and B < time [ 2 ] :
trg = A が time の 1 番 目 より 小さく かつ B が time の 2 番 目 より 小さい とき 、
rst = A が time の 1 番 目 より 小さく かつ B が time の 2 番 目 より 小さい とき 、 <eos>
506
src = print ( A , B [ A ] + C [ A ] )
trg = A 、 B の A 番 目 に C の A 番 目 を加えた 値 を出力する
rst = A 、 B の A 番 目 に C の A 番 目 を加えた 値 を出力する <eos>
507
src = A = int ( B ** 0.5 ) + 1
trg = B の 0.5 乗 の 整数値 に 1 を加えた 値を A とする
rst = B の 0.5 乗 の 整数値 に 1 を加えた 値を A とする <eos>
508
src = A = max ( A , B + C [ D - 1 - B ] )
trg = A 、 B に C の D から 1 を 引 いた 値 から B を 引 いた 値 番 目 を加えた 値の 最大 値を A とする
rst = A 、 B に C の D から 1 を 引 いた 値 から B を 引 いた 値 番 目 を加えた 値の 最大 値を A とする <eos>
509
src = E = B [ F ] [ D ] - B [ C ] [ D ]
trg = B の F 番目の D 番 目 から B の C 番目の D 番 目 を 引 いた 値を E とする
rst = B の F 番目の D 番 目 から B の C 番目の D 番 目 を 引 いた 値を E とする <eos>
510
src = A = B . x * C . x + B . y * C . y
trg = B の x 座標 に C の x 座標 を 掛 け た 値に B の y 座標 に C の y 座標 を 掛 け た 値 を加えた 値を A とする
rst = B の x 座標 に C の x 座標 を 掛 け た 値に B の y 座標 に C の y 座標 を 掛 け た 値 を加えた 値を A とする <eos>
511
src = A . renew [ B ] = 0
trg = 0 を A の renew の B 番 目 にする
rst = 0 を A の renew の B 番 目 にする <eos>
512
src = A = B . dequeue ( )
trg = B . dequeue () を A とする
rst = B . dequeue () を A とする <eos>
513
src = A = tuple ( [ 2 ** B for B in range ( 16 ) ] )
trg = 0 から 16 未 満 までの 数 列 の 各要素 を B とし 、 2 の B 乗 の 列 の 組 を A とする
rst = 0 から 16 未 満 までの 数 列 の 各要素 を B とし 、 2 の B 乗 の 列 の 組 を A とする <eos>
514
src = for A in range ( 201 ) :
trg = 0 から 20 1 未 満 までの 数 列 を 順に A として 、 繰り返す
rst = 0 から 20 1 未 満 までの 数 列 を 順に A として 、 繰り返す <eos>
515
src = return c ( A . value + B . value )
trg = c ( A . value + B . value ) を返す
rst = c ( A . value + B . value ) を返す <eos>
516
src = A , B = pp ( )
trg = pp () を 展開 し 、 それぞれ A 、 B とする
rst = pop _ team () を 展開 し 、 それぞれ A 、 B とする <eos>
517
src = A , B = search ( A , str ( C ) )
trg = C の 文字列 において 正規表現 A が 最初 にマッチする 位置 を 展開 し 、 それぞれ A 、 B とする
rst = C の 文字列 において 正規表現 A が 最初 にマッチする 位置 を 展開 し 、 それぞれ A 、 B とする <eos>
518
src = A += B [ C ] * B [ D - C ]
trg = A を B の C 番 目 に B の D から C を 引 いた 値 番 目 を 掛 け た 値 だけ 増加 させる
rst = A を B の C 番 目 に B の D から C を 引 いた 値 番 目 を 掛 け た 値 だけ 増加 させる <eos>
519
src = if ( A % 1000 ) // 100 == B // 1000 or ( A % 1000 ) // 100 == ( B % 100 ) // 10 or ( A % 1000 ) // 100 == B % 10 :
trg = A を 1000 で 割 った 余 り を 100 で 割 った 商 が B を 1000 で 割 った 商 と 等 しく または A を 1000 で 割 った 余 り を 100 で 割 った 商 が B を 100 で 割 った 余 り を 10 で 割 った 商 と 等 しく または A を 1000 で 割 った 余 り を 100 で 割 った 商 が B を 10 で 割 った
rst = A を 1000 で 割 った 余 り を 100 で 割 った 商 が B を 1000 で 割 った 商 と 等 しく または A を 1000 で 割 った 余 り を 100 で 割 った 商 が B を 1000 で 割 った 余 り を
520
src = print ( * A [ ( B , C ) ] )
trg = A の ( B 、 C ) の 組 番 目 を 展開 して を出力する
rst = A の ( B 、 C ) の 組 番 目 を 展開 して を出力する <eos>
521
src = A , B = C [ D ] , C [ E ]
trg = C の D 番 目 、 C の E 番 目 を A 、 B とする
rst = C の D 番 目 、 C の E 番 目 を A 、 B とする <eos>
522
src = A [ B ] = C [ B ] + 1
trg = C の B 番 目 に 1 を加えた 値を A の B 番 目 にする
rst = C の B 番 目 に 1 を加えた 値を A の B 番 目 にする <eos>
523
src = A = B . node [ C ]
trg = B の node の C 番 目 を A とする
rst = B の node の C 番 目 を A とする <eos>
524
src = for A , B in [ [ 0 , - 3 ] , [ 0 , - 2 ] , [ 0 , - 1 ] , [ 3 , 0 ] , [ 2 , 0 ] , [ 1 , 0 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 0 , 1 ] , [ - 3 , 0 ] , [ - 2 , 0 ] , [ - 1
trg = ( ( 0 、 -3 ) からなる 列 、 ( 0 、 -2 ) からなる 列 、 ( 0 、 -1 ) からなる 列 、 ( 3 、 0 ) からなる 列 、 ( 2 、 0 ) からなる 列 、 ( 1 、 0 ) からなる 列 、 ( 0 、 3 ) からなる 列 、 ( 0 、 2 ) からなる 列 、 ( 0 、 1 ) からなる 列 、 ( -3 、 0 ) からなる 列
rst = ( ( 0 、 -3 ) からなる 列 、 ( 0 、 -2 ) からなる 列 、 ( 0 、 -1 ) からなる 列 、 ( 0 、 2 ) からなる 列 、 ( 0 、 0 ) からなる 列 、 ( 1 、 0 、 1 ) からなる 列
525
src = A . append ( str ( input ( ) ) )
trg = A の 末 尾 に 入力された 文字列 の 文字列 を追加する
rst = A の 末 尾 に 入力された 文字列 の 文字列 を追加する <eos>
526
src = A [ 1 ] , A [ 5 ] , A [ 0 ] , A [ 3 ] = A [ 0 ] , A [ 1 ] , A [ 3 ] , A [ 5 ]
trg = A の先頭 、 A の 1 番 目 、 A の 3 番 目 、 A の 5 番 目 を A の 1 番 目 、 A の 5 番 目 、 A の先頭 、 A の 3 番 目 とする
rst = A の先頭 、 A の 1 番 目 、 A の 3 番 目 を A の 1 番 目 、 A の 5 番 目 、 A の先頭 、 A の 3 番 目 とする <eos>
527
src = print ( A % ( B , C [ B ] . p ) , end = '' )
trg = 改行 せずに A を ( B 、 C の B 番目の p ) の 組 で 割 った 余 り を出力する
rst = 改行 せずに A を ( B 、 C の B 番目の p で 割 った 余 り ) の 組 で 割 った 余 り を出力する <eos>
528
src = A . G = B
trg = B を A の G にする
rst = B を A の G にする <eos>
529
src = dequeue ( A [ 1 ] )
trg = dequeue ( A [ 1 ] )
rst = dequeue ( A [ 1 ] ) <eos>
530
src = A = [ B , C , D , E , F , G ]
trg = ( B 、 C 、 D 、 E 、 F 、 G ) からなる 列 を A とする
rst = ( B 、 C 、 D 、 E 、 F 、 G ) からなる 列 を A とする <eos>
531
src = A . value [ B ] = ( C , D )
trg = ( C 、 D ) の 組 を A の value の B 番 目 にする
rst = ( C 、 D ) の 組 を A の value の B 番 目 にする <eos>
532
src = A [ B - C ] = e
trg = ネ イ ピ ア 数 を A の B から C を 引 いた 値 番 目 にする
rst = ネ イ ピ ア 数 を A の B から C を 引 いた 値 番 目 にする <eos>
533
src = print ( B . format ( C , ' ' . join ( map ( str , A ) ) ) ) if len ( A ) != 0 else print ( {i}: )
trg = A の長さ が 0 と 等 しく ない とき B を 書式 として C 、 空白 文字 を 間 に 入れ て A の 各要素 に str を適用した 列 を 連結 した 文字列 で 整 形 した 文字列 を出力する 、 そうでなければ " { } : " を出力する
rst = A の長さ が 0 と 等 しく ない とき B を 書式 として C 、 空白 文字 を 間 に 入れ て A の 各要素 に str を適用した 列 を 連結 した 文字列 で 整 形 した 文字列 を出力する 、 そうでなければ 、 つまり 未 定 値 を出力する <eos>
534
src = def d2t ( A ) : return ( A // 100 ) * 60 + ( A % 100 )
trg = 関数 d 2 t を d を パラメータ として 定義 する
rst = 関数 d を パラメータ として 定義 する <eos>
535
src = A = deque ( [ int ( input ( ) ) for B in range ( C ) ] )
trg = 0 から C 未 満 までの 数 列 の 各要素 を B とし 、 、 つまり 入力された 文字列 の 整数値 の 列 の 両 端 キュー を A とする
rst = 0 から C 未 満 までの 数 列 の 各要素 を B とし 、 、 つまり 入力された 文字列 の 整数値 の 列 の 両 端 キュー を A とする <eos>
536
src = A , B = input ( ) . strip ( ) . split ( ' ' )
trg = 入力された 文字列 の 両 端 から 空白 改行 を取り 除 いた 文字列を 空白 文字 で 分割 した 字句 列 を 展開 し 、 それぞれ A 、 B とする
rst = 入力された 文字列 の 両 端 から 空白 改行 を取り 除 いた 文字列を 空白 文字 で 分割 した 字句 列 を 展開 し 、 それぞれ A 、 B とする <eos>
537
src = A , B , C = 2 , 1 , 0
trg = 2 、 1 、 0 を A 、 B 、 C とする
rst = 2 、 1 、 0 を A 、 B 、 C とする <eos>
538
src = print ( A . format ( B - 1911 ) )
trg = A を 書式 として B から 19 11 を 引 いた 値 で 整 形 した 文字列 を出力する
rst = A を 書式 として B から 19 11 を 引 いた 値 で 整 形 した 文字列 を出力する <eos>
539
src = A [ 1 ] = A [ 3 ]
trg = A の 3 番 目 を A の 1 番 目 にする
rst = A の 3 番 目 を A の 1 番 目 にする <eos>
540
src = A , B , C = [ int ( D . readline ( ) ) for E in range ( 3 ) ]
trg = 0 から 3 未 満 までの 数 列 の 各要素 を E とし 、 D から 読み 込 んだ 一行 の 整数値 の 列 を 展開 し 、 それぞれ A 、 B 、 C とする
rst = 0 から 3 未 満 までの 数 列 の 各要素 を E とし 、 D から 読み 込 んだ 一行 の 整数値 の 列 を 展開 し 、 それぞれ A 、 B 、 C とする <eos>
541
src = A = - 1 / B
trg = -1 を B で 割 った 値を A とする
rst = -1 を B で 割 った 値を A とする <eos>
542
src = A , B = C . cross_points ( D )
trg = C . cross _ points ( D ) を 展開 し 、 それぞれ A 、 B とする
rst = C . _ select _ index ( D ) を 展開 し 、 それぞれ A 、 B とする <eos>
543
src = A . append ( B [ C ] + B [ D ] )
trg = A の 末 尾 に B の C 番 目 に B の D 番 目 を加えた 値 を追加する
rst = A の 末 尾 に B の C 番 目 に B の D 番 目 を加えた 値 を追加する <eos>
544
src = A = Node ( None , None , 1 , sys . maxsize )
trg = Node ( None , None , 1, sys . maxsize ) を A とする
rst = Node ( None , None , 1, sys . maxsize ) を A とする <eos>
545
src = A [ B ] = ( B * C + D ) % E
trg = B に C を 掛 け た 値に D を加えた 値を E で 割 った 余 り を A の B 番 目 にする
rst = B に C を 掛 け た 値に D を加えた 値を E で 割 った 余 り を A の B 番 目 にする <eos>
546
src = print ( A * 100 )
trg = A に 100 を 掛 け た 値 を出力する
rst = A に 100 を 掛 け た 値 を出力する <eos>
547
src = print ( int ( min ( A ) ) )
trg = A の 最小 値の 整数値 を出力する
rst = A の 最小 値の 整数値 を出力する <eos>
548
src = if A != B . _parent [ C ] and A != D [ C ] :
trg = A が B の _ parent の C 番 目 と 等 しく なく かつ A が D の C 番 目 と 等 しく ない とき 、
rst = A が B の _ parent の C 番 目 と 等 しく なく かつ A が D の C 番 目 と 等 しく ない とき 、 <eos>
549
src = A = [ [ - 1 for B in range ( C ) ] for D in range ( C ) ]
trg = 0 から C 未 満 までの 数 列 の 各要素 を D とし 、 0 から C 未 満 までの 数 列 の 各要素 を B とし 、 -1 の 列 の 列 を A とする
rst = 0 から C 未 満 までの 数 列 の 各要素 を D とし 、 0 から C 未 満 までの 数 列 の 各要素 を B とし 、 -1 の 列 の 列 を A とする <eos>
550
src = A [ ( B , C , D ) ] = E
trg = E を A の ( B 、 C 、 D ) の 組 番 目 にする
rst = E を A の ( B 、 C 、 D ) の 組 番 目 にする <eos>
551
src = A == B
trg = A が B と 等 しい かどうか
rst = A が B と 等 しい かどうか <eos>
552
src = countingSort ( A , B )
trg = countingSort ( A , B )
rst = <unk> ( A , B ) <eos>
553
src = A = date ( B , C , D )
trg = date ( B , C , D ) を A とする
rst = date ( B , C , D ) を A とする <eos>
554
src = if A != B and all ( [ C in ( 1 , 2 ) for C in ( A , B ) ] ) :
trg = A が B と 等 しく なく かつ ( A 、 B ) の 組 の 各要素 を C とし 、 C が ( 1 、 2 ) の 組 に含まれる かどうか の 列 が 全て が 真 の とき 、
rst = A が B と 等 しく なく かつ ( A 、 B ) の 組 の 各要素 を C とし 、 ( C が 1 、 2 ) の 組 に含まれる かどうか の 列 が 全て が 真 の とき 、 <eos>
555
src = A |= 1 << ( e - 1 )
trg = A を 1 を ネ イ ピ ア 数 から 1 を 引 いた 値 だけ 左 シフト した 値 と の 論理 和 にする
rst = A を 1 を ネ イ ピ ア 数 から 1 を 引 いた 値 だけ 左 シフト した 値 と の 論理 和 にする <eos>
556
src = A = { key : 0 , (kx-1, ky-1, tx-1, ty-1) : 0 }
trg = ( ( B , 0 ) 、 ( ( C から 1 を 引 いた 値 、 D から 1 を 引 いた 値 、 E から 1 を 引 いた 値 、 F から 1 を 引 いた 値 ) の 組 , 0 ) ) からなる 辞書 を A とする
rst = ( ( B , 0 ) 、 ( C , 0 ) ) からなる 辞書 を A とする <eos>
557
src = return _lca ( A [ B ] [ C - 1 ] , A [ D ] [ C - 1 ] )
trg = _ lca ( A [ B ] [ C -1 ] , A [ D ] [ C -1 ] ) を返す
rst = <unk> ( A [ B ] [ C -1 ] , A [ D ] [ C -1 ] ) を返す <eos>
558
src = A = deque ( [ B - 1 ] )
trg = ( B から 1 を 引 いた 値 ) からなる 列 の 両 端 キュー を A とする
rst = ( B から 1 を 引 いた 値 ) からなる 列 の 両 端 キュー を A とする <eos>
559
src = A [ ( B + C [ B ] ) % D ] . append ( B )
trg = A の B に C の B 番 目 を加えた 値を D で 割 った 余 り 番目の 末 尾 に B を追加する
rst = A の B に C の B 番 目 を加えた 値を D で 割 った 余 り 番目の 末 尾 に B を追加する <eos>
560
src = A = B [ C [ D ] [ E ] ]
trg = B の C の D 番目の E 番 目 番 目 を A とする
rst = B の C の D 番目の E 番 目 番 目 を A とする <eos>
561
src = A . find ( B [ 0 ] )
trg = A の先頭 から B の先頭 を 探 して 見つかった 位置
rst = A の先頭 から B の先頭 を 探 して 見つかった 位置 <eos>
562
src = A , B , C = [ int ( D ) for D in E [ F ] . split ( ) ]
trg = E の F 番 目 を 空白 で 分割 した 字句 列 の 各要素 を D とし 、 D の 整数値 の 列 を 展開 し 、 それぞれ A 、 B 、 C とする
rst = E の F 番 目 を 空白 で 分割 した 字句 列 の 各要素 を D とし 、 D の 整数値 の 列 を 展開 し 、 それぞれ A 、 B 、 C とする <eos>
563
src = A . d [ 1 ] , A . d [ 3 ] , A . d [ 6 ] , A . d [ 4 ] = A . d [ 4 ] , A . d [ 1 ] , A . d [ 3 ] , A . d [ 6 ]
trg = A の d の 4 番 目 、 A の d の 1 番 目 、 A の d の 3 番 目 、 A の d の 6 番 目 を A の d の 1 番 目 、 A の d の 3 番 目 、 A の d の 6 番 目 、 A の d の 4 番 目 とする
rst = A の d の 4 番 目 、 A の d の 1 番 目 、 A の d の 3 番 目 、 A の d の 6 番 目 を A の d の 1 番 目 、 A の d の 3 番 目 、 A の
564
src = print ( A % ( ( B - C * D ) / E , D ) )
trg = A を ( B から C * D を 引 いた 値を E で 割 った 値 、 D ) の 組 で 割 った 余 り を出力する
rst = A を ( B から C に D を 掛 け た 値を 引 いた 値を E で 割 った 値 、 D ) の 組 で 割 った 余 り を出力する <eos>
565
src = A = ( ( 0 , 0 ) , ( 1 , 0 ) , ( 0 , 1 ) , ( - 1 , 0 ) , ( 0 , - 1 ) )
trg = ( ( 0 、 0 ) の 組 、 ( 1 、 0 ) の 組 、 ( 0 、 1 ) の 組 、 ( -1 、 0 ) の 組 、 ( 0 、 -1 ) の 組 ) の 組 を A とする
rst = ( ( 0 、 0 ) の 組 、 ( 1 、 0 ) の 組 、 ( 0 、 1 ) の 組 、 ( -1 、 0 ) の 組 、 ( 0 、 -1 ) の 組 ) の 組 を A とする <eos>
566
src = A . _size = B
trg = B を A の _ size にする
rst = B を A の _ size にする <eos>
567
src = for A , B in enumerate ( C [ 1 : ] , start = 1 ) :
trg = 1 を 開始 番号 として C の先頭 を 除 いた 部分 列 に 番号 付 した 組 の 列 を 順に A 、 B として 、 繰り返す
rst = 1 を 開始 番号 として C の先頭 を 除 いた 部分 列 、 番号 付 した 組 の 列 を 順に A 、 B として 、 繰り返す <eos>
568
src = A , B , C = 0 , '' , 1
trg = 0 、 空文字列 、 1 を A 、 B 、 C とする
rst = 0 、 空文字列 、 1 を A 、 B 、 C とする <eos>
569
src = A = [ 1 ] * 50021
trg = (1) からなる 列 の 500 21 回 分 の 列 を A とする
rst = (1) からなる 列 の 500 21 回 分 の 列 を A とする <eos>
570
src = for A , B in [ ( 0 , 0 ) , ( - 1 , 0 ) , ( 1 , 0 ) , ( 0 , - 1 ) , ( 0 , 1 ) ] :
trg = ( ( 0 、 0 ) の 組 、 ( -1 、 0 ) の 組 、 ( 1 、 0 ) の 組 、 ( 0 、 -1 ) の 組 、 ( 0 、 1 ) の 組 ) からなる 列 を 順に A 、 B として 、 繰り返す
rst = ( ( 0 、 0 ) の 組 、 ( -1 、 0 ) の 組 、 ( 1 、 0 ) の 組 、 ( 0 、 1 ) の 組 、 ( 0 、 1 ) の 組 ) からなる 列 を 順に A 、 B として 、
571
src = A = [ [ [ ] , [ ] , [ ] ] , [ [ ] , [ ] , [ ] ] , [ [ ] , [ ] , [ ] ] , [ [ ] , [ ] , [ ] ] ]
trg = ( ( 、 つまり 空 列 、 空 列 、 空 列 ) からなる 列 、 ( 、 つまり 空 列 、 空 列 、 空 列 ) からなる 列 、 ( 、 つまり 空 列 、 空 列 、 空 列 ) からなる 列 、 ( 、 つまり 空 列 、 空 列 、 空 列 ) からなる 列 ) からなる 列 を A とする
rst = ( 、 つまり 空 列 、 空 列 、 空 列 、 空 列 、 空 列 、 空 列 、 空 列 、 空 列 、 空 列 、 空 列 、 空 列 、 空 列 、 空 列 ) からなる 列 を A とする <eos>
572
src = count = 1
trg = 1 を 無限 の 整数 列 とする
rst = 1 を 無限 の 整数 列 とする <eos>
573
src = A . add_edge ( 2 * B , 2 * C , 1 , 0 )
trg = A . add _ edge ( 2 * B , 2 * C , 1, 0 )
rst = A . add _ edge ( 2 * B , 2 * C , 1, 0 ) <eos>
574
src = A = cross_point ( B , C , D , E )
trg = cross _ point ( B , C , D , E ) を A とする
rst = cross _ point ( B , C , D , E ) を A とする <eos>
575
src = A , B , C = abs ( D - E ) , abs ( F - G ) , abs ( H - I )
trg = D から E を 引 いた 値の 絶対 値 、 F から G を 引 いた 値の 絶対 値 、 H から I を 引 いた 値の 絶対 値を A 、 B 、 C とする
rst = D から E を 引 いた 値の 絶対 値 、 F から G を 引 いた 値の 絶対 値 、 H から I を 引 いた 値の 絶対 値を A 、 B 、 C とする <eos>
576
src = print ( A . weight ( B , C ) )
trg = A . weight ( B , C ) を出力する
rst = A . weight ( B , C ) を出力する <eos>
577
src = A = [ [ 0 for B in range ( 1001 ) ] for B in range ( 10 ) ]
trg = 0 から 10 未 満 までの 数 列 の 各要素 を B とし 、 0 から 100 1 未 満 までの 数 列 の 各要素 を B とし 、 0 の 列 の 列 を A とする
rst = 0 から 10 未 満 までの 数 列 の 各要素 を B とし 、 0 から 100 1 未 満 までの 数 列 の 各要素 を B とし 、 0 の 列 の 列 を A とする <eos>
578
src = print ( A . format ( B & C ) )
trg = A を 書式 として B と C の 論理 積 で 整 形 した 文字列 を出力する
rst = A を 書式 として B と C の 論理 積 で 整 形 した 文字列 を出力する <eos>
579
src = for A in range ( B - 1 , 0 , - 1 ) :
trg = B から 1 を 引 いた 値 から 0 未 満 までの -1 間隔 の 数 列 を 順に A として 、 繰り返す
rst = B から 1 を 引 いた 値 から 0 未 満 までの -1 間隔 の 数 列 を 順に A として 、 繰り返す <eos>
580
src = A [ B ] = - 1 * A [ B ]
trg = -1 に A の B 番 目 を 掛 け た 値を A の B 番 目 にする
rst = -1 に A の B 番 目 を 掛 け た 値を A の B 番 目 にする <eos>
581
src = for A in range ( 2 , int ( round ( pow ( B + 1 , 0.5 ) ) ) ) :
trg = 2 から B に 1 を加えた 値の 0.5 乗 を 四 捨 五 入 した 整数値 の 整数値 未 満 までの 数 列 を 順に A として 、 繰り返す
rst = 2 から B に 1 を加えた 値の 0.5 乗 の 整数値 未 満 までの 数 列 を 順に A として 、 繰り返す <eos>
582
src = print ( A . wait )
trg = A の wait を出力する
rst = A の wait を出力する <eos>
583
src = A = list ( map ( lambda B : ( B [ 0 ] , int ( B [ 1 ] ) ) , input ( ) . split ( ) ) )
trg = 入力された 文字列を 空白 で 分割 した 字句 列 の 各要素 に x を パラメータ として ( B の先頭 、 B [ 1 ] の 整数値 ) の 組 を返す関数 を適用した 列 の リストを A とする
rst = 入力された 文字列を 空白 で 分割 した 字句 列 の 各要素 に x を パラメータ として ( B の先頭 、 B の 1 番目の 整数値 、 入力された 文字列を 空白 で 分割 した 字句 列 の 各要素 に x の先頭 を パラメータ として x の 整数値 を返す関数 を適用した 列 の リストを A
584
src = A = ( B * C - D * E ) / ( E * F - C * G )
trg = B に C を 掛 け た 値 から D に E を 掛 け た 値を 引 いた 値を E に F を 掛 け た 値 から C に G を 掛 け た 値を 引 いた 値 で 割 った 値を A とする
rst = B に C を 掛 け た 値 から D に E を 掛 け た 値を 引 いた 値を E に F を 掛 け た 値 から C に G を 掛 け た 値を 引 いた 値 で 割 った 値を A とする <eos>
585
src = A [ B - 1 ] , A [ B ] = A [ B ] , A [ B - 1 ]
trg = A の B から 1 を 引 いた 値 番 目 と A の B 番 目 を 入れ替え る
rst = A の B 番 目 、 A の B から 1 を 引 いた 値 番 目 を A の B から 1 を 引 いた 値 番 目 、 A の B 番 目 とする <eos>
586
src = A = B % ( C + D )
trg = B を C に D を加えた 値 で 割 った 余 り を A とする
rst = B を C に D を加えた 値 で 割 った 余 り を A とする <eos>
587
src = if ( A , B ) == ( C , D ) :
trg = ( A 、 B ) の 組 が ( C 、 D ) の 組 と 等 しい とき 、
rst = ( A 、 B ) の 組 が ( C 、 D ) の 組 と 等 しい とき 、 <eos>
588
src = A = B // _pow ( 10 , 40 )
trg = B を _ pow ( 10 , 40 ) で 割 った 商 を A とする
rst = B を _ pow ( 10 , 40 ) で 割 った 商 を A とする <eos>
589
src = A += [ 5 , 4 , 3 , 2 , 1 , 0 , 1 , 2 , 3 , 4 , 5 ]
trg = A を ( 5 、 4 、 3 、 2 、 1 、 0 、 1 、 2 、 3 、 4 、 5 ) からなる 列 だけ 増加 させる
rst = A を ( 5 、 4 、 3 、 2 、 1 、 0 、 1 、 2 、 3 、 4 、 5 ) からなる 列 だけ 増加 させる <eos>
590
src = A [ B ] = C [ 0 ] [ 2 ]
trg = C の先頭 の 2 番 目 を A の B 番 目 にする
rst = C の先頭 の 2 番 目 を A の B 番 目 にする <eos>
591
src = if 0 <= A < B and 0 <= C < D and ( ( E == 0 and F [ min ( A , A - G ) ] [ H ] == 0 ) or ( G == 0 and I [ J ] [ min ( C , C - E ) ] == 0 ) ) and K [ A ] [ C ] == - 1 :
trg = 0 が A 以下 かどうか が B より 小さく かつ 0 が C 以下 かどうか が D より 小さく かつ E が 0 と 等 しく かつ F [ min ( A , A - G ) ] [ H ] が 0 と 等 しく または G が 0 と 等 しく かつ I [ J ] [ min ( C , C - E ) ] が 0 と 等 しく かつ K の A 番目の C 番
rst = 0 が A 以下 かどうか が B より 小さく かつ 0 が C 以下 かどうか が D より 小さく かつ E が 0 と 等 しく かつ F の A - G 番目の 最小 値が 0 と 等 しく または F の A から G を 引 いた 値 番目の
592
src = A . append ( abs ( B - C ) )
trg = A の 末 尾 に B から C を 引 いた 値の 絶対 値 を追加する
rst = A の 末 尾 に B から C を 引 いた 値の 絶対 値 を追加する <eos>
593
src = dfs ( A . index ( - 1 ) )
trg = dfs ( A . index ( -1 ) )
rst = dfs ( A . index ( -1 ) ) <eos>
594
src = A . FaceValue [ B ] = C
trg = C を A の FaceValue の B 番 目 にする
rst = C を A の FaceValue の B 番 目 にする <eos>
595
src = A [ B ] = C [ B ] = 1
trg = 1 を C の B 番 目 とする を A の B 番 目 にする
rst = 1 を C の B 番 目 とする を A の B 番 目 にする <eos>
596
src = A . append ( pos ( B [ C * 2 ] , B [ C * 2 + 1 ] ) )
trg = A の 末 尾 に pos ( B [ C * 2 ] , B [ C * 2 + 1 ] ) を追加する
rst = A の 末 尾 に pos ( B の C に 2 を 掛 け た 値 番 目 、 B の C に 2 を 掛 け た 値に 1 を加えた 値 番 目 ) の 組 を追加する <eos>
597
src = for A in range ( B * ( B - 1 ) // 2 ) :
trg = 0 から B に B から 1 を 引 いた 値を 掛 け た 値を 2 で 割 った 商 未 満 までの 数 列 を 順に A として 、 繰り返す
rst = 0 から B に B から 1 を 引 いた 値を 掛 け た 値を 2 で 割 った 商 未 満 までの 数 列 を 順に A として 、 繰り返す <eos>
598
src = A = B [ C ] - D [ E ]
trg = B の C 番 目 から D の E 番 目 を 引 いた 値を A とする
rst = B の C 番 目 から D の E 番 目 を 引 いた 値を A とする <eos>
599
src = A = [ [ 0 for B in range ( C ) ] for D in range ( C ) ]
trg = 0 から C 未 満 までの 数 列 の 各要素 を D とし 、 0 から C 未 満 までの 数 列 の 各要素 を B とし 、 0 の 列 の 列 を A とする
rst = 0 から C 未 満 までの 数 列 の 各要素 を D とし 、 0 から C 未 満 までの 数 列 の 各要素 を B とし 、 0 の 列 の 列 を A とする <eos>
600
src = sys . stdin = open ( A , B )
trg = A 、 B を 開 いた ファイル ストリーム を sys の stdin にする
rst = A 、 B を 開 いた ファイル ストリーム を sys の stdin にする <eos>
601
src = while A [ B ] :
trg = A の B 番目の 間 、 次 を 繰り返す
rst = A の B 番目の 間 、 次 を 繰り返す <eos>
602
src = A = list ( map ( lambda C : C * B [ 0 ] , A ) )
trg = A の 各要素 に x を パラメータ として x に B の先頭 を 掛 け た 値を返す 関数 を適用した 列 の リストを A とする
rst = A の 各要素 に x を パラメータ として x に B の先頭 を 掛 け た 値を返す 関数 を適用した 列 の リストを A とする <eos>
603
src = print ( A - sum ( B ) )
trg = A から B の 総 和 を 引 いた 値 を出力する
rst = A から B の 総 和 を 引 いた 値 を出力する <eos>
604
src = A = [ 1 , 10 , 11 , 12 , 13 ]
trg = ( 1 、 10 、 11 、 12 、 13 ) からなる 列 を A とする
rst = ( 1 、 10 、 11 、 12 、 13 ) からなる 列 を A とする <eos>
605
src = print ( E if abs ( cross ( A - B , C - D ) ) < 1e-10 else F )
trg = cross ( A - B , C - D ) の 絶対 値が 1 e -10 より 小さい とき E 、 そうでなければ F を出力する
rst = cross ( A - B , C - D ) の 絶対 値が 1 e -10 より 小さい とき E 、 そうでなければ F を出力する <eos>
606
src = for A in range ( B . bit_length ( ) - 1 ) :
trg = 0 から B の ビット 長 から 1 を 引 いた 値 未 満 までの 数 列 を 順に A として 、 繰り返す
rst = 0 から B の ビット 長 から 1 を 引 いた 値 未 満 までの 数 列 を 順に A として 、 繰り返す <eos>
607
src = if A != 0 and B != 0 :
trg = A が 0 と 等 しく なく かつ B が 0 と 等 しく ない とき 、
rst = A が 0 と 等 しく なく かつ B が 0 と 等 しく ない とき 、 <eos>
608
src = return ( A . count ( B ) , A [ - 1 ] )
trg = ( A 内の B の 出現 回数 、 A の 末 尾 ) の 組 を返す
rst = ( A 内の B の 出現 回数 、 A の 末 尾 ) の 組 を返す <eos>
609
src = A [ B ] [ C ] [ D ] -= 1
trg = A の B 番目の C 番目の D 番 目 を 1 だけ 減少 させる
rst = A の B 番目の C 番目の D 番 目 を 1 だけ 減少 させる <eos>
610
src = A . cap -= B
trg = A の cap を B だけ 減少 させる
rst = A の cap を B だけ 減少 させる <eos>
611
src = if A <= 125 :
trg = A が 1 25 以下の とき 、
rst = A が 1 25 以下の とき 、 <eos>
612
src = return A . query ( ( B - 1 ) // 2 , C , D )
trg = A . query ( ( B -1 ) / /2 , C , D ) を返す
rst = A . query ( ( B -1 ) / /2 , C , D ) を返す <eos>
613
src = A , B , C , D , E = map ( int , input ( ) . split ( ) )
trg = 入力された 文字列を 空白 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 を 展開 し 、 それぞれ A 、 B 、 C 、 D 、 E とする
rst = 入力された 文字列を 空白 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 を 展開 し 、 それぞれ A 、 B 、 C 、 D 、 E とする <eos>
614
src = if A == B or A == [ 1 , 10 , 11 , 12 , 13 ] :
trg = A が B と 等 しく または A が ( 1 、 10 、 11 、 12 、 13 ) からなる 列 と 等 しい とき 、
rst = A が B と 等 しく または A が ( 1 、 10 、 11 、 12 、 13 ) からなる 列 と 等 しい とき 、 <eos>
615
src = print ( math . ceil ( ( A * B - C ) / D ) if A * B - C >= 0 else 0 )
trg = A に B を 掛 け た 値 から C を 引 いた 値が 0 以上の とき A * B から C を 引 いた 値を D で 割 った 値の 切り 上げ 整数値 、 そうでなければ 0 を出力する
rst = A に B を 掛 け た 値 から C を 引 いた 値が 0 以上の とき A * B から C を 引 いた 値を D で 割 った 値の 切り 上げ 整数値 、 そうでなければ 0 を出力する <eos>
616
src = A = min ( A , B [ C ] [ D + 1 ] + B [ D + 1 ] [ E + 1 ] )
trg = A 、 B の C 番目の D に 1 を加えた 値 番 目 に B の D に 1 を加えた 値 番目の E に 1 を加えた 値 番 目 を加えた 値の 最小 値を A とする
rst = A 、 B の C 番目の D に 1 を加えた 値 番 目 に B の D に 1 を加えた 値 番目の E に 1 を加えた 値 番 目 を加えた 値の 最小 値を A とする <eos>
617
src = if A [ 0 : 2 ] == B and A [ - 1 : ] == C :
trg = A の 、 つまり 先頭 から 2 番 目 までの 部分 列 が B と 等 しく かつ A の 、 つまり 末 尾 から 、 つまり 末 尾 までの 部分 列 が C と 等 しい とき 、
rst = A の 、 つまり 先頭 から 2 番 目 までの 部分 列 が B と 等 しく かつ A の 、 つまり 末 尾 から 、 つまり 末 尾 までの 部分 列 が C と 等 しい とき 、 <eos>
618
src = A . mp [ B ] [ C ] = D [ B ]
trg = D の B 番 目 を A の mp の B 番目の C 番 目 にする
rst = D の B 番 目 を A の mp の B 番目の C 番 目 にする <eos>
619
src = if 0 <= - A <= B :
trg = 0 が - A 以下 かどうか が B 以下の とき 、
rst = 0 が - A 以下 かどうか が B 以下の とき 、 <eos>
620
src = A . pages = { }
trg = 空 辞書 を A の pages にする
rst = 空 辞書 を A の pages にする <eos>
621
src = A = [ list ( map ( int , input ( ) . split ( ) ) ) for B in range ( 3 ) ]
trg = 0 から 3 未 満 までの 数 列 の 各要素 を B とし 、 、 つまり 入力された 文字列を 空白 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 のリスト の 列 を A とする
rst = 0 から 3 未 満 までの 数 列 の 各要素 を B とし 、 、 つまり 入力された 文字列を 空白 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 のリスト の 列 を A とする <eos>
622
src = if solver ( A , B , C , D [ : E ] + [ F ] + D [ E + 1 : ] ) :
trg = solver ( A , B , C , D [ : E ] + [ F ] + D [ E + 1 : ] ) の とき 、
rst = <unk> ( A , B , C , D [ : E ] + [ F ] + D [ E + 1 : ] ) の とき 、 <eos>
623
src = if A not in B . forest :
trg = A が B の forest に 含まれ ない とき 、
rst = A が B の forest に 含まれ ない とき 、 <eos>
624
src = A , B = [ int ( C ) for C in input ( ) . split ( ) ]
trg = 入力された 文字列を 空白 で 分割 した 字句 列 の 各要素 を C とし 、 C の 整数値 の 列 を 展開 し 、 それぞれ A 、 B とする
rst = 入力された 文字列を 空白 で 分割 した 字句 列 の 各要素 を C とし 、 C の 整数値 の 列 を 展開 し 、 それぞれ A 、 B とする <eos>
625
src = if A & ( 1 << B ) :
trg = A と 1 を B だけ 左 シフト した 値の 論理 積 の とき 、
rst = A と 1 を B だけ 左 シフト した 値の 論理 積 の とき 、 <eos>
626
src = A . add_edge ( B , C + D , 1 , E )
trg = A . add _ edge ( B , C + D , 1, E )
rst = A . add _ edge ( B , C + D , 1, E ) <eos>
627
src = A [ B + 2 ] [ C ] = D
trg = D を A の B に 2 を加えた 値 番目の C 番 目 にする
rst = D を A の B に 2 を加えた 値 番目の C 番 目 にする <eos>
628
src = func ( A )
trg = func ( A )
rst = func ( A ) <eos>
629
src = if df_lower_search ( A , 0 , B , C , None ) :
trg = df _ lower _ search ( A , 0 , B , C , None ) の とき 、
rst = df _ lower _ search ( A , 0 , B , C , None ) の とき 、 <eos>
630
src = A = max ( max ( ( [ B [ C ] for C in range ( D ) if E != C ] ) , default = F ) , F )
trg = F を default として 0 から D 未 満 までの 数 列 の 各要素 を C とし 、 E が C と 等 しく ない とき の B の C 番目の 列 の 最大 値 、 F の 最大 値を A とする
rst = F を default として 0 から D 未 満 までの 数 列 の 各要素 を C とし 、 E が C と 等 しく ない とき の B の C 番目の 列 の 最大 値 、 F の 最大 値を A とする <eos>
631
src = A = B * C * D / E
trg = B に C を 掛 け た 値に D を 掛 け た 値を E で 割 った 値を A とする
rst = B に C を 掛 け た 値に D を 掛 け た 値を E で 割 った 値を A とする <eos>
632
src = A [ 1 ] , A [ 2 ] = A [ 2 ] , A [ 1 ]
trg = A の 2 番 目 、 A の 1 番 目 を A の 1 番 目 、 A の 2 番 目 とする
rst = A の 2 番 目 、 A の 1 番 目 を A の 1 番 目 、 A の 2 番 目 とする <eos>
633
src = A = ( 1000 - B - 1 ) * 195
trg = 1000 から B を 引 いた 値 から 1 を 引 いた 値に 195 を 掛 け た 値を A とする
rst = 195 から B を 引 いた 値 から 1 を 引 いた 値に 195 を 掛 け た 値を A とする <eos>
634
src = print ( A [ B - 1 ] , A [ B + 1 ] )
trg = A の B から 1 を 引 いた 値 番 目 、 A の B に 1 を加えた 値 番 目 を出力する
rst = A の B から 1 を 引 いた 値 番 目 、 A の B に 1 を加えた 値 番 目 を出力する <eos>
635
src = if A in B [ C ] and D in B [ C ] :
trg = A が B の C 番 目 に 含まれ かつ D が B の C 番 目 に含まれる とき 、
rst = A が B の C 番 目 に 含まれ かつ D が B の C 番 目 に含まれる とき 、 <eos>
636
src = A . distance [ B ] [ C ] = min ( A . distance [ B ] [ C ] , A . distance [ B ] [ D ] + A . distance [ D ] [ C ] )
trg = A の distance の B 番目の C 番 目 、 A の distance の B 番目の D 番 目 に A の distance の D 番目の C 番 目 を加えた 値の 最小 値を A の distance の B 番目の C 番 目 にする
rst = A の distance の B 番目の C 番 目 、 A の distance の B 番目の D 番 目 に A の distance の C 番 目 を加えた 値の 最小 値を A の distance の B 番目の C 番 目 にする <eos>
637
src = A = dfs ( B , C , 0 , 0 , 0 , D + 1 )
trg = dfs ( B , C , 0 , 0 , 0 , D + 1 ) を A とする
rst = dfs ( B , C , 0 , 0 , D + 1 ) を A とする <eos>
638
src = print ( str ( A + 1 ) + B + C [ A ] )
trg = A に 1 を加えた 値の 文字列 に B を加えた 値に C の A 番 目 を加えた 値 を出力する
rst = A に 1 を加えた 値の 文字列 に B を加えた 値に C の A 番 目 を加えた 値 を出力する <eos>
639
src = if len ( A ) != 0 or B == False :
trg = A の長さ が 0 と 等 しく なく または B が 、 つまり 偽 と 等 しい とき 、
rst = A の長さ が 0 と 等 しく なく または B が 、 つまり 偽 と 等 しい とき 、 <eos>
640
src = A = get_cycle ( B , C , D )
trg = get _ cycle ( B , C , D ) を A とする
rst = <unk> ( B , C , D ) を A とする <eos>
641
src = A = [ B ] + [ sum ( map ( int , C . readline ( ) . split ( ) ) ) for D in range ( 4 ) ]
trg = ( B ) からなる 列 に 0 から 4 未 満 までの 数 列 の 各要素 を D とし 、 C . readline () を 空白 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 の 総 和 の 列 を加えた 値を A とする
rst = ( B ) からなる 列 に 0 から 4 未 満 までの 数 列 の 各要素 を D とし 、 C から 読み 込 んだ 一行 を 空白 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 の 総 和 の 列 を加えた 値を A とする <eos>
642
src = while A < B [ C [ 0 ] ] * D :
trg = A が B の C の先頭 番 目 に D を 掛 け た 値 より 小さい 間 、 次 を 繰り返す
rst = A が B の C の先頭 番 目 に D を 掛 け た 値 より 小さい 間 、 次 を 繰り返す <eos>
643
src = A = A - 25 * B
trg = A から 25 に B を 掛 け た 値を 引 いた 値を A とする
rst = A から 25 に B を 掛 け た 値を 引 いた 値を A とする <eos>
644
src = A = [ set ( range ( B ) ) for C in range ( B ) ]
trg = 0 から B 未 満 までの 数 列 の 各要素 を C とし 、 0 から B 未 満 までの 数 列 の集合 の 列 を A とする
rst = 0 から B 未 満 までの 数 列 の 各要素 を C とし 、 0 から B 未 満 までの 数 列 の集合 の 列 を A とする <eos>
645
src = A = - 10 ** 18
trg = -10 の 18 乗 を A とする
rst = -10 の 18 乗 を A とする <eos>
646
src = print ( A ) if ( input ( ) * 2 ) . find ( input ( ) ) > - 1 else print ( B )
trg = 入力された 文字列 に 2 を 掛 け た 値 の先頭 から 、 つまり 入力された 文字列を 探 して 見つかった 位置 が -1 より 大きい とき A を出力する 、 そうでなければ B を出力する
rst = input () に 2 を 掛 け た 値 から 、 つまり 入力された 文字列 の 2 番 目 から 、 つまり 入力された 文字列 が -1 と 等 しい とき A 、 そうでなければ B を出力する <eos>
647
src = A = [ ( B , None , 0 ) ]
trg = ( ( B 、 未 定 値 、 0 ) の 組 ) からなる 列 を A とする
rst = ( ( B 、 未 定 値 、 0 ) の 組 ) からなる 列 を A とする <eos>
648
src = return put_queen_in_row ( A + 1 )
trg = put _ queen _ in _ row ( A + 1 ) を返す
rst = put _ queen _ in _ row ( A + 1 ) を返す <eos>
649
src = A = min ( 9 , B )
trg = 9 、 B の 最小 値を A とする
rst = 9 、 B の 最小 値を A とする <eos>
650
src = if A . _is_red ( B . left ) and A . _is_red ( B . left . left ) :
trg = A . _ is _ red ( B . left ) かつ A . _ is _ red ( B . left . left ) の とき 、
rst = A . _ is _ red ( B . left ) かつ A . _ is _ red ( B . left ) の とき 、 <eos>
651
src = attack ( A , B , C )
trg = attack ( A , B , C )
rst = <unk> ( A , B , C ) <eos>
652
src = A = combinations ( B , 2 )
trg = B の 2 個 までの コン ビ ネ ー ション を A とする
rst = B の 2 個 までの コン ビ ネ ー ション を A とする <eos>
653
src = A += B [ C [ - 1 ] ] [ - 1 ]
trg = A を B の C の 末 尾 番目の 末 尾 だけ 増加 させる
rst = A を B の C の 末 尾 番目の 末 尾 だけ 増加 させる <eos>
654
src = A = B * C * sin ( D ) * 0.5
trg = B に C を 掛 け た 値に D の 正 弦 を 掛 け た 値に 0.5 を 掛 け た 値を A とする
rst = B に C を 掛 け た 値に D の 正 弦 を 掛 け た 値に 0.5 を 掛 け た 値を A とする <eos>
655
src = A [ B + C ] = D . FREE
trg = D の FREE を A の B に C を加えた 値 番 目 にする
rst = D の FREE を A の B に C を加えた 値 番 目 にする <eos>
656
src = A = ( B [ C ] [ D ] + 2 == B [ C + 1 ] [ D ] )
trg = B の C 番目の D 番 目 に 2 を加えた 値が B の C に 1 を加えた 値 番目の D 番 目 と 等 しい かどうか を A とする
rst = B の C 番目の D 番 目 に 2 を加えた 値が B の C に 1 を加えた 値 番目の D 番 目 と 等 しい かどうか を A とする <eos>
657
src = print ( int ( ( A * B + C * D ) * 0.8 ) )
trg = A に B を 掛 け た 値に C に D を 掛 け た 値 を加えた 値に 0 . 8 を 掛 け た 値の 整数値 を出力する
rst = A に B を 掛 け た 値に C に D を 掛 け た 値 を加えた 値に 0 . 8 を 掛 け た 値の 整数値 を出力する <eos>
658
src = if A - 1 < B :
trg = A から 1 を 引 いた 値が B より 小さい とき 、
rst = A から 1 を 引 いた 値が B より 小さい とき 、 <eos>
659
src = if A [ 0 : 2 ] == B and A [ - 2 : ] == C :
trg = A の 、 つまり 先頭 から 2 番 目 までの 部分 列 が B と 等 しく かつ A の -2 番 目 から 、 つまり 末 尾 までの 部分 列 が C と 等 しい とき 、
rst = A の 、 つまり 先頭 から 2 番 目 までの 部分 列 が B と 等 しく かつ A の -2 番 目 から 、 つまり 末 尾 までの 部分 列 が C と 等 しい とき 、 <eos>
660
src = A = max ( [ ( B + 27 * ( C - e ) == D ) + ( E + 9 * ( C - e ) == D ) + ( F + 3 * ( C - e ) == D ) + ( G + ( C - e ) == D ) for C in H ] )
trg = H の 各要素 を C とし 、 ( B + 27 * ( C - e ) == D ) に ( E + 9 * ( C - e ) == D ) を加えた 値に F + 3 * ( C - e ) が D と 等 しい かどうか を加えた 値に G に ( C - e ) を加えた 値が D と 等 しい かどうか を加えた 値の 列 の 最大 値を A とする
rst = D から H を 引 いた 値に C から D を 引 いた 値を 掛 け た 値に E を加えた 値 を加えた 値 と F から G を 引 いた 値に C から D を 引 いた 値を 掛 け た 値に ネ イ ピ ア 数 + ( e
661
src = return A * B < 100 * C
trg = A に B を 掛 け た 値が 100 に C を 掛 け た 値 より 小さい かどうか を返す
rst = A に B を 掛 け た 値が 100 に C を 掛 け た 値 より 小さい かどうか を返す <eos>
662
src = A . graph [ B ] [ C ] [ 2 ] += D
trg = A の graph の B 番目の C 番目の 2 番 目 を D だけ 増加 させる
rst = A の graph の B 番目の C 番目の 2 番 目 を D だけ 増加 させる <eos>
663
src = if A [ 1 ] == B [ 1 ] == C [ 1 ] :
trg = A の 1 番 目 が B の 1 番 目 と 等 しい かどうか が C の 1 番 目 と 等 しい とき 、
rst = A の 1 番 目 が B の 1 番 目 と 等 しい かどうか が C の 1 番 目 と 等 しい とき 、 <eos>
664
src = A [ B - 3 ] = ( C , D )
trg = ( C 、 D ) の 組 を A の B から 3 を 引 いた 値 番 目 にする
rst = ( C 、 D ) の 組 を A の B から 3 を 引 いた 値 番 目 にする <eos>
665
src = A . length = 0
trg = 0 を A の length にする
rst = 0 を A の length にする <eos>
666
src = A = get ( B , C , D , E , F , 2 ) [ : ]
trg = get ( B , C , D , E , F , 2 ) の コピー された 列 を A とする
rst = get ( B , C , D , E , F , 2 ) の コピー された 列 を A とする <eos>
667
src = A = B [ - 1 ] - B [ 0 ]
trg = B の 末 尾 から B の先頭 を 引 いた 値を A とする
rst = B の -1 番 目 から B の先頭 を 引 いた 値を A とする <eos>
668
src = A [ B ] [ C ] = D + 1
trg = D に 1 を加えた 値を A の B 番目の C 番 目 にする
rst = D に 1 を加えた 値を A の B 番目の C 番 目 にする <eos>
669
src = if str . isnumeric ( A [ B ] ) == True :
trg = 整数 、 A の B 番 目 が 全て 数字 かどうか が 、 つまり 真 と 等 しい とき 、
rst = 整数 、 A の B 番目の 文字列 が 、 つまり 真 と 等 しい とき 、 <eos>
670
src = print ( A * ( - B ) , sep = '' , end = '' )
trg = 区切り なしで 改行 せずに A に - B を 掛 け た 値 を出力する
rst = 区切り なしで 改行 せずに A に - B を 掛 け た 値 を出力する <eos>
671
src = return max ( A . values ( ) )
trg = A の値 の集まり の 最大 値を返す
rst = A の値 の集まり の 最大 値を返す <eos>
672
src = A = [ '' for B in range ( len ( C ) ) ]
trg = 0 から C の長さ 未 満 までの 数 列 の 各要素 を B とし 、 、 つまり 空文字列 の 列 を A とする
rst = 0 から C の長さ 未 満 までの 数 列 の 各要素 を B とし 、 、 つまり 空文字列 の 列 を A とする <eos>
673
src = A = { b : [ [ [ 0 ] * 10 , [ 0 ] * 10 , [ 0 ] * 10 ] for B in range ( 1 , 5 ) ] }
trg = ( ( B , 1 から 5 未 満 までの 数 列 の 各要素 を B とし 、 ( [ 0 ] の 10 回 分 の 列 、 [ 0 ] の 10 回 分 の 列 、 [ 0 ] の 10 回 分 の 列 ) からなる 列 の 列 ) ) からなる 辞書 を A とする
rst = ( ( B , 0 から 1 未 満 までの 数 列 の 各要素 を B とし 、 ( ( 0 ) からなる 列 の 10 回 分 の 列 ) からなる 列 の 10 回 分 の 列 ) 、 ( ( 0 、 10 ) からなる 列 の
674
src = A [ 4 ] = B [ 4 ]
trg = B の 4 番 目 を A の 4 番 目 にする
rst = B の 4 番 目 を A の 4 番 目 にする <eos>
675
src = A = len ( B . pos )
trg = B の pos の長さ を A とする
rst = B の pos の長さ を A とする <eos>
676
src = A [ B + 1 ] = C
trg = C を A の B に 1 を加えた 値 番 目 にする
rst = C を A の B に 1 を加えた 値 番 目 にする <eos>
677
src = return ( 7 - A , B , C )
trg = ( 7 から A を 引 いた 値 、 B 、 C ) の 組 を返す
rst = ( 7 から A を 引 いた 値 、 B 、 C ) の 組 を返す <eos>
678
src = write ( A % sum ( B ) )
trg = write ( A % sum ( B ) )
rst = write ( A % sum ( B ) ) <eos>
679
src = A = segmentTree ( B , C , sentinel = 0 )
trg = segmentTree ( B , C , sentinel = 0 ) を A とする
rst = <unk> ( B , C , <unk> ( 0 ) ) を A とする <eos>
680
src = if A . isalpha ( ) and A not in B :
trg = A が 全て アルファベット かつ A が B に 含まれ ない とき 、
rst = A が 全て アルファベット かつ A が B に 含まれ ない とき 、 <eos>
681
src = print ( sum ( [ ( A - B - 1 ) * C [ B ] for B in range ( A ) ] ) )
trg = 0 から A 未 満 までの 数 列 の 各要素 を B とし 、 A - B から 1 を 引 いた 値に C の B 番 目 を 掛 け た 値の 列 の 総 和 を出力する
rst = 0 から A 未 満 までの 数 列 の 各要素 を B とし 、 A から B を 引 いた 値に C の B 番 目 を 掛 け た 値の 列 の 総 和 を出力する <eos>
682
src = A [ B ] [ C ] [ D ] += A [ B - 1 ] [ E ] [ F ] / 4
trg = A の B 番目の C 番目の D 番 目 を A の B から 1 を 引 いた 値 番目の E 番目の F 番 目 を 4 で 割 った 値 だけ 増加 させる
rst = A の B 番目の C 番目の D 番 目 を A の B から 1 を 引 いた 値 番目の E 番 目 を F で 割 った 値 だけ 増加 させる <eos>
683
src = return A // gcd ( A , B ) * B
trg = A を A と B の 最大 公 約 数 で 割 った 商 に B を 掛 け た 値を返す
rst = A を A と B の 最大 公 約 数 で 割 った 商 に B を 掛 け た 値を返す <eos>
684
src = print ( A . join ( [ '\n' . join ( map ( str , B ) ) for B in C ] ) )
trg = A を 間 に 入れ て C の 各要素 を B とし 、 、 つまり 改行 文字 を 間 に 入れ て B の 各要素 に str を適用した 列 を 連結 した 文字列 の 列 を 連結 した 文字列 を出力する
rst = A を 間 に 入れ て C の 各要素 を B とし 、 、 つまり 改行 文字 を 間 に 入れ て B の 各要素 に 整数 を適用した 列 を 連結 した 文字列 の 列 を 連結 した 文字列 を出力する <eos>
685
src = A . bit . append ( 0 )
trg = A の bit の 末 尾 に 0 を追加する
rst = A の bit の 末 尾 に 0 を追加する <eos>
686
src = A , B = [ int ( C ) for C in input ( ) . split ( D ) ]
trg = 入力された 文字列を D で 分割 した 字句 列 の 各要素 を C とし 、 C の 整数値 の 列 を 展開 し 、 それぞれ A 、 B とする
rst = 入力された 文字列を D で 分割 した 字句 列 の 各要素 を C とし 、 C の 整数値 の 列 を 展開 し 、 それぞれ A 、 B とする <eos>
687
src = if A > - 1 :
trg = A が -1 より 大きい とき 、
rst = A が -1 より 大きい とき 、 <eos>
688
src = A [ B + 1 ] = min ( A [ B ] , A [ B + 1 ] )
trg = A の B 番 目 、 A の B に 1 を加えた 値 番目の 最小 値を A の B に 1 を加えた 値 番 目 にする
rst = A の B 番 目 、 A の B に 1 を加えた 値 番目の 最小 値を A の B に 1 を加えた 値 番 目 にする <eos>
689
src = print ( ' ' . join ( [ str ( A ) for A in B . postorder ( ) ] ) )
trg = 空白 文字 を 間 に 入れ て B . postorder () の 各要素 を A とし 、 A の 文字列 の 列 を 連結 した 文字列 を出力する
rst = 空白 文字 を 間 に 入れ て B . postorder () の 各要素 を A とし 、 A の 文字列 の 列 を 連結 した 文字列 を出力する <eos>
690
src = for A in input ( ) . strip ( ) :
trg = 入力された 文字列 の 両 端 から 空白 改行 を取り 除 いた 文字列を 順に A として 、 繰り返す
rst = 入力された 文字列 の 両 端 から 空白 改行 を取り 除 いた 文字列 を 順に A として 、 繰り返す <eos>
691
src = D [ C ] += 1
trg = D の C 番 目 を 1 だけ 増加 させる
rst = D の C 番 目 を 1 だけ 増加 させる <eos>
692
src = while A [ B ] != C [ D ] :
trg = A の B 番 目 が C の D 番 目 と 等 しく ない 間 、 次 を 繰り返す
rst = A の B 番 目 が C の D 番 目 と 等 しく ない 間 、 次 を 繰り返す <eos>
693
src = A . add ( B - 1 , C )
trg = A に B から 1 を 引 いた 値 、 C を追加した 集 ま り
rst = A に B から 1 を 引 いた 値 、 C を追加した 集 ま り <eos>
694
src = A = math . ceil ( A )
trg = A の 切り 上げ 整数値 を A とする
rst = A の 切り 上げ 整数値 を A とする <eos>
695
src = A [ B ] [ C ] = 1 - A [ B ] [ C ]
trg = 1 から A の B 番目の C 番 目 を 引 いた 値を A の B 番目の C 番 目 にする
rst = 1 から A の B 番目の C 番 目 を 引 いた 値を A の B 番目の C 番 目 にする <eos>
696
src = A , B = bridge_finding ( C , D )
trg = bridge _ finding ( C , D ) を 展開 し 、 それぞれ A 、 B とする
rst = solve _ int ( C , D ) を 展開 し 、 それぞれ A 、 B とする <eos>
697
src = print ( traveling_salesman ( A , B ) )
trg = traveling _ salesman ( A , B ) を出力する
rst = <unk> ( A , B ) を出力する <eos>
698
src = A [ B ] [ C ] = A [ B ] [ C - D [ 0 ] [ 1 ] ] + D [ 0 ] [ 0 ]
trg = A の B 番目の C から D の先頭 の 1 番 目 を 引 いた 値 番 目 に D の先頭 の先頭 を加えた 値を A の B 番目の C 番 目 にする
rst = A の B 番目の C から D の先頭 の 1 番 目 を 引 いた 値 番 目 に D の先頭 を加えた 値を A の B 番目の C 番 目 にする <eos>
699
src = A = - 2000000001
trg = - 2000 0000 01 を A とする
rst = - 2000 0000 00 を A とする <eos>
700
src = A = math . sin ( B ) * ( C - D ) + math . cos ( B ) * ( E - F ) + F
trg = B の 正 弦 に C から D を 引 いた 値を 掛 け た 値に B の 余 弦 に E から F を 引 いた 値を 掛 け た 値 を加えた 値に F を加えた 値を A とする
rst = B の 正 弦 に C から D を 引 いた 値を 掛 け た 値に B の 余 弦 に E から F を 引 いた 値を 掛 け た 値 を加えた 値に F を加えた 値を A とする <eos>
701
src = A = B . size [ B . root ] // 2
trg = B の size の B の root 番 目 を 2 で 割 った 商 を A とする
rst = B の size の B の root 番 目 を 2 で 割 った 商 を A とする <eos>
702
src = A = [ - 1 , 1 , 0 , 0 ]
trg = ( -1 、 1 、 0 、 0 ) からなる 列 を A とする
rst = ( -1 、 1 、 0 、 0 ) からなる 列 を A とする <eos>
703
src = D = E [ - 1 - C ]
trg = E の -1 から C を 引 いた 値 番 目 を D とする
rst = E の -1 から C を 引 いた 値 番 目 を D とする <eos>
704
src = A = dimension ( B , C )
trg = dimension ( B , C ) を A とする
rst = <unk> ( B , C ) を A とする <eos>
705
src = A = _find_cycle ( B , C )
trg = _ find _ cycle ( B , C ) を A とする
rst = <unk> ( B , C ) を A とする <eos>
706
src = A = int ( - 1e10 )
trg = -1 e 10 の 整数値 を A とする
rst = 1 e -10 の 整数値 を A とする <eos>
707
src = return int ( A . replace ( B , str ( C ) ) )
trg = A 内の B を C の 文字列 で 置き換え た 文字列 の 整数 値を返す
rst = A 内の B を C の 文字列 で 置き換え た 文字列 の 整数 値を返す <eos>
708
src = print ( ' ' . join ( map ( str , A [ count - 1 ] ) ) )
trg = 空白 文字 を 間 に 入れ て A の count から 1 を 引 いた 値 番目の 各要素 に 整数 を適用した 列 を 連結 した 文字列 を出力する
rst = 空白 文字 を 間 に 入れ て A の 、 つまり 無限 の 整数 列 から 1 を 引 いた 値 番目の 各要素 に 整数 列 を適用した 列 を 連結 した 文字列 を出力する <eos>
709
src = F = G [ E ] - G [ C ]
trg = G の E 番 目 から G の C 番 目 を 引 いた 値を F とする
rst = G の E 番 目 から G の C 番 目 を 引 いた 値を F とする <eos>
710
src = A = [ 1 , 2 , 4 , 8 , 16 , 32 , 64 , 128 , 256 , 512 ]
trg = ( 1 、 2 、 4 、 8 、 16 、 32 、 64 、 1 28 、 25 6 、 5 12 ) からなる 列 を A とする
rst = ( 1 、 2 、 4 、 8 、 32 、 64 、 32 、 36 、 6 7 6 、 8 1 、 100 ) からなる 列 を A とする <eos>
711
src = if cross ( A - B , C - B ) > 0 :
trg = cross ( A - B , C - B ) が 0 より 大きい とき 、
rst = cross ( A - B , C - B ) が 0 より 大きい とき 、 <eos>
712
src = A = sum ( [ min ( B [ C ] , D [ C ] ) for C in range ( 8 ) ] )
trg = 0 から 8 未 満 までの 数 列 の 各要素 を C とし 、 B の C 番 目 、 D の C 番目の 最小 値の 列 の 総 和 を A とする
rst = 0 から 8 未 満 までの 数 列 の 各要素 を C とし 、 B の C 番 目 、 D の C 番目の 最小 値の 列 の 総 和 を A とする <eos>
713
src = for A in ( B , C , D , E ) :
trg = ( B 、 C 、 D 、 E ) の 組 を 順に A として 、 繰り返す
rst = ( B 、 C 、 D 、 E ) の 組 を 順に A として 、 繰り返す <eos>
714
src = return A . __class__ ( A . x + B . x , A . y + B . y )
trg = A . __ class __ ( A . x + B . x , A . y + B . y ) を返す
rst = A . __ class __ ( A . x + B . x , A . y + B . y ) を返す <eos>
715
src = now = A + B
trg = A に B を加えた 値を 現在の 日 時 とする
rst = A に B を加えた 値を 現在の 日 時 とする <eos>
716
src = for A , B , C in D . graph [ E ] :
trg = D の graph の E 番 目 を 順に A 、 B 、 C として 、 繰り返す
rst = D の graph の E 番 目 を 順に A 、 B 、 C として 、 繰り返す <eos>
717
src = A = max ( [ abs ( B [ C ] - D [ C ] ) , A ] )
trg = ( B の C 番 目 から D の C 番 目 を 引 いた 値の 絶対 値 、 A ) からなる 列 の 最大 値を A とする
rst = ( B の C 番 目 から D の C 番 目 を 引 いた 値の 絶対 値 、 A ) からなる 列 の 最大 値を A とする <eos>
718
src = A += ( B - C ) ** D * combination ( B , C )
trg = A を B から C を 引 いた 値の D 乗 に combination ( B , C ) を 掛 け た 値 だけ 増加 させる
rst = A を B から C を 引 いた 値の D 乗 に combination ( B , C ) を 掛 け た 値 だけ 増加 させる <eos>
719
src = for A in itertools . permutations ( B ) :
trg = B の 順 列 を 順に A として 、 繰り返す
rst = B の 順 列 を 順に A として 、 繰り返す <eos>
720
src = C += E
trg = C を E だけ 増加 させる
rst = C を E だけ 増加 させる <eos>
721
src = A = deque ( [ input ( ) . split ( ) for B in range ( C ) ] )
trg = 0 から C 未 満 までの 数 列 の 各要素 を B とし 、 、 つまり 入力された 文字列を 空白 で 分割 した 字句 列 の 列 の 両 端 キュー を A とする
rst = 0 から C 未 満 までの 数 列 の 各要素 を B とし 、 、 つまり 入力された 文字列を 空白 で 分割 した 字句 列 の 列 の 両 端 キュー を A とする <eos>
722
src = if A . count ( 0 ) > 1 :
trg = A 内の 0 の 出現 回数 が 1 より 大きい とき 、
rst = A 内の 0 の 出現 回数 が 1 より 大きい とき 、 <eos>
723
src = A = 100000000
trg = 1 0000 0000 を A とする
rst = 10 4 6 5 27 を A とする <eos>
724
src = A = B [ C - D ] [ E ] + F
trg = B の C から D を 引 いた 値 番目の E 番 目 に F を加えた 値を A とする
rst = B の C から D を 引 いた 値 番目の E 番 目 に F を加えた 値を A とする <eos>
725
src = if ( A + B ) * C < 10000 :
trg = A に B を加えた 値に C を 掛 け た 値が 1 0000 より 小さい とき 、
rst = A に B を加えた 値に C を 掛 け た 値が 1 0000 より 小さい とき 、 <eos>
726
src = s ( A , 0 , B )
trg = s ( A , 0 , B )
rst = s ( A , 0 , B ) <eos>
727
src = swap_range ( A , B , e , C )
trg = swap _ range ( A , B , e , C )
rst = <unk> ( A , B , e , C ) <eos>
728
src = A = B . upper ( )
trg = B を 英 大文字 に変換し た 文字列を A とする
rst = B を 英 大文字 に変換し た 文字列を A とする <eos>
729
src = return [ 7 , ( A [ 0 ] , B [ 0 ] ) ]
trg = ( 7 、 ( A の先頭 、 B の先頭 ) の 組 ) からなる 列 を返す
rst = ( 7 、 ( A の先頭 、 B の先頭 ) の 組 ) からなる 列 を返す <eos>
730
src = A = [ 0 ] * 30
trg = ( 0 ) からなる 列 の 30 回 分 の 列 を A とする
rst = ( 0 ) からなる 列 の 30 回 分 の 列 を A とする <eos>
731
src = for A in range ( B * B , 1000000 , B ) :
trg = B に B を 掛 け た 値 から 100 0000 未 満 までの B 間隔 の 数 列 を 順に A として 、 繰り返す
rst = B に B を 掛 け た 値 から 100 0000 未 満 までの B 間隔 の 数 列 を 順に A として 、 繰り返す <eos>
732
src = A = B [ A ]
trg = B の A 番 目 を A とする
rst = B の A 番 目 を A とする <eos>
733
src = if A <= B < C + 1 and D [ B - 1 ] - D [ B ] >= E :
trg = A が B 以下 かどうか が C に 1 を加えた 値 より 小さく かつ D の B から 1 を 引 いた 値 番 目 から D の B 番 目 を 引 いた 値が E 以上の とき 、
rst = A が B 以下 かどうか が C に 1 を加えた 値 より 小さく かつ D の B から 1 を 引 いた 値 番 目 から D の B 番 目 を 引 いた 値が E 以上の とき 、 <eos>
734
src = return {self.pt1},{self.pt2},{self.vector}
trg = " { } , { } , { } " を返す
rst = " T { } " を返す <eos>
735
src = if A [ B - 1 ] + 1 in A or A [ B - 1 ] == 2019 :
trg = A の B から 1 を 引 いた 値 番 目 に 1 を加えた 値が A に 含まれ または A の B から 1 を 引 いた 値 番 目 が 2019 と 等 しい とき 、
rst = A の B から 1 を 引 いた 値 番 目 に 1 を加えた 値が A に 含まれ または A の B から 1 を 引 いた 値 番 目 が 2019 と 等 しい とき 、 <eos>
736
src = return A + 1 if A % 2 == 1 else A
trg = A を 2 で 割 った 余 り が 1 と 等 しい とき A に 1 を加えた 値 、 そうでなければ A を返す
rst = A を 2 で 割 った 余 り が 1 と 等 しい とき A に 1 を加えた 値 、 そうでなければ A を返す <eos>
737
src = A [ 0 ] += min ( 24 , ( B - 1 ) // 1461 ) * 4
trg = A の 0 番 目 を 24 、 B から 1 を 引 いた 値を 14 6 1 で 割 った 商 の 最小 値に 4 を 掛 け た 値 だけ 増加 させる
rst = A の 0 番 目 を 24 、 B から 1 を 引 いた 値を 14 6 1 で 割 った 商 の 最小 値に 4 を 掛 け た 値 だけ 増加 させる <eos>
738
src = A . bel [ B + 1 ] [ C + 1 ] %= A . mod
trg = A の bel の B に 1 を加えた 値 番目の C に 1 を加えた 値 番 目 を A の mod で 割 った 余 り にする
rst = A の bel の B に 1 を加えた 値 番目の C に 1 を加えた 値 番 目 を A の mod で 割 った 余 り にする <eos>
739
src = print ( E if abs ( dot ( A - B , C - D ) ) < 1.e-10 else F )
trg = dot ( A - B , C - D ) の 絶対 値が 1. e -10 より 小さい とき E 、 そうでなければ F を出力する
rst = dot ( A - B , C - D ) の 絶対 値が 1 e - 6 より 小さい とき E 、 そうでなければ F を出力する <eos>
740
src = A = Cp ( B , C , D )
trg = Cp ( B , C , D ) を A とする
rst = <unk> ( B , C , D ) を A とする <eos>
741
src = print ( A [ B ] [ len ( A [ B ] ) - 1 ] )
trg = A の B 番目の A の B 番目の 長さ から 1 を 引 いた 値 番 目 を出力する
rst = A の B 番目の A の B 番目の 長さ から 1 を 引 いた 値 番 目 を出力する <eos>
742
src = return pow ( A , 1 / B )
trg = A の 1 を B で 割 った 値 乗 を返す
rst = A の 1 を B で 割 った 値 乗 を返す <eos>
743
src = dfs ( 0 , - 1 , None )
trg = dfs ( 0 , - 1, None )
rst = dfs ( 0 , - 1, None ) <eos>
744
src = A = bitDP ( 0 , 0 , B )
trg = bitDP ( 0 , 0 , B ) を A とする
rst = <unk> ( 0 , 0 , B ) を A とする <eos>
745
src = A [ 3 ] = B [ 5 ]
trg = B の 5 番 目 を A の 3 番 目 にする
rst = B の 5 番 目 を A の 3 番 目 にする <eos>
746
src = A += ( B // C ) * 7
trg = A を B を C で 割 った 商 に 7 を 掛 け た 値 だけ 増加 させる
rst = A を B を C で 割 った 商 に 7 を 掛 け た 値 だけ 増加 させる <eos>
747
src = for A , B , C in D [ E - 1 ] :
trg = D の E から 1 を 引 いた 値 番 目 を 順に A 、 B 、 C として 、 繰り返す
rst = D の E から 1 を 引 いた 値 番 目 を 順に A 、 B 、 C として 、 繰り返す <eos>
748
src = A . append ( ( B [ C * 2 ] , B [ C * 2 + 1 ] ) )
trg = A の 末 尾 に ( B の C に 2 を 掛 け た 値 番 目 、 B の C に 2 を 掛 け た 値に 1 を加えた 値 番 目 ) の 組 を追加する
rst = A の 末 尾 に ( B の C に 2 を 掛 け た 値 番 目 、 B の C に 2 を 掛 け た 値に 1 を加えた 値 番 目 ) の 組 を追加する <eos>
749
src = if ( C [ A ] if A < B + 1 else C [ A ] - ( D - E ) ) < F - D :
trg = A が B に 1 を加えた 値 より 小さい とき C の A 番 目 、 そうでなければ C の A 番 目 から D から E を 引 いた 値を 引 いた 値が F から D を 引 いた 値 より 小さい とき 、
rst = A が B に 1 を加えた 値 より 小さい とき C の A 番 目 、 そうでなければ C の A 番 目 から D から E を 引 いた 値を 引 いた 値が F から D を 引 いた 値 より 小さい とき 、 <eos>
750
src = return A . k_parent [ 0 ] [ B ]
trg = A の k _ parent の先頭 の B 番 目 を返す
rst = A の k _ parent の先頭 の B 番 目 を返す <eos>
751
src = print ( '' . join ( A . mp [ B ] ) )
trg = 空文字列 を 間 に 入れ て A の mp の B 番 目 を 連結 した 文字列 を出力する
rst = 空文字列 を 間 に 入れ て A の mp の B 番 目 を 連結 した 文字列 を出力する <eos>
752
src = A . parent . left = A . right
trg = A の right を A の parent の left にする
rst = A の right を A の parent の left にする <eos>
753
src = A . append ( heapPop_max ( B ) )
trg = A の 末 尾 に heapPop _ max ( B ) を追加する
rst = A の 末 尾 に <unk> ( B ) を追加する <eos>
754
src = printComparison ( int ( A [ 0 ] ) , int ( A [ 1 ] ) )
trg = printComparison ( int ( A [ 0 ] ) , int ( A [ 1 ] ) )
rst = <unk> ( int ( A [ 0 ] ) , int ( A [ 1 ] ) ) <eos>
755
src = A [ B ] [ 1 ] = min ( A [ C ] [ 0 ] + A [ D ] [ 1 ] + E [ C ] , A [ C ] [ 1 ] + A [ D ] [ 0 ] + E [ D ] , A [ C ] [ 1 ] + A [ D ] [ 1 ] )
trg = A の C 番目の 0 番 目 に A の D 番目の 1 番 目 を加えた 値に E の C 番 目 を加えた 値 、 A の C 番目の 1 番 目 に A の D 番目の 0 番 目 を加えた 値に E の D 番 目 を加えた 値 、 A の C 番目の 1 番 目 に A の D 番目の 1 番 目 を加えた 値の 最小 値を A の B 番目の 1 番 目 にする
rst = A の C 番目の 0 番 目 に A の D 番目の 1 番 目 を加えた 値に E の C 番 目 を加えた 値 、 A の D 番目の 0 番 目 に A の C 番目の 1 番 目 を加えた 値の 最小 値を A の B 番目の 1 番
756
src = A [ B + C ] [ D + E ] = True
trg = 真 を A の B に C を加えた 値 番目の D に E を加えた 値 番 目 にする
rst = 真 を A の B に C を加えた 値 番目の D に E を加えた 値 番 目 にする <eos>
757
src = if A [ B ] < A [ C ] :
trg = A の B 番 目 が A の C 番 目 より 小さい とき 、
rst = A の B 番 目 が A の C 番 目 より 小さい とき 、 <eos>
758
src = A = B - 1868 + 1
trg = B から 18 68 を 引 いた 値に 1 を加えた 値を A とする
rst = B から 18 68 を 引 いた 値に 1 を加えた 値を A とする <eos>
759
src = if A - ( B + C ) > 1e-10 :
trg = A から B に C を加えた 値を 引 いた 値が 1 e -10 より 大きい とき 、
rst = A から B に C を加えた 値を 引 いた 値が 1 e -10 より 大きい とき 、 <eos>
760
src = A , B = insertionSort ( C , A , B )
trg = insertionSort ( C , A , B ) を 展開 し 、 それぞれ A 、 B とする
rst = insertionSort ( C , A , B ) を 展開 し 、 それぞれ A 、 B とする <eos>
761
src = if A . ok ( B , C ) :
trg = A . ok ( B , C ) の とき 、
rst = A . _ intersect ( B , C ) の とき 、 <eos>
762
src = A [ B - 1 ] [ C ] = 1
trg = 1 を A の B から 1 を 引 いた 値 番目の C 番 目 にする
rst = 1 を A の B から 1 を 引 いた 値 番目の C 番 目 にする <eos>
763
src = A = - 1e-9
trg = -1 e - 9 を A とする
rst = - 1 e - 9 を A とする <eos>
764
src = A = [ 1 , 1 , 1 , 1 , 1 , 2 , 2 , 2 , 3 ]
trg = ( 1 、 1 、 1 、 1 、 1 、 2 、 2 、 2 、 3 ) からなる 列 を A とする
rst = ( 1 、 1 、 1 、 1 、 1 、 2 、 2 、 2 、 2 、 3 ) からなる 列 を A とする <eos>
765
src = A = 256
trg = 25 6 を A とする
rst = 25 6 を A とする <eos>
766
src = A = [ { } for B in range ( C ) ]
trg = 0 から C 未 満 までの 数 列 の 各要素 を B とし 、 、 つまり 空 辞書 の 列 を A とする
rst = 0 から C 未 満 までの 数 列 の 各要素 を B とし 、 、 つまり 空 辞書 の 列 を A とする <eos>
767
src = A = [ calcDp ( B ) for B in range ( 5 ) ]
trg = 0 から 5 未 満 までの 数 列 の 各要素 を B とし 、 calcDp ( B ) の 列 を A とする
rst = 0 から 5 未 満 までの 数 列 の 各要素 を B とし 、 <unk> ( B ) の 列 を A とする <eos>
768
src = A . append ( B + max ( C ) )
trg = A の 末 尾 に B に C の 最大 値 を加えた 値 を追加する
rst = A の 末 尾 に B に C の 最大 値 を加えた 値 を追加する <eos>
769
src = A , B = repeating_decimals ( C , D )
trg = repeating _ decimals ( C , D ) を 展開 し 、 それぞれ A 、 B とする
rst = solve _ int ( C , D ) を 展開 し 、 それぞれ A 、 B とする <eos>
770
src = A += B . count ( C )
trg = A を B 内の C の 出現 回数 だけ 増加 させる
rst = A を B 内の C の 出現 回数 だけ 増加 させる <eos>
771
src = if A [ B - 1 ] % C > A [ B ] % C :
trg = A の B から 1 を 引 いた 値 番 目 を C で 割 った 余 り が A の B 番 目 を C で 割 った 余 り より 大きい とき 、
rst = A の B から 1 を 引 いた 値 番 目 を C で 割 った 余 り が A の B 番 目 を C で 割 った 余 り より 大きい とき 、 <eos>
772
src = A = 1e30
trg = 1 e 30 を A とする
rst = 10 4 6 5 27 を A とする <eos>
773
src = A . append ( right key = {a[i*2+1]}, )
trg = A の 末 尾 に " rightkey = { } , " を追加する
rst = A の 末 尾 に " rightkey = { } , " を追加する <eos>
774
src = print ( F if A <= B <= C - A and A <= D <= E - A else G )
trg = A が B 以下 かどうか が C から A を 引 いた 値 以下 かつ A が D 以下 かどうか が E から A を 引 いた 値 以下の とき F 、 そうでなければ G を出力する
rst = A < = B が C - A 以下 かつ A が D 以下 かどうか が E から A を 引 いた 値 以下の とき F 、 そうでなければ G を出力する <eos>
775
src = return MyList ( [ 0 ] * A . D )
trg = MyList ( [ 0 ] * A . D ) を返す
rst = MyList ( [ 0 ] * A . D ) を返す <eos>
776
src = A = [ [ - 2 , 0 ] , [ - 1 , - 1 ] , [ - 1 , 0 ] , [ - 1 , 1 ] , [ 0 , - 2 ] , [ 0 , - 1 ] , [ 0 , 0 ] , [ 0 , 1 ] , [ 0 , 2 ] , [ 1 , - 1 ] , [ 1 , 0 ] , [ 1 ,
trg = ( ( -2 、 0 ) からなる 列 、 ( -1 、 -1 ) からなる 列 、 ( -1 、 0 ) からなる 列 、 ( -1 、 1 ) からなる 列 、 ( 0 、 -2 ) からなる 列 、 ( 0 、 -1 ) からなる 列 、 ( 0 、 0 ) からなる 列 、 ( 0 、 1 ) からなる 列 、 ( 0 、 2 ) からなる 列 、 ( 1 、 -1 ) からなる 列
rst = ( ( -2 、 0 ) からなる 列 、 ( -1 、 -1 ) からなる 列 、 ( -1 、 0 ) からなる 列 、 ( 1 、 1 、 0 ) からなる 列 、 ( 2 、 0 、 1 ) からなる 列 、 ( 0 、 1 、
777
src = A = 1001
trg = 100 1 を A とする
rst = 100 1 を A とする <eos>
778
src = if len ( A ) >= 5 :
trg = A の長さ が 5 以上の とき 、
rst = A の長さ が 5 以上の とき 、 <eos>
779
src = A . n_ = B
trg = B を A の n _ にする
rst = B を A の <unk> にする <eos>
780
src = A = ( B + C + D ) // 3
trg = B に C を加えた 値に D を加えた 値を 3 で 割 った 商 を A とする
rst = B に C を加えた 値に D を加えた 値を 3 で 割 った 商 を A とする <eos>
781
src = A = B [ 0 ] = int ( input ( ) )
trg = 入力された 文字列 の 整数値 を B の 0 番 目 とする を A とする
rst = 入力された 文字列 の 整数値 を B の 0 番 目 とする を A とする <eos>
782
src = if A == [ ( 0 , 0 ) , ( 0 , 1 ) , ( 1 , 1 ) , ( 1 , 2 ) ] :
trg = A が ( ( 0 、 0 ) の 組 、 ( 0 、 1 ) の 組 、 ( 1 、 1 ) の 組 、 ( 1 、 2 ) の 組 ) からなる 列 と 等 しい とき 、
rst = A が ( ( 0 、 0 ) の 組 、 ( 0 、 1 ) の 組 、 ( 1 、 1 ) の 組 、 ( 1 、 2 ) の 組 ) からなる 列 と 等 しい とき 、 <eos>
783
src = A [ B ] [ C ] = max ( A [ B - 1 ] [ C ] , A [ B ] [ C - D [ B ] [ 1 ] ] + D [ B ] [ 0 ] )
trg = A の B から 1 を 引 いた 値 番目の C 番 目 、 A の B 番目の C から D [ B ] の 1 番 目 を 引 いた 値 番 目 に D の B 番目の 先頭 を加えた 値の 最大 値を A の B 番目の C 番 目 にする
rst = A の B から 1 を 引 いた 値 番目の C 番 目 、 A の B 番目の C から D [ B ] の 1 番 目 を 引 いた 値 番 目 に D の B 番目の D 番 目 を加えた 値の 最大 値を A の B 番目の
784
src = A = 100 ** 2
trg = 100 の 2 乗 を A とする
rst = 100 の 2 乗 を A とする <eos>
785
src = while len ( A ) > B and cross ( C [ A [ - 2 ] ] , C [ A [ - 1 ] ] , C [ D ] ) >= 0 :
trg = A の長さ が B より 大きく かつ cross ( C [ A [ -2 ]] , C [ A [ -1 ]] , C [ D ] ) が 0 以上の 間 、 次 を 繰り返す
rst = A の長さ が B より 大きく かつ cross ( C [ A [ -2 ]] , C [ A [ -1 ]] , C [ D ] ) が 0 以上の 間 、 次 を 繰り返す <eos>
786
src = if A [ B ] [ 1 ] <= A [ C ] [ 0 ] and A [ B ] [ 2 ] <= A [ C ] [ 1 ] and A [ B ] [ 3 ] <= A [ C ] [ 2 ] and A [ B ] [ 1 ] * 4 + A [ B ] [ 2 ] * 9 + A [ B ] [ 3 ] * 4 <= A
trg = A [ B ] の 1 番 目 が A [ C ] の 0 番 目 以下 かつ A [ B ] の 2 番 目 が A [ C ] の 1 番 目 以下 かつ A の B 番目の 3 番 目 が A の C 番目の 2 番 目 以下 かつ A [ B ] [ 1 ] に 4 を 掛 け た 値に A [ B ] [ 2 ] に 9 を 掛
rst = A [ B ] の 1 番 目 が A の C 番目の 0 番 目 以下 かつ A [ B ] の 2 番 目 が A の C [ 1 ] に A [ B ] [ 2 ] を 掛 け た 値に A [ B ]
787
src = A [ B | C ] = D [ B ] + 2
trg = D の B 番 目 に 2 を加えた 値を A の B と C の 論理 和 番 目 にする
rst = D の B 番 目 に 2 を加えた 値を A の B と C の 論理 和 番 目 にする <eos>
788
src = if str ( A ) == B [ 0 ] or ( A >= 10 and B [ 0 ] == C ) :
trg = A の 文字列 が B の 0 番 目 と 等 しく または A が 10 以上 かつ B の 0 番 目 が C と 等 しい とき 、
rst = A の 文字列 が B の 0 番 目 と 等 しく または A が 10 以上 かつ B の 0 番 目 が C と 等 しい とき 、 <eos>
789
src = A = B + ( C - B ) . rotate ( 60.0 )
trg = B に C から B を 引 いた 値の 要素を 右 に 6 0.0 個 、 回 転 する を加えた 値を A とする
rst = B に C から B を 引 いた 値の 要素を 右 に ひとつ to _ rotate () を加えた 値を A とする <eos>
790
src = while not test ( ) :
trg = test () でない 間 、 次 を 繰り返す
rst = test () でない 間 、 次 を 繰り返す <eos>
791
src = A [ 2 ] = copy [ 0 ]
trg = copy の先頭 を A の 2 番 目 にする
rst = copy の先頭 を A の 2 番 目 にする <eos>
792
src = if not A [ B ] [ C ] [ 0 ] :
trg = A の B 番目の C 番目の 先頭 でない とき 、
rst = A の B 番目の C 番目の 先頭 でない とき 、 <eos>
793
src = if A in dict :
trg = A が 、 つまり 辞書 に含まれる とき 、
rst = A が 、 つまり 辞書 に含まれる とき 、 <eos>
794
src = A = B * 151
trg = B に 15 1 を 掛 け た 値を A とする
rst = B に 15 1 を 掛 け た 値を A とする <eos>
795
src = A = B . GetNodes ( )
trg = B . GetNodes () を A とする
rst = B . GetNodes () を A とする <eos>
796
src = A = [ len ( input ( ) ) for B in range ( int ( input ( ) ) ) ]
trg = 0 から 、 つまり 入力された 文字列 の 整数値 未 満 までの 数 列 の 各要素 を B とし 、 、 つまり 入力された 文字列 の長さ の 列 を A とする
rst = 0 から 、 つまり 入力された 文字列 の 整数値 未 満 までの 数 列 の 各要素 を B とし 、 、 つまり 入力された 文字列 の長さ の 列 を A とする <eos>
797
src = if A + 1 < B and C [ A + 1 ] > 0 :
trg = A に 1 を加えた 値が B より 小さく かつ C の A に 1 を加えた 値 番 目 が 0 より 大きい とき 、
rst = A に 1 を加えた 値が B より 小さく かつ C の A に 1 を加えた 値 番 目 が 0 より 大きい とき 、 <eos>
798
src = A = calc_kagen ( A )
trg = calc _ kagen ( A ) を A とする
rst = <unk> ( A ) を A とする <eos>
799
src = if A == 9 :
trg = A が 9 と 等 しい とき 、
rst = A が 9 と 等 しい とき 、 <eos>
800
src = print ( euler_phi ( A , B ) )
trg = euler _ phi ( A , B ) を出力する
rst = <unk> ( A , B ) を出力する <eos>
801
src = A = B . vec [ C % 2 ]
trg = B の vec の C を 2 で 割 った 余 り 番 目 を A とする
rst = B の <unk> の C を 2 で 割 った 余 り 番 目 を A とする <eos>
802
src = A += abs ( B * C - D * E ) / 2
trg = A を B に C を 掛 け た 値 から D に E を 掛 け た 値を 引 いた 値の 絶対 値を 2 で 割 った 値 だけ 増加 させる
rst = A を B に C を 掛 け た 値 から D に E を 掛 け た 値を 引 いた 値の 絶対 値を 2 で 割 った 値 だけ 増加 させる <eos>
803
src = print ( A % ( B , C ) )
trg = A を ( B 、 C ) の 組 で 割 った 余 り を出力する
rst = A を ( B 、 C ) の 組 で 割 った 余 り を出力する <eos>
804
src = A = max ( A , min ( B , C , D - e , E - D ) )
trg = A 、 B 、 C 、 D から 、 つまり ネ イ ピ ア 数 を 引 いた 値 、 E から D を 引 いた 値の 最小 値の 最大 値を A とする
rst = A 、 B 、 C 、 D から 、 つまり ネ イ ピ ア 数 を 引 いた 値 、 E から D を 引 いた 値の 最小 値の 最大 値を A とする <eos>
805
src = A . cursor = A . cursor . prev
trg = A の cursor の prev を A の cursor にする
rst = A の cursor の prev を A の cursor にする <eos>
806
src = A [ B + 1 ] [ C + 1 ] = 1
trg = 1 を A の B に 1 を加えた 値 番目の C に 1 を加えた 値 番 目 にする
rst = 1 を A の B に 1 を加えた 値 番目の C に 1 を加えた 値 番 目 にする <eos>
807
src = print ( A . format ( B + 1 , C [ B ] ) )
trg = A を 書式 として B に 1 を加えた 値 、 C の B 番 目 で 整 形 した 文字列 を出力する
rst = A を 書式 として B に 1 を加えた 値 、 C の B 番 目 で 整 形 した 文字列 を出力する <eos>
808
src = A += ( ( B - 1 - C ) * D [ C ] ) / ( ( B - 1 ) * E )
trg = A を B から 1 を 引 いた 値 から C を 引 いた 値に D の C 番 目 を 掛 け た 値を B から 1 を 引 いた 値に E を 掛 け た 値 で 割 った 値 だけ 増加 させる
rst = A を B から 1 を 引 いた 値 から C を 引 いた 値に D の C 番 目 を 掛 け た 値を B から 1 を 引 いた 値に E を 掛 け た 値 で 割 った 値 だけ 増加 させる <eos>
809
src = A = __createtable ( )
trg = __ createtable () を A とする
rst = <unk> () を A とする <eos>
810
src = for A in range ( 2 , 10000000 ) :
trg = 2 から 1000 0000 未 満 までの 数 列 を 順に A として 、 繰り返す
rst = 2 から 1000 0000 未 満 までの 数 列 を 順に A として 、 繰り返す <eos>
811
src = print ( pow ( 2 , A , B ) )
trg = 2 の A 乗 に対する B の 剰 余 を出力する
rst = 2 の A 乗 に対する B の 剰 余 を出力する <eos>
812
src = A = set ( map ( B , C ) )
trg = C の 各要素 に B を適用した 列 の集合 を A とする
rst = C の 各要素 に B を適用した 列 の集合 を A とする <eos>
813
src = A [ 0 ] , A [ 1 ] , A [ 2 ] , A [ 3 ] , A [ 4 ] , A [ 5 ] = A [ 4 ] , A [ 0 ] , A [ 2 ] , A [ 3 ] , A [ 5 ] , A [ 1 ]
trg = A の 4 番 目 、 A の先頭 、 A の 2 番 目 、 A の 3 番 目 、 A の 5 番 目 、 A の 1 番 目 を A の先頭 、 A の 1 番 目 、 A の 2 番 目 、 A の 3 番 目 、 A の 4 番 目 、 A の 5 番 目 とする
rst = A の先頭 、 A の 4 番 目 、 A の 2 番 目 、 A の 3 番 目 、 A の 1 番 目 を A の先頭 、 A の 1 番 目 、 A の 2 番 目 、 A の 3 番 目 、 A の
814
src = treewalk_preorder ( A [ B ] [ C ] )
trg = treewalk _ preorder ( A [ B ] [ C ] )
rst = treewalk _ preorder ( A [ B ] [ C ] ) <eos>
815
src = print ( A [ B ] , C + 1 )
trg = A の B 番 目 、 C に 1 を加えた 値 を出力する
rst = A の B 番 目 、 C に 1 を加えた 値 を出力する <eos>
816
src = A = lambda B : abs ( math . sqrt ( B [ 0 ] ** 2 + B [ 1 ] ** 2 ) - C )
trg = l を パラメータ として B [ 0 ] * * 2 に B [ 1 ] * * 2 を加えた 値の 平 方 根 から C を 引 いた 値の 絶対 値を返す 関数を A とする
rst = i を パラメータ として B [ 0 ] の 2 乗 に B [ 1 ] の 2 乗 を加えた 値の 平 方 根 から C を 引 いた 値を返す 関数を A とする <eos>
817
src = A = ( B - C ) + ( D // E )
trg = B から C を 引 いた 値に D を E で 割 った 商 を加えた 値を A とする
rst = B から C を 引 いた 値に D を E で 割 った 商 を加えた 値を A とする <eos>
818
src = A = 15
trg = 15 を A とする
rst = 15 を A とする <eos>
819
src = A , B , C = 0 , 255 , 0
trg = 0 、 25 5 、 0 を A 、 B 、 C とする
rst = 0 、 25 5 、 0 を A 、 B 、 C とする <eos>
820
src = pd = [ map ( int , A . readline ( ) . split ( ) ) for B in range ( C ) ]
trg = 0 から C 未 満 までの 数 列 の 各要素 を B とし 、 A から 読み 込 んだ 一行 を 空白 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 の 列 を pd とする
rst = 0 から C 未 満 までの 数 列 の 各要素 を B とし 、 A から 読み 込 んだ 一行 を 空白 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 の 列 を pd とする <eos>
821
src = print ( A , B - 1925 , sep = '' )
trg = 区切り なしで A 、 B から 19 25 を 引 いた 値 を出力する
rst = 区切り なしで A 、 B から 19 25 を 引 いた 値 を出力する <eos>
822
src = A -= Fraction ( 90 , 1 << B )
trg = A を Fraction ( 90 , 1 < < B ) だけ 減少 させる
rst = A を Fraction ( 90 , 1 < B ) だけ 減少 させる <eos>
823
src = A = ( [ B for B , C in zip ( D , D [ 1 : ] + [ None ] ) if B != C ] )
trg = D 、 D の 1 番 目 から 、 つまり 末 尾 までの 部分 列 に ( 、 つまり 未 定 値 ) からなる 列 を加えた 値の 要素を それぞれ 組 にした 列 の 各要素 を B 、 C とし 、 B が C と 等 しく ない とき の B の 列 を A とする
rst = D 、 D の 1 番 目 から 、 つまり 末 尾 までの 部分 列 、 ( None ) からなる 列 の 要素を それぞれ 組 にした 列 の 各要素 を B 、 C とし 、 B が C と 等 しく ない とき の B の 列 を A とする
824
src = A [ B ] . parent_id = C
trg = C を A の B 番目の parent _ id にする
rst = C を A の B 番目の parent _ id にする <eos>
825
src = for A in range ( 3 , int ( math . sqrt ( B ) ) + 1 , 2 ) :
trg = 3 から B の 平 方 根 の 整数値 に 1 を加えた 値 未 満 までの 2 間隔 の 数 列 を 順に A として 、 繰り返す
rst = 3 から B の 平 方 根 の 整数値 に 1 を加えた 値 未 満 までの 2 間隔 の 数 列 を 順に A として 、 繰り返す <eos>
826
src = if A [ B ] - C - D >= E :
trg = A の B 番 目 から C を 引 いた 値 から D を 引 いた 値が E 以上の とき 、
rst = A の B 番 目 から C を 引 いた 値 から D を 引 いた 値が E 以上の とき 、 <eos>
827
src = A = solve ( B + 1 , C ) or solve ( B + 1 , C - D [ B ] )
trg = solve ( B + 1, C ) または solve ( B + 1, C - D [ B ] ) を A とする
rst = solve ( B + 1, C ) または solve ( B + 1, C - D [ B ] ) を A とする <eos>
828
src = return bin ( A . FLAGS ) . count ( B )
trg = A の FLAGS の 2 進 数 文字列 内の B の 出現 回数 を返す
rst = A の FLAGS の 2 進 数 文字列 内の B の 出現 回数 を返す <eos>
829
src = A = least_multiplication ( B )
trg = least _ multiplication ( B ) を A とする
rst = <unk> ( B ) を A とする <eos>
830
src = if A == 0 and B in C :
trg = A が 0 と 等 しく かつ B が C に含まれる とき 、
rst = A が 0 と 等 しく かつ B が C に含まれる とき 、 <eos>
831
src = if A >= 20 :
trg = A が 20 以上の とき 、
rst = A が 20 以上の とき 、 <eos>
832
src = print ( int ( phi ( A ) ) )
trg = phi ( A ) の 整数値 を出力する
rst = <unk> ( int ( A ) ) の 整数値 を出力する <eos>
833
src = A = [ '' , B , C , D ]
trg = ( 、 つまり 空文字列 、 B 、 C 、 D ) からなる 列 を A とする
rst = ( 、 つまり 空文字列 、 B 、 C 、 D ) からなる 列 を A とする <eos>
834
src = A = WeightedUnionFindTree ( B - 1 )
trg = WeightedUnionFindTree ( B -1 ) を A とする
rst = lower _ bound ( B -1 ) を A とする <eos>
835
src = print ( isSolved ( A ) )
trg = isSolved ( A ) を出力する
rst = <unk> ( A ) を出力する <eos>
836
src = A = ( B , 0 )
trg = ( B 、 0 ) の 組 を A とする
rst = ( B 、 0 ) の 組 を A とする <eos>
837
src = A [ B * C ] = 1
trg = 1 を A の B に C を 掛 け た 値 番 目 にする
rst = 1 を A の B に C を 掛 け た 値 番 目 にする <eos>
838
src = return list ( set ( A ) )
trg = A の集合 のリスト を返す
rst = A の集合 のリスト を返す <eos>
839
src = A = [ B . pop ( ) ]
trg = ( B の先頭 を取り 出した 値 ) からなる 列 を A とする
rst = ( B の先頭 を取り 出した 値 ) からなる 列 を A とする <eos>
840
src = A = dice ( )
trg = dice () を A とする
rst = dice () を A とする <eos>
841
src = if A + ( B + 1 ) <= C :
trg = A に B に 1 を加えた 値 を加えた 値が C 以下の とき 、
rst = A に B に 1 を加えた 値が C 以下の とき 、 <eos>
842
src = print ( C if par ( A ) == par ( B ) else D )
trg = par ( A ) が par ( B ) と 等 しい とき C 、 そうでなければ D を出力する
rst = A の長さ が par ( B ) と 等 しい とき C 、 そうでなければ D を出力する <eos>
843
src = A [ B ] = [ ( C , D ) ]
trg = ( ( C 、 D ) の 組 ) からなる 列 を A の B 番 目 にする
rst = ( ( C 、 D ) の 組 ) からなる 列 を A の B 番 目 にする <eos>
844
src = A = [ '' , B , C , B , C , B ]
trg = ( 、 つまり 空文字列 、 B 、 C 、 B 、 C 、 B ) からなる 列 を A とする
rst = ( 、 つまり 空文字列 、 B 、 C 、 B 、 C 、 B ) からなる 列 を A とする <eos>
845
src = A = ( [ str ( B ) for B in range ( 1 , C + 1 ) ] )
trg = 1 から C に 1 を加えた 値 未 満 までの 数 列 の 各要素 を B とし 、 B の 文字列 の 列 を A とする
rst = 1 から C に 1 を加えた 値 未 満 までの 数 列 の 各要素 を B とし 、 B の 文字列 の 列 を A とする <eos>
846
src = A [ B ] [ C ] = + ( sum ( [ D [ B ] [ E ] & F [ E ] [ C ] for E in range ( G ) ] ) > 0 )
trg = 0 から G 未 満 までの 数 列 の 各要素 を E とし 、 D [ B ] [ E ] と F [ E ] [ C ] の 論理 積 の 列 の 総 和 が 0 より 大きい かどうか に [MASK] を加えた 値を A の B 番目の C 番 目 にする
rst = 0 から G 未 満 までの 数 列 の 各要素 を E とし 、 D [ B ] の E 番 目 と F の E 番目の 論理 積 の 列 の 総 和 に 大きい かどうか を加えた 値を A の B 番目の C 番 目 にする <eos>
847
src = A = min_cost_sort ( B )
trg = min _ cost _ sort ( B ) を A とする
rst = <unk> ( B ) を A とする <eos>
848
src = return A . cost ( )
trg = A . cost () を返す
rst = A . cost () を返す <eos>
849
src = A . _edges [ e . v ] . append ( e )
trg = A の _ edges の 、 つまり ネ イ ピ ア 数の v 番目の 末 尾 に ネ イ ピ ア 数 を追加する
rst = A の _ edges の 、 つまり ネ イ ピ ア 数の v 番目の 末 尾 に ネ イ ピ ア 数 を追加する <eos>
850
src = if A [ B ] [ C ] and D [ B ] [ C ] == 0 :
trg = A の B 番目の C 番 目 かつ D の B 番目の C 番 目 が 0 と 等 しい とき 、
rst = A の B 番目の C 番 目 かつ D の B 番目の C 番 目 が 0 と 等 しい とき 、 <eos>
851
src = A = ( B [ 0 ] * C [ 0 ] + B [ 1 ] * C [ 1 ] ) / ( B [ 0 ] ** 2 + B [ 1 ] ** 2 )
trg = B の 先頭に C の先頭 を 掛 け た 値に B の 1 番 目 に C の 1 番 目 を 掛 け た 値 を加えた 値を B の先頭 の 2 乗 に B の 1 番目の 2 乗 を加えた 値 で 割 った 値を A とする
rst = B の 0 番 目 に C の 0 番 目 を 掛 け た 値に B の 1 番 目 に C の 1 番 目 を 掛 け た 値 を加えた 値を B の 0 番目の 2 乗 に B の 1 番目の 2 乗 を加えた 値 で
852
src = print ( 0: )
trg = " 0 : " を出力する
rst = " T { } " を出力する <eos>
853
src = A = B + C * ( D - E ) - ( F + G * H )
trg = B に C に D から E を 引 いた 値を 掛 け た 値 を加えた 値 から F に G に H を 掛 け た 値 を加えた 値を 引 いた 値を A とする
rst = B に C に D から E を 引 いた 値を 掛 け た 値 を加えた 値 から F に G に H を 掛 け た 値 を加えた 値を 引 いた 値を A とする <eos>
854
src = A = B * C - D * E
trg = B に C を 掛 け た 値 から D に E を 掛 け た 値を 引 いた 値を A とする
rst = B に C を 掛 け た 値 から D に E を 掛 け た 値を 引 いた 値を A とする <eos>
855
src = A = [ get_area ( ) ]
trg = ( get _ area () ) からなる 列 を A とする
rst = ( <unk> () ) からなる 列 を A とする <eos>
856
src = if sum ( A [ : 2 ] ) > 179 or B > 239 or 100 in A :
trg = A の 、 つまり 先頭 から 2 番 目 までの 部分 列 の 総 和 が 1 79 より 大きく または B が 23 9 より 大きく または 100 が A に含まれる とき 、
rst = A の 、 つまり 先頭 から 2 番 目 までの 部分 列 の 総 和 が 3 より 大きく または B が 100 より 大きく または B が 100 より 大きい とき 、 <eos>
857
src = A [ B ] [ C ] = A [ B - 1 ] [ C ] + 1
trg = A の B から 1 を 引 いた 値 番目の C 番 目 に 1 を加えた 値を A の B 番目の C 番 目 にする
rst = A の B から 1 を 引 いた 値 番目の C 番 目 に 1 を加えた 値を A の B 番目の C 番 目 にする <eos>
858
src = if A not in B [ find ( C ) ] :
trg = A が B の find ( C ) 番 目 に 含まれ ない とき 、
rst = A が B の find ( C ) 番 目 に 含まれ ない とき 、 <eos>
859
src = A , B = listing ( C [ 0 ] , D ) , listing ( C [ 1 ] , D )
trg = listing ( C [ 0 ] , D ) 、 listing ( C [ 1 ] , D ) を A 、 B とする
rst = calc _ distance ( C [ 0 ] , D ) 、 <unk> ( C [ 1 ] , D ) を A 、 B とする <eos>
860
src = A = B . find ( A )
trg = B の先頭 から A を 探 して 見つかった 位置 を A とする
rst = B の先頭 から A を 探 して 見つかった 位置 を A とする <eos>
861
src = A = max ( [ B - C for C , B in D if B - C < E ] )
trg = D の 各要素 を C 、 B とし 、 B から C を 引 いた 値が E より 小さい とき の B から C を 引 いた 値の 列 の 最大 値を A とする
rst = D の 各要素 を C 、 B とし 、 B から C を 引 いた 値が E より 小さい とき の B から C を 引 いた 値の 列 の 最大 値を A とする <eos>
862
src = A [ B ] [ 0 ] = [ 0 , 1 , 0 , 0 ]
trg = ( 0 、 1 、 0 、 0 ) からなる 列 を A の B 番目の 0 番 目 にする
rst = ( 0 、 1 、 0 、 0 ) からなる 列 を A の B 番目の 0 番 目 にする <eos>
863
src = A , time = sys . stdin . readline ( ) . split ( )
trg = sys の stdin から 読み 込 んだ 一行 を 空白 で 分割 した 字句 列 を 展開 し 、 それぞれ A 、 time とする
rst = sys の stdin から 読み 込 んだ 一行 を 空白 で 分割 した 字句 列 を 展開 し 、 それぞれ A 、 time とする <eos>
864
src = A . extend ( [ 0 ] * 8 )
trg = ( 0 ) からなる 列 の 8 回 分 の 列 を追加し て A を拡張する
rst = ( 0 ) からなる 列 の 8 回 分 の 列 を追加し て A を拡張する <eos>
865
src = A = A % _pow ( 10 , 68 )
trg = A を _ pow ( 10 , 68 ) で 割 った 余 り を A とする
rst = A を _ pow ( 10 , 68 ) で 割 った 余 り を A とする <eos>
866
src = swaping ( A , B , C , e , D )
trg = swaping ( A , B , C , e , D )
rst = <unk> ( A , B , C , e , D ) <eos>
867
src = return A [ 0 ] * 2
trg = A の 先頭に 2 を 掛 け た 値を返す
rst = A の 先頭に 2 を 掛 け た 値を返す <eos>
868
src = buildMaxHeap ( A , B )
trg = buildMaxHeap ( A , B )
rst = <unk> ( A , B ) <eos>
869
src = A [ B + 1 ] = A [ B ] * C % D
trg = A の B 番 目 に C を 掛 け た 値を D で 割 った 余 り を A の B に 1 を加えた 値 番 目 にする
rst = A の B 番 目 に C を 掛 け た 値を D で 割 った 余 り を A の B に 1 を加えた 値 番 目 にする <eos>
870
src = A = B % 2
trg = B を 2 で 割 った 余 り を A とする
rst = B を 2 で 割 った 余 り を A とする <eos>
871
src = A , B = B , A % B
trg = B 、 A を B で 割 った 余 り を A 、 B とする
rst = B 、 A を B で 割 った 余 り を A 、 B とする <eos>
872
src = print ( ans ( A , B ) )
trg = ans ( A , B ) を出力する
rst = <unk> ( A , B ) を出力する <eos>
873
src = del A [ B [ 0 ] ]
trg = A の B の先頭 番 目 を削除する
rst = A の B の先頭 番 目 を削除する <eos>
874
src = A = lambda B , C : B * C
trg = x 、 y を パラメータ として x に y を 掛 け た 値を返す 関数を A とする
rst = x 、 y を パラメータ として x に y を 掛 け た 値を返す 関数を A とする <eos>
875
src = if not 0 <= A <= 9 :
trg = 0 が A 以下 かどうか が 9 以下 でない とき 、
rst = 0 が A 以下 かどうか が 9 以下 でない とき 、 <eos>
876
src = for A in range ( B . size ) :
trg = 0 から B の size 未 満 までの 数 列 を 順に A として 、 繰り返す
rst = 0 から B の size 未 満 までの 数 列 を 順に A として 、 繰り返す <eos>
877
src = A . append ( int . from_bytes ( B . encode ( C ) , D ) - E )
trg = A の 末 尾 に バイト 列 B を 文字コード C で 復 号 化した 文字列 、 D から の 整数値 から E を 引 いた 値 を追加する
rst = A の 末 尾 に <unk> 列 B を 文字コード C で <unk> <unk> <unk> 文字列 、 D から E を 引 いた 値の 整数値 を追加する <eos>
878
src = print ( A . name )
trg = A の name を出力する
rst = A の name を出力する <eos>
879
src = for A in range ( - B , 2 * B ) :
trg = - B から 2 に B を 掛 け た 値 未 満 までの 数 列 を 順に A として 、 繰り返す
rst = - B から 2 に B を 掛 け た 値 未 満 までの 数 列 を 順に A として 、 繰り返す <eos>
880
src = A . next = None
trg = 未 定 値を A の next にする
rst = 未 定 値を A の next にする <eos>
881
src = A = [ ( B [ 0 ] + C [ 0 ] ) / 2 , ( B [ 1 ] + C [ 1 ] ) / 2 ]
trg = ( B の 0 番 目 に C の先頭 を加えた 値を 2 で 割 った 値 、 B の 1 番 目 に C の 1 番 目 を加えた 値を 2 で 割 った 値 ) からなる 列 を A とする
rst = ( B の 0 番 目 に C の先頭 を加えた 値を 2 で 割 った 値 、 B の 1 番 目 に C の 1 番 目 を加えた 値を 2 で 割 った 値 ) からなる 列 を A とする <eos>
882
src = A = 2 * B - 1
trg = 2 に B を 掛 け た 値 から 1 を 引 いた 値を A とする
rst = 2 に B を 掛 け た 値 から 1 を 引 いた 値を A とする <eos>
883
src = for A in range ( 2 , B , 2 ) :
trg = 2 から B 未 満 までの 2 間隔 の 数 列 を 順に A として 、 繰り返す
rst = 2 から B 未 満 までの 2 間隔 の 数 列 を 順に A として 、 繰り返す <eos>
884
src = A [ 1 ] = ( B [ 0 ] - C [ 0 ] ) * math . sin ( D ) + ( B [ 1 ] - C [ 1 ] ) * math . cos ( D ) + C [ 1 ]
trg = B の 0 番 目 から C の先頭 を 引 いた 値に D の 正 弦 を 掛 け た 値に B の 1 番 目 から C の 1 番 目 を 引 いた 値に D の 余 弦 を 掛 け た 値 を加えた 値に C の 1 番 目 を加えた 値を A の 1 番 目 にする
rst = B の 0 番 目 から C の先頭 を 引 いた 値に D の 正 弦 を 掛 け た 値に B の 1 番 目 から C の 1 番 目 を 引 いた 値に D の 正 弦 を 掛 け た 値 を加えた 値に C の 1
885
src = if A == 100 :
trg = A が 100 と 等 しい とき 、
rst = A が 100 と 等 しい とき 、 <eos>
886
src = A = phase ( - B )
trg = phase ( - B ) を A とする
rst = phase ( - B ) を A とする <eos>
887
src = A [ - B - 1 ] -= C * D
trg = A の - B から 1 を 引 いた 値 番 目 を C に D を 掛 け た 値 だけ 減少 させる
rst = A の - B から 1 を 引 いた 値 番 目 を C に D を 掛 け た 値 だけ 減少 させる <eos>
888
src = A = ( B + C ) % 10
trg = B に C を加えた 値を 10 で 割 った 余 り を A とする
rst = B に C を加えた 値を 10 で 割 った 余 り を A とする <eos>
889
src = print ( A + B * int ( int ( input ( ) ) / 100 ) )
trg = A に B に int ( input () ) を 100 で 割 った 値の 整数値 を 掛 け た 値 を加えた 値 を出力する
rst = A に B に input () の 整数値 を 100 で 割 った 値の 整数値 を 掛 け た 値 を加えた 値 を出力する <eos>
890
src = A = [ 4 , 1 , 4 , 1 , 2 , 1 , 2 , 1 , 4 , 1 , 4 , 1 , 2 , 1 , 2 , 1 ]
trg = ( 4 、 1 、 4 、 1 、 2 、 1 、 2 、 1 、 4 、 1 、 4 、 1 、 2 、 1 、 2 、 1 ) からなる 列 を A とする
rst = ( 4 、 1 、 1 、 4 、 1 、 2 、 1 、 2 、 1 、 4 、 1 、 2 、 1 、 2 ) からなる 列 を A とする <eos>
891
src = A . itr = MyList ( [ 0 ] * A . V )
trg = MyList ( [ 0 ] * A . V ) を A の itr にする
rst = MyList ( [ 0 ] * A . V ) を A の itr にする <eos>
892
src = A = dot ( B , C ) / dot ( C , C )
trg = dot ( B , C ) を dot ( C , C ) で 割 った 値を A とする
rst = dot ( B , C ) を dot ( C , C ) で 割 った 値を A とする <eos>
893
src = if A [ 1 ] [ 1 ] == B - 2 :
trg = A の 1 番目の 1 番 目 が B から 2 を 引 いた 値 と 等 しい とき 、
rst = A の 1 番目の 1 番 目 が B から 2 を 引 いた 値 と 等 しい とき 、 <eos>
894
src = if ( A , A + 1 ) in B [ C ] :
trg = ( A 、 A に 1 を加えた 値 ) の 組 が B の C 番 目 に含まれる とき 、
rst = ( A 、 A に 1 を加えた 値 ) の 組 が B の C 番 目 に含まれる とき 、 <eos>
895
src = A [ B + 2 ] += 1
trg = A の B に 2 を加えた 値 番 目 を 1 だけ 増加 させる
rst = A の B に 2 を加えた 値 番 目 を 1 だけ 増加 させる <eos>
896
src = A [ B ] , A [ B + 1 ] = A [ B + 1 ] , A [ B ]
trg = A の B に 1 を加えた 値 番 目 、 A の B 番 目 を A の B 番 目 、 A の B に 1 を加えた 値 番 目 とする
rst = A の B に 1 を加えた 値 番 目 、 A の B 番 目 を A の B 番 目 、 A の B に 1 を加えた 値 番 目 とする <eos>
897
src = A , B , C , D , E , F , G = H
trg = H を 展開 し 、 それぞれ A 、 B 、 C 、 D 、 E 、 F 、 G とする
rst = H を 展開 し 、 それぞれ A 、 B 、 C 、 D 、 E 、 F 、 G とする <eos>
898
src = A = [ [ - 1 for B in range ( C ) ] for B in range ( C ) ]
trg = 0 から C 未 満 までの 数 列 の 各要素 を B とし 、 0 から C 未 満 までの 数 列 の 各要素 を B とし 、 -1 の 列 の 列 を A とする
rst = 0 から C 未 満 までの 数 列 の 各要素 を B とし 、 0 から C 未 満 までの 数 列 の 各要素 を B とし 、 -1 の 列 の 列 を A とする <eos>
899
src = if e [ 0 ] != e [ 1 ] and e [ 1 ] != e [ 2 ] and e [ 2 ] != e [ 0 ] :
trg = ネ イ ピ ア 数の 0 番 目 が 、 つまり ネ イ ピ ア 数の 1 番 目 と 等 しく なく かつ 、 つまり ネ イ ピ ア 数の 1 番 目 が 、 つまり ネ イ ピ ア 数の 2 番 目 と 等 しく なく かつ 、 つまり ネ イ ピ ア 数の 2 番 目 が 、 つまり ネ イ ピ ア 数 の先頭 と 等 しく ない とき 、
rst = ネ イ ピ ア 数の 0 番 目 が 、 つまり ネ イ ピ ア 数の 1 番 目 と 等 しく なく かつ 、 つまり ネ イ ピ ア 数の 1 番 目 が 、 つまり ネ イ ピ ア 数の 2 番 目 と 等 しく ない とき
900
src = print ( A . format ( B [ C ] - 26 ) )
trg = A を 書式 として B の C 番 目 から 26 を 引 いた 値 で 整 形 した 文字列 を出力する
rst = A を 書式 として B の C 番 目 から 26 を 引 いた 値 で 整 形 した 文字列 を出力する <eos>
901
src = A = B [ C ] [ D + 1 ] [ E ] [ F - 1 ] + 1
trg = B の C 番目の D に 1 を加えた 値 番目の E 番目の F から 1 を 引 いた 値 番 目 に 1 を加えた 値を A とする
rst = B の C 番目の D に 1 を加えた 値 番目の E 番目の F から 1 を 引 いた 値 番 目 に 1 を加えた 値を A とする <eos>
902
src = if A [ B ] [ C ] + A [ C ] [ D ] + A [ D ] [ B ] < 0 :
trg = A の B 番目の C 番 目 に A の C 番目の D 番 目 を加えた 値に A の D 番目の B 番 目 を加えた 値が 0 より 小さい とき 、
rst = A の B 番目の C 番 目 に A の C 番目の D 番 目 を加えた 値に A の D 番目の B 番 目 を加えた 値が 0 より 小さい とき 、 <eos>
903
src = A = B * C * 4
trg = B に C を 掛 け た 値に 4 を 掛 け た 値を A とする
rst = B に C を 掛 け た 値に 4 を 掛 け た 値を A とする <eos>
904
src = for A in range ( 200 ) :
trg = 0 から 200 未 満 までの 数 列 を 順に A として 、 繰り返す
rst = 0 から 200 未 満 までの 数 列 を 順に A として 、 繰り返す <eos>
905
src = print ( A [ B ] , C [ B ] , D [ B ] )
trg = A の B 番 目 、 C の B 番 目 、 D の B 番 目 を出力する
rst = A の B 番 目 、 C の B 番 目 、 D の B 番 目 を出力する <eos>
906
src = print ( * ( [ sum ( sorted ( [ int ( input ( ) ) for A in range ( 10 ) ] ) [ - 3 : ] ) for A in range ( 2 ) ] ) )
trg = 0 から 2 未 満 までの 数 列 の 各要素 を A とし 、 sorted ( [ int ( input () ) forAinrange ( 10 ) ] ) の -3 番 目 から 、 つまり 末 尾 までの 部分 列 の 総 和 の 列 を 展開 して を出力する
rst = 0 から 2 未 満 までの 数 列 の 各要素 を A とし 、 [ int ( input () ) forAinrange ( 10 ) ] を ソート した 列 の 、 つまり 先頭 から 3 番 目 までの 部分 列 の 総 和 の 列 を 展開 して を出力する <eos>
907
src = write ( '\n' . join ( [ A % ( B , C ) for B , C in enumerate ( D ) ] ) )
trg = write ( ' \ n ' . join ( [ A % ( B , C ) forB , Cinenumerate ( D ) ] ) )
rst = write ( ' \ n ' . join ( [ A % ( B , C ) <unk> ( D ) ] ) <eos>
908
src = print ( ' ' + ' ' . join ( map ( str , A [ 1 : ] ) ) )
trg = 空白 文字 に 空白 文字 を 間 に 入れ て A の先頭 を 除 いた 部分 列 の 各要素 に 整数 を適用した 列 を 連結 した 文字列 を加えた 値 を出力する
rst = 空白 文字 に 空白 文字 を 間 に 入れ て A の先頭 を 除 いた 部分 列 の 各要素 に 整数 を適用した 列 を 連結 した 文字列 を加えた 値 を出力する <eos>
909
src = A . laz [ ( B << 1 ) + 1 ] = A . op ( A . laz [ ( B << 1 ) + 1 ] , A . laz [ B ] )
trg = A . op ( A . laz [ ( B < < 1 ) + 1 ] , A . laz [ B ] ) を A の laz の B を 1 だけ 左 シフト した 値に 1 を加えた 値 番 目 にする
rst = A . op ( A . laz [ ( B < 1 ) ] + 1 ) 、 A の laz の B 番 目 を A の laz の B を 1 だけ 左 シフト した 値に 1 を加えた 値 番 目 にする <eos>
910
src = A = [ 1 ] * 1000000
trg = (1) からなる 列 の 100 0000 回 分 の 列 を A とする
rst = (1) からなる 列 の 100 0000 回 分 の 列 を A とする <eos>
911
src = A = xn ( B / 2 , B )
trg = xn ( B /2 , B ) を A とする
rst = <unk> ( B / /2 , B ) を A とする <eos>
912
src = if not A in B . answers :
trg = A が B の answers に 含まれ ない とき 、
rst = A が B の answers に 含まれ ない とき 、 <eos>
913
src = print ( min ( [ abs ( e - math . sqrt ( A ** 2 + ( B - A ) ** 2 ) ) for A in range ( B // 2 + 1 ) ] ) )
trg = 0 から B / /2 に 1 を加えた 値 未 満 までの 数 列 の 各要素 を A とし 、 e から math . sqrt ( A * * 2 + ( B - A ) * * 2 ) を 引 いた 値の 絶対 値の 列 の 最小 値 を出力する
rst = 0 から B / /2 に 1 を加えた 値 未 満 までの 数 列 の 各要素 を A とし 、 ( e - A * * 2 + ( B - A ) * * 2 ) - A の 絶対 値の 列 の 最小 値 を出力する <eos>
914
src = A = [ [ None ] * [ 5 for B in range ( 5 ) ] ]
trg = ( ( 、 つまり 未 定 値 ) からなる 列 の 0 から 5 未 満 までの 数 列 の 各要素 を B とし 、 5 の 列 回 分 の 列 ) からなる 列 を A とする
rst = ( ( 、 つまり 未 定 値 ) からなる 列 の 0 から 5 未 満 までの 数 列 の 各要素 を B とし 、 5 の 列 回 分 の 列 ) からなる 列 を A とする <eos>
915
src = if A [ B - 1 ] [ C ] < A [ B ] [ C ] and D . back > E :
trg = A の B から 1 を 引 いた 値 番目の C 番 目 が A の B 番目の C 番 目 より 小さく かつ D の back が E より 大きい とき 、
rst = A の B から 1 を 引 いた 値 番目の C 番 目 が A の B 番目の C 番 目 より 小さく かつ D の back が E より 大きい とき 、 <eos>
916
src = if len ( A ) > 1 and A [ 0 ] == B or len ( C ) > 1 and C [ 0 ] == B or len ( D ) > 1 and D [ 0 ] == B :
trg = A の長さ が 1 より 大きく かつ A の先頭 が B と 等 しく または C の長さ が 1 より 大きく かつ C の先頭 が B と 等 しく または D の長さ が 1 より 大きく かつ D の先頭 が B と 等 しい とき 、
rst = A の長さ が 1 より 大きく かつ A の 0 番 目 が B と 等 しく または C の長さ が 1 より 大きく かつ C の 0 番 目 が B と 等 しく または D の長さ が 1 より 大きく かつ D の 0 番 目 が B
917
src = A -= ( A - 1 ) % 5
trg = A を A から 1 を 引 いた 値を 5 で 割 った 余 り だけ 減少 させる
rst = A を A から 1 を 引 いた 値を 5 で 割 った 余 り だけ 減少 させる <eos>
918
src = print ( A . list [ 0 ] )
trg = A の list の先頭 を出力する
rst = A の list の先頭 を出力する <eos>
919
src = return int ( max ( A ) + 0.5 )
trg = A の 最大 値に 0.5 を加えた 値の 整数 値を返す
rst = A の 最大 値に 0.5 を加えた 値の 整数 値を返す <eos>
920
src = print ( [ B , C ] [ D == A ] + E )
trg = ( B 、 C ) からなる 列 の D が A と 等 しい かどうか 番 目 に E を加えた 値 を出力する
rst = ( B 、 C ) からなる 列 の D が A と 等 しい かどうか 番 目 に E を加えた 値 を出力する <eos>
921
src = print ( ( A [ B ] // A [ B - C ] ) % D )
trg = A の B 番 目 を A の B から C を 引 いた 値 番 目 で 割 った 商 を D で 割 った 余 り を出力する
rst = A の B 番 目 を A の B から C を 引 いた 値 番 目 で 割 った 商 を D で 割 った 余 り を出力する <eos>
922
src = A = B [ C ] [ 0 ] * D [ C ]
trg = B の C 番目の 0 番 目 に D の C 番 目 を 掛 け た 値を A とする
rst = B の C 番目の 先頭に D の C 番 目 を 掛 け た 値を A とする <eos>
923
src = A = B . deque ( [ int ( input ( ) ) for C in range ( D ) ] )
trg = B . deque ( [ int ( input () ) forCinrange ( D ) ] ) を A とする
rst = B の 0 から D 未 満 までの 数 列 の 各要素 を C とし 、 、 つまり 入力された 文字列 の 整数値 の 列 の 両 端 キュー を A とする <eos>
924
src = A [ B ] [ C ] . append ( 0 )
trg = A の B 番目の C 番目の 末 尾 に 0 を追加する
rst = A の B 番目の C 番目の 末 尾 に 0 を追加する <eos>
925
src = A = min ( A , dfs ( B , C + 1 , 0 , D , 1 , 0 ) )
trg = A 、 dfs ( B , C + 1, 0 , D , 1, 0 ) の 最小 値を A とする
rst = A 、 dfs ( B , C + 1, 0 , D , 1 ) 、 0 の 最小 値を A とする <eos>
926
src = A = { 'A' : True , 'B' : False , 'C' : False }
trg = ( ( B , 真 ) 、 ( C , 偽 ) 、 ( D , 偽 ) ) からなる 辞書 を A とする
rst = ( ( B , 、 つまり 真 ) 、 ( C , 、 つまり 偽 ) 、 ( 、 偽 ) ) からなる 辞書 を A とする <eos>
927
src = A = B . head . next
trg = B の head の next を A とする
rst = B の head の next を A とする <eos>
928
src = A = list ( map ( int , input ( ) . split ( ) ) ) [ 1 : ]
trg = 入力された 文字列を 空白 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 のリスト の先頭 を 除 いた 部分 列 を A とする
rst = 入力された 文字列を 空白 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 のリスト の先頭 を 除 いた 部分 列 を A とする <eos>
929
src = for A in B [ : 10 ] :
trg = B の 、 つまり 先頭 から 10 番 目 までの 部分 列 を 順に A として 、 繰り返す
rst = B の 、 つまり 先頭 から 10 番 目 までの 部分 列 を 順に A として 、 繰り返す <eos>
930
src = A . M = [ [ B . INFINITY ] * [ C for D in range ( C ) ] ]
trg = ( ( B の INFINITY ) からなる 列 の 0 から C 未 満 までの 数 列 の 各要素 を D とし 、 C の 列 回 分 の 列 ) からなる 列 を A の M にする
rst = ( ( B の INFINITY ) からなる 列 の 0 から C 未 満 までの 数 列 の 各要素 を D とし 、 C の 列 回 分 の 列 ) からなる 列 を A の M にする <eos>
931
src = A = [ B for B in C . GetNodes ( ) if C . InDegree ( B ) == 0 ]
trg = C . GetNodes () の 各要素 を B とし 、 C . InDegree ( B ) が 0 と 等 しい とき の B の 列 を A とする
rst = C . GetNodes () の 各要素 を B とし 、 C . <unk> ( B ) が 0 と 等 しい とき の B の 列 を A とする <eos>
932
src = A += min ( abs ( B - C [ D ] ) , abs ( B - C [ D - 1 ] ) )
trg = A を B から C の D 番 目 を 引 いた 値の 絶対 値 、 B から C の D から 1 を 引 いた 値 番 目 を 引 いた 値の 絶対 値の 最小 値 だけ 増加 させる
rst = A を B から C の D 番 目 を 引 いた 値の 絶対 値 、 B から C の D から 1 を 引 いた 値 番 目 を 引 いた 値の 絶対 値の 最小 値 だけ 増加 させる <eos>
933
src = for A , B in enumerate ( zip ( C , D , D [ 1 : ] ) , start = 1 ) :
trg = 1 を 開始 番号 として C 、 D 、 D の先頭 を 除 いた 部分 列 の 要素を それぞれ 組 にした 列 に 番号 付 した 組 の 列 を 順に A 、 B として 、 繰り返す
rst = 1 を 開始 番号 として C 、 D の先頭 を 除 いた 部分 列 の 要素を それぞれ 組 にした 列 に 番号 付 した 組 の 列 を 順に A 、 B として 、 繰り返す <eos>
934
src = A . tail . prev . next = B
trg = B を A の tail の prev の next にする
rst = B を A の tail の next にする <eos>
935
src = A , B = [ - 1 ] * C , [ - 1 ] * C
trg = ( -1 ) からなる 列 の C 回 分 の 列 、 ( -1 ) からなる 列 の C 回 分 の 列 を A 、 B とする
rst = ( -1 ) からなる 列 の C 回 分 の 列 、 ( -1 ) からなる 列 の C 回 分 の 列 を A 、 B とする <eos>
936
src = print ( A [ B == 2 ] )
trg = A の B が 2 と 等 しい かどうか 番 目 を出力する
rst = A の B が 2 と 等 しい かどうか 番 目 を出力する <eos>
937
src = A = [ None ] * 31
trg = ( 、 つまり 未 定 値 ) からなる 列 の 3 1 回 分 の 列 を A とする
rst = ( 、 つまり 未 定 値 ) からなる 列 の 3 1 回 分 の 列 を A とする <eos>
938
src = return power ( A , B // 2 ) ** 2 * A % C
trg = power ( A , B / /2 ) の 2 乗 に A を 掛 け た 値を C で 割 った 余 り を返す
rst = power ( A , B / /2 ) の 2 乗 に A を 掛 け た 値を C で 割 った 余 り を返す <eos>
939
src = A [ B ] [ C ] = len ( D ) - ( E - F )
trg = D の長さ から E から F を 引 いた 値を 引 いた 値を A の B 番目の C 番 目 にする
rst = D の長さ から E から F を 引 いた 値を 引 いた 値を A の B 番目の C 番 目 にする <eos>
940
src = if A == [ 2 , 3 ] :
trg = A が ( 2 、 3 ) からなる 列 と 等 しい とき 、
rst = A が ( 2 、 3 ) からなる 列 と 等 しい とき 、 <eos>
941
src = while A and A * B [ 0 ] [ 0 ] < C :
trg = A かつ A に B の先頭 の 0 番 目 を 掛 け た 値が C より 小さい 間 、 次 を 繰り返す
rst = A かつ A に B の先頭 の 0 番 目 を 掛 け た 値が C より 小さい 間 、 次 を 繰り返す <eos>
942
src = A . append ( ( B , C , D , 10 ** 9 , 0 , 0 ) )
trg = A の 末 尾 に ( B 、 C 、 D 、 10 の 9 乗 、 0 、 0 ) の 組 を追加する
rst = A の 末 尾 に ( B 、 C 、 D 、 10 の 9 乗 、 0 、 0 ) の 組 を追加する <eos>
943
src = swap ( A [ 0 ] )
trg = swap ( A [ 0 ] )
rst = swap ( A [ 0 ] ) <eos>
944
src = A = dcmp ( cross ( B [ 1 ] - B [ 0 ] , C - B [ 0 ] ) )
trg = dcmp ( cross ( B [ 1 ]- B [ 0 ] , C - B [ 0 ] ) ) を A とする
rst = <unk> ( cross ( B [ 1 ]- B [ 0 ] , C - B [ 0 ] ) ) を A とする <eos>
945
src = A , B = divmod ( A , 10000 )
trg = A と 1 0000 を 割 った とき の ( 商 を 展開 し 、 それぞれ A 、 B とする
rst = A と 1 0000 を 割 った とき の ( 商 を 展開 し 、 それぞれ A 、 B とする <eos>
946
src = for A in range ( 4 , B + 1 , 2 ) :
trg = 4 から B に 1 を加えた 値 未 満 までの 2 間隔 の 数 列 を 順に A として 、 繰り返す
rst = 4 から B に 1 を加えた 値 未 満 までの 2 間隔 の 数 列 を 順に A として 、 繰り返す <eos>
947
src = A -= min ( 3 , ( A - 1 ) // 36524 ) * 36524
trg = A を 3 、 A から 1 を 引 いた 値を 36 5 24 で 割 った 商 の 最小 値に 36 5 24 を 掛 け た 値 だけ 減少 させる
rst = A を 3 、 A から 1 を 引 いた 値を 36 5 24 で 割 った 商 の 最小 値に 3 を 掛 け た 値 だけ 減少 させる <eos>
948
src = if A . root . left is None :
trg = A の root の left が 、 つまり 未 定 値 と 等 しく ない とき 、
rst = A の root の left が 、 つまり 未 定 値 と 等 しく ない とき 、 <eos>
949
src = A . nodes = [ ]
trg = 空 列 を A の nodes にする
rst = 空 列 を A の nodes にする <eos>
950
src = A = B . ccw ( C [ - 1 ] , D , E )
trg = B . ccw ( C [ -1 ] , D , E ) を A とする
rst = B . ccw ( C [ -1 ] , D , E ) を A とする <eos>
951
src = A += B * C [ D - E - 1 ]
trg = A を B に C の D から E を 引 いた 値 から 1 を 引 いた 値 番 目 を 掛 け た 値 だけ 増加 させる
rst = A を B に C の D から E を 引 いた 値 から 1 を 引 いた 値 番 目 を 掛 け た 値 だけ 増加 させる <eos>
952
src = A = asin ( B / sqrt ( C ) )
trg = asin ( B / sqrt ( C ) ) を A とする
rst = asin ( B / sqrt ( C ) ) を A とする <eos>
953
src = A . data ^= 1 << int ( B )
trg = A の data を 1 を B の 整数値 だけ 左 シフト した 値 と の 排 他 的 論理 和 にする
rst = A の data を 1 を B の 整数値 だけ 左 シフト した 値 と の 排 他 的 論理 和 にする <eos>
954
src = if not A + B :
trg = A に B を加えた 値 でない とき 、
rst = A に B を加えた 値 でない とき 、 <eos>
955
src = relax ( e )
trg = relax ( e )
rst = <unk> ( e ) <eos>
956
src = return C [ D ] if A [ B ] else E + 1
trg = A の B 番目の とき C の D 番 目 、 そうでなければ E に 1 を加えた 値を返す
rst = A の B 番目の とき C の D 番 目 、 そうでなければ E に 1 を加えた 値を返す <eos>
957
src = if A [ 0 ] // 10 <= B < C [ 0 ] // 10 or A [ 0 ] // 10 == C [ 0 ] // 10 == B :
trg = A の先頭 を 10 で 割 った 商 が B 以下 かどうか が C の先頭 を 10 で 割 った 商 より 小さく または A の先頭 を 10 で 割 った 商 が C の先頭 を 10 で 割 った 商 と 等 しい かどうか が B と 等 しい とき 、
rst = A の 0 番 目 を 10 で 割 った 商 が B より 小さい かどうか が C の 0 番 目 を 10 で 割 った 商 以下 または A の 0 番 目 を 10 で 割 った 商 が B と 等 しい とき 、 <eos>
958
src = A = list ( map ( int , input ( ) . split ( ) ) ) + [ sys . maxsize ]
trg = 入力された 文字列を 空白 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 のリスト に ( sys の maxsize ) からなる 列 を加えた 値を A とする
rst = 入力された 文字列を 空白 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 のリスト に ( sys の maxsize ) からなる 列 を加えた 値を A とする <eos>
959
src = for A , B in sorted ( C . items ( ) , key = lambda D : D [ 1 ] ) [ : : - 1 ] :
trg = x を パラメータ として x の 1 番 目 を返す関数 を キー として C の キー と 値 の集まり を ソート した 列 の 逆 順 を 順に A 、 B として 、 繰り返す
rst = x を パラメータ として x の 1 番 目 を返す関数 を キー として C の キー と 値 の集まり を ソート した 列 の 逆 順 を 順に A 、 B として 、 繰り返す <eos>
960
src = A . push ( B , C )
trg = A . push ( B , C )
rst = A . push ( B , C ) <eos>
961
src = A = ( 2 * ( B - C ) * D - E ** 2 - B ** 2 + F ** 2 + C ** 2 ) / ( 2 * ( F - E ) )
trg = 2 * ( B - C ) * D から E * * 2 を 引 いた 値 から B の 2 乗 を 引 いた 値に F の 2 乗 を加えた 値に C の 2 乗 を加えた 値を 2 に F から E を 引 いた 値を 掛 け た 値 で 割 った 値を A とする
rst = 2 に B から C を 引 いた 値を 掛 け た 値に D を 掛 け た 値 から E * * 2 を 引 いた 値に F * * 2 に C * * 2 を加えた 値を 掛 け た 値を 引 いた 値を 2 で 割 った
962
src = A . append ( [ True ] + [ False ] * B + [ True ] )
trg = A の 末 尾 に ( 、 つまり 真 ) からなる 列 に ( 、 つまり 偽 ) からなる 列 の B に ( True ) からなる 列 を加えた 値 回 分 の 列 を加えた 値 を追加する
rst = A の 末 尾 に ( 、 つまり 真 ) からなる 列 に ( 、 つまり 偽 ) からなる 列 の B に [ 、 つまり 真 ] を加えた 値 回 分 の 列 を加えた 値 を追加する <eos>
963
src = A = [ 0 , 1 , 2 , 4 , 6 , 16 , 12 , 64 , 24 , 36 , 48 , 1024 , 60 ]
trg = ( 0 、 1 、 2 、 4 、 6 、 16 、 12 、 64 、 24 、 36 、 4 8 、 10 24 、 60 ) からなる 列 を A とする
rst = ( 0 、 1 、 2 、 4 、 6 、 16 、 12 、 64 、 24 、 36 、 4 8 、 10 24 、 60 ) からなる 列 を A とする <eos>
964
src = print ( max ( A , B ) )
trg = A 、 B の 最大 値 を出力する
rst = A 、 B の 最大 値 を出力する <eos>
965
src = A = sorted ( B , key = lambda C : ( - C [ 1 ] , C [ 2 ] , C [ 0 ] ) )
trg = x を パラメータ として ( - C の 1 番 目 、 x の 2 番 目 、 x の先頭 ) の 組 を返す関数 を キー として B を ソート した 列 を A とする
rst = x を パラメータ として ( - C の 1 番 目 、 x の 2 番 目 、 x の先頭 ) の 組 を返す関数 を キー として B を ソート した 列 を A とする <eos>
966
src = A , B , C , D = C , D , A , B
trg = C 、 D 、 A 、 B を A 、 B 、 C 、 D とする
rst = C 、 D 、 A 、 B を A 、 B 、 C 、 D とする <eos>
967
src = while A [ 0 ] [ 1 ] == B :
trg = A の先頭 の 1 番 目 が B と 等 しい 間 、 次 を 繰り返す
rst = A の先頭 の 1 番 目 が B と 等 しい 間 、 次 を 繰り返す <eos>
968
src = A = { 'A' : 0 , 'B' : 0 , 'AB' : 0 , 'O' : 0 }
trg = ( ( B , 0 ) 、 ( C , 0 ) 、 ( D , 0 ) 、 ( E , 0 ) ) からなる 辞書 を A とする
rst = ( ( B , 0 ) 、 ( C , 0 ) 、 ( D , 0 ) 、 ( E , 0 ) ) からなる 辞書 を A とする <eos>
969
src = A = sum ( [ B . count ( - 1 ) for B in C ] )
trg = C の 各要素 を B とし 、 B 内の -1 の 出現 回数 の 列 の 総 和 を A とする
rst = C の 各要素 を B とし 、 B 内の -1 の 出現 回数 の 列 の 総 和 を A とする <eos>
970
src = A = B * ( C - D + 1 )
trg = B に C から D を 引 いた 値に 1 を加えた 値を 掛 け た 値を A とする
rst = B に C から D を 引 いた 値に 1 を加えた 値を 掛 け た 値を A とする <eos>
971
src = if A % 3 == 0 or B in str ( A ) :
trg = A を 3 で 割 った 余 り が 0 と 等 しく または B が A の 文字列 に含まれる とき 、
rst = A を 3 で 割 った 余 り が 0 と 等 しく または B が A の 文字列 に含まれる とき 、 <eos>
972
src = A = it ( ) - B
trg = it () から B を 引 いた 値を A とする
rst = it () から B を 引 いた 値を A とする <eos>
973
src = A = B [ C [ D + 1 ] ]
trg = B の C の D に 1 を加えた 値 番 目 番 目 を A とする
rst = B の C の D に 1 を加えた 値 番 目 番 目 を A とする <eos>
974
src = A , B , C , D , e , E = F [ 0 ] , F [ 1 ] , F [ 2 ] , F [ 3 ] , F [ 4 ] , F [ 5 ]
trg = F の先頭 、 F の 1 番 目 、 F の 2 番 目 、 F の 3 番 目 、 F の 4 番 目 、 F の 5 番 目 を A 、 B 、 C 、 D 、 ネ イ ピ ア 数 、 E とする
rst = F の先頭 、 F の 1 番 目 、 F の 2 番 目 、 F の 3 番 目 、 F の 4 番 目 を A 、 B 、 C 、 D 、 ネ イ ピ ア 数 、 E とする <eos>
975
src = A [ 0 ] = B [ C ] [ D ] [ 0 ] - B [ E - 1 ] [ D ] [ 0 ] - B [ C ] [ F - 1 ] [ 0 ] + B [ E - 1 ] [ F - 1 ] [ 0 ]
trg = B [ C ] の D 番目の 0 番 目 から B [ E -1 ] の D 番目の 0 番 目 を 引 いた 値 から B の C 番目の F から 1 を 引 いた 値 番目の 0 番 目 を 引 いた 値に B の E から 1 を 引 いた 値 番目の F から 1 を 引 いた 値 番目の 先頭 を加えた 値を A の 0 番 目 にする
rst = B の C 番目の D 番目の 0 番 目 から B の E -1 番目の D 番目の 先頭 を 引 いた 値 から B の C 番目の F から 1 を 引 いた 値 番目の 0 番 目 を 引 いた 値に B の E から 1 を 引 いた
976
src = return A . real * ( B - C ) + C
trg = A の real に B から C を 引 いた 値を 掛 け た 値に C を加えた 値を返す
rst = A の real に B から C を 引 いた 値を 掛 け た 値に C を加えた 値を返す <eos>
977
src = A [ B ] [ C ] += max ( A [ B - 1 ] [ C : C + 2 ] )
trg = A の B 番目の C 番 目 を A の B から 1 を 引 いた 値 番目の C 番 目 から C に 2 を加えた 値 までの 部分 列 の 最大 値 だけ 増加 させる
rst = A の B 番目の C 番 目 を A の B から 1 を 引 いた 値 番目の C 番 目 から C に 2 を加えた 値 までの 部分 列 の 最大 値 だけ 増加 させる <eos>
978
src = A [ B ] = ( C [ B ] + C [ B + 1 ] ) % 10
trg = C の B 番 目 に C の B に 1 を加えた 値 番 目 を加えた 値を 10 で 割 った 余 り を A の B 番 目 にする
rst = C の B 番 目 に C の B に 1 を加えた 値 番 目 を加えた 値を 10 で 割 った 余 り を A の B 番 目 にする <eos>
979
src = A . append ( B * 20 )
trg = A の 末 尾 に B に 20 を 掛 け た 値 を追加する
rst = A の 末 尾 に B に 20 を 掛 け た 値 を追加する <eos>
980
src = A . append ( ' ' )
trg = A の 末 尾 に 空白 文字 を追加する
rst = A の 末 尾 に 空白 文字 を追加する <eos>
981
src = print ( int ( A [ B ] ) )
trg = A の B 番目の 整数値 を出力する
rst = A の B 番目の 整数値 を出力する <eos>
982
src = A = atan2 ( B . c . y - C . c . y , B . c . x - C . c . x )
trg = atan 2 ( B . c . y - C . c . y , B . c . x - C . c . x ) を A とする
rst = atan 2 ( B . c . y - C . c . y , B . c - C . x ) を A とする <eos>
983
src = if dot ( A , B ) < 0 :
trg = dot ( A , B ) が 0 より 小さい とき 、
rst = dot ( A , B ) が 0 より 小さい とき 、 <eos>
984
src = funcs[op] ( A )
trg = funcs [ op ] ( A )
rst = <unk> ( A ) <eos>
985
src = A . append ( [ B , C , D , E - F ] )
trg = A の 末 尾 に ( B 、 C 、 D 、 E から F を 引 いた 値 ) からなる 列 を追加する
rst = A の 末 尾 に ( B 、 C 、 D 、 E から F を 引 いた 値 ) からなる 列 を追加する <eos>
986
src = A = { [ B for B in range ( C ) ] }
trg = ( < __ main __ . Cammaobjectat 0 x 10 a 1 db 8 80 > ) の集合 を A とする
rst = ( < __ main __ . Cammaobjectat 0 x 10 a 1 b 7 a 30 > ) の集合 を A とする <eos>
987
src = A = [ [ B for C in range ( D * 2 - 1 ) ] for C in range ( E * 2 - 1 ) ]
trg = 0 から E に 2 を 掛 け た 値 から 1 を 引 いた 値 未 満 までの 数 列 の 各要素 を C とし 、 0 から D に 2 を 掛 け た 値 から 1 を 引 いた 値 未 満 までの 数 列 の 各要素 を C とし 、 B の 列 の 列 を A とする
rst = 0 から E に 2 を 掛 け た 値 から 1 を 引 いた 値 未 満 までの 数 列 の 各要素 を C とし 、 0 から D に 2 を 掛 け た 値 から 1 を 引 いた 値 未 満 までの 数 列 の 各要素
988
src = print ( A . strip ( ) . replace ( B , C ) . replace ( D , B ) . replace ( C , D ) )
trg = A の 両 端 から 空白 改行 を取り 除 いた 文字列 内の B を C で 置き換え た 文字列 内の D を B で 置き換え た 文字列 内の C を D で 置き換え た 文字列 を出力する
rst = A 内の [MASK] の 両 端 から 空白 改行 を取り 除 いた 文字列 内の B を C で 置き換え た 文字列 内の D を B で 置き換え た 文字列 内の C を D で 置き換え た 文字列 を出力する <eos>
989
src = A . index = [ None ] * B
trg = ( 、 つまり 未 定 値 ) からなる 列 の B 回 分 の 列 を A の [MASK] と 等 しい 要素 の最初の 位置 にする
rst = ( 、 つまり 未 定 値 ) からなる 列 の B 回 分 の 列 を A の [MASK] と 等 しい 要素 の最初の 位置 にする <eos>
990
src = A = B + ( ( C + e - D ) % ( e - B ) )
trg = B に C に ネ イ ピ ア 数 を加えた 値 から D を 引 いた 値を ネ イ ピ ア 数 から B を 引 いた 値 で 割 った 余 り を加えた 値を A とする
rst = B に C に e を加えた 値 から D を 引 いた 値を ネ イ ピ ア 数 から B を 引 いた 値 で 割 った 余 り を加えた 値を A とする <eos>
991
src = A = search ( A , B )
trg = B において 正規表現 A が 最初 にマッチする 位置 を A とする
rst = B において 正規表現 A が 最初 にマッチする 位置 を A とする <eos>
992
src = open ( 1 , A ) . writelines ( [ B % bisect ( C , int ( readline ( ) ) - 1 ) for D in range ( int ( readline ( ) ) ) ] )
trg = open ( 1, A ) . writelines ( [ B % bisect ( C , int ( readline () ) -1 ) forDinrange ( int ( readline () ) ) ] )
rst = open ( 1, A ) . writelines ( [ B % ( C , int ( readline () ) - int ( D ) ) <unk> ( readline () ) ] ) <eos>
993
src = A . remove ( [ B + 1 , C ] )
trg = A 内の ( B に 1 を加えた 値 、 C ) からなる 列 と 等 しい 要素を 取り除く
rst = A 内の ( B に 1 を加えた 値 、 C ) からなる 列 と 等 しい 要素を 取り除く <eos>
994
src = print ( A if A != inf else 0 )
trg = A が 、 つまり 無限大 と 等 しく ない とき A 、 そうでなければ 0 を出力する
rst = A が 、 つまり 無限大 と 等 しく ない とき A 、 そうでなければ 0 を出力する <eos>
995
src = A = moveNodeW ( B . node , C )
trg = moveNodeW ( B . node , C ) を A とする
rst = <unk> ( B . node , C ) を A とする <eos>
996
src = A += B // C [ D ]
trg = A を B を C の D 番 目 で 割 った 商 だけ 増加 させる
rst = A を B を C の D 番 目 で 割 った 商 だけ 増加 させる <eos>
997
src = write ( dfs ( A , 0 ) )
trg = write ( dfs ( A , 0 ) )
rst = write ( dfs ( A , 0 ) ) <eos>
998
src = B += 2
trg = B を 2 だけ 増加 させる
rst = B を 2 だけ 増加 させる <eos>
999
src = if A * B + C * D == 0 :
trg = A に B を 掛 け た 値に C に D を 掛 け た 値 を加えた 値が 0 と 等 しい とき 、
rst = A に B を 掛 け た 値に C に D を 掛 け た 値 を加えた 値が 0 と 等 しい とき 、 <eos>
1000
src = A = paint ( A , B - 1 , C )
trg = paint ( A , B - 1, C ) を A とする
rst = paint ( A , B - 1, C ) を A とする <eos>
1001
src = if A [ B + C ] [ 0 ] >= 0 :
trg = A の B に C を加えた 値 番目の 0 番 目 が 0 以上の とき 、
rst = A の B に C を加えた 値 番目の 0 番 目 が 0 以上の とき 、 <eos>
1002
src = print ( int ( sum ( [ max ( 40 , int ( input ( ) ) ) for A in range ( 5 ) ] ) / 5 ) )
trg = range ( 5 ) の 各要素 を A とし 、 max ( 40 , int ( input () ) ) の 列 の 総 和 を 5 で 割 った 値の 整数値 を出力する
rst = 0 から 5 未 満 までの 数 列 の 各要素 を A とし 、 40 、 int ( input () ) の 最大 値の 列 の 総 和 を 5 で 割 った 値の 整数値 を出力する <eos>
1003
src = A = A [ B - len ( A ) : ] + A [ : B ]
trg = A の B から A の長さ を 引 いた 値 から 、 つまり 末 尾 までの 部分 列 に A の 、 つまり 先頭 から B 番 目 までの 部分 列 を加えた 値を A とする
rst = A の B から A の長さ を 引 いた 値 から 、 つまり 末 尾 までの 部分 列 に A の 、 つまり 先頭 から B 番 目 までの 部分 列 を加えた 値を A とする <eos>
1004
src = return sum ( vector_product ( A , B ) )
trg = vector _ product ( A , B ) の 総 和 を返す
rst = <unk> ( A , B ) の 総 和 を返す <eos>
1005
src = if A + B + C <= 20 :
trg = A に B を加えた 値に C を加えた 値が 20 以下の とき 、
rst = A に B を加えた 値に C を加えた 値が 20 以下の とき 、 <eos>
1006
src = A [ B ] = A [ B - 1 ] + C [ B ]
trg = A の B から 1 を 引 いた 値 番 目 に C の B 番 目 を加えた 値を A の B 番 目 にする
rst = A の B から 1 を 引 いた 値 番 目 に C の B 番 目 を加えた 値を A の B 番 目 にする <eos>
1007
src = DFS ( A + 1 )
trg = DFS ( A + 1 )
rst = DFS ( A + 1 ) <eos>
1008
src = A = min ( [ B [ C ] [ D ] for C in range ( 1 << E ) ] )
trg = 0 から 1 を E だけ 左 シフト した 値 未 満 までの 数 列 の 各要素 を C とし 、 B の C 番目の D 番目の 列 の 最小 値を A とする
rst = 0 から 1 を E だけ 左 シフト した 値 未 満 までの 数 列 の 各要素 を C とし 、 B の C 番目の D 番目の 列 の 最小 値を A とする <eos>
1009
src = A += B [ C ] * C
trg = A を B の C 番 目 に C を 掛 け た 値 だけ 増加 させる
rst = A を B の C 番 目 に C を 掛 け た 値 だけ 増加 させる <eos>
1010
src = A [ 1 ] [ 0 ] [ 1 ] = sum ( [ C [ 1 ] [ D ] [ E ] + C [ D ] [ E ] [ 1 ] for D in [ F for E in F ] ] ) - sum ( [ C [ 1 ] [ D ] [ 1 ] for D in F ] ) if B in [ 0 , 2 ] else 0
trg = B が ( 0 、 2 ) からなる 列 に含まれる とき F の 各要素 を E とし 、 F の 列 の 各要素 を D とし 、 C [ 1 ] [ D ] [ E ] に C [ D ] [ E ] [ 1 ] を加えた 値の 列 の 総 和 から F の 各要素 を D とし 、 C [ 1 ] [ D ] の 1 番目の 列 の 総 和 を 引 いた 値
rst = B が ( 0 、 1 ) からなる 列 に含まれる とき F の 各要素 を E とし 、 F の 列 の 各要素 を D とし 、 C [ 1 ] [ D ] [ E ] に C [ 1 ] [ D ] [ 0 ] を加えた 値の
1011
src = print ( A . solve ( B , C , 1 , 1 , 1 , 0 ) )
trg = A . solve ( B , C , 1, 1, 1, 0 ) を出力する
rst = A . solve ( B , C , 1, 1, 0 ) を出力する <eos>
1012
src = if A [ B ] [ 1 ] == C :
trg = A の B 番目の 1 番 目 が C と 等 しい とき 、
rst = A の B 番目の 1 番 目 が C と 等 しい とき 、 <eos>
1013
src = A %= 25
trg = A を 25 で 割 った 余 り にする
rst = A を 25 で 割 った 余 り にする <eos>
1014
src = return A + 1911
trg = A に 19 11 を加えた 値を返す
rst = A に 19 11 を加えた 値を返す <eos>
1015
src = A -= 3 * B
trg = A を 3 に B を 掛 け た 値 だけ 減少 させる
rst = A を 3 に B を 掛 け た 値 だけ 減少 させる <eos>
1016
src = for e , A , B in C :
trg = C を 順に ネ イ ピ ア 数 、 A 、 B として 、 繰り返す
rst = C を 順に ネ イ ピ ア 数 、 A 、 B として 、 繰り返す <eos>
1017
src = A . append ( ( B , 0 , C , - 1 ) )
trg = A の 末 尾 に ( B 、 0 、 C 、 -1 ) の 組 を追加する
rst = A の 末 尾 に ( B 、 0 、 C 、 -1 ) の 組 を追加する <eos>
1018
src = if is_passable ( A , B , C , D , E , F [ G ] , H [ G ] ) and I [ J ] [ K ] == float ( L ) :
trg = is _ passable ( A , B , C , D , E , F [ G ] , H [ G ] ) かつ I の J 番目の K 番 目 が L の 浮動小数点数 と 等 しい とき 、
rst = line ( A , B , C , D , E , F [ G ] , H ] ) かつ I [ J ] の K 番 目 が L と 等 しい とき 、 <eos>
1019
src = return 6000
trg = 600 0 を返す
rst = 600 0 を返す <eos>
1020
src = if Cond ( A , B , C , D , E ) :
trg = Cond ( A , B , C , D , E ) の とき 、
rst = loadable ( A , B , C , D , E ) の とき 、 <eos>
1021
src = A . C [ B ] [ C ] = D + A . C [ B - 1 ] [ C - E ]
trg = D に A の C の B から 1 を 引 いた 値 番目の C から E を 引 いた 値 番 目 を加えた 値を A の C の B 番目の C 番 目 にする
rst = D に A の C の B から 1 を 引 いた 値 番目の C から E を 引 いた 値 番 目 を加えた 値を A の C の B 番目の C 番 目 にする <eos>
1022
src = A , B = map ( int , C . strip ( ) . split ( ) )
trg = C の 両 端 から 空白 改行 を取り 除 いた 文字列を 空白 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 を 展開 し 、 それぞれ A 、 B とする
rst = C の 両 端 から 空白 改行 を取り 除 いた 文字列を 空白 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 を 展開 し 、 それぞれ A 、 B とする <eos>
1023
src = A . sort ( key = lambda B : - B [ 1 ] )
trg = t を パラメータ として - t の 1 番 目 を返す関数 を key として A を ソート する
rst = item を パラメータ として - item の 1 番 目 を返す関数 を key として A を ソート する <eos>
1024
src = A [ B ] . sort ( key = lambda D : atan2 ( C [ D ] [ 1 ] - E , C [ D ] [ 0 ] - F ) )
trg = p を パラメータ として atan 2 ( C [ D ] [ 1 ]- E , C [ D ] [ 0 ]- F ) を返す関数 を key として A の B 番 目 を ソート する
rst = x を パラメータ として atan 2 ( C [ D ] [ 1 ]- E , C [ D ] [ 0 ]- F ) を返す関数 を key として A の B 番 目 を ソート する <eos>
1025
src = A [ B ] [ C ] = 10000
trg = 1 0000 を A の B 番目の C 番 目 にする
rst = 1 0000 を A の B 番目の C 番 目 にする <eos>
1026
src = A ^= 1
trg = A を 1 と の 排 他 的 論理 和 にする
rst = A を 1 と の 排 他 的 論理 和 にする <eos>
1027
src = A . rev [ B ] . append ( C )
trg = A の rev の B 番目の 末 尾 に C を追加する
rst = A の rev の B 番目の 末 尾 に C を追加する <eos>
1028
src = A = solve ( B + 1 , C )
trg = solve ( B + 1, C ) を A とする
rst = solve ( B + 1, C ) を A とする <eos>
1029
src = A [ B ] = C [ 1 : C [ 0 ] + 1 ]
trg = C の 1 番 目 から C の 先頭に 1 を加えた 値 までの 部分 列 を A の B 番 目 にする
rst = C の 1 番 目 から C の 0 番 目 に 1 を加えた 値 までの 部分 列 を A の B 番 目 にする <eos>
1030
src = if A . n == B :
trg = A の n が B と 等 しい とき 、
rst = A の n が B と 等 しい とき 、 <eos>
1031
src = if list ( range ( A , A + 5 ) ) == B :
trg = A から A に 5 を加えた 値 未 満 までの 数 列 のリスト が B と 等 しい とき 、
rst = A から A に 5 を加えた 値 未 満 までの 数 列 のリスト が B と 等 しい とき 、 <eos>
1032
src = print ( int ( ( A + B ) / 2 ) )
trg = A に B を加えた 値を 2 で 割 った 値の 整数値 を出力する
rst = A に B を加えた 値を 2 で 割 った 値の 整数値 を出力する <eos>
1033
src = A [ 18 ] , A [ 20 ] = A [ 20 ] , A [ 18 ]
trg = A の 20 番 目 、 A の 18 番 目 を A の 18 番 目 、 A の 20 番 目 とする
rst = A の 20 番 目 、 A の 18 番 目 を A の 18 番 目 、 A の 20 番 目 とする <eos>
1034
src = A [ 4 ] += B
trg = A の 4 番 目 を B だけ 増加 させる
rst = A の 4 番 目 を B だけ 増加 させる <eos>
1035
src = A [ B + C * D ] = E + C * F
trg = E に C に F を 掛 け た 値 を加えた 値を A の B に C に D を 掛 け た 値 を加えた 値 番 目 にする
rst = E に C に F を 掛 け た 値 を加えた 値を A の B に C に D を 掛 け た 値 を加えた 値 番 目 にする <eos>
1036
src = print ( [ 0 , 1 ] [ A < B ] )
trg = ( 0 、 1 ) からなる 列 の A が B より 小さい かどうか 番 目 を出力する
rst = ( 0 、 1 ) からなる 列 の A が B より 小さい かどうか 番 目 を出力する <eos>
1037
src = A = str ( B // 3600 ) . zfill ( 2 )
trg = B を 3 600 で 割 った 商 の 文字列を 長さ 2 になる ように ' 0 ' 左 詰 め した 文字列を A とする
rst = B を 3 600 で 割 った 商 の 文字列を 長さ 2 になる ように ' 0 ' 左 詰 め した 文字列を A とする <eos>
1038
src = A [ B * C + D ] = E [ B ] [ D ]
trg = E の B 番目の D 番 目 を A の B に C を 掛 け た 値に D を加えた 値 番 目 にする
rst = E の B 番目の D 番 目 を A の B に C を 掛 け た 値に D を加えた 値 番 目 にする <eos>
1039
src = if 0 < A % 1000 <= 500 :
trg = 0 が A を 1000 で 割 った 余 り より 小さい かどうか が 500 以下の とき 、
rst = 0 が A を 1000 で 割 った 余 り より 小さい かどうか が 500 以下の とき 、 <eos>
1040
src = for A in B . keys ( ) :
trg = B の キー の集まり を 順に A として 、 繰り返す
rst = B の キー の集まり を 順に A として 、 繰り返す <eos>
1041
src = A = ( B * 2 + C ) / 3
trg = B に 2 を 掛 け た 値に C を加えた 値を 3 で 割 った 値を A とする
rst = B に 2 を 掛 け た 値に C を加えた 値を 3 で 割 った 値を A とする <eos>
1042
src = A += ( inorder ( B [ C ] [ 0 ] ) )
trg = A を inorder ( B [ C ] [ 0 ] ) だけ 増加 させる
rst = A を inorder ( B [ C ] [ 0 ] ) だけ 増加 させる <eos>
1043
src = A [ : ] = B [ : C * D ]
trg = B の 、 つまり 先頭 から C に D を 掛 け た 値 までの 部分 列 を A の 、 つまり 先頭 から 、 つまり 末 尾 までの 部分 列 にする
rst = B の 、 つまり 先頭 から C に D を 掛 け た 値 までの 部分 列 を A の 、 つまり 先頭 から 、 つまり 末 尾 までの 部分 列 にする <eos>
1044
src = A = phase ( B )
trg = phase ( B ) を A とする
rst = phase ( B ) を A とする <eos>
1045
src = for A , B , C in D [ E ] :
trg = D の E 番 目 を 順に A 、 B 、 C として 、 繰り返す
rst = D の E 番 目 を 順に A 、 B 、 C として 、 繰り返す <eos>
1046
src = A = fib ( B - 1 )
trg = fib ( B -1 ) を A とする
rst = fib ( B -1 ) を A とする <eos>
1047
src = A [ - 2 ] = A [ - 2 ] + A [ - 1 ] + 1
trg = A の -2 番 目 に A の -1 番 目 を加えた 値に 1 を加えた 値を A の -2 番 目 にする
rst = A の -2 番 目 に A の 末 尾 を加えた 値に 1 を加えた 値を A の -2 番 目 にする <eos>
1048
src = A [ B + C ] . append ( ( B + D , E [ C - D - 1 ] ) )
trg = A の B に C を加えた 値 番目の 末 尾 に ( B に D を加えた 値 、 E の C から D を 引 いた 値 から 1 を 引 いた 値 番 目 ) の 組 を追加する
rst = A の B に C を加えた 値 番目の 末 尾 に ( B に D を加えた 値 、 E の C から D を 引 いた 値 から 1 を 引 いた 値 番 目 ) の 組 を追加する <eos>
1049
src = A += B . pop ( )
trg = A を B の先頭 を取り 出した 値 だけ 増加 させる
rst = A を B の先頭 を取り 出した 値 だけ 増加 させる <eos>
1050
src = A = sum ( [ B [ C ] for C in range ( D - 1 ) ] ) + E - 1
trg = 0 から D -1 未 満 までの 数 列 の 各要素 を C とし 、 B の C 番目の 列 の 総 和 に E を加えた 値 から 1 を 引 いた 値を A とする
rst = 0 から D から 1 を 引 いた 値 未 満 までの 数 列 の 各要素 を C とし 、 B の C 番目の 列 の 総 和 に E を加えた 値 から 1 を 引 いた 値を A とする <eos>
1051
src = else = A [ B ] [ 1 ]
trg = A の B 番目の 1 番 目 を そうでなければ 、 とする
rst = A の B 番目の 1 番 目 を そうでなければ 、 とする <eos>
1052
src = A [ B ] [ C ] = A [ B + 1 ] [ C ]
trg = A の B に 1 を加えた 値 番目の C 番 目 を A の B 番目の C 番 目 にする
rst = A の B に 1 を加えた 値 番目の C 番 目 を A の B 番目の C 番 目 にする <eos>
1053
src = return A * 10 ** B + C
trg = A に 10 の B 乗 を 掛 け た 値に C を加えた 値を返す
rst = A に 10 の B 乗 を 掛 け た 値に C を加えた 値を返す <eos>
1054
src = print ( A + str ( B ) + C + str ( D ) )
trg = A に B の 文字列 を加えた 値に C を加えた 値に D の 文字列 を加えた 値 を出力する
rst = A に B の 文字列 を加えた 値に C を加えた 値に D の 文字列 を加えた 値 を出力する <eos>
1055
src = if A . q [ B ] > A . q [ C ] :
trg = A の q の B 番 目 が A の q の C 番 目 より 大きい とき 、
rst = A の q の B 番 目 が A の q の C 番 目 より 大きい とき 、 <eos>
1056
src = for A in range ( 1 , 26 ) :
trg = 1 から 26 未 満 までの 数 列 を 順に A として 、 繰り返す
rst = 1 から 26 未 満 までの 数 列 を 順に A として 、 繰り返す <eos>
1057
src = if ( A in B ) or ( C in B ) :
trg = A が B に 含まれ または C が B に含まれる とき 、
rst = A が B に 含まれ または C が B に含まれる とき 、 <eos>
1058
src = if count [ 0 ] [ 1 ] == 3 :
trg = 無限 の 整数 列 の先頭 の 1 番 目 が 3 と 等 しい とき 、
rst = 無限 の 整数 列 の先頭 の 1 番 目 が 3 と 等 しい とき 、 <eos>
1059
src = A . time -= B
trg = A の time を B だけ 減少 させる
rst = A の time を B だけ 減少 させる <eos>
1060
src = insort ( A , ( - pi , - 1 ) )
trg = ( - 、 つまり 円 周 率 、 -1 ) の 組 を A に ソート 順 で 最後に 挿入 する
rst = ( - 、 つまり 円 周 率 、 -1 ) の 組 を A に ソート 順 で 最後に 挿入 する <eos>
1061
src = A = '' . join ( [ B [ C + D ] [ D ] for D in range ( E ) if 0 <= C + D < E ] )
trg = 空文字列 を 間 に 入れ て 0 から E 未 満 までの 数 列 の 各要素 を D とし 、 0 が C に D を加えた 値 以下 かどうか が E より 小さい とき の B の C に D を加えた 値 番目の D 番目の 列 を 連結 した 文字列を A とする
rst = 空文字列 を 間 に 入れ て 0 から E 未 満 までの 数 列 の 各要素 を D とし 、 0 が C に D を加えた 値 以下 かどうか が E より 小さい とき の B の C に D を加えた 値 番目の D 番目の 列 を 連結 した 文字列を
1062
src = for e in map ( A . index , B ) :
trg = B の 各要素 に A の [MASK] と 等 しい 要素 の最初の 位置 を適用した 列 を 順に ネ イ ピ ア 数 として 、 繰り返す
rst = B の 各要素 に A の [MASK] と 等 しい 要素 の最初の 位置 を適用した 列 を 順に ネ イ ピ ア 数 として 、 繰り返す <eos>
1063
src = next ( A )
trg = next ( A )
rst = next ( A ) <eos>
1064
src = A [ B ] |= ( 2 << C )
trg = A の B 番 目 を 2 を C だけ 左 シフト した 値 と の 論理 和 にする
rst = A の B 番 目 を 2 を C だけ 左 シフト した 値 と の 論理 和 にする <eos>
1065
src = A [ 2 ] = 1
trg = 1 を A の 2 番 目 にする
rst = 1 を A の 2 番 目 にする <eos>
1066
src = if A and B [ A // ( A & - A ) ] == 3 :
trg = A かつ B の A を A と - A の 論理 積 で 割 った 商 番 目 が 3 と 等 しい とき 、
rst = A かつ B の A を A と - A の 論理 積 で 割 った 商 番 目 が 3 と 等 しい とき 、 <eos>
1067
src = return ( A % ( B , C ) )
trg = A を ( B 、 C ) の 組 で 割 った 余 り を返す
rst = ( A を ( B 、 C ) の 組 で 割 った 余 り ) の 組 を返す <eos>
1068
src = print ( A [ 0 ] [ 1 ] , A [ 1 ] )
trg = A の先頭 の 1 番 目 、 A の 1 番 目 を出力する
rst = A の先頭 の 1 番 目 、 A の 1 番 目 を出力する <eos>
1069
src = B = ( ( C ** 2 + D ** 2 ) / ( 2 * C ) if C <= D else D )
trg = C が D 以下の とき C の 2 乗 に D の 2 乗 を加えた 値を 2 に C を 掛 け た 値 で 割 った 値 、 そうでなければ D を B とする
rst = C が D 以下の とき C の 2 乗 に D の 2 乗 を加えた 値を 2 に C を 掛 け た 値 で 割 った 値 、 そうでなければ D を B とする <eos>
1070
src = for A in range ( 11 , 1000000 ) :
trg = 11 から 100 0000 未 満 までの 数 列 を 順に A として 、 繰り返す
rst = 11 から 100 0000 未 満 までの 数 列 を 順に A として 、 繰り返す <eos>
1071
src = for A in str ( input ( ) ) :
trg = 入力された 文字列 の 文字列を 順に A として 、 繰り返す
rst = 入力された 文字列 の 文字列 の 文字列を 順に A として 、 繰り返す <eos>
1072
src = return A % 400 == 0 or ( A % 4 == 0 and A % 100 != 0 )
trg = A を 400 で 割 った 余 り が 0 と 等 しく または A を 4 で 割 った 余 り が 0 と 等 しく かつ A を 100 で 割 った 余 り が 0 と 等 しく ない かどうか を返す
rst = A を 400 で 割 った 余 り が 0 と 等 しく または A を 4 で 割 った 余 り が 0 と 等 しく かつ A を 100 で 割 った 余 り が 0 と 等 しく ない かどうか を返す <eos>
1073
src = A = path [ A ] [ B ]
trg = os . path の A 番目の B 番 目 を A とする
rst = os . path の A 番目の B 番 目 を A とする <eos>
1074
src = time [ A : B ] = [ 1 ] * ( B - A )
trg = (1) からなる 列 の B から A を 引 いた 値 回 分 の 列 を time の A 番 目 から B 番 目 までの 部分 列 にする
rst = (1) からなる 列 の B から A を 引 いた 値 回 分 の 列 を time の A 番 目 から B 番 目 までの 部分 列 にする <eos>
1075
src = A += B if B > C // 2 else C - B
trg = A を B が C を 2 で 割 った 商 より 大きい とき B 、 そうでなければ C から B を 引 いた 値 だけ 増加 させる
rst = A を B が C を 2 で 割 った 商 より 大きい とき B 、 そうでなければ C から B を 引 いた 値 だけ 増加 させる <eos>
1076
src = A . appendleft ( B [ 4 : ] )
trg = A の 先頭に B の 4 番 目 から 、 つまり 末 尾 までの 部分 列 を追加する
rst = A の 先頭に B の 4 番 目 から 、 つまり 末 尾 までの 部分 列 を追加する <eos>
1077
src = A [ 3 ] = e = A [ 3 ] - B - C - 2
trg = A の 3 番 目 から B を 引 いた 値 から C を 引 いた 値 から 2 を 引 いた 値を ネ イ ピ ア 数 とする を A の 3 番 目 にする
rst = A の 3 番 目 から B を 引 いた 値 から C を 引 いた 値 から 2 を 引 いた 値を ネ イ ピ ア 数 とする を A の 3 番 目 にする <eos>
1078
src = A . ms = dict ( )
trg = 辞書 を A の ms にする
rst = 辞書 を A の ms にする <eos>
1079
src = A . par [ B ] = C
trg = C を A の par の B 番 目 にする
rst = C を A の par の B 番 目 にする <eos>
1080
src = A = + ( B == 0 )
trg = B が 0 と 等 しい かどうか に [MASK] を加えた 値を A とする
rst = B が 0 と 等 しい かどうか に [MASK] を加えた 値を A とする <eos>
1081
src = A = B [ A ] + 1
trg = B の A 番 目 に 1 を加えた 値を A とする
rst = B の A 番 目 に 1 を加えた 値を A とする <eos>
1082
src = A += B - max ( C . values ( ) )
trg = A を B から C の値 の集まり の 最大 値を 引 いた 値 だけ 増加 させる
rst = A を B から C の値 の集まり の 最大 値を 引 いた 値 だけ 増加 させる <eos>
1083
src = return A . ONLINE_FRONT
trg = A の ONLINE _ FRONT を返す
rst = A の <unk> を返す <eos>
1084
src = return A . root
trg = A の root を返す
rst = A の root を返す <eos>
1085
src = A = open ( 1 , B ) . writelines
trg = 1 、 B を 開 いた ファイル ストリーム の writelines を A とする
rst = open ( 1, B ) . writelines = 0 . writelines ( 1 ) を A とする <eos>
1086
src = A = max ( B - C [ D ] , E [ D ] - F )
trg = B から C の D 番 目 を 引 いた 値 、 E の D 番 目 から F を 引 いた 値の 最大 値を A とする
rst = B から C の D 番 目 を 引 いた 値 、 E の D 番 目 から F を 引 いた 値の 最大 値を A とする <eos>
1087
src = A . bit1 . add ( B , - C * ( B - 1 ) )
trg = A の bit 1 に B 、 - C に B から 1 を 引 いた 値を 掛 け た 値 を追加した 集 ま り
rst = A の bit 1 に B 、 - C に B から 1 を 引 いた 値を 掛 け た 値 を追加した 集 ま り <eos>
1088
src = if time > A :
trg = time が A より 大きい とき 、
rst = time が A より 大きい とき 、 <eos>
1089
src = A [ B - 1 ] = min ( A [ 2 * B - 1 ] , A [ 2 * B ] )
trg = A の 2 に B を 掛 け た 値 から 1 を 引 いた 値 番 目 、 A の 2 に B を 掛 け た 値 番目の 最小 値を A の B から 1 を 引 いた 値 番 目 にする
rst = A の 2 に B を 掛 け た 値 から 1 を 引 いた 値 番 目 、 A の 2 に B を 掛 け た 値 番目の 最小 値を A の B から 1 を 引 いた 値 番 目 にする <eos>
1090
src = return ( sum ( map ( A , B ) ) + 1 ) % C
trg = B の 各要素 に A を適用した 列 の 総 和 に 1 を加えた 値を C で 割 った 余 り を返す
rst = B の 各要素 に A を適用した 列 の 総 和 に 1 を加えた 値を C で 割 った 余 り を返す <eos>
1091
src = A . append ( [ B + [ C ] , D - C ] )
trg = A の 末 尾 に ( B に ( C ) からなる 列 を加えた 値 、 D から C を 引 いた 値 ) からなる 列 を追加する
rst = A の 末 尾 に ( B に ( C ) からなる 列 を加えた 値 、 D から C を 引 いた 値 ) からなる 列 を追加する <eos>
1092
src = A = [ ( - 1 , 0 ) , ( 0 , 1 ) , ( 1 , 0 ) , ( 0 , - 1 ) ]
trg = ( ( -1 、 0 ) の 組 、 ( 0 、 1 ) の 組 、 ( 1 、 0 ) の 組 、 ( 0 、 -1 ) の 組 ) からなる 列 を A とする
rst = ( ( -1 、 0 ) の 組 、 ( 0 、 1 ) の 組 、 ( 1 、 0 ) の 組 、 ( 0 、 -1 ) の 組 ) からなる 列 を A とする <eos>
1093
src = print ( A . format ( B . top ) )
trg = A を 書式 として B の top で 整 形 した 文字列 を出力する
rst = A を 書式 として B の top で 整 形 した 文字列 を出力する <eos>
1094
src = saizo ( list ( map ( int , input ( ) . split ( ) ) ) )
trg = saizo ( list ( map ( int , input () . split () ) ) )
rst = <unk> ( list ( map ( int , input () . split () ) ) <eos>
1095
src = A [ e ] = A . get ( e , 0 ) + 1
trg = A に対応する 値 、 も し 存在 し なければ 、 つまり ネ イ ピ ア 数 、 0 に 1 を加えた 値を A の 、 つまり ネ イ ピ ア 数 番 目 にする
rst = A に対応する 値 、 も し 存在 し なければ 、 つまり ネ イ ピ ア 数 、 0 に 1 を加えた 値を A の 、 つまり ネ イ ピ ア 数 番 目 にする <eos>
1096
src = while index ( A , B , C ) > D :
trg = index ( A , B , C ) が D より 大きい 間 、 次 を 繰り返す
rst = index ( A , B , C ) が D より 大きい 間 、 次 を 繰り返す <eos>
1097
src = return math . ceil ( A / 1000 ) * 1000
trg = A を 1000 で 割 った 値の 切り 上げ 整数値 に 1000 を 掛 け た 値を返す
rst = A を 1000 で 割 った 値の 切り 上げ 整数値 に 1000 を 掛 け た 値を返す <eos>
1098
src = A , B = check_rightdown ( C , A , B , D )
trg = check _ rightdown ( C , A , B , D ) を 展開 し 、 それぞれ A 、 B とする
rst = check _ dice ( C , A , B , D ) を 展開 し 、 それぞれ A 、 B とする <eos>
1099
src = setHeapUp_max ( A , 0 )
trg = setHeapUp _ max ( A , 0 )
rst = <unk> ( A , 0 ) <eos>
1100
src = if A [ B ] + A [ B + 1 ] < 10 :
trg = A の B 番 目 に A の B に 1 を加えた 値 番 目 を加えた 値が 10 より 小さい とき 、
rst = A の B 番 目 に A の B に 1 を加えた 値 番 目 を加えた 値が 10 より 小さい とき 、 <eos>
1101
src = A = list ( map ( int , A ) )
trg = A の 各要素 に 整数 を適用した 列 の リストを A とする
rst = A の 各要素 に 整数 を適用した 列 の リストを A とする <eos>
1102
src = A [ 0 ] [ 0 ] = B [ 0 ] [ 0 ]
trg = B の先頭 の先頭 を A の先頭 の 0 番 目 にする
rst = B の先頭 の先頭 を A の先頭 の 0 番 目 にする <eos>
1103
src = preorder_tree_walk ( A , A [ B ] . right_node_no , C )
trg = preorder _ tree _ walk ( A , A [ B ] . right _ node _ no , C )
rst = preorder _ tree _ walk ( A , A [ B ] . right _ node _ no , C ) <eos>
1104
src = write ( A % B [ 0 ] if B [ 0 ] != - 1 else C )
trg = write ( A % B [ 0 ] ifB [ 0 ] ! = -1 elseC )
rst = write ( A % B [ 0 ] == -1 <unk> ( C ) ] ) <eos>
1105
src = A = [ B for B in set ( C ) if C . count ( B ) > 1 ]
trg = C の集合 の 各要素 を B とし 、 C 内の B の 出現 回数 が 1 より 大きい とき の B の 列 を A とする
rst = C の集合 内の B の 出現 回数 が 1 より 大きい とき の B の 列 を A とする <eos>
1106
src = A [ 0 ] [ B ] = [ 0 , 0 , 0 , 1 ]
trg = ( 0 、 0 、 0 、 1 ) からなる 列 を A の先頭 の B 番 目 にする
rst = ( 0 、 0 、 0 、 1 ) からなる 列 を A の先頭 の B 番 目 にする <eos>
1107
src = heappush ( A , ( B + C , D + E ) )
trg = heappush ( A , ( B + C , D + E ) )
rst = heappush ( A , ( B + C , D + E ) ) <eos>
1108
src = A = A or search ( [ B for B in C if B != D ] , E , D - 1 , F , 1 )
trg = A または E 、 D から 1 を 引 いた 値 、 F 、 1 において 正規表現 C の 各要素 を B とし 、 B が D と 等 しく ない とき の B の 列 が 最初 にマッチする 位置 を A とする
rst = A または D 、 E 、 D から 1 を 引 いた 値 、 F から 1 を 引 いた 値 、 1 において 正規表現 C の 各要素 を B とし 、 B が D と 等 しく ない とき の B の 列 が 最初 にマッチする 位置 を A
1109
src = A = str ( B [ 0 ] ) + str ( B [ 1 ] ) + str ( B [ 2 ] ) + str ( B [ 3 ] ) + str ( B [ 4 ] )
trg = B [ 0 ] の 文字列 に B [ 1 ] の 文字列 を加えた 値に B の 2 番目の 文字列 を加えた 値に B の 3 番目の 文字列 を加えた 値に B の 4 番目の 文字列 を加えた 値を A とする
rst = B の先頭 の 文字列 に B [ 1 ] の 文字列 を加えた 値に B の 2 番目の 文字列 を加えた 値に B の 3 番目の 文字列 を加えた 値に B の 4 番目の 文字列 を加えた 値を A とする <eos>
1110
src = A . lr = [ ]
trg = 空 列 を A の lr にする
rst = 空 列 を A の lr にする <eos>
1111
src = A = [ [ - 1 ] + list ( map ( int , input ( ) . split ( ) ) ) + [ - 1 ] for B in range ( C ) ]
trg = 0 から C 未 満 までの 数 列 の 各要素 を B とし 、 ( -1 ) からなる 列 に input () . split () の 各要素 に int を適用した 列 のリスト を加えた 値に ( -1 ) からなる 列 を加えた 値の 列 を A とする
rst = 0 から C 未 満 までの 数 列 の 各要素 を B とし 、 ( -1 ) からなる 列 に input () . split () の 各要素 に int を適用した 列 のリスト を加えた 値に ( -1 ) からなる 列 を加えた 値の 列 を A とする <eos>
1112
src = A = B [ 0 ] [ 0 ] + B [ 1 ] [ 1 ] + B [ 2 ] [ 2 ]
trg = B の先頭 の 0 番 目 に B の 1 番目の 1 番 目 を加えた 値に B の 2 番目の 2 番 目 を加えた 値を A とする
rst = B の先頭 の 0 番 目 に B の 1 番目の 1 番 目 を加えた 値に B の 2 番目の 2 番 目 を加えた 値を A とする <eos>
1113
src = if A [ 1 ] [ B ] :
trg = A の 1 番目の B 番目の とき 、
rst = A の 1 番目の B 番目の とき 、 <eos>
1114
src = A = A or judge ( B [ 3 : ] )
trg = A または judge ( B [ 3 : ] ) を A とする
rst = A または judge ( B [ 3 : ] ) を A とする <eos>
1115
src = A . size = A . iter_size * 2 - 1
trg = A の iter _ size に 2 を 掛 け た 値 から 1 を 引 いた 値を A の size にする
rst = A の iter _ size に 2 を 掛 け た 値 から 1 を 引 いた 値を A の size にする <eos>
1116
src = for A in range ( B * 5 - 1 , - 1 , - 1 ) :
trg = B に 5 を 掛 け た 値 から 1 を 引 いた 値 から -1 未 満 までの -1 間隔 の 数 列 を 順に A として 、 繰り返す
rst = B に 5 を 掛 け た 値 から 1 を 引 いた 値 から -1 未 満 までの -1 間隔 の 数 列 を 順に A として 、 繰り返す <eos>
1117
src = A += B . size - 1
trg = A を B の size から 1 を 引 いた 値 だけ 増加 させる
rst = A を B の size から 1 を 引 いた 値 だけ 増加 させる <eos>
1118
src = for A in range ( B , C + 1 , B ) :
trg = B から C に 1 を加えた 値 未 満 までの B 間隔 の 数 列 を 順に A として 、 繰り返す
rst = B から C に 1 を加えた 値 未 満 までの B 間隔 の 数 列 を 順に A として 、 繰り返す <eos>
1119
src = print ( 7 * ( A + 1 ) )
trg = 7 に A に 1 を加えた 値を 掛 け た 値 を出力する
rst = 7 に A に 1 を加えた 値を 掛 け た 値 を出力する <eos>
1120
src = print ( 1925 + A )
trg = 19 25 に A を加えた 値 を出力する
rst = 19 25 に A を加えた 値 を出力する <eos>
1121
src = A , B , C = expr ( )
trg = expr () を 展開 し 、 それぞれ A 、 B 、 C とする
rst = expr () を 展開 し 、 それぞれ A 、 B 、 C とする <eos>
1122
src = A = B + ( C != D and E == D )
trg = B に C が D と 等 しく なく かつ E が D と 等 しい かどうか を加えた 値を A とする
rst = B に C が D と 等 しく なく かつ E が D と 等 しい かどうか を加えた 値を A とする <eos>
1123
src = print ( A * 60 + B )
trg = A に 60 を 掛 け た 値に B を加えた 値 を出力する
rst = A に 60 を 掛 け た 値に B を加えた 値 を出力する <eos>
1124
src = A = sorted ( set ( range ( 1 , 2 * B + 1 ) ) - set ( C ) )
trg = 1 から 2 * B に 1 を加えた 値 未 満 までの 数 列 の集合 から C の集合 を 引 いた 値を ソート した 列 を A とする
rst = 1 から 2 に B を 掛 け た 値に 1 を加えた 値 未 満 までの 数 列 の集合 から C の集合 を 引 いた 値を ソート した 列 を A とする <eos>
1125
src = A [ B ] [ B + 1 ] = C [ B ] [ 0 ] * C [ B ] [ 1 ] * C [ B + 1 ] [ 1 ]
trg = C の B 番目の 先頭に C の B 番目の 1 番 目 を 掛 け た 値に C の B に 1 を加えた 値 番目の 1 番 目 を 掛 け た 値を A の B 番目の B に 1 を加えた 値 番 目 にする
rst = C の B 番目の 先頭に C の B 番目の 1 番 目 を 掛 け た 値に C の B に 1 を加えた 値 番目の 1 番 目 を 掛 け た 値を A の B 番目の B に 1 を加えた 値 番 目 にする <eos>
1126
src = if A == 0 and B > 0 :
trg = A が 0 と 等 しく かつ B が 0 より 大きい とき 、
rst = A が 0 と 等 しく かつ B が 0 より 大きい とき 、 <eos>
1127
src = A = A + 3 ** B
trg = A に 3 の B 乗 を加えた 値を A とする
rst = A に 3 の B 乗 を加えた 値を A とする <eos>
1128
src = if A * B - C * D == 0 :
trg = A に B を 掛 け た 値 から C に D を 掛 け た 値を 引 いた 値が 0 と 等 しい とき 、
rst = A に B を 掛 け た 値 から C に D を 掛 け た 値を 引 いた 値が 0 と 等 しい とき 、 <eos>
1129
src = A [ B ] [ B + 1 ] = C [ B ] * C [ B + 1 ] * C [ B + 2 ]
trg = C の B 番 目 に C の B に 1 を加えた 値 番 目 を 掛 け た 値に C の B に 2 を加えた 値 番 目 を 掛 け た 値を A の B 番目の B に 1 を加えた 値 番 目 にする
rst = C の B 番 目 に C の B に 1 を加えた 値 番 目 を 掛 け た 値に C の B に 2 を加えた 値 番 目 を 掛 け た 値 を加えた 値を A の B 番目の B に 1 を加えた 値 番 目 にする <eos>
1130
src = A [ chr ( B ) ] = B - ord ( C ) + 10
trg = B から C の 順序 数 を 引 いた 値に 10 を加えた 値を A の 、 つまり 文字コード B の 文字 番 目 にする
rst = B から C の 順序 数 を 引 いた 値に 10 を加えた 値を A の 、 つまり 文字コード B の 文字 番 目 にする <eos>
1131
src = if A [ 1 ] == B [ 1 ] :
trg = A の 1 番 目 が B の 1 番 目 と 等 しい とき 、
rst = A の 1 番 目 が B の 1 番 目 と 等 しい とき 、 <eos>
1132
src = A [ B ] = B
trg = B を A の B 番 目 にする
rst = B を A の B 番 目 にする <eos>
1133
src = A . append ( ( B + 1 , ( C , D ) , E , F ) )
trg = A の 末 尾 に ( B に 1 を加えた 値 、 ( C 、 D ) の 組 、 E 、 F ) の 組 を追加する
rst = A の 末 尾 に ( B に 1 を加えた 値 、 ( C 、 D ) の 組 、 E 、 F ) の 組 を追加する <eos>
1134
src = return A + 1867
trg = A に 1 86 7 を加えた 値を返す
rst = A に 1 86 7 を加えた 値を返す <eos>
1135
src = A [ B ] [ C ] = ( A [ B - C ] [ C ] + A [ B - 1 ] [ C - 1 ] ) % D
trg = A の B から C を 引 いた 値 番目の C 番 目 に A の B から 1 を 引 いた 値 番目の C から 1 を 引 いた 値 番 目 を加えた 値を D で 割 った 余 り を A の B 番目の C 番 目 にする
rst = A の B から C を 引 いた 値 番目の C 番 目 に A の B から 1 を 引 いた 値 番目の C から 1 を 引 いた 値 番 目 を加えた 値を D で 割 った 余 り を A の B 番目の C 番 目 にする
1136
src = A . append ( [ - 1 * B [ 1 ] , B [ 0 ] ] )
trg = A の 末 尾 に ( -1 に B の 1 番 目 を 掛 け た 値 、 B の先頭 ) からなる 列 を追加する
rst = A の 末 尾 に ( -1 に B の 1 番 目 を 掛 け た 値 、 B の先頭 ) からなる 列 を追加する <eos>
1137
src = A [ B ] . parent = C
trg = C を A の B 番目の parent にする
rst = C を A の B 番目の parent にする <eos>
1138
src = return abs ( A . cross ( B , C ) ) < A . epsilon
trg = A . cross ( B , C ) の 絶対 値が A の epsilon より 小さい かどうか を返す
rst = A . cross ( B , C ) の 絶対 値が A の epsilon より 小さい かどうか を返す <eos>
1139
src = print ( A [ 1 ] )
trg = A の 1 番 目 を出力する
rst = A の 1 番 目 を出力する <eos>
1140
src = if A . last is not None :
trg = A の last が 、 つまり 未 定 値 と 等 しい とき 、
rst = A の last が 、 つまり 未 定 値 と 等 しい とき 、 <eos>
1141
src = A [ B ] = chr ( C + B )
trg = 文字コード C に B を加えた 値の 文字 を A の B 番 目 にする
rst = 文字コード C に B を加えた 値の 文字 を A の B 番 目 にする <eos>
1142
src = A = score ( B & ~ C , D + E [ F ] , count + 1 )
trg = score ( B & ~ C , D + E [ F ] , count + 1 ) を A とする
rst = score ( B & ~ C , D + E [ F ] , count + 1 ) を A とする <eos>
1143
src = A = ( B * C - D * E ) / F
trg = B に C を 掛 け た 値 から D に E を 掛 け た 値を 引 いた 値を F で 割 った 値を A とする
rst = B に C を 掛 け た 値 から D に E を 掛 け た 値を 引 いた 値を F で 割 った 値を A とする <eos>
1144
src = if A . direction :
trg = A の direction の とき 、
rst = A の <unk> の とき 、 <eos>
1145
src = A += ( 1 - B )
trg = A を 1 から B を 引 いた 値 だけ 増加 させる
rst = A を 1 から B を 引 いた 値 だけ 増加 させる <eos>
1146
src = print ( prim ( A ) )
trg = prim ( A ) を出力する
rst = prim ( A ) を出力する <eos>
1147
src = return int ( A [ B : C + 1 ] ) // 2 + 1
trg = A の B 番 目 から C に 1 を加えた 値 までの 部分 列 の 整数値 を 2 で 割 った 商 に 1 を加えた 値を返す
rst = A の B 番 目 から C に 1 を加えた 値 までの 部分 列 の 整数値 を 2 で 割 った 商 に 1 を加えた 値を返す <eos>
1148
src = A = B - abs ( A - B )
trg = B から A から B を 引 いた 値の 絶対 値を 引 いた 値を A とする
rst = B から A から B を 引 いた 値の 絶対 値を 引 いた 値を A とする <eos>
1149
src = A = [ list ( map ( int , readline ( ) . split ( ) ) ) for B in range ( C + 1 ) ]
trg = 0 から C に 1 を加えた 値 未 満 までの 数 列 の 各要素 を B とし 、 readline () を 空白 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 のリスト の 列 を A とする
rst = 0 から C に 1 を加えた 値 未 満 までの 数 列 の 各要素 を B とし 、 readline () を 空白 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 のリスト の 列 を A とする <eos>
1150
src = A = Counter ( B ) . most_common ( ) [ 0 ] [ 0 ]
trg = B の 辞書 カウンタ の 出現 頻 度 順 の 列 の先頭 の先頭 を A とする
rst = B の 辞書 カウンタ の 出現 頻 度 順 の 列 の先頭 を A とする <eos>
1151
src = A = ( A + B ) % 4
trg = A に B を加えた 値を 4 で 割 った 余 り を A とする
rst = A に B を加えた 値を 4 で 割 った 余 り を A とする <eos>
1152
src = A += dfs ( B + 1 , C | ( 1 << ( D * 4 + E ) ) )
trg = A を dfs ( B + 1, C | ( 1 < < ( D * 4 + E ) ) ) だけ 増加 させる
rst = A を dfs ( B + 1, C | ( 1 < D * 4 + E ) ) だけ 増加 させる <eos>
1153
src = ( A , B , C ) = triangle ( D , E , F )
trg = triangle ( D , E , F ) を ( A 、 B 、 C ) の 組 とする
rst = triangle ( D , E , F ) を ( A 、 B 、 C ) の 組 とする <eos>
1154
src = A = [ [ float ( B ) ] * [ C for D in range ( E ) ] ]
trg = ( ( B の 浮動小数点数 ) からなる 列 の 0 から E 未 満 までの 数 列 の 各要素 を D とし 、 C の 列 回 分 の 列 ) からなる 列 を A とする
rst = ( ( B の 浮動小数点数 ) からなる 列 の 0 から E 未 満 までの 数 列 の 各要素 を D とし 、 C の 列 回 分 の 列 ) からなる 列 を A とする <eos>
1155
src = A = [ [ B - C ] * [ ( D + 1 ) for E in range ( F + 1 ) ] ]
trg = ( ( B から C を 引 いた 値 ) からなる 列 の 0 から F に 1 を加えた 値 未 満 までの 数 列 の 各要素 を E とし 、 D に 1 を加えた 値の 列 回 分 の 列 ) からなる 列 を A とする
rst = ( ( B から C を 引 いた 値 ) からなる 列 の 0 から F に 1 を加えた 値 未 満 までの 数 列 の 各要素 を E とし 、 D に 1 を加えた 値の 列 回 分 の 列 ) からなる 列 を A とする <eos>
1156
src = dfs ( A [ B ] )
trg = dfs ( A [ B ] )
rst = dfs ( A [ B ] ) <eos>
1157
src = A [ 2 * B + 1 ] [ C - 1 ] = D
trg = D を A の 2 に B を 掛 け た 値に 1 を加えた 値 番目の C から 1 を 引 いた 値 番 目 にする
rst = D を A の 2 に B を 掛 け た 値に 1 を加えた 値 番目の C から 1 を 引 いた 値 番 目 にする <eos>
1158
src = return Fib ( A - 1 ) + Fib ( A - 2 )
trg = Fib ( A -1 ) に Fib ( A -2 ) を加えた 値を返す
rst = <unk> _ sosu ( A -1 ) に <unk> ( A -2 ) を加えた 値を返す <eos>
1159
src = if A % 15 == 0 :
trg = A を 15 で 割 った 余 り が 0 と 等 しい とき 、
rst = A を 15 で 割 った 余 り が 0 と 等 しい とき 、 <eos>
1160
src = A = SegmentTree ( B )
trg = SegmentTree ( B ) を A とする
rst = SegmentTree ( B ) を A とする <eos>
1161
src = A , B , C = f ( D , E , 1 ) , f ( F , G , 1 ) , f ( H , I , 1 )
trg = f ( D , E , 1 ) 、 f ( F , G , 1 ) 、 f ( H , I , 1 ) を A 、 B 、 C とする
rst = f ( D , E , 1 ) 、 f ( F , G , 1 ) 、 f ( H , I , 1 ) を A 、 B 、 C とする <eos>
1162
src = if A + B [ C ] > D :
trg = A に B の C 番 目 を加えた 値が D より 大きい とき 、
rst = A に B の C 番 目 を加えた 値が D より 大きい とき 、 <eos>
1163
src = print ( * [ A [ - 1 ] [ - 2 ] , B ] )
trg = ( A の 末 尾 の -2 番 目 、 B ) からなる 列 を 展開 して を出力する
rst = ( A の 末 尾 の -2 番 目 、 B ) からなる 列 を 展開 して を出力する <eos>
1164
src = C = 0
trg = 0 を C とする
rst = 0 を C とする <eos>
1165
src = A , B = - 1e11 , 1e11
trg = -1 e 11 、 1 e 11 を A 、 B とする
rst = - 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11
1166
src = A = B < C and D [ E ] < D [ B ]
trg = B が C より 小さく かつ D の E 番 目 が D の B 番 目 より 小さい かどうか を A とする
rst = B が C より 小さく かつ D の E 番 目 が D の B 番 目 より 小さい かどうか を A とする <eos>
1167
src = for A in B [ now ] :
trg = B の 、 つまり 現在の 日 時 番 目 を 順に A として 、 繰り返す
rst = B の 、 つまり 現在の 日 時 番 目 を 順に A として 、 繰り返す <eos>
1168
src = A . append ( ( B [ C ] , B [ D ] ) if B [ C ] < B [ D ] else ( B [ D ] , B [ C ] ) )
trg = A の 末 尾 に B の C 番 目 が B の D 番 目 より 小さい とき ( B の C 番 目 、 B の D 番 目 ) の 組 、 そうでなければ ( B の D 番 目 、 B の C 番 目 ) の 組 を追加する
rst = A の 末 尾 に B の C 番 目 が B の D 番 目 より 小さい とき ( B の C 番 目 、 B の D 番 目 ) の 組 、 そうでなければ ( B の D 番 目 、 B の C 番 目 ) の
1169
src = _in_order_line ( A . right )
trg = _ in _ order _ line ( A . right )
rst = _ in _ order _ line ( A . right ) <eos>
1170
src = A -= 2 ** ( 9 - B )
trg = A を 2 の 9 から B を 引 いた 値 乗 だけ 減少 させる
rst = A を 2 の 9 から B を 引 いた 値 乗 だけ 減少 させる <eos>
1171
src = A = { (ALL, i) : [ 0 for C in range ( D ) ] }
trg = ( ( ( B 、 C ) の 組 , 0 から D 未 満 までの 数 列 の 各要素 を C とし 、 0 の 列 ) ) からなる 辞書 を A とする
rst = ( ( ( ( 1 、 0 から D 未 満 までの 数 列 の 各要素 を C とし 、 0 から D 未 満 までの 数 列 の 各要素 を C とし 、 0 の 列 ) ) ) からなる 辞書 を A とする <eos>
1172
src = A = [ B . count ( C ) for C in range ( 1 , 101 ) ]
trg = 1 から 10 1 未 満 までの 数 列 の 各要素 を C とし 、 B 内の C の 出現 回数 の 列 を A とする
rst = 1 から 10 1 未 満 までの 数 列 の 各要素 を C とし 、 B 内の C の 出現 回数 の 列 を A とする <eos>
1173
src = return A [ B ] [ 7 ]
trg = A の B 番目の 7 番 目 を返す
rst = A の B 番目の 7 番 目 を返す <eos>
1174
src = A = Counter ( B . cards )
trg = B の cards の 辞書 カウンタ を A とする
rst = B の cards の 辞書 カウンタ を A とする <eos>
1175
src = if A < B - abs ( C - D ) :
trg = A が B から C から D を 引 いた 値の 絶対 値を 引 いた 値 より 小さい とき 、
rst = A が B から C から D を 引 いた 値の 絶対 値を 引 いた 値 より 小さい とき 、 <eos>
1176
src = A = calc_d ( B [ 0 ] , B [ C + 1 ] )
trg = calc _ d ( B [ 0 ] , B [ C + 1 ] ) を A とする
rst = calc _ distance ( B [ 0 ] , B [ C + 1 ] ) を A とする <eos>
1177
src = A [ B . DEPTH ] = depth ( C [ A [ B . PARENT ] ] ) + 1
trg = depth ( C [ A [ B . PARENT ]]) に 1 を加えた 値を A の B の DEPTH 番 目 にする
rst = depth ( C [ A [ B . PARENT ] ) に 1 を加えた 値を A の B の DEPTH 番 目 にする <eos>
1178
src = A = B - ( C + D )
trg = B から C に D を加えた 値を 引 いた 値を A とする
rst = B から C に D を加えた 値を 引 いた 値を A とする <eos>
1179
src = A , B = scrap_top_left ( C )
trg = scrap _ top _ left ( C ) を 展開 し 、 それぞれ A 、 B とする
rst = <unk> ( C ) を 展開 し 、 それぞれ A 、 B とする <eos>
1180
src = if binsearch ( A , B ) :
trg = binsearch ( A , B ) の とき 、
rst = <unk> ( A , B ) の とき 、 <eos>
1181
src = A = B + ( C - D ) * E
trg = B に C から D を 引 いた 値に E を 掛 け た 値 を加えた 値を A とする
rst = B に C から D を 引 いた 値に E を 掛 け た 値 を加えた 値を A とする <eos>
1182
src = return A . node [ B ]
trg = A の node の B 番 目 を返す
rst = A の node の B 番 目 を返す <eos>
1183
src = A = math . factorial ( B + C - 1 ) // math . factorial ( B ) // math . factorial ( C - 1 )
trg = B に C を加えた 値 から 1 を 引 いた 値の 階乗 を B の 階乗 で 割 った 商 を C から 1 を 引 いた 値の 階乗 で 割 った 商 を A とする
rst = B に C を加えた 値 から 1 を 引 いた 値の 階乗 を B の 階乗 で 割 った 商 を C から 1 を 引 いた 値の 階乗 で 割 った 商 を A とする <eos>
1184
src = A . rank [ B ] = max ( A . rank [ B ] , A . par [ C ] + 1 )
trg = A の rank の B 番 目 、 A の par の C 番 目 に 1 を加えた 値の 最大 値を A の rank の B 番 目 にする
rst = A の rank の B 番 目 、 A の par の C 番 目 に 1 を加えた 値の 最大 値を A の rank の B 番 目 にする <eos>
1185
src = A , B = [ float ( C ) for C in D [ E ] . split ( ) ]
trg = D の E 番 目 を 空白 で 分割 した 字句 列 の 各要素 を C とし 、 C の 浮動小数点数 の 列 を 展開 し 、 それぞれ A 、 B とする
rst = D の E 番 目 を 空白 で 分割 した 字句 列 の 各要素 を C とし 、 C の 浮動小数点数 の 列 を 展開 し 、 それぞれ A 、 B とする <eos>
1186
src = A [ B + 1 ] += A [ B ]
trg = A の B に 1 を加えた 値 番 目 を A の B 番 目 だけ 増加 させる
rst = A の B に 1 を加えた 値 番 目 を A の B 番 目 だけ 増加 させる <eos>
1187
src = A = B - ( C [ D ] - C [ E ] )
trg = B から C の D 番 目 から C の E 番 目 を 引 いた 値を 引 いた 値を A とする
rst = B から C の D 番 目 から C の E 番 目 を 引 いた 値を 引 いた 値を A とする <eos>
1188
src = A = B [ C % len ( B ) ]
trg = B の C を B の長さ で 割 った 余 り 番 目 を A とする
rst = B の C を B の長さ で 割 った 余 り 番 目 を A とする <eos>
1189
src = A += input ( ) . rstrip ( )
trg = A を 入力された 文字列 の 末 尾 から 空白 改行 を取り 除 いた 文字列 だけ 増加 させる
rst = A を 入力された 文字列 の 末 尾 から 空白 改行 を取り 除 いた 文字列 だけ 増加 させる <eos>
1190
src = A = B . format ( C , D , E , F , G , H , I )
trg = B を 書式 として C 、 D 、 E 、 F 、 G 、 H 、 I で 整 形 した 文字列を A とする
rst = B を 書式 として C 、 D 、 E 、 F 、 G 、 H 、 I で 整 形 した 文字列を A とする <eos>
1191
src = A = _sort ( 0 , len ( B ) )
trg = _ sort ( 0 , len ( B ) ) を A とする
rst = <unk> ( 0 , len ( B ) ) を A とする <eos>
1192
src = A = calc_start ( B )
trg = calc _ start ( B ) を A とする
rst = <unk> ( B ) を A とする <eos>
1193
src = print ( A , int ( B ) )
trg = A 、 B の 整数値 を出力する
rst = A 、 B の 整数値 を出力する <eos>
1194
src = heappush ( A , ( B + C , D , E , F ) )
trg = heappush ( A , ( B + C , D , E , F ) )
rst = heappush ( A , ( B + C , D , E , F ) ) <eos>
1195
src = while A > B and cross ( C [ A - 1 ] - C [ A - 2 ] , D [ E ] - C [ A - 1 ] ) < 0 :
trg = A が B より 大きく かつ cross ( C [ A -1 ]- C [ A -2 ] , D [ E ]- C [ A -1 ] ) が 0 より 小さい 間 、 次 を 繰り返す
rst = A が B より 大きく かつ cross ( C [ A -1 ]- C [ A -2 ] , D [ E ]- C [ A -1 ] ) が 0 より 小さい 間 、 次 を 繰り返す <eos>
1196
src = for A in range ( len ( B ) // 2 + 1 , len ( B ) ) :
trg = B の長さ を 2 で 割 った 商 に 1 を加えた 値 から B の長さ 未 満 までの 数 列 を 順に A として 、 繰り返す
rst = B の長さ を 2 で 割 った 商 に 1 を加えた 値 から B の長さ 未 満 までの 数 列 を 順に A として 、 繰り返す <eos>
1197
src = koch ( A - 1 , ( B , C ) , ( D , E ) )
trg = koch ( A - 1, ( B , C ) , ( D , E ) )
rst = koch ( A - 1, ( B , C ) , ( D , E ) ) <eos>
1198
src = A = ( B , C ) + tuple ( D )
trg = ( B 、 C ) の 組 に D の 組 を加えた 値を A とする
rst = ( B 、 C ) の 組 に D の 組 を加えた 値を A とする <eos>
1199
src = if ( A [ 0 ] == B and len ( A ) > 1 ) or ( C [ 0 ] == B and len ( C ) > 1 ) or ( D [ 0 ] == B and len ( D ) > 1 ) :
trg = A の 0 番 目 が B と 等 しく かつ A の長さ が 1 より 大きく または C の 0 番 目 が B と 等 しく かつ C の長さ が 1 より 大きく または D の 0 番 目 が B と 等 しく かつ D の長さ が 1 より 大きい とき 、
rst = A の 0 番 目 が B と 等 しく かつ A の長さ が 1 より 大きく または C の 0 番 目 が B と 等 しく かつ C の長さ が 1 より 大きく または D の 0 番 目 が B と 等 しく かつ D の長さ が
1200
src = print ( A . rm . get ( B , 0 ) )
trg = A の rm に対応する 値 、 も し 存在 し なければ B 、 0 を出力する
rst = A に対応する 値 、 も し 存在 し なければ B 、 0 を出力する <eos>
1201
src = A = 2 * B - 2 * C
trg = 2 に B を 掛 け た 値 から 2 に C を 掛 け た 値を 引 いた 値を A とする
rst = 2 に B を 掛 け た 値 から 2 に C を 掛 け た 値を 引 いた 値を A とする <eos>
1202
src = if A . count ( ) == B . NQUEENS :
trg = A 内の [MASK] の 出現 回数 が B の NQUEENS と 等 しい とき 、
rst = A 内の [MASK] の 出現 回数 が B の <unk> と 等 しい とき 、 <eos>
1203
src = A = max ( A , B [ C ] - B [ D ] )
trg = A 、 B の C 番 目 から B の D 番 目 を 引 いた 値の 最大 値を A とする
rst = A 、 B の C 番 目 から B の D 番 目 を 引 いた 値の 最大 値を A とする <eos>
1204
src = A [ B + 1 ] = ( C [ B ] - D ) + A [ B ]
trg = C の B 番 目 から D を 引 いた 値に A の B 番 目 を加えた 値を A の B に 1 を加えた 値 番 目 にする
rst = C の B 番 目 から D を 引 いた 値に A の B 番 目 を加えた 値を A の B に 1 を加えた 値 番 目 にする <eos>
1205
src = A = RKSearch ( B , C )
trg = RKSearch ( B , C ) を A とする
rst = <unk> ( B , C ) を A とする <eos>
1206
src = for A in range ( B , C + D + E + 1 ) :
trg = B から C に D を加えた 値に E を加えた 値に 1 を加えた 値 未 満 までの 数 列 を 順に A として 、 繰り返す
rst = B から C に D を加えた 値に E を加えた 値に 1 を加えた 値 未 満 までの 数 列 を 順に A として 、 繰り返す <eos>
1207
src = while A <= datetime . date ( B , C , D ) :
trg = A が datetime 、 B 、 C 、 D の 日付 以下の 間 、 次 を 繰り返す
rst = A が datetime 、 B 、 C 、 D の 日付 以下の 間 、 次 を 繰り返す <eos>
1208
src = A = B - C
trg = B から C を 引 いた 値を A とする
rst = B から C を 引 いた 値を A とする <eos>
1209
src = A [ B - 1 ] [ : ] = C
trg = C を A の B から 1 を 引 いた 値 番目の 、 つまり 先頭 から 、 つまり 末 尾 までの 部分 列 にする
rst = C を A の B から 1 を 引 いた 値 番目の 、 つまり 先頭 から 、 つまり 末 尾 までの 部分 列 にする <eos>
1210
src = print ( greatest_common_divisor ( A , B ) )
trg = greatest _ common _ divisor ( A , B ) を出力する
rst = <unk> ( A , B ) を出力する <eos>
1211
src = if A == B or C & ( 1 << B ) == 0 :
trg = A が B と 等 しく または C と 1 を B だけ 左 シフト した 値の 論理 積 が 0 と 等 しい とき 、
rst = A が B と 等 しく または C と 1 を B だけ 左 シフト した 値の 論理 積 が 0 と 等 しい とき 、 <eos>
1212
src = A = set ( B [ 1 : - 1 ] . split ( C ) )
trg = B の 1 番 目 から 、 つまり 末 尾 までの 部分 列 を C で 分割 した 字句 列 の集合 を A とする
rst = B の 1 番 目 から 、 つまり 末 尾 までの 部分 列 を C で 分割 した 字句 列 の集合 を A とする <eos>
1213
src = if e == 2 :
trg = ネ イ ピ ア 数が 2 と 等 しい とき 、
rst = ネ イ ピ ア 数が 2 と 等 しい とき 、 <eos>
1214
src = print ( sum ( A [ B ] ) , end = ' ' )
trg = 空白 文字 を 代わり の 行 末 として A の B 番目の 総 和 を出力する
rst = 空白 文字 を 代わり の 行 末 として A の B 番目の 総 和 を出力する <eos>
1215
src = if A [ B ] [ C ] + e < A [ B + 1 ] [ C + 1 ] :
trg = A の B 番目の C 番 目 に ネ イ ピ ア 数 を加えた 値が A の B に 1 を加えた 値 番目の C に 1 を加えた 値 番 目 より 小さい とき 、
rst = A の B 番目の C 番 目 に ネ イ ピ ア 数 を加えた 値が A の B に 1 を加えた 値 番目の C に 1 を加えた 値 番 目 より 小さい とき 、 <eos>
1216
src = if not 0 <= A < B or not 0 <= C < D or E [ A ] [ C ] or F [ A ] [ C ] :
trg = 0 < = A が B より 小さく なく または 0 < = C が D より 小さく なく または E の A 番目の C 番 目 または F の A 番目の C 番目の とき 、
rst = 0 が A 以下 かどうか が B より 小さく なく または 0 が C 以下 かどうか が D より 小さく なく または E の A 番目の C 番 目 または F の A 番目の C 番目の とき 、 <eos>
1217
src = A . add ( ( B , C ) if B <= C else ( C , B ) )
trg = A に B が C 以下の とき ( B 、 C ) の 組 、 そうでなければ ( C 、 B ) の 組 を追加した 集 ま り
rst = A に B が C 以下の とき ( B 、 C ) の 組 、 そうでなければ ( C 、 B ) の 組 を追加した 集 ま り <eos>
1218
src = return A . left is not None
trg = A の left が 、 つまり 未 定 値 と 等 しい かどうか を返す
rst = A の left が 、 つまり 未 定 値 と 等 しい かどうか を返す <eos>
1219
src = A = [ 0 ] * 300001
trg = ( 0 ) からなる 列 の 3 0000 1 回 分 の 列 を A とする
rst = ( 0 ) からなる 列 の 3 0000 5 回 分 の 列 を A とする <eos>
1220
src = A [ B : B + C ] = range ( D , D - C , - 1 )
trg = D から D から C を 引 いた 値 未 満 までの -1 間隔 の 数 列 を A の B 番 目 から B に C を加えた 値 までの 部分 列 にする
rst = D から D から C を 引 いた 値 未 満 までの -1 間隔 の 数 列 を A の B 番 目 から B に C を加えた 値 までの 部分 列 にする <eos>
1221
src = rec ( A + 1 , B , C , D , E )
trg = rec ( A + 1, B , C , D , E )
rst = rec ( A + 1, B , C , D , E ) <eos>
1222
src = A = B + rect ( C , D + E )
trg = B に rect ( C , D + E ) を加えた 値を A とする
rst = B に rect ( C , D + E ) を加えた 値を A とする <eos>
1223
src = print ( A [ 1 ] [ 0 ] , B . format ( A [ 1 ] [ 1 ] ) )
trg = A の 1 番目の 先頭 、 B を 書式 として A の 1 番目の 1 番 目 で 整 形 した 文字列 を出力する
rst = A の 1 番目の 先頭 、 B を 書式 として A の 1 番目の 1 番 目 で 整 形 した 文字列 を出力する <eos>
1224
src = + [ A ] + koch ( A , B , count - 1 )
trg = ( A ) からなる 列 に [MASK] を加えた 値に koch ( A , B , count -1 ) を加えた 値
rst = ( A ) からなる 列 に koch ( A , B , count -1 ) を加えた 値 <eos>
1225
src = A [ B ] [ C ] = A [ C ] [ B ] = ( ( D - E ) ** 2 + ( F - G ) ** 2 ) ** .5
trg = D から E を 引 いた 値の 2 乗 に F から G を 引 いた 値の 2 乗 を加えた 値の . 5 乗 を A の C 番目の B 番 目 とする を A の B 番目の C 番 目 にする
rst = D から E を 引 いた 値の 2 乗 に F から G を 引 いた 値の 2 乗 を加えた 値を A の C 番目の B 番 目 とする を A の B 番目の C 番 目 にする <eos>
1226
src = print ( * sorted ( set ( map ( int , input ( ) . split ( ) ) ) ) )
trg = input () . split () の 各要素 に int を適用した 列 の集合 を ソート した 列 を 展開 して を出力する
rst = input () . split () の 各要素 に int を適用した 列 の集合 を ソート した 列 を 展開 して を出力する <eos>
1227
src = if ( isStable ( A , B ) ) :
trg = isStable ( A , B ) の とき 、
rst = <unk> ( A , B ) の とき 、 <eos>
1228
src = print ( max ( A ) )
trg = A の 最大 値 を出力する
rst = A の 最大 値 を出力する <eos>
1229
src = write ( A % ( B ) )
trg = write ( A % ( B ) )
rst = write ( A % ( B ) ) <eos>
1230
src = A = B * B + 2 * B * math . sqrt ( C * C + B * B / 4 )
trg = B に B を 掛 け た 値に 2 に B を 掛 け た 値に C に C を 掛 け た 値に B * B を 4 で 割 った 値 を加えた 値の 平 方 根 を 掛 け た 値 を加えた 値を A とする
rst = B に B を 掛 け た 値に 2 に B を 掛 け た 値に C に C を 掛 け た 値 を加えた 値に C に B を 掛 け た 値を 4 で 割 った 値 を加えた 値の 平 方 根 を A とする <eos>
1231
src = A [ B - 1 ] = True
trg = 真 を A の B から 1 を 引 いた 値 番 目 にする
rst = 真 を A の B から 1 を 引 いた 値 番 目 にする <eos>
1232
src = for A , B in C . range_hld ( 0 , D , edge = True ) :
trg = C . range _ hld ( 0 , D , edge = True ) を 順に A 、 B として 、 繰り返す
rst = C . edge ( 0 , D , edge = True ) を 順に A 、 B として 、 繰り返す <eos>
1233
src = A = bubble_sort ( B , C )
trg = bubble _ sort ( B , C ) を A とする
rst = bubble _ sort ( B , C ) を A とする <eos>
1234
src = print ( abs ( A ) )
trg = A の 絶対 値 を出力する
rst = A の 絶対 値 を出力する <eos>
1235
src = A = 500
trg = 500 を A とする
rst = 500 を A とする <eos>
1236
src = A = B . print_preorder ( )
trg = B . print _ preorder () を A とする
rst = B . print _ preorder () を A とする <eos>
1237
src = A = B . most_common ( ) [ 0 ] [ 0 ]
trg = B の 出現 頻 度 順 の 列 の先頭 の先頭 を A とする
rst = B の 出現 頻 度 順 の 列 の先頭 を A とする <eos>
1238
src = print ( A [ 1 - ( B & 1 ) ] )
trg = A の 1 から B と 1 の 論理 積 を 引 いた 値 番 目 を出力する
rst = A の 1 から B と 1 の 論理 積 を 引 いた 値 番 目 を出力する <eos>
1239
src = return int ( sum ( A ) )
trg = A の 総 和 の 整数 値を返す
rst = A の 総 和 の 整数 値を返す <eos>
1240
src = return max ( [ sum ( A ) for A in zip ( * B ) ] )
trg = B を 展開 して の 要素を それぞれ 組 にした 列 の 各要素 を A とし 、 A の 総 和 の 列 の 最大 値を返す
rst = B を 展開 して の 要素を それぞれ 組 にした 列 の 各要素 を A とし 、 A の 総 和 の 列 の 最大 値を返す <eos>
1241
src = print ( A + 1 , B )
trg = A に 1 を加えた 値 、 B を出力する
rst = A に 1 を加えた 値 、 B を出力する <eos>
1242
src = A = deque ( )
trg = [MASK] の 両 端 キュー を A とする
rst = [MASK] の 両 端 キュー を A とする <eos>
1243
src = A [ B | C ] = D [ B ]
trg = D の B 番 目 を A の B と C の 論理 和 番 目 にする
rst = D の B 番 目 を A の B と C の 論理 和 番 目 にする <eos>
1244
src = return _find ( A , B , 1 , 1 , C )
trg = _ find ( A , B , 1, 1, C ) を返す
rst = _ find ( A , B , 1, C ) を返す <eos>
1245
src = print ( ' ' . join ( [ str ( A ) for A in B [ C [ 1 ] ] ] ) )
trg = 空白 文字 を 間 に 入れ て B の C の 1 番 目 番目の 各要素 を A とし 、 A の 文字列 の 列 を 連結 した 文字列 を出力する
rst = 空白 文字 を 間 に 入れ て B の C の 1 番 目 番目の 各要素 を A とし 、 A の 文字列 の 列 を 連結 した 文字列 を出力する <eos>
1246
src = A = [ ( 0 , 0 ) , ( B , C ) , ( D , E ) ]
trg = ( ( 0 、 0 ) の 組 、 ( B 、 C ) の 組 、 ( D 、 E ) の 組 ) からなる 列 を A とする
rst = ( ( 0 、 0 ) の 組 、 ( B 、 C ) の 組 、 ( D 、 E ) の 組 ) からなる 列 を A とする <eos>
1247
src = A . _dfs ( B , C , D + 1 )
trg = A . _ dfs ( B , C , D + 1 )
rst = A . _ dfs ( B , C , D + 1 ) <eos>
1248
src = if A == B [ bisect_left ( B , A ) ] :
trg = A が B の 、 つまり ソート された 順序 を 保 った まま A を B に 挿入 できる 位置 番 目 と 等 しい とき 、
rst = A が B の 、 つまり ソート された 順序 を 保 った まま A を B に 挿入 できる 位置 番 目 と 等 しい とき 、 <eos>
1249
src = return [ ( A + B * ( C - A ) , D + B * ( E - D ) ) ]
trg = ( ( A に B に C から A を 引 いた 値を 掛 け た 値 を加えた 値 、 D に B に E から D を 引 いた 値を 掛 け た 値 を加えた 値 ) の 組 ) からなる 列 を返す
rst = ( ( A に B に C から A を 引 いた 値を 掛 け た 値 を加えた 値 、 D に B に E から D を 引 いた 値を 掛 け た 値 を加えた 値 ) の 組 ) からなる 列 を返す <eos>
1250
src = A [ int ( B ) ] . pop ( )
trg = A の B の 整数値 番目の 先頭 を取り 出した 値
rst = A の B の 整数値 番目の 先頭 を取り 出した 値 <eos>
1251
src = if A [ bisect_left ( A , B ) ] == B :
trg = A の 、 つまり ソート された 順序 を 保 った まま B を A に 挿入 できる 位置 番 目 が B と 等 しい とき 、
rst = A の 、 つまり ソート された 順序 を 保 った まま B を A に 挿入 できる 位置 番 目 が B と 等 しい とき 、 <eos>
1252
src = A = A . zfill ( 5 )
trg = A を 長さ 5 になる ように ' 0 ' 左 詰 め した 文字列を A とする
rst = A を 長さ 5 になる ように ' 0 ' 左 詰 め した 文字列を A とする <eos>
1253
src = A += ( B - C ) ** D * C ( B , C ) * ( - 1 ) ** C
trg = A を B から C を 引 いた 値の D 乗 に C ( B , C ) を 掛 け た 値に -1 の C 乗 を 掛 け た 値 だけ 増加 させる
rst = A を B から C を 引 いた 値の D 乗 に C の B 乗 に対する C の 剰 余 を 掛 け た 値に -1 の C 乗 を 掛 け た 値 だけ 増加 させる <eos>
1254
src = A = sorted ( [ B , C , D ] )
trg = ( B 、 C 、 D ) からなる 列 を ソート した 列 を A とする
rst = ( B 、 C 、 D ) からなる 列 を ソート した 列 を A とする <eos>
1255
src = A = _create ( _root ( B ) )
trg = _ create ( _ root ( B ) ) を A とする
rst = <unk> ( B ) を A とする <eos>
1256
src = A = [ 0 ] * 45
trg = ( 0 ) からなる 列 の 4 5 回 分 の 列 を A とする
rst = ( 0 ) からなる 列 の 4 5 回 分 の 列 を A とする <eos>
1257
src = return A . FLAGS & A . Masks [ B ] == A . Masks [ B ]
trg = A の FLAGS と A の Masks の B 番目の 論理 積 が A の Masks の B 番 目 と 等 しい かどうか を返す
rst = A の FLAGS と A の Masks の B 番目の 論理 積 が A の Masks の B 番 目 と 等 しい かどうか を返す <eos>
1258
src = A += A [ : B ]
trg = A を A の 、 つまり 先頭 から B 番 目 までの 部分 列 だけ 増加 させる
rst = A を A の 、 つまり 先頭 から B 番 目 までの 部分 列 だけ 増加 させる <eos>
1259
src = if A % 2 == 1 :
trg = A を 2 で 割 った 余 り が 1 と 等 しい とき 、
rst = A を 2 で 割 った 余 り が 1 と 等 しい とき 、 <eos>
1260
src = if primeq ( int ( input ( ) ) ) :
trg = primeq ( int ( input () ) ) の とき 、
rst = make _ guruguru ( int ( input () ) ) の とき 、 <eos>
1261
src = A += 90 if B == C else - 90
trg = A を B が C と 等 しい とき 90 、 そうでなければ - 90 だけ 増加 させる
rst = A を B が C と 等 しい とき 90 、 そうでなければ - 90 だけ 増加 させる <eos>
1262
src = if count == 10000 :
trg = 無限 の 整数 列 が 1 0000 と 等 しい とき 、
rst = 無限 の 整数 列 が 1 0000 と 等 しい とき 、 <eos>
1263
src = A = [ [ 0 for B in range ( C + 1 ) ] for B in range ( D + 1 ) ]
trg = 0 から D に 1 を加えた 値 未 満 までの 数 列 の 各要素 を B とし 、 0 から C に 1 を加えた 値 未 満 までの 数 列 の 各要素 を B とし 、 0 の 列 の 列 を A とする
rst = 0 から D に 1 を加えた 値 未 満 までの 数 列 の 各要素 を B とし 、 0 から C に 1 を加えた 値 未 満 までの 数 列 の 各要素 を B とし 、 0 の 列 の 列 を A とする <eos>
1264
src = if A == B . INFINITY :
trg = A が B の INFINITY と 等 しい とき 、
rst = A が B の INFINITY と 等 しい とき 、 <eos>
1265
src = A = B . next = Node ( B , None , None )
trg = Node ( B , None , None ) を B の next とする を A とする
rst = Node ( B , None , None ) を B の next とする を A とする <eos>
1266
src = A = [ max ( B , 40 ) for B in C ]
trg = C の 各要素 を B とし 、 B 、 40 の 最大 値の 列 を A とする
rst = C の 各要素 を B とし 、 B 、 40 の 最大 値の 列 を A とする <eos>
1267
src = A , B = C + 1 , 2
trg = C に 1 を加えた 値 、 2 を A 、 B とする
rst = C に 1 を加えた 値 、 2 を A 、 B とする <eos>
1268
src = A = min ( A , B . graph [ B . pv [ C ] ] [ B . pe [ C ] ] [ 2 ] )
trg = A 、 B の graph の B . pv の C 番 目 番目の B の pe の C 番 目 番目の 2 番目の 最小 値を A とする
rst = A 、 B の graph の B の pv の C 番 目 番目の B の pe の C 番 目 番目の B の pe の 2 番 目 番目の 最小 値を A とする <eos>
1269
src = A = ( B [ 0 ] [ 1 ] + B [ 1 ] [ 1 ] ) / 2
trg = B の先頭 の 1 番 目 に B の 1 番目の 1 番 目 を加えた 値を 2 で 割 った 値を A とする
rst = B の先頭 の 1 番 目 に B の 1 番目の 1 番 目 を加えた 値を 2 で 割 った 値を A とする <eos>
1270
src = write ( A % ( B + ( C - 1 ) // 2 * 2 ) )
trg = write ( A % ( B + ( C -1 ) / /2 * 2 ) )
rst = write ( A % ( B + ( C -1 ) / /2 * 2 ) ) <eos>
1271
src = print ( B if len ( A ) == 0 or max ( A ) < 2 else len ( A ) + 1 )
trg = A の長さ が 0 と 等 しく または A の 最大 値が 2 より 小さい とき B 、 そうでなければ A の長さ に 1 を加えた 値 を出力する
rst = A の長さ が 0 と 等 しく または A の 最大 値が 2 より 小さい とき B 、 そうでなければ A の長さ に 1 を加えた 値 を出力する <eos>
1272
src = A = paint ( A , B + 1 , C + 1 )
trg = paint ( A , B + 1, C + 1 ) を A とする
rst = paint ( A , B + 1, C + 1 ) を A とする <eos>
1273
src = for A , B , C , D , e in E :
trg = E を 順に A 、 B 、 C 、 D 、 ネ イ ピ ア 数 として 、 繰り返す
rst = E を 順に A 、 B 、 C 、 D 、 ネ イ ピ ア 数 として 、 繰り返す <eos>
1274
src = A = gen ( B , C , D )
trg = gen ( B , C , D ) を A とする
rst = gen ( B , C , D ) を A とする <eos>
1275
src = A = [ B , C ] . __getitem__
trg = ( B 、 C ) からなる 列 の __ getitem __ を A とする
rst = ( B 、 C ) からなる 列 の __ getitem __ を A とする <eos>
1276
src = A = floor ( A ) if A > 0 else ceil ( A )
trg = A が 0 より 大きい とき A の 切り 捨 て 整数値 、 そうでなければ A の 切り 上げ 整数値 を A とする
rst = A が 0 より 大きい とき A の 切り 捨 て 整数値 、 そうでなければ A の 最小 値を A とする <eos>
1277
src = A = B . _nodes [ B . cur // 2 - 1 ]
trg = B の _ nodes の B の cur を 2 で 割 った 商 から 1 を 引 いた 値 番 目 を A とする
rst = B の _ nodes の B の cur を 2 で 割 った 商 から 1 を 引 いた 値 番 目 を A とする <eos>
1278
src = dij ( A [ 1 ] - 1 , A [ 2 ] - 1 , B )
trg = dij ( A [ 1 ]- 1, A [ 2 ]- 1, B )
rst = dij ( A [ 1 ]- 1, A [ 2 ] - 1, B ) <eos>
1279
src = A . append ( ( B , C , D [ : ] ) )
trg = A の 末 尾 に ( B 、 C 、 D の コピー された 列 ) の 組 を追加する
rst = A の 末 尾 に ( B 、 C 、 D の コピー された 列 ) の 組 を追加する <eos>
1280
src = A . relations ( B , C )
trg = A . relations ( B , C )
rst = A . process ( B , C ) <eos>
1281
src = def read_list ( B ) : return [ t ( A ) for A in input ( ) . split ( ) ]
trg = 関数 read _ list を t を パラメータ として 定義 する
rst = 関数 read _ <unk> を t 、 N を パラメータ として 定義 する <eos>
1282
src = A = { e : [ B for B , e in enumerate ( C ) ] }
trg = ( ( ネ イ ピ ア 数 , C に 番号 付 した 組 の 列 の 各要素 を B 、 ネ イ ピ ア 数 とし 、 B の 列 ) ) からなる 辞書 を A とする
rst = ( ( ネ イ ピ ア 数 , C に 番号 付 した 組 の 列 の 各要素 を B 、 ネ イ ピ ア 数 とし 、 B の 列 ) ) からなる 辞書 を A とする <eos>
1283
src = print ( 90 )
trg = 90 を出力する
rst = 90 を出力する <eos>
1284
src = A [ B [ C ] - 1 ] [ 1 ] = 1
trg = 1 を A の B の C 番 目 から 1 を 引 いた 値 番目の 1 番 目 にする
rst = 1 を A の B の C 番 目 から 1 を 引 いた 値 番目の 1 番 目 にする <eos>
1285
src = A = A + ' ' + str ( B + 5 )
trg = A に 空白 文字 を加えた 値に B に 5 を加えた 値の 文字列 を加えた 値を A とする
rst = A に 空白 文字 を加えた 値に B に 5 を加えた 値の 文字列 を加えた 値を A とする <eos>
1286
src = - A [ 0 ] * B [ 2 ] * C [ 1 ]
trg = - A の 0 番 目 に B の 2 番 目 を 掛 け た 値に C の 1 番 目 を 掛 け た 値
rst = - A の 先頭に B の 2 番 目 を 掛 け た 値に C の 1 番 目 を 掛 け た 値 <eos>
1287
src = if A in [ 2 , 3 , 5 , 7 ] :
trg = A が ( 2 、 3 、 5 、 7 ) からなる 列 に含まれる とき 、
rst = A が ( 2 、 3 、 5 、 7 ) からなる 列 に含まれる とき 、 <eos>
1288
src = if 50 <= A :
trg = 50 が A 以下の とき 、
rst = 50 が A 以下の とき 、 <eos>
1289
src = while A < len ( B ) and C < len ( D ) :
trg = A が B の長さ より 小さく かつ C が D の長さ より 小さい 間 、 次 を 繰り返す
rst = A が B の長さ より 小さく かつ C が D の長さ より 小さい 間 、 次 を 繰り返す <eos>
1290
src = A [ ( B , C , D ) ] = A [ ( B , C , D ) ] + E
trg = A の ( B 、 C 、 D ) の 組 番 目 に E を加えた 値を A の ( B 、 C 、 D ) の 組 番 目 にする
rst = A の ( B 、 C 、 D ) の 組 番 目 に E を加えた 値を A の ( B 、 C 、 D ) の 組 番 目 にする <eos>
1291
src = if A < len ( B ) and C == B [ A ] :
trg = A が B の長さ より 小さく かつ C が B の A 番 目 と 等 しい とき 、
rst = A が B の長さ より 小さく かつ C が B の A 番 目 と 等 しい とき 、 <eos>
1292
src = print ( '\n' . join ( [ str ( bl ( A , int ( B . readline ( ) ) ) ) for C in range ( D ) ] ) )
trg = 改行 文字 を 間 に 入れ て 0 から D 未 満 までの 数 列 の 各要素 を C とし 、 bl ( A , int ( B . readline () ) ) の 文字列 の 列 を 連結 した 文字列 を出力する
rst = 改行 文字 を 間 に 入れ て 0 から D 未 満 までの 数 列 の 各要素 を C とし 、 bl ( A , B . readline () ) の 文字列 の 整数値 の 列 を 連結 した 文字列 を出力する <eos>
1293
src = A = [ B - C , D - E ]
trg = ( B から C を 引 いた 値 、 D から E を 引 いた 値 ) からなる 列 を A とする
rst = ( B から C を 引 いた 値 、 D から E を 引 いた 値 ) からなる 列 を A とする <eos>
1294
src = A = max ( A , dfs ( B + 1 , C , D + E [ B ] , F , 0 , 0 ) )
trg = A 、 dfs ( B + 1, C , D + E [ B ] , F , 0 , 0 ) の 最大 値を A とする
rst = A 、 dfs ( B + 1, C , D + E [ B ] , F , 0 ) の 最大 値を A とする <eos>
1295
src = return [ [ 0 for A in range ( 10 ) ] for B in range ( 3 ) ]
trg = 0 から 3 未 満 までの 数 列 の 各要素 を B とし 、 0 から 10 未 満 までの 数 列 の 各要素 を A とし 、 0 の 列 の 列 を返す
rst = 0 から 3 未 満 までの 数 列 の 各要素 を B とし 、 0 から 10 未 満 までの 数 列 の 各要素 を A とし 、 0 の 列 の 列 を返す <eos>
1296
src = A = makeItems ( B , C )
trg = makeItems ( B , C ) を A とする
rst = <unk> ( B , C ) を A とする <eos>
1297
src = for A in range ( B + 1 , len ( C ) ) :
trg = B に 1 を加えた 値 から C の長さ 未 満 までの 数 列 を 順に A として 、 繰り返す
rst = B に 1 を加えた 値 から C の長さ 未 満 までの 数 列 を 順に A として 、 繰り返す <eos>
1298
src = for A in range ( len ( B . mat ) ) :
trg = 0 から B の mat の長さ 未 満 までの 数 列 を 順に A として 、 繰り返す
rst = 0 から B の mat の長さ 未 満 までの 数 列 を 順に A として 、 繰り返す <eos>
1299
src = A = create_prime ( 50000 )
trg = create _ prime ( 5 0000 ) を A とする
rst = 5 0000 7 5 24 6 を A とする <eos>
1300
src = if ( ( A [ B + C ] - A [ B + D + C ] ) - E * F [ C ] ) % G == 0 :
trg = A の B + C 番 目 から A の B + D + C 番 目 を 引 いた 値 から E に F の C 番 目 を 掛 け た 値を 引 いた 値を G で 割 った 余 り が 0 と 等 しい とき 、
rst = A の B に C を加えた 値 番 目 から A の B + D に C を加えた 値 番 目 を 引 いた 値 から E に F の C 番 目 を 掛 け た 値を 引 いた 値を G で 割 った 余 り が 0 と
1301
src = if A [ 2 ] :
trg = A の 2 番目の とき 、
rst = A の 2 番目の とき 、 <eos>
1302
src = A [ B [ 0 ] ] [ C ] , A [ B [ 1 ] ] [ C ] = B [ 1 ] , B [ 0 ]
trg = B の 1 番 目 、 B の先頭 を A の B の先頭 番目の C 番 目 、 A の B の 1 番 目 番目の C 番 目 とする
rst = B の 1 番 目 、 B の先頭 を A の B の先頭 番目の C 番 目 、 A の B の 1 番 目 番目の C 番 目 とする <eos>
1303
src = if A [ B - 1 ] [ C - 1 ] :
trg = A の B から 1 を 引 いた 値 番目の C から 1 を 引 いた 値 番目の とき 、
rst = A の B から 1 を 引 いた 値 番目の C から 1 を 引 いた 値 番目の とき 、 <eos>
1304
src = A = list ( input ( ) )
trg = 入力された 文字列 の リストを A とする
rst = 入力された 文字列 の リストを A とする <eos>
1305
src = print ( len ( str ( sum ( map ( int , input ( ) . split ( ) ) ) ) ) )
trg = input () . split () の 各要素 に int を適用した 列 の 総 和 の 文字列 の長さ を出力する
rst = input () . split () の 各要素 に int を適用した 列 の 総 和 の 文字列 の長さ を出力する <eos>
1306
src = A = B / time
trg = B を time で 割 った 値を A とする
rst = B を time で 割 った 値を A とする <eos>
1307
src = if A . head is not None :
trg = A の head が 、 つまり 未 定 値 と 等 しい とき 、
rst = A の head が 、 つまり 未 定 値 と 等 しい とき 、 <eos>
1308
src = for A in topologicalSort ( B , e ) :
trg = topologicalSort ( B , e ) を 順に A として 、 繰り返す
rst = <unk> _ back ( B , e ) を 順に A として 、 繰り返す <eos>
1309
src = A = B . d [ C ]
trg = B の d の C 番 目 を A とする
rst = B の d の C 番 目 を A とする <eos>
1310
src = if A . root is None :
trg = A の root が 、 つまり 未 定 値 と 等 しく ない とき 、
rst = A の root が 、 つまり 未 定 値 と 等 しく ない とき 、 <eos>
1311
src = [ print ( ' ' . join ( A [ B + C ] ) ) for C in range ( - 1 , 2 ) if 0 <= ( B + C ) < len ( A ) ]
trg = -1 から 2 未 満 までの 数 列 の 各要素 を C とし 、 0 が B に C を加えた 値 以下 かどうか が A の長さ より 小さい とき の 、 つまり 空白 文字 を 間 に 入れ て A の B に C を加えた 値 番 目 を 連結 した 文字列 を出力する の 列
rst = -1 から 2 未 満 までの 数 列 の 各要素 を C とし 、 0 が B に C を加えた 値 以下 かどうか が A の長さ より 小さい とき の A の B に C を加えた 値 番 目 を出力する の 列 <eos>
1312
src = print ( * [ A . format ( B [ 0 ] , B [ 1 ] ) for B in C ] )
trg = C の 各要素 を B とし 、 A を 書式 として B の先頭 、 B の 1 番 目 で 整 形 した 文字列 の 列 を 展開 して を出力する
rst = C の 各要素 を B とし 、 A を 書式 として B の先頭 、 B の 1 番 目 で 整 形 した 文字列 の 列 を 展開 して を出力する <eos>
1313
src = if A [ B ] [ C ] and D [ B ] != C :
trg = A の B 番目の C 番 目 かつ D の B 番 目 が C と 等 しく ない とき 、
rst = A の B 番目の C 番 目 かつ D の B 番 目 が C と 等 しく ない とき 、 <eos>
1314
src = return binsearch ( A , B [ 0 ] )
trg = binsearch ( A , B [ 0 ] ) を返す
rst = <unk> ( A , B [ 0 ] ) を返す <eos>
1315
src = if ( A [ B ] == C and A [ B + 1 ] == D ) or ( A [ B ] == D and A [ B + 1 ] == C ) or ( A [ B ] == E and A [ B + 1 ] == F ) or ( A [ B ] == F and A [ B + 1 ] == E ) :
trg = A [ B ] が C と 等 しく かつ A [ B + 1 ] が D と 等 しく または A [ B ] が D と 等 しく かつ A [ B + 1 ] が C と 等 しく または A の B 番 目 が E と 等 しく かつ A の B + 1 番 目 が F と 等 しく または A の B 番 目 が F と 等 しく かつ A
rst = A の B 番 目 が C と 等 しく かつ A の B に 1 を加えた 値 番 目 が D と 等 しく または A の B 番 目 が D と 等 しく かつ A の B に 1 を加えた 値 番 目 が D と 等
1316
src = while A [ B ] [ 0 ] > C [ D ] :
trg = A の B 番目の 0 番 目 が C の D 番 目 より 大きい 間 、 次 を 繰り返す
rst = A の B 番目の 0 番 目 が C の D 番 目 より 大きい 間 、 次 を 繰り返す <eos>
1317
src = A = 10 ** 9 + 2
trg = 10 の 9 乗 に 2 を加えた 値を A とする
rst = 10 の 9 乗 に 2 を加えた 値を A とする <eos>
1318
src = A = ( ( B - C ) * ( D ** 2 - E ** 2 + F ** 2 - C ** 2 ) + ( C - F ) * ( G ** 2 - E ** 2 + B ** 2 - C ** 2 ) ) / H
trg = B から C を 引 いた 値に D * * 2 - E * * 2 に F * * 2 を加えた 値 から C の 2 乗 を 引 いた 値を 掛 け た 値に C から F を 引 いた 値に G * * 2 - E * * 2 に B * * 2 を加えた 値 から C の 2 乗 を 引 いた 値を 掛 け た 値 を加えた 値を H で 割 った 値を A
rst = B から C を 引 いた 値に D * * 2 - E * * 2 に F * * 2 を加えた 値 から C の 2 乗 を 引 いた 値を 掛 け た 値に G の 2 乗 から B から C を 引 いた 値を 引 いた
1319
src = func ( A , [ ] )
trg = func ( A , [] )
rst = func ( A , [] ) <eos>
1320
src = if len ( A [ B ] . children ) == 0 :
trg = A の B 番目の children の長さ が 0 と 等 しい とき 、
rst = A の B 番目の children の長さ が 0 と 等 しい とき 、 <eos>
1321
src = A = { i : [ deque ( ) for B in range ( C ) ] }
trg = ( ( B , 0 から C 未 満 までの 数 列 の 各要素 を B とし 、 [MASK] の 両 端 キュー の 列 ) ) からなる 辞書 を A とする
rst = ( ( B , 0 から C 未 満 までの 数 列 の 各要素 を B とし 、 [MASK] の 両 端 キュー の 列 ) ) からなる 辞書 を A とする <eos>
1322
src = A = sum ( [ 0.5 ** B for B , C in enumerate ( D [ 25 : ] , start = 1 ) if C == E ] )
trg = 1 を 開始 番号 として D の 25 番 目 から 、 つまり 末 尾 までの 部分 列 に 番号 付 した 組 の 列 の 各要素 を B 、 C とし 、 C が E と 等 しい とき の 0.5 の B 乗 の 列 の 総 和 を A とする
rst = 1 を 開始 番号 として D の 、 つまり 先頭 から 25 番 目 までの 部分 列 の 要素を それぞれ 組 にした 列 の 各要素 を B 、 C とし 、 C が E と 等 しい とき の D の B 乗 の 列 の 総 和 を A
1323
src = A . pop ( B . index ( C ) )
trg = A の B の C と 等 しい 要素 の最初の 位置 を取り 出した 値
rst = A の B の C と 等 しい 要素 の最初の 位置 を取り 出した 値 <eos>
1324
src = if ( A [ 0 ] + A [ 4 ] + A [ 8 ] ) % B != C :
trg = A の 0 番 目 に A の 4 番 目 を加えた 値に A の 8 番 目 を加えた 値を B で 割 った 余 り が C と 等 しく ない とき 、
rst = A の 0 番 目 に A の 4 番 目 を加えた 値に A の 8 番 目 を加えた 値を B で 割 った 余 り が C と 等 しく ない とき 、 <eos>
1325
src = A += B [ 2 ] * int ( B [ 1 ] )
trg = A を B の 2 番 目 に B の 1 番目の 整数値 を 掛 け た 値 だけ 増加 させる
rst = A を B の 2 番 目 に B の 1 番目の 整数値 を 掛 け た 値 だけ 増加 させる <eos>
1326
src = A . append ( A [ - 1 ] + B [ C ] )
trg = A の 末 尾 に A の 末 尾 に B の C 番 目 を加えた 値 を追加する
rst = A の 末 尾 に A の -1 番 目 に B の C 番 目 を加えた 値 を追加する <eos>
1327
src = A . top = A . w
trg = A の w を A の top にする
rst = A の w を A の top にする <eos>
1328
src = if A > 0 and B > 0 :
trg = A が 0 より 大きく かつ B が 0 より 大きい とき 、
rst = A が 0 より 大きく かつ B が 0 より 大きい とき 、 <eos>
1329
src = if A not in B [ len ( A ) ] :
trg = A が B の A の長さ 番 目 に 含まれ ない とき 、
rst = A が B の A の長さ 番 目 に 含まれ ない とき 、 <eos>
1330
src = if 0 < A <= B and C [ D ] [ A ] [ now ] > C [ now ] [ E ] [ F ] + G / A :
trg = 0 が A より 小さい かどうか が B 以下 かつ C の D 番目の A 番目の 、 つまり 現在の 日 時 番 目 が C [ now ] の E 番目の F 番 目 に G を A で 割 った 値 を加えた 値 より 大きい とき 、
rst = 0 が A より 小さい かどうか が B より 小さく かつ C の D 番目の A 番目の 、 つまり 現在の 日 時 番 目 が C の 、 つまり 現在の 日 時 番目の E 番 目 に F を 掛 け た 値 を加えた 値を A で 割 った 値
1331
src = A . cursor = A . cursor . next
trg = A の cursor の next を A の cursor にする
rst = A の cursor の next を A の cursor にする <eos>
1332
src = A = string_to_complex ( B )
trg = string _ to _ complex ( B ) を A とする
rst = string _ to _ complex ( B ) を A とする <eos>
1333
src = A = max ( B )
trg = B の 最大 値を A とする
rst = B の 最大 値を A とする <eos>
1334
src = A , B = [ float ( C ) for C in D . split ( ) ]
trg = D を 空白 で 分割 した 字句 列 の 各要素 を C とし 、 C の 浮動小数点数 の 列 を 展開 し 、 それぞれ A 、 B とする
rst = D を 空白 で 分割 した 字句 列 の 各要素 を C とし 、 C の 浮動小数点数 の 列 を 展開 し 、 それぞれ A 、 B とする <eos>
1335
src = A += B . node [ C ]
trg = A を B の node の C 番 目 だけ 増加 させる
rst = A を B の node の C 番 目 だけ 増加 させる <eos>
1336
src = A [ B ] = max ( A [ B + 12 ] , A [ B ] )
trg = A の B に 12 を加えた 値 番 目 、 A の B 番目の 最大 値を A の B 番 目 にする
rst = A の B に 12 を加えた 値 番 目 、 A の B 番目の 最大 値を A の B 番 目 にする <eos>
1337
src = if A [ B ] . imag < A [ C ] . imag :
trg = A の B 番目の imag が A の C 番目の imag より 小さい とき 、
rst = A の B 番目の imag が A の C 番目の imag より 小さい とき 、 <eos>
1338
src = for A in range ( 0 , B , C ) :
trg = 0 から B 未 満 までの C 間隔 の 数 列 を 順に A として 、 繰り返す
rst = 0 から B 未 満 までの C 間隔 の 数 列 を 順に A として 、 繰り返す <eos>
1339
src = A , B = input ( ) . split ( )
trg = 入力された 文字列を 空白 で 分割 した 字句 列 を 展開 し 、 それぞれ A 、 B とする
rst = 入力された 文字列を 空白 で 分割 した 字句 列 を 展開 し 、 それぞれ A 、 B とする <eos>
1340
src = A [ B ] = root ( A , A [ B ] )
trg = root ( A , A [ B ] ) を A の B 番 目 にする
rst = root ( A , A [ B ] ) を A の B 番 目 にする <eos>
1341
src = A = B + 1 + ( C [ D + 1 ] != E )
trg = B に 1 を加えた 値に C の D に 1 を加えた 値 番 目 が E と 等 しく ない かどうか を加えた 値を A とする
rst = B に 1 を加えた 値に C の D に 1 を加えた 値 番 目 が E と 等 しく ない かどうか を加えた 値を A とする <eos>
1342
src = if A . size < B . size :
trg = A の size が B の size より 小さい とき 、
rst = A の size が B の size より 小さい とき 、 <eos>
1343
src = print ( A [ B ] [ - 1 ] + 1 , - A [ B ] [ 0 ] )
trg = A の B 番目の -1 番 目 に 1 を加えた 値 、 - A の B 番目の 先頭 を出力する
rst = A の B 番目の -1 番 目 に 1 を加えた 値 、 - A の B 番目の 先頭 を出力する <eos>
1344
src = E = check ( F )
trg = check ( F ) を E とする
rst = check ( F ) を E とする <eos>
1345
src = A , B = 100 * C + D , 100 * E + F
trg = 100 に C を 掛 け た 値に D を加えた 値 、 100 に E を 掛 け た 値に F を加えた 値を A 、 B とする
rst = 100 に C を 掛 け た 値に D を加えた 値 、 100 に E を 掛 け た 値に F を加えた 値を A 、 B とする <eos>
1346
src = A = ' ' . join ( [ B + str ( C ) for C , B in bubbleSort ( D [ : ] , C ) ] )
trg = 空白 文字 を 間 に 入れ て bubbleSort ( D [ : ] , C ) の 各要素 を C 、 B とし 、 B に C の 文字列 を加えた 値の 列 を 連結 した 文字列を A とする
rst = 空白 文字 を 間 に 入れ て bubbleSort ( D [ : ] , C ) の 各要素 を C 、 B とし 、 B に C の 文字列 を加えた 値の 列 を 連結 した 文字列を A とする <eos>
1347
src = A . behind = e
trg = ネ イ ピ ア 数 を A の behind にする
rst = ネ イ ピ ア 数 を A の behind にする <eos>
1348
src = while A [ - 1 ] * 3 + 1 < B :
trg = A の -1 番 目 に 3 を 掛 け た 値に 1 を加えた 値が B より 小さい 間 、 次 を 繰り返す
rst = A の -1 番 目 に 3 を 掛 け た 値に 1 を加えた 値が B より 小さい 間 、 次 を 繰り返す <eos>
1349
src = return set ( A )
trg = A の集合 を返す
rst = A の集合 を返す <eos>
1350
src = A = [ B [ 0 ] + ( B [ 1 ] - B [ 0 ] ) * C for C in range ( D ) ]
trg = 0 から D 未 満 までの 数 列 の 各要素 を C とし 、 B の 0 番 目 に B の 1 番 目 から B の先頭 を 引 いた 値に C を 掛 け た 値 を加えた 値の 列 を A とする
rst = 0 から D 未 満 までの 数 列 の 各要素 を C とし 、 B の 0 番 目 に B の 1 番 目 から B の先頭 を 引 いた 値に C を 掛 け た 値 を加えた 値の 列 を A とする <eos>
1351
src = e = ( A . p2 - A . p1 ) / abs ( A . p2 - A . p1 )
trg = A の p 2 から A の p 1 を 引 いた 値を A の p 2 から A の p 1 を 引 いた 値の 絶対 値 で 割 った 値を ネ イ ピ ア 数 とする
rst = A の p 2 から A の p 1 を 引 いた 値を A の p 2 から A の p 1 を 引 いた 値の 絶対 値 で 割 った 値を ネ イ ピ ア 数 とする <eos>
1352
src = A . pop ( ( B , C ) )
trg = A の ( B 、 C ) の 組 を取り 出した 値
rst = A の ( B 、 C ) の 組 を取り 出した 値 <eos>
1353
src = if len ( set ( A ) ) != B :
trg = A の集合 の長さ が B と 等 しく ない とき 、
rst = A の集合 の長さ が B と 等 しく ない とき 、 <eos>
1354
src = frame ( A , B )
trg = frame ( A , B )
rst = <unk> ( A , B ) <eos>
1355
src = A = 600 // B
trg = 600 を B で 割 った 商 を A とする
rst = 600 を B で 割 った 商 を A とする <eos>
1356
src = if 0 <= dot2 ( A , B ) <= dist1 ( A ) :
trg = 0 が dot 2 ( A , B ) 以下 かどうか が dist 1 ( A ) 以下の とき 、
rst = 0 が dot 2 ( A , B ) 以下 かどうか が dist 1 ( A ) 以下の とき 、 <eos>
1357
src = return Num ( A . x + B . x )
trg = Num ( A . x + B . x ) を返す
rst = Num ( A . x + B . x ) を返す <eos>
1358
src = A -= 3
trg = A を 3 だけ 減少 させる
rst = A を 3 だけ 減少 させる <eos>
1359
src = A = ( lambda D , E : B . update ( D - 1 , E , C ) , lambda D , E : print ( B . find ( D - 1 , E - 1 ) ) )
trg = ( x 、 y を パラメータ として x から 1 を 引 いた 値 、 y 、 C を追加し て B を 更新 する を返す関数 、 x 、 y を パラメータ として B の位置 E から 1 を 引 いた 値 から D から 1 を 引 いた 値を 探 して 見つかった 位置 を出力する を返す関数 ) の 組 を A とする
rst = ( [MASK] を追加し て A を 更新 する 、 B を 更新 する 、 C から 1 を 引 いた 値 、 D から E を 探 して 見つかった 位置 、 x を パラメータ として B の 末 尾 から x を 引 いた 値 を出力する を返す関数 ) の 組
1360
src = if - 1 == A [ B ] :
trg = -1 が A の B 番 目 と 等 しい とき 、
rst = -1 が A の B 番 目 と 等 しい とき 、 <eos>
1361
src = D += E [ C ]
trg = D を E の C 番 目 だけ 増加 させる
rst = D を E の C 番 目 だけ 増加 させる <eos>
1362
src = if np > 0 :
trg = np が 0 より 大きい とき 、
rst = np が 0 より 大きい とき 、 <eos>
1363
src = A = map ( lambda B : math . pow ( B , C ) , D )
trg = D の 各要素 に x を パラメータ として math . pow ( B , C ) を返す関数 を適用した 列 を A とする
rst = D の 各要素 に x を パラメータ として B の C 乗 を返す関数 を適用した 列 を A とする <eos>
1364
src = return 1730 <= A <= 1930
trg = 17 30 が A 以下 かどうか が 19 30 以下 かどうか を返す
rst = 19 30 が A 以下 かどうか が 19 30 以下 かどうか を返す <eos>
1365
src = A = max ( B // ( C + D * ( E + 1 ) ) , A )
trg = B を C に D に E に 1 を加えた 値を 掛 け た 値 を加えた 値 で 割 った 商 、 A の 最大 値を A とする
rst = B を C に D に E に 1 を加えた 値を 掛 け た 値 を加えた 値 で 割 った 商 、 A の 最大 値を A とする <eos>
1366
src = ( B , C ) = ( 0 , 1 ) if A < e else ( 1 , 0 )
trg = A が 、 つまり ネ イ ピ ア 数 より 小さい とき ( 0 、 1 ) の 組 を ( B 、 C ) の 組 とする 、 そうでなければ ( 1 、 0 ) の 組
rst = A が ( 、 つまり ネ イ ピ ア 数 、 1 ) の 組 より 小さい とき ( 0 、 1 ) の 組 、 そうでなければ ( 1 、 0 ) の 組 を ( B 、 C ) の 組 とする <eos>
1367
src = if not 0 <= A <= B < C or not 0 <= D <= E < F :
trg = 0 が A 以下 かどうか が B 以下 かどうか が C より 小さく なく または 0 が D 以下 かどうか が E 以下 かどうか が F より 小さく ない とき 、
rst = 0 が A 以下 かどうか が B より 小さい かどうか が C より 小さく なく または 0 が D 以下 かどうか が E より 小さく ない とき 、 <eos>
1368
src = if complist ( A , B ) :
trg = complist ( A , B ) の とき 、
rst = <unk> ( A , B ) の とき 、 <eos>
1369
src = return A ** 2
trg = A の 2 乗 を返す
rst = A の 2 乗 を返す <eos>
1370
src = if now % 60 <= A <= B % 60 :
trg = 現在の 日 時 を 60 で 割 った 余 り が A 以下 かどうか が B を 60 で 割 った 余 り 以下の とき 、
rst = 現在の 日 時 を 60 で 割 った 余 り が A 以下 かどうか が B を 60 で 割 った 余 り 以下の とき 、 <eos>
1371
src = print ( ' ' . join ( map ( str , A [ B + 1 : ] ) ) )
trg = 空白 文字 を 間 に 入れ て A の B に 1 を加えた 値 から 、 つまり 末 尾 までの 部分 列 の 各要素 に 整数 を適用した 列 を 連結 した 文字列 を出力する
rst = 空白 文字 を 間 に 入れ て A の B に 1 を加えた 値 から 、 つまり 末 尾 までの 部分 列 の 各要素 に 整数 を適用した 列 を 連結 した 文字列 を出力する <eos>
1372
src = if not ( 0 <= A < len ( B [ 0 ] ) and ( 0 <= C < len ( B ) ) ) or B [ C ] [ A ] == D :
trg = 0 が A 以下 かどうか が B [ 0 ] の長さ より 小さく かつ 0 が C 以下 かどうか が B の長さ より 小さく なく または B の C 番目の A 番 目 が D と 等 しい とき 、
rst = 0 が A 以下 かどうか が B の先頭 の長さ より 小さく なく かつ 0 が C が B の長さ より 小さく または D の C 番目の A 番 目 が D と 等 しい とき 、 <eos>
1373
src = A = [ [ False ] * [ 201 for B in range ( 201 ) ] ]
trg = ( ( 、 つまり 偽 ) からなる 列 の 0 から 20 1 未 満 までの 数 列 の 各要素 を B とし 、 20 1 の 列 回 分 の 列 ) からなる 列 を A とする
rst = ( ( 、 つまり 偽 ) からなる 列 の 0 から 20 1 未 満 までの 数 列 の 各要素 を B とし 、 20 1 の 列 回 分 の 列 ) からなる 列 を A とする <eos>
1374
src = A = [ 1 ] * 45
trg = (1) からなる 列 の 4 5 回 分 の 列 を A とする
rst = (1) からなる 列 の 4 5 回 分 の 列 を A とする <eos>
1375
src = if segment_line_dist ( A , B , C ) < ( D + E ) ** 2 + F :
trg = segment _ line _ dist ( A , B , C ) が D に E を加えた 値の 2 乗 に F を加えた 値 より 小さい とき 、
rst = segment _ line _ dist ( A , B , C ) が D に E を加えた 値の 2 乗 に F を加えた 値 より 小さい とき 、 <eos>
1376
src = for A in itertools . permutations ( [ B , C , D , E ] , 4 ) :
trg = ( B 、 C 、 D 、 E ) からなる 列 のうち 4 個 までの 順 列 を 順に A として 、 繰り返す
rst = ( B 、 C 、 D 、 E ) からなる 列 のうち 4 個 までの 順 列 を 順に A として 、 繰り返す <eos>
1377
src = A . append ( min ( B , C ) )
trg = A の 末 尾 に B 、 C の 最小 値 を追加する
rst = A の 末 尾 に B 、 C の 最小 値 を追加する <eos>
1378
src = A . log [ B - 1 ] = ( A . log [ B - 1 ] [ 0 ] , A . log [ B - 1 ] [ 1 ] , A . step )
trg = ( A の log の B から 1 を 引 いた 値 番目の 先頭 、 A の log の B から 1 を 引 いた 値 番目の 1 番 目 、 A の step ) の 組 を A の log の B から 1 を 引 いた 値 番 目 にする
rst = A の log の B から 1 を 引 いた 値 番目の 先頭 、 A の B から 1 を 引 いた 値 番目の 1 番 目 、 A の log の B から 1 を 引 いた 値 番目の 1 番 目 を A の log の B から
1379
src = A = B [ C ] - D [ C ]
trg = B の C 番 目 から D の C 番 目 を 引 いた 値を A とする
rst = B の C 番 目 から D の C 番 目 を 引 いた 値を A とする <eos>
1380
src = heappush ( A , ( B , C , D , E , F ) )
trg = heappush ( A , ( B , C , D , E , F ) )
rst = heappush ( A , ( B , C , D , E , F ) ) <eos>
1381
src = A = sorted ( A , key = lambda B : ( - B [ 2 ] , B [ 3 ] , B [ 0 ] ) )
trg = x を パラメータ として ( - B の 2 番 目 、 x の 3 番 目 、 x の先頭 ) の 組 を返す関数 を キー として A を ソート した 列 を A とする
rst = x を パラメータ として ( - B の 2 番 目 、 x の 3 番 目 、 x の先頭 ) の 組 を返す関数 を キー として A を ソート した 列 を A とする <eos>
1382
src = A = B [ C ] + D
trg = B の C 番 目 に D を加えた 値を A とする
rst = B の C 番 目 に D を加えた 値を A とする <eos>
1383
src = A = FifteenPuzzle ( B , 45 )
trg = FifteenPuzzle ( B , 4 5 ) を A とする
rst = <unk> ( B , 4 4 5 ) を A とする <eos>
1384
src = A . pos = B
trg = B を A の pos にする
rst = B を A の pos にする <eos>
1385
src = return A . top >= A . Max
trg = A の top が A の Max 以上 かどうか を返す
rst = A の top が A の top 以上 かどうか が A の <unk> 以上 かどうか を返す <eos>
1386
src = print ( A [ ( B + 4 ) % 7 ] )
trg = A の B に 4 を加えた 値を 7 で 割 った 余 り 番 目 を出力する
rst = A の B に 4 を加えた 値を 7 で 割 った 余 り 番 目 を出力する <eos>
1387
src = A = push ( B , C [ D ] , A ) [ 1 ]
trg = push ( B , C [ D ] , A ) の 1 番 目 を A とする
rst = push ( B , C [ D ] , A ) の 1 番 目 を A とする <eos>
1388
src = for A in range ( B - 2 * C ) :
trg = 0 から B から 2 に C を 掛 け た 値を 引 いた 値 未 満 までの 数 列 を 順に A として 、 繰り返す
rst = 0 から B から 2 に C を 掛 け た 値を 引 いた 値 未 満 までの 数 列 を 順に A として 、 繰り返す <eos>
1389
src = A = e - B
trg = ネ イ ピ ア 数 から B を 引 いた 値を A とする
rst = ネ イ ピ ア 数 から B を 引 いた 値を A とする <eos>
1390
src = A . pop ( 0 )
trg = A の 0 を取り 出した 値
rst = A の 0 を取り 出した 値 <eos>
1391
src = return A . _sum ( B ) - A . _sum ( C - 1 )
trg = A . _ sum ( B ) から A . _ sum ( C -1 ) を 引 いた 値を返す
rst = A . _ sum ( B ) から A . _ sum ( C -1 ) を 引 いた 値を返す <eos>
1392
src = A = gindex ( B , C )
trg = gindex ( B , C ) を A とする
rst = gindex ( B , C ) を A とする <eos>
1393
src = A [ B - 1 ] . penalty [ C ] += 20
trg = A の B から 1 を 引 いた 値 番目の penalty の C 番 目 を 20 だけ 増加 させる
rst = A の B から 1 を 引 いた 値 番目の penalty の C 番 目 を 20 だけ 増加 させる <eos>
1394
src = for A in time :
trg = time を 順に A として 、 繰り返す
rst = time を 順に A として 、 繰り返す <eos>
1395
src = A . append ( ( B , C - D ) )
trg = A の 末 尾 に ( B 、 C から D を 引 いた 値 ) の 組 を追加する
rst = A の 末 尾 に ( B 、 C から D を 引 いた 値 ) の 組 を追加する <eos>
1396
src = A [ B ] = ( A [ C ] + [ D ] ) if C != - 1 else [ D ]
trg = C が -1 と 等 しく ない とき A の C 番 目 に ( D ) からなる 列 を加えた 値 、 そうでなければ ( D ) からなる 列 を A の B 番 目 にする
rst = C が -1 と 等 しく ない とき A の C 番 目 に ( D ) からなる 列 を加えた 値 、 そうでなければ D の とき A の B 番 目 に [MASK] を加えた 値 、 そうでなければ D 番 目 を A の B 番 目 にする <eos>
1397
src = time += A [ 0 ] [ 1 ]
trg = time を A の先頭 の 1 番 目 だけ 増加 させる
rst = time を A の先頭 の 1 番 目 だけ 増加 させる <eos>
1398
src = print ( A , B - 1 , C - 1 )
trg = A 、 B から 1 を 引 いた 値 、 C から 1 を 引 いた 値 を出力する
rst = A 、 B から 1 を 引 いた 値 、 C から 1 を 引 いた 値 を出力する <eos>
1399
src = if A . p [ B ] != - 1 :
trg = A の p の B 番 目 が -1 と 等 しく ない とき 、
rst = A の p の B 番 目 が -1 と 等 しく ない とき 、 <eos>
1400
src = A = parse_hash ( B , 0 )
trg = parse _ hash ( B , 0 ) を A とする
rst = parse _ hash ( B , 0 ) を A とする <eos>
1401
src = if ( A , B , C , D , E ) not in F :
trg = ( A 、 B 、 C 、 D 、 E ) の 組 が F に 含まれ ない とき 、
rst = ( A 、 B 、 C 、 D 、 E ) の 組 が F に 含まれ ない とき 、 <eos>
1402
src = A = B // 146097
trg = B を 14 60 9 7 で 割 った 商 を A とする
rst = B を 14 60 9 7 で 割 った 商 を A とする <eos>
1403
src = A . value [ B ] = None
trg = 未 定 値を A の value の B 番 目 にする
rst = 未 定 値を A の value の B 番 目 にする <eos>
1404
src = A = MagicalTiles ( B )
trg = MagicalTiles ( B ) を A とする
rst = <unk> ( B ) を A とする <eos>
1405
src = if len ( A ) > 0 :
trg = A の長さ が 0 より 大きい とき 、
rst = A の長さ が 0 より 大きい とき 、 <eos>
1406
src = A = [ None , None , None ]
trg = ( 、 つまり 未 定 値 、 未 定 値 、 未 定 値 ) からなる 列 を A とする
rst = ( 、 つまり 未 定 値 、 未 定 値 、 未 定 値 ) からなる 列 を A とする <eos>
1407
src = print ( A . format ( B , C , D , E ) )
trg = A を 書式 として B 、 C 、 D 、 E で 整 形 した 文字列 を出力する
rst = A を 書式 として B 、 C 、 D 、 E で 整 形 した 文字列 を出力する <eos>
1408
src = if A [ B ] == [ None , None ] :
trg = A の B 番 目 が ( 、 つまり 未 定 値 、 未 定 値 ) からなる 列 と 等 しい とき 、
rst = A の B 番 目 が ( 、 つまり 未 定 値 、 未 定 値 ) からなる 列 と 等 しい とき 、 <eos>
1409
src = A += parse_line ( B . strip ( ) )
trg = A を parse _ line ( B . strip () ) だけ 増加 させる
rst = A を <unk> ( B . strip () ) だけ 増加 させる <eos>
1410
src = if find ( A [ 1 ] ) :
trg = find ( A [ 1 ] ) の とき 、
rst = find ( A [ 1 ] ) の とき 、 <eos>
1411
src = A = sorted ( list ( map ( int , B ) ) )
trg = B の 各要素 に 整数 を適用した 列 の リストを ソート した 列 を A とする
rst = B の 各要素 に 整数 を適用した 列 の リストを ソート した 列 を A とする <eos>
1412
src = return find_gcd ( A , B % A )
trg = find _ gcd ( A , B % A ) を返す
rst = _ lca ( A , B % A ) を返す <eos>
1413
src = A . add_edge ( B [ C ] , D + 1 , E , 0 )
trg = A . add _ edge ( B [ C ] , D + 1, E , 0 )
rst = A . add _ edge ( B [ C ] , D + 1, E , 0 ) <eos>
1414
src = A = B & - B
trg = B と - B の 論理 積 を A とする
rst = B と - B の 論理 積 を A とする <eos>
1415
src = A = get_bounds ( B )
trg = get _ bounds ( B ) を A とする
rst = <unk> ( B ) を A とする <eos>
1416
src = A = mat_mul ( A , B , C )
trg = mat _ mul ( A , B , C ) を A とする
rst = mat _ mul ( A , B , C ) を A とする <eos>
1417
src = A = ( B - C * ( D - B ) ) - ( E - F * ( G - E ) )
trg = B から C に D から B を 引 いた 値を 掛 け た 値を 引 いた 値 から E から F に G から E を 引 いた 値を 掛 け た 値を 引 いた 値を 引 いた 値を A とする
rst = B から C に D から B を 引 いた 値を 掛 け た 値を 引 いた 値 から E から F に G から E を 引 いた 値を 掛 け た 値を 引 いた 値を 引 いた 値を A とする <eos>
1418
src = A = 0x7fffff
trg = 0 x 7 fffff を A とする
rst = 10 4 6 5 27 を A とする <eos>
1419
src = A [ : 2 ] = [ 0 , 0 ]
trg = ( 0 、 0 ) からなる 列 を A の 、 つまり 先頭 から 2 番 目 までの 部分 列 にする
rst = ( 0 、 0 ) からなる 列 を A の 、 つまり 先頭 から 2 番 目 までの 部分 列 にする <eos>
1420
src = A [ B ] [ C ] = min ( A [ D ] [ E ] + 1 , A [ B ] [ C ] )
trg = A の D 番目の E 番 目 に 1 を加えた 値 、 A の B 番目の C 番目の 最小 値を A の B 番目の C 番 目 にする
rst = A の D 番目の E 番 目 に 1 を加えた 値 、 A の B 番目の C 番目の 最小 値を A の B 番目の C 番 目 にする <eos>
1421
src = return A - 1
trg = A から 1 を 引 いた 値を返す
rst = A から 1 を 引 いた 値を返す <eos>
1422
src = if not A . is_empty ( ) :
trg = A . is _ empty () でない とき 、
rst = A . <unk> () でない とき 、 <eos>
1423
src = A = [ B + 1 for C in range ( D + 1 ) ]
trg = 0 から D に 1 を加えた 値 未 満 までの 数 列 の 各要素 を C とし 、 B に 1 を加えた 値の 列 を A とする
rst = 0 から D に 1 を加えた 値 未 満 までの 数 列 の 各要素 を C とし 、 B に 1 を加えた 値の 列 を A とする <eos>
1424
src = A [ B ] [ C ] = A [ D ] [ E ] + F
trg = A の D 番目の E 番 目 に F を加えた 値を A の B 番目の C 番 目 にする
rst = A の D 番目の E 番 目 に F を加えた 値を A の B 番目の C 番 目 にする <eos>
1425
src = for A in range ( B == C - 1 , 10 ) :
trg = B が C から 1 を 引 いた 値 と 等 しい かどうか から 10 未 満 までの 数 列 を 順に A として 、 繰り返す
rst = B が C から 1 を 引 いた 値 から 10 未 満 までの 数 列 を 順に A として 、 繰り返す <eos>
1426
src = print ( check_circles ( A , B , C , D , E , F ) )
trg = check _ circles ( A , B , C , D , E , F ) を出力する
rst = <unk> _ <unk> ( A , B , C , D , E , F ) を出力する <eos>
1427
src = if A + 1 < B and C [ D * 2 ] [ A ] == 0 and E [ D ] [ A + 1 ] > F + 1 :
trg = A に 1 を加えた 値が B より 小さく かつ C の D * 2 番目の A 番 目 が 0 と 等 しく かつ E の D 番目の A に 1 を加えた 値 番 目 が F に 1 を加えた 値 より 大きい とき 、
rst = A に 1 を加えた 値が B より 小さく かつ C の D に 2 を 掛 け た 値 番目の A 番 目 が 0 と 等 しく かつ E の D 番目の A に 1 を加えた 値 番 目 が F に 1 を加えた 値 より 大きい とき 、
1428
src = return find_upper ( A , B )
trg = find _ upper ( A , B ) を返す
rst = <unk> ( A , B ) を返す <eos>
1429
src = A . cap = B
trg = B を A の cap にする
rst = B を A の cap にする <eos>
1430
src = if len ( A ) and B != C and C [ D ] * ( len ( A ) - 2 ) > B [ D ] * ( len ( A ) + 2 ) :
trg = A の長さ かつ B が C と 等 しく なく かつ C の D 番 目 に A の長さ から 2 を 引 いた 値を 掛 け た 値が B の D 番 目 に A の長さ に 2 を加えた 値を 掛 け た 値 より 大きい とき 、
rst = A の長さ かつ B が C の D 番 目 に C の D 番 目 に len ( A ) から 2 を 引 いた 値を 掛 け た 値 より 大きい かどうか が B に D を加えた 値 より 大きい とき 、 <eos>
1431
src = for A in range ( len ( e [ B ] ) ) :
trg = 0 から 、 つまり ネ イ ピ ア 数の B 番目の 長さ 未 満 までの 数 列 を 順に A として 、 繰り返す
rst = 0 から 、 つまり ネ イ ピ ア 数の B 番目の 長さ 未 満 までの 数 列 を 順に A として 、 繰り返す <eos>
1432
src = if max ( A . values ( ) ) < 1000000 :
trg = A の値 の集まり の 最大 値が 100 0000 より 小さい とき 、
rst = A の値 の集まり の 最大 値が 100 0000 より 小さい とき 、 <eos>
1433
src = print ( A . format ( B ^ e ) )
trg = A を 書式 として B と ネ イ ピ ア 数の 排 他 論理 和 で 整 形 した 文字列 を出力する
rst = A を 書式 として B と ネ イ ピ ア 数の 排 他 論理 和 で 整 形 した 文字列 を出力する <eos>
1434
src = A = B [ 1 : : 2 ]
trg = B の 1 番 目 から 、 つまり 末 尾 までの 2 間隔 による 部分 列 を A とする
rst = B の 1 番 目 から 2 番 目 までの 部分 列 を A とする <eos>
1435
src = A . ord [ B ] = A . cnt
trg = A の cnt を A の ord の B 番 目 にする
rst = A の cnt を A の ord の B 番 目 にする <eos>
1436
src = A = primes2 ( 10 ** 7 )
trg = primes 2 ( 10 * * 7 ) を A とする
rst = primes 2 ( 10 の 7 乗 ) を A とする <eos>
1437
src = A . update ( [ ( B , C , D ) for B in range ( E ) ] )
trg = 0 から E 未 満 までの 数 列 の 各要素 を B とし 、 ( B 、 C 、 D ) の 組 の 列 を追加し て A を 更新 する
rst = 0 から E 未 満 までの 数 列 の 各要素 を B とし 、 ( B 、 C 、 D ) の 組 の 列 を追加し て A を 更新 する <eos>
1438
src = C = - C
trg = - C を C とする
rst = - C を C とする <eos>
1439
src = while A [ B - 1 ] != C :
trg = A の B から 1 を 引 いた 値 番 目 が C と 等 しく ない 間 、 次 を 繰り返す
rst = A の B から 1 を 引 いた 値 番 目 が C と 等 しく ない 間 、 次 を 繰り返す <eos>
1440
src = A . lazy [ B ] = C
trg = C を A の lazy の B 番 目 にする
rst = C を A の lazy の B 番 目 にする <eos>
1441
src = A = max ( A , B [ C - 1 ] [ D ] )
trg = A 、 B の C から 1 を 引 いた 値 番目の D 番目の 最大 値を A とする
rst = A 、 B の C から 1 を 引 いた 値 番目の D 番目の 最大 値を A とする <eos>
1442
src = print ( C if A > ( B >> 1 ) else D )
trg = A が B を 1 だけ 右 シフト した 値 より 大きい とき C 、 そうでなければ D を出力する
rst = A が B を 1 だけ 右 シフト した 値 より 大きい とき C 、 そうでなければ D を出力する <eos>
1443
src = if A . key == B . right :
trg = A の key が B の right と 等 しい とき 、
rst = A の key が B の right と 等 しい とき 、 <eos>
1444
src = print ( Binaryserch ( ) )
trg = Binaryserch () を出力する
rst = <unk> () を出力する <eos>
1445
src = if A == 0 and B :
trg = A が 0 と 等 しく かつ B の とき 、
rst = A が 0 と 等 しく かつ B の とき 、 <eos>
1446
src = for A , B in [ ( A , B ) for A in [ C for B in range ( 1 , 14 ) if ( A , B ) not in D ] ] :
trg = 1 から 14 未 満 までの 数 列 の 各要素 を B とし 、 ( A 、 B ) の 組 が D に 含まれ ない とき の C の 列 の 各要素 を A とし 、 ( A 、 B ) の 組 の 列 を 順に A 、 B として 、 繰り返す
rst = 1 から 14 未 満 までの 数 列 の 各要素 を B とし 、 A 、 B でない とき の A の 列 の 各要素 を A 、 B とし 、 A の 列 を 順に A 、 B として 、 繰り返す <eos>
1447
src = rdfs ( A [ B ] [ C ] , D )
trg = rdfs ( A [ B ] [ C ] , D )
rst = <unk> ( A [ B ] [ C ] , D ) <eos>
1448
src = if A [ B ] > C :
trg = A の B 番 目 が C より 大きい とき 、
rst = A の B 番 目 が C より 大きい とき 、 <eos>
1449
src = if ( A % 2 ) == ( B % 2 ) :
trg = A を 2 で 割 った 余 り が B を 2 で 割 った 余 り と 等 しい とき 、
rst = A を 2 で 割 った 余 り が B を 2 で 割 った 余 り と 等 しい とき 、 <eos>
1450
src = return ( ( A + B * C / D , E + F * C / D ) , G * H / I )
trg = ( ( A に B に C を 掛 け た 値を D で 割 った 値 を加えた 値 、 E に F に C を 掛 け た 値を D で 割 った 値 を加えた 値 ) の 組 、 G に H を 掛 け た 値を I で 割 った 値 ) の 組 を返す
rst = ( A に B に C を 掛 け た 値を D で 割 った 値 を加えた 値 、 E に F に C を 掛 け た 値を D で 割 った 値 を加えた 値 、 G に H を 掛 け た 値 を加えた 値 ) の 組
1451
src = A . spc_y = B // 3
trg = B を 3 で 割 った 商 を A の spc _ y にする
rst = B を 3 で 割 った 商 を A の spc _ y にする <eos>
1452
src = A [ B & 3 ] = 1
trg = 1 を A の B と 3 の 論理 積 番 目 にする
rst = 1 を A の B と 3 の 論理 積 番 目 にする <eos>
1453
src = if ( A + 1 ) ** 3 == e :
trg = A に 1 を加えた 値の 3 乗 が 、 つまり ネ イ ピ ア 数 と 等 しい とき 、
rst = A に 1 を加えた 値の 3 乗 が 、 つまり ネ イ ピ ア 数 と 等 しい とき 、 <eos>
1454
src = A [ B ] = 40
trg = 40 を A の B 番 目 にする
rst = 40 を A の B 番 目 にする <eos>
1455
src = print ( A . lower ( ) , end = '' )
trg = 改行 せずに A を 英 小文字 に変換し た 文字列 を出力する
rst = 改行 せずに A を 英 小文字 に変換し た 文字列 を出力する <eos>
1456
src = A . cnt += 1
trg = A の cnt を 1 だけ 増加 させる
rst = A の cnt を 1 だけ 増加 させる <eos>
1457
src = A += B [ C ] * sum ( [ B [ D ] for D in range ( max ( C + 1 , E + 1 - C ) , 101 ) ] )
trg = A を B の C 番 目 に C + 1 、 E + 1 - C の 最大 値 から 10 1 未 満 までの 数 列 の 各要素 を D とし 、 B の D 番目の 列 の 総 和 を 掛 け た 値 だけ 増加 させる
rst = A を B の C 番 目 に 0 から C + 1 、 E に 1 を加えた 値 から C を 引 いた 値の 最大 値 未 満 までの 数 列 の 各要素 を D とし 、 B の D 番目の 列 の 総 和 を 掛 け た
1458
src = A = tuple ( map ( int , input ( ) . split ( ) ) )
trg = 入力された 文字列を 空白 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 の 組 を A とする
rst = 入力された 文字列を 空白 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 の 組 を A とする <eos>
1459
src = for A in B [ 1 : ] + [ 0 ] :
trg = B の 1 番 目 から 、 つまり 末 尾 までの 部分 列 に ( 0 ) からなる 列 を加えた 値を 順に A として 、 繰り返す
rst = B の 1 番 目 から 、 つまり 末 尾 までの 部分 列 に ( 0 ) からなる 列 を加えた 値を 順に A として 、 繰り返す <eos>
1460
src = A = BubbleSort ( B , C )
trg = BubbleSort ( B , C ) を A とする
rst = BubbleSort ( B , C ) を A とする <eos>
1461
src = A = dot ( B , C - D )
trg = dot ( B , C - D ) を A とする
rst = dot ( B , C - D ) を A とする <eos>
1462
src = return [ A % 3 for A in range ( 27 ) ]
trg = 0 から 27 未 満 までの 数 列 の 各要素 を A とし 、 A を 3 で 割 った 余 り の 列 を返す
rst = 0 から 27 未 満 までの 数 列 の 各要素 を A とし 、 A を 3 で 割 った 余 り の 列 を返す <eos>
1463
src = A = mod_pow ( B * B % C , D // 2 )
trg = mod _ pow ( B * B % C , D / /2 ) を A とする
rst = <unk> ( B * B % C , D / /2 ) を A とする <eos>
1464
src = A . iter [ B ] += 1
trg = A の iter の B 番 目 を 1 だけ 増加 させる
rst = A の iter の B 番 目 を 1 だけ 増加 させる <eos>
1465
src = A = 360 - B [ C ]
trg = 3 60 から B の C 番 目 を 引 いた 値を A とする
rst = 3 60 から B の C 番 目 を 引 いた 値を A とする <eos>
1466
src = A . color = [ B . Status . white ] * A . num_of_nodes
trg = ( B の Status の white ) からなる 列 の A の num _ of _ nodes 回 分 の 列 を A の color にする
rst = ( B の Status の white ) からなる 列 の A の num _ of _ nodes 回 分 の 列 を A の color にする <eos>
1467
src = A . append ( str ( eval ( B + C + D ) ) )
trg = A の 末 尾 に 文字列 B に C を加えた 値に D を加えた 値を 評価 した 値の 文字列 を追加する
rst = A の 末 尾 に 文字列 B に C を加えた 値に D を加えた 値を 評価 した 値の 文字列 を追加する <eos>
1468
src = if A [ B ] [ 2 ] :
trg = A の B 番目の 2 番目の とき 、
rst = A の B 番目の 2 番目の とき 、 <eos>
1469
src = for A in range ( B * C ) :
trg = 0 から B に C を 掛 け た 値 未 満 までの 数 列 を 順に A として 、 繰り返す
rst = 0 から B に C を 掛 け た 値 未 満 までの 数 列 を 順に A として 、 繰り返す <eos>
1470
src = if A . is_parallel ( B ) :
trg = A . is _ parallel ( B ) の とき 、
rst = A . is _ parallel ( B ) の とき 、 <eos>
1471
src = A = [ [ - 1 for B in range ( C + 1 ) ] for D in range ( E + 1 ) ]
trg = 0 から E に 1 を加えた 値 未 満 までの 数 列 の 各要素 を D とし 、 0 から C に 1 を加えた 値 未 満 までの 数 列 の 各要素 を B とし 、 -1 の 列 の 列 を A とする
rst = 0 から E に 1 を加えた 値 未 満 までの 数 列 の 各要素 を D とし 、 0 から C に 1 を加えた 値 未 満 までの 数 列 の 各要素 を B とし 、 -1 の 列 の 列 を A とする <eos>
1472
src = A [ ( B , 5 ) ] = [ C + D for C in A [ ( B , 4 ) ] ]
trg = A の ( B 、 4 ) の 組 番目の 各要素 を C とし 、 C に D を加えた 値の 列 を A の ( B 、 5 ) の 組 番 目 にする
rst = A の ( B 、 4 ) の 組 番目の 各要素 を C とし 、 C に D を加えた 値の 列 を A の ( B 、 5 ) の 組 番 目 にする <eos>
1473
src = return ( A . bits )
trg = A の bits を返す
rst = A の bits を返す <eos>
1474
src = return dfs2 ( A [ B ] , C , D )
trg = dfs 2 ( A [ B ] , C , D ) を返す
rst = dfs 2 ( A [ B ] , C , D ) を返す <eos>
1475
src = for A , B , C in combinations ( D , 3 ) :
trg = D の 3 個 までの コン ビ ネ ー ション を 順に A 、 B 、 C として 、 繰り返す
rst = D の 3 個 までの コン ビ ネ ー ション を 順に A 、 B 、 C として 、 繰り返す <eos>
1476
src = A = [ 0 ] * ( 12 + 1 )
trg = ( 0 ) からなる 列 の 12 に 1 を加えた 値 回 分 の 列 を A とする
rst = ( 0 ) からなる 列 の 12 に 1 を加えた 値 回 分 の 列 を A とする <eos>
1477
src = A , B , C = e
trg = ネ イ ピ ア 数 を 展開 し 、 それぞれ A 、 B 、 C とする
rst = ネ イ ピ ア 数 を 展開 し 、 それぞれ A 、 B 、 C とする <eos>
1478
src = A = find ( B )
trg = find ( B ) を A とする
rst = find ( B ) を A とする <eos>
1479
src = A = ( B - C - 1 ) * D [ E ]
trg = B から C を 引 いた 値 から 1 を 引 いた 値に D の E 番 目 を 掛 け た 値を A とする
rst = B から C を 引 いた 値 から 1 を 引 いた 値に D の E 番 目 を 掛 け た 値を A とする <eos>
1480
src = A [ int ( input ( ) ) - 1 ] = 1
trg = 1 を A の 、 つまり 入力された 文字列 の 整数値 から 1 を 引 いた 値 番 目 にする
rst = 1 を A の 、 つまり 入力された 文字列 の 整数値 から 1 を 引 いた 値 番 目 にする <eos>
1481
src = print ( A + 1 , - 1 )
trg = A に 1 を加えた 値 、 -1 を出力する
rst = A に 1 を加えた 値 、 -1 を出力する <eos>
1482
src = A = int ( B ) * 300
trg = B の 整数値 に 300 を 掛 け た 値を A とする
rst = B の 整数値 に 300 を 掛 け た 値を A とする <eos>
1483
src = A . heappush ( B , C . Node ( D , 0 ) )
trg = A . heappush ( B , C . Node ( D , 0 ) )
rst = A . heappush ( B , C . Node ( D , 0 ) ) <eos>
1484
src = A = max ( A , B * C / D )
trg = A 、 B に C を 掛 け た 値を D で 割 った 値の 最大 値を A とする
rst = A 、 B に C を 掛 け た 値を D で 割 った 値の 最大 値を A とする <eos>
1485
src = if float ( A ) / float ( B ) ** 2 >= 25 :
trg = A の 浮動小数点数 を B の 浮動小数点数 の 2 乗 で 割 った 値が 25 以上の とき 、
rst = A の 浮動小数点数 を B の 浮動小数点数 の 2 乗 で 割 った 値が 25 以上の とき 、 <eos>
1486
src = if A . pip [ 0 ] == B and A . pip [ 1 ] == C :
trg = A の pip の 0 番 目 が B と 等 しく かつ A の pip の 1 番 目 が C と 等 しい とき 、
rst = A の pip の 0 番 目 が B と 等 しく かつ A の pip の 1 番 目 が C と 等 しい とき 、 <eos>
1487
src = if find ( A , int ( B [ C ] [ 5 : ] ) ) :
trg = find ( A , int ( B [ C ] [ 5 : ] ) ) の とき 、
rst = find ( A , int ( B [ C ] [ 5 : ] ) ) の とき 、 <eos>
1488
src = A = ( B - ( C [ D ] - C [ E ] ) ) // 2
trg = B から C の D 番 目 から C の E 番 目 を 引 いた 値を 引 いた 値を 2 で 割 った 商 を A とする
rst = B から C の D 番 目 から C の E 番 目 を 引 いた 値を 引 いた 値を 2 で 割 った 商 を A とする <eos>
1489
src = D = B [ C + 1 ]
trg = B の C に 1 を加えた 値 番 目 を D とする
rst = B の C に 1 を加えた 値 番 目 を D とする <eos>
1490
src = A = Point ( 0 , 0 )
trg = Point ( 0 , 0 ) を A とする
rst = Point ( 0 , 0 ) を A とする <eos>
1491
src = if A / B ** 2 >= 25 :
trg = A を B の 2 乗 で 割 った 値が 25 以上の とき 、
rst = A を B の 2 乗 で 割 った 値が 25 以上の とき 、 <eos>
1492
src = A = prepare_board ( )
trg = prepare _ board () を A とする
rst = <unk> () を A とする <eos>
1493
src = if A < B or 0 < C :
trg = A が B より 小さく または 0 が C より 小さい とき 、
rst = A が B より 小さく または 0 が C より 小さい とき 、 <eos>
1494
src = A = B [ C - 1 ] [ D + 1 ]
trg = B の C から 1 を 引 いた 値 番目の D に 1 を加えた 値 番 目 を A とする
rst = B の C から 1 を 引 いた 値 番目の D に 1 を加えた 値 番 目 を A とする <eos>
1495
src = A = ( B - 1 , B - 1 , 1 )
trg = ( B から 1 を 引 いた 値 、 B から 1 を 引 いた 値 、 1 ) の 組 を A とする
rst = ( B から 1 を 引 いた 値 、 B から 1 を 引 いた 値 、 1 ) の 組 を A とする <eos>
1496
src = for A in combinations ( B , r = 5 ) :
trg = 5 を r として B の コン ビ ネ ー ション を 順に A として 、 繰り返す
rst = 5 を r として B の コン ビ ネ ー ション を 順に A として 、 繰り返す <eos>
1497
src = B = 10 ** 18
trg = 10 の 18 乗 を B とする
rst = 10 の 18 乗 を B とする <eos>
1498
src = A = ( A + B ) % len ( C )
trg = A に B を加えた 値を C の長さ で 割 った 余 り を A とする
rst = A に B を加えた 値を C の長さ で 割 った 余 り を A とする <eos>
1499
src = A = ( ( e * ( 1 - B ) + C * B ) , ( D * ( 1 - B ) + E * B ) )
trg = ( 、 つまり ネ イ ピ ア 数 に 1 から B を 引 いた 値を 掛 け た 値に C に B を 掛 け た 値 を加えた 値 、 D に 1 から B を 引 いた 値を 掛 け た 値に E に B を 掛 け た 値 を加えた 値 ) の 組 を A とする
rst = ( 、 つまり ネ イ ピ ア 数 に 1 から B を 引 いた 値を 掛 け た 値に C に B を 掛 け た 値 を加えた 値 、 D に 1 から B を 引 いた 値を 掛 け た 値に E に B を 掛 け
1500
src = for A in zip ( B , C ) :
trg = B 、 C の 要素を それぞれ 組 にした 列 を 順に A として 、 繰り返す
rst = B 、 C の 要素を それぞれ 組 にした 列 を 順に A として 、 繰り返す <eos>
1501
src = A [ B ] , A [ C ] = A [ C ] , A [ B ]
trg = A の C 番 目 、 A の B 番 目 を A の B 番 目 、 A の C 番 目 とする
rst = A の C 番 目 、 A の B 番 目 を A の B 番 目 、 A の C 番 目 とする <eos>
1502
src = if A [ B ] == C . inf :
trg = A の B 番 目 が C の inf と 等 しい とき 、
rst = A の B 番 目 が C の inf と 等 しい とき 、 <eos>
1503
src = A = B . f
trg = B の f を A とする
rst = B の f を A とする <eos>
1504
src = C . popleft ( ) if A [ 0 ] == B else C . pop ( )
trg = A の 0 番 目 が B と 等 しい とき C . popleft () 、 そうでなければ C の先頭 を取り 出した 値
rst = A の 0 番 目 が B と 等 しい とき C . popleft () 、 そうでなければ C の先頭 を取り 出した 値 <eos>
1505
src = A += search ( B , C , D , E , F , G )
trg = A を C 、 D 、 E 、 F 、 G において 正規表現 B が 最初 にマッチする 位置 だけ 増加 させる
rst = A を C 、 D 、 E 、 F 、 G において 正規表現 B が 最初 にマッチする 位置 だけ 増加 させる <eos>
1506
src = return 0 <= A and B <= dist2 ( C , D )
trg = 0 が A 以下 かつ B が dist 2 ( C , D ) 以下 かどうか を返す
rst = 0 が A 以下 かつ B が dist 2 ( C , D ) 以下 かどうか を返す <eos>
1507
src = print ( A , B , sep = '' , end = ' ' )
trg = 区切り なしで 空白 文字 を 代わり の 行 末 として A 、 B を出力する
rst = 区切り なしで 空白 文字 を 代わり の 行 末 として A 、 B を出力する <eos>
1508
src = A = max ( B . values ( ) )
trg = B の値 の集まり の 最大 値を A とする
rst = B の値 の集まり の 最大 値を A とする <eos>
1509
src = A [ B ] += C // 2 + 1
trg = A の B 番 目 を C を 2 で 割 った 商 に 1 を加えた 値 だけ 増加 させる
rst = A の B 番 目 を C を 2 で 割 った 商 に 1 を加えた 値 だけ 増加 させる <eos>
1510
src = return True if A [ B * 2 - 1 ] [ C ] == 0 else False
trg = A の B * 2 から 1 を 引 いた 値 番目の C 番 目 が 0 と 等 しい とき 、 つまり 真 、 そうでなければ 、 つまり 偽 を返す
rst = A の B に 2 を 掛 け た 値 から 1 を 引 いた 値 番目の C 番 目 が 0 と 等 しい とき 、 つまり 真 、 そうでなければ 、 つまり 偽 を返す <eos>
1511
src = A , B = extendedEuler ( C , D )
trg = extendedEuler ( C , D ) を 展開 し 、 それぞれ A 、 B とする
rst = extendedEuler ( C , D ) を 展開 し 、 それぞれ A 、 B とする <eos>
1512
src = print ( ( B - ( min ( [ C for C in A if C % 2 ] ) if B % 2 else 0 ) ) // 2 )
trg = B から B を 2 で 割 った 余 り の とき [ CforCinAifC % 2 ] の 最小 値 、 そうでなければ 0 を 引 いた 値を 2 で 割 った 商 を出力する
rst = B を 2 で 割 った 余 り の とき B から A [ C % 2 の とき C の 各要素 を C とし 、 C の 列 の 最小 値を 2 で 割 った 商 、 そうでなければ 0 を出力する <eos>
1513
src = A = list ( range ( B , C - 1 , - 1 ) )
trg = B から C から 1 を 引 いた 値 未 満 までの -1 間隔 の 数 列 の リストを A とする
rst = B から C から 1 を 引 いた 値 未 満 までの -1 間隔 の 数 列 の リストを A とする <eos>
1514
src = if collision_ll ( A , B , C , D ) :
trg = collision _ ll ( A , B , C , D ) の とき 、
rst = <unk> ( A , B , C , D ) の とき 、 <eos>
1515
src = aoj ( )
trg = aoj ()
rst = <unk> () <eos>
1516
src = A = B / 4 * ( C ** 4 - D ** 4 ) + ( E - B * D ) / 3 * ( C ** 3 - D ** 3 )
trg = B を 4 で 割 った 値に C の 4 乗 から D の 4 乗 を 引 いた 値を 掛 け た 値に E から B に D を 掛 け た 値を 引 いた 値を 3 で 割 った 値に C の 3 乗 から D の 3 乗 を 引 いた 値を 掛 け た 値 を加えた 値を A とする
rst = B を 4 で 割 った 値に C の 4 乗 から D の 4 乗 を 引 いた 値を 掛 け た 値に E から B に D を 掛 け た 値を 引 いた 値を 3 で 割 った 値に C の 3 乗 から D の 3
1517
src = A += partition ( B , C - D ) * combination ( C , D )
trg = A を partition ( B , C - D ) に combination ( C , D ) を 掛 け た 値 だけ 増加 させる
rst = A を partition ( B , C - D ) に combination ( C , D ) を 掛 け た 値 だけ 増加 させる <eos>
1518
src = if ( A + 1 ) % B > 0 :
trg = A に 1 を加えた 値を B で 割 った 余 り が 0 より 大きい とき 、
rst = A に 1 を加えた 値を B で 割 った 余 り が 0 より 大きい とき 、 <eos>
1519
src = str = A + B + C
trg = A に B を加えた 値に C を加えた 値を 整数 とする
rst = A に B を加えた 値に C を加えた 値を 整数 とする <eos>
1520
src = A = B [ C ] . x
trg = B の C 番目の x 座標 を A とする
rst = B の C 番目の x 座標 を A とする <eos>
1521
src = A . to , A . cap , A . rev = B , C , D
trg = B 、 C 、 D を A の to 、 A の cap 、 A の rev とする
rst = B 、 C 、 D を A の to 、 A の cap 、 A の rev とする <eos>
1522
src = A = { 'start' : - 1 }
trg = ( ( B , -1 ) ) からなる 辞書 を A とする
rst = ( ( 0 、 2 の B 乗 から 1 を 引 いた 値 , -1 ) ) からなる 辞書 を A とする <eos>
1523
src = A = list ( filter ( B . isleap , range ( C , D + 1 ) ) )
trg = C から D に 1 を加えた 値 未 満 までの 数 列 の 各 値を B の isleap で フィルタ ー した 列 の リストを A とする
rst = 0 から D に 1 を加えた 値 未 満 までの 数 列 の 各要素 に B の isleap ( C , D + 1 ) 未 満 までの 数 列 の リストを A とする <eos>
1524
src = A . root = int ( math . sqrt ( B ) )
trg = B の 平 方 根 の 整数値 を A の root にする
rst = B の 平 方 根 の 整数値 を A の root にする <eos>
1525
src = A = [ B for B , C in D . items ( ) if C == E ]
trg = D の キー と 値 の集まり の 各要素 を B 、 C とし 、 C が E と 等 しい とき の B の 列 を A とする
rst = D の キー と 値 の集まり の 各要素 を B 、 C とし 、 C が E と 等 しい とき の B の 列 を A とする <eos>
1526
src = A += 1000
trg = A を 1000 だけ 増加 させる
rst = A を 1000 だけ 増加 させる <eos>
1527
src = A , B = int ( input ( ) ) , list ( map ( int , input ( ) . split ( ) ) )
trg = 入力された 文字列 の 整数値 、 入力された 文字列を 空白 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 の リストを A 、 B とする
rst = 入力された 文字列 の 整数値 、 入力された 文字列を 空白 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 の リストを A 、 B とする <eos>
1528
src = A = B . root ( B . id [ C ] )
trg = B . root ( B . id [ C ] ) を A とする
rst = B . root ( B . id [ C ] ) を A とする <eos>
1529
src = print ( A [ B : : 2 ] )
trg = A の B 番 目 から 、 つまり 末 尾 までの 2 間隔 による 部分 列 を出力する
rst = A の B 番 目 から 、 つまり 末 尾 までの 2 間隔 による 部分 列 を出力する <eos>
1530
src = print ( max ( [ A [ B ] + A [ B + 1 ] + A [ B + 2 ] for B in range ( len ( A ) - 2 ) ] ) )
trg = 0 から len ( A ) から 2 を 引 いた 値 未 満 までの 数 列 の 各要素 を B とし 、 A [ B ] に A [ B + 1 ] を加えた 値に A の B + 2 番 目 を加えた 値の 列 の 最大 値 を出力する
rst = 0 から A の長さ から 2 を 引 いた 値 未 満 までの 数 列 の 各要素 を B とし 、 A [ B ] に A [ B + 1 ] を加えた 値に A の B + 2 番 目 を加えた 値の 列 の 最大 値 を出力する <eos>
1531
src = A = max ( ( B - C + D - E - 1 ) // ( D - E ) , 0 )
trg = B - C に D を加えた 値 から E を 引 いた 値 から 1 を 引 いた 値を D から E を 引 いた 値 で 割 った 商 、 0 の 最大 値を A とする
rst = B から C を 引 いた 値に D を加えた 値 から E を 引 いた 値 から 1 を 引 いた 値を D から E を 引 いた 値 で 割 った 商 、 0 の 最大 値を A とする <eos>
1532
src = A = PathSum2 ( B , 0 )
trg = PathSum 2 ( B , 0 ) を A とする
rst = <unk> ( B , 0 ) を A とする <eos>
1533
src = if A [ B ] != A [ B + 1 ] :
trg = A の B 番 目 が A の B に 1 を加えた 値 番 目 と 等 しく ない とき 、
rst = A の B 番 目 が A の B に 1 を加えた 値 番 目 と 等 しく ない とき 、 <eos>
1534
src = A [ 0 ] , A [ 2 ] = A [ 2 ] , A [ 0 ]
trg = A の 2 番 目 、 A の先頭 を A の先頭 、 A の 2 番 目 とする
rst = A の 2 番 目 、 A の先頭 を A の先頭 、 A の 2 番 目 とする <eos>
1535
src = A . append ( B + 8 )
trg = A の 末 尾 に B に 8 を加えた 値 を追加する
rst = A の 末 尾 に B に 8 を加えた 値 を追加する <eos>
1536
src = raise KeyError ( A )
trg = KeyError ( A ) エラー となる
rst = <unk> ( A ) エラー となる <eos>
1537
src = print ( D if ( A and B ) or C else E )
trg = A かつ B または C の とき D 、 そうでなければ E を出力する
rst = A かつ B または C の とき D 、 そうでなければ E を出力する <eos>
1538
src = return A . find ( B , C . left )
trg = A の位置 C の left から B を 探 して 見つかった 位置 を返す
rst = A の位置 C の left から B を 探 して 見つかった 位置 を返す <eos>
1539
src = A [ 4000 - B ] = A [ B ]
trg = A の B 番 目 を A の 400 0 から B を 引 いた 値 番 目 にする
rst = A の B 番 目 を A の 400 から B を 引 いた 値 番 目 にする <eos>
1540
src = A . append ( ( B + C , D ) )
trg = A の 末 尾 に ( B に C を加えた 値 、 D ) の 組 を追加する
rst = A の 末 尾 に ( B に C を加えた 値 、 D ) の 組 を追加する <eos>
1541
src = A = [ [ [ ] for B in range ( C ) ] for D in range ( C ) ]
trg = 0 から C 未 満 までの 数 列 の 各要素 を D とし 、 0 から C 未 満 までの 数 列 の 各要素 を B とし 、 、 つまり 空 列 の 列 の 列 を A とする
rst = 0 から C 未 満 までの 数 列 の 各要素 を D とし 、 0 から C 未 満 までの 数 列 の 各要素 を B とし 、 、 つまり 空 列 の 列 の 列 の 列 を A とする <eos>
1542
src = A [ B ] . append ( 3 * C + D )
trg = A の B 番目の 末 尾 に 3 に C を 掛 け た 値に D を加えた 値 を追加する
rst = A の B 番目の 末 尾 に 3 に C を 掛 け た 値に D を加えた 値 を追加する <eos>
1543
src = A [ B ] [ C ] = A [ C ] [ B ] = e ^ 1
trg = ネ イ ピ ア 数 と 1 の 排 他 論理 和 を A の C 番目の B 番 目 とする を A の B 番目の C 番 目 にする
rst = ネ イ ピ ア 数 と 1 の 排 他 論理 和 を A の C 番目の B 番 目 とする を A の B 番目の C 番 目 にする <eos>
1544
src = A , B = [ float ( C ) for C in D [ E ] . split ( F ) ]
trg = D の E 番 目 を F で 分割 した 字句 列 の 各要素 を C とし 、 C の 浮動小数点数 の 列 を 展開 し 、 それぞれ A 、 B とする
rst = D の E 番 目 を F で 分割 した 字句 列 の 各要素 を C とし 、 C の 浮動小数点数 の 列 を 展開 し 、 それぞれ A 、 B とする <eos>
1545
src = A = B [ : 8 ]
trg = B の 、 つまり 先頭 から 8 番 目 までの 部分 列 を A とする
rst = B の 、 つまり 先頭 から 8 番 目 までの 部分 列 を A とする <eos>
1546
src = return A . status [ B ]
trg = A の status の B 番 目 を返す
rst = A の status の B 番 目 を返す <eos>
1547
src = A = [ ( e , A [ e ] ) for e in A . keys ( ) ]
trg = A の キー の集まり の 各要素 を ネ イ ピ ア 数 とし 、 ( 、 つまり ネ イ ピ ア 数 、 A の 、 つまり ネ イ ピ ア 数 番 目 ) の 組 の 列 を A とする
rst = A の キー の集まり の 各要素 を ネ イ ピ ア 数 とし 、 ( 、 つまり ネ イ ピ ア 数 、 A の 、 つまり ネ イ ピ ア 数 番 目 ) の 組 の 列 を A とする <eos>
1548
src = A += B [ C - 1 ] [ D - 1 ]
trg = A を B の C から 1 を 引 いた 値 番目の D から 1 を 引 いた 値 番 目 だけ 増加 させる
rst = A を B の C から 1 を 引 いた 値 番目の D から 1 を 引 いた 値 番 目 だけ 増加 させる <eos>
1549
src = if A [ B - 1 ] [ C ] and D [ B - 1 ] [ C ] == 0 :
trg = A の B から 1 を 引 いた 値 番目の C 番 目 かつ D の B から 1 を 引 いた 値 番目の C 番 目 が 0 と 等 しい とき 、
rst = A の B から 1 を 引 いた 値 番目の C 番 目 かつ D の B から 1 を 引 いた 値 番目の C 番 目 が 0 と 等 しい とき 、 <eos>
1550
src = print ( 2000 * A )
trg = 2000 に A を 掛 け た 値 を出力する
rst = 2000 に A を 掛 け た 値 を出力する <eos>
1551
src = for A , e in zip ( B , C ) :
trg = B 、 C の 要素を それぞれ 組 にした 列 を 順に A 、 ネ イ ピ ア 数 として 、 繰り返す
rst = B 、 C の 要素を それぞれ 組 にした 列 を 順に A 、 ネ イ ピ ア 数 として 、 繰り返す <eos>
1552
src = A . p = [ B for B in range ( C ) ]
trg = 0 から C 未 満 までの 数 列 の 各要素 を B とし 、 B の 列 を A の p にする
rst = 0 から C 未 満 までの 数 列 の 各要素 を B とし 、 B の 列 を A の p にする <eos>
1553
src = print ( A . pip [ 0 ] )
trg = A の pip の先頭 を出力する
rst = A の pip の先頭 を出力する <eos>
1554
src = try :
trg = 次 は 例外 に関する 条件 がある
rst = <unk> <eos>
1555
src = A . rank = 0
trg = 0 を A の rank にする
rst = 0 を A の rank にする <eos>
1556
src = A |= 1 << B [ C ]
trg = A を 1 を B の C 番 目 だけ 左 シフト した 値 と の 論理 和 にする
rst = A を 1 を B の C 番 目 だけ 左 シフト した 値 と の 論理 和 にする <eos>
1557
src = A += ( 5 - B ) * C
trg = A を 5 から B を 引 いた 値に C を 掛 け た 値 だけ 増加 させる
rst = A を 5 から B を 引 いた 値に C を 掛 け た 値 だけ 増加 させる <eos>
1558
src = A [ B [ C . RIGHT ] ] [ C . SIBLING ] = B [ C . LEFT ]
trg = B の C の LEFT 番 目 を A の B の C の RIGHT 番 目 番目の C の SIBLING 番 目 にする
rst = B の C の LEFT 番 目 を A の B の C の RIGHT 番 目 番目の C の <unk> 番 目 にする <eos>
1559
src = if A . dist * math . cos ( B ) + ( A . rad ** 2 - ( A . dist * math . sin ( B ) ) ** 2 ) ** ( 1 / 2 ) > C :
trg = A の dist に B の 余 弦 を 掛 け た 値に A . rad の 2 乗 から ( A . dist * math . sin ( B ) ) の 2 乗 を 引 いた 値の 1 を 2 で 割 った 値 乗 を加えた 値が C より 大きい とき 、
rst = A の dist に B の 余 弦 を 掛 け た 値に A の rad から A の dist の 2 乗 を 引 いた 値の 正 弦 を 掛 け た 値 を加えた 値が C の 2 乗 より 大きい とき 、 <eos>
1560
src = if A > 2 :
trg = A が 2 より 大きい とき 、
rst = A が 2 より 大きい とき 、 <eos>
1561
src = B = 13
trg = 13 を B とする
rst = 13 を B とする <eos>
1562
src = A = Segment ( B . pt1 , C )
trg = Segment ( B . pt 1, C ) を A とする
rst = Segment ( B . pt 1, C ) を A とする <eos>
1563
src = A . add ( ( B + 1 , C ) )
trg = A に ( B に 1 を加えた 値 、 C ) の 組 を追加した 集 ま り
rst = A に ( B に 1 を加えた 値 、 C ) の 組 を追加した 集 ま り <eos>
1564
src = A = min ( A , dfs ( B - 1 , C ) + 1 )
trg = A 、 dfs ( B - 1, C ) に 1 を加えた 値の 最小 値を A とする
rst = A 、 dfs ( B - 1, C ) に 1 を加えた 値の 最小 値を A とする <eos>
1565
src = A . append ( ( B , C , int ( D ) * 3 + int ( E ) ) )
trg = A の 末 尾 に ( B 、 C 、 D の 整数値 に 3 を 掛 け た 値に E の 整数値 を加えた 値 ) の 組 を追加する
rst = A の 末 尾 に ( B 、 C 、 D の 整数値 に 3 を 掛 け た 値に E の 整数値 を加えた 値 ) の 組 を追加する <eos>
1566
src = return A < dist2 ( B , C ) + 1e-9 and - 1e-9 < D
trg = A が dist 2 ( B , C ) に 1 e - 9 を加えた 値 より 小さく かつ -1 e - 9 が D より 小さい かどうか を返す
rst = A が dist 2 ( B , C ) に 1 e - 9 を加えた 値 より 小さく かつ -1 が D より 小さい かどうか を返す <eos>
1567
src = if A < 7 :
trg = A が 7 より 小さい とき 、
rst = A が 7 より 小さい とき 、 <eos>
1568
src = A = ( 1 , 5 , 10 , 50 , 100 , 500 )
trg = ( 1 、 5 、 10 、 50 、 100 、 500 ) の 組 を A とする
rst = ( 1 、 5 、 10 、 50 、 100 、 500 ) の 組 を A とする <eos>
1569
src = while A and B [ A [ - 1 ] ] < C [ D ] :
trg = A かつ B の A の 末 尾 番 目 が C の D 番 目 より 小さい 間 、 次 を 繰り返す
rst = A かつ B の A の 末 尾 番 目 が C の D 番 目 より 小さい 間 、 次 を 繰り返す <eos>
1570
src = if A [ B - 1 ] [ 0 ] == 0 :
trg = A の B から 1 を 引 いた 値 番目の 0 番 目 が 0 と 等 しい とき 、
rst = A の B から 1 を 引 いた 値 番目の 0 番 目 が 0 と 等 しい とき 、 <eos>
1571
src = A = A . _replace ( left = B )
trg = A . _ replace ( left = B ) を A とする
rst = A . _ replace ( left = B ) を A とする <eos>
1572
src = print ( A % ( ( B + C ) / 2 ) )
trg = A を B に C を加えた 値を 2 で 割 った 値 で 割 った 余 り を出力する
rst = A を B に C を加えた 値を 2 で 割 った 値 で 割 った 余 り を出力する <eos>
1573
src = A = ( B * max ( C , 5 ) + D * max ( E , 2 ) ) * 8 // 10
trg = B に C 、 5 の 最大 値を 掛 け た 値に D に E 、 2 の 最大 値を 掛 け た 値 を加えた 値に 8 を 掛 け た 値を 10 で 割 った 商 を A とする
rst = B に C 、 5 の 最大 値を 掛 け た 値に D に E 、 2 の 最大 値を 掛 け た 値 を加えた 値を 10 で 割 った 商 を A とする <eos>
1574
src = A [ B [ 2 ] ] = B [ 1 ]
trg = B の 1 番 目 を A の B の 2 番 目 番 目 にする
rst = B の 1 番 目 を A の B の 2 番 目 番 目 にする <eos>
1575
src = B >>= 2
trg = B を 2 だけ 右 シフト する
rst = <unk> <eos>
1576
src = for A in list ( B . keys ( ) ) :
trg = B の キー の集まり の リストを 順に A として 、 繰り返す
rst = B の キー の集まり の リストを 順に A として 、 繰り返す <eos>
1577
src = if A [ B ] == ( C [ B + D ] - C [ D ] * E [ B ] ) % F :
trg = A の B 番 目 が C の B に D を加えた 値 番 目 から C の D 番 目 に E の B 番 目 を 掛 け た 値を 引 いた 値を F で 割 った 余 り と 等 しい とき 、
rst = A の B 番 目 が C の B に D を加えた 値 番 目 から C の D 番 目 に E の B 番 目 を 掛 け た 値を 引 いた 値を F で 割 った 余 り と 等 しい とき 、 <eos>
1578
src = A = list ( map ( lambda B : [ 0 ] + list ( accumulate ( B ) ) , A ) )
trg = A の 各要素 に lst を パラメータ として ( 0 ) からなる 列 に accumulate ( B ) のリスト を加えた 値を返す 関数 を適用した 列 の リストを A とする
rst = A の 各要素 に line を パラメータ として ( 0 ) からなる 列 に accumulate ( B ) のリスト を加えた 値を返す 関数 を適用した 列 の リストを A とする <eos>
1579
src = A = 110000
trg = 11 0000 を A とする
rst = 11 0000 を A とする <eos>
1580
src = A , B = map ( int , e . split ( ) )
trg = ネ イ ピ ア 数 を 空白 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 を 展開 し 、 それぞれ A 、 B とする
rst = ネ イ ピ ア 数 を 空白 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 を 展開 し 、 それぞれ A 、 B とする <eos>
1581
src = A = B [ C ] [ D ] + B [ D ] [ E ]
trg = B の C 番目の D 番 目 に B の D 番目の E 番 目 を加えた 値を A とする
rst = B の C 番目の D 番 目 に B の D 番目の E 番 目 を加えた 値を A とする <eos>
1582
src = print ( len ( str ( A ) ) )
trg = A の 文字列 の長さ を出力する
rst = A の 文字列 の長さ を出力する <eos>
1583
src = heappush ( A , ( B + e , C , D ) )
trg = heappush ( A , ( B + e , C , D ) )
rst = heappush ( A , ( B + e , C , D ) ) <eos>
1584
src = for A in range ( 60 * 60 * 24 ) :
trg = 0 から 60 に 60 を 掛 け た 値に 24 を 掛 け た 値 未 満 までの 数 列 を 順に A として 、 繰り返す
rst = 0 から 60 に 60 を 掛 け た 値に 24 を 掛 け た 値 未 満 までの 数 列 を 順に A として 、 繰り返す <eos>
1585
src = if A != B . f_keys [ B . __TOP ] :
trg = A が B の f _ keys の B の __ TOP 番 目 と 等 しく ない とき 、
rst = A が B の f _ keys の B の __ FRONT 番 目 と 等 しく ない とき 、 <eos>
1586
src = A , B = sorted ( map ( int , input ( ) . split ( ) ) , reverse = True )
trg = 逆 順に 入力された 文字列を 空白 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 を ソート した 列 を 展開 し 、 それぞれ A 、 B とする
rst = 逆 順に 入力された 文字列を 空白 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 を ソート した 列 を 展開 し 、 それぞれ A 、 B とする <eos>
1587
src = A = B [ 6 : ]
trg = B の 6 番 目 から 、 つまり 末 尾 までの 部分 列 を A とする
rst = B の 6 番 目 から 、 つまり 末 尾 までの 部分 列 を A とする <eos>
1588
src = return A . nodes [ A . index ( B ) + 1 ]
trg = A の nodes の A の B と 等 しい 要素 の最初の 位置 に 1 を加えた 値 番 目 を返す
rst = A の nodes の A の B と 等 しい 要素 の最初の 位置 に 1 を加えた 値 番 目 を返す <eos>
1589
src = def read_line ( A ) : return t ( input ( ) )
trg = 関数 read _ line を t を パラメータ として 定義 する
rst = 関数 read _ <unk> を t 、 N を パラメータ として 定義 する <eos>
1590
src = if int ( A ) <= B :
trg = A の 整数値 が B 以下の とき 、
rst = A の 整数値 が B 以下の とき 、 <eos>
1591
src = return rec ( A )
trg = rec ( A ) を返す
rst = rec ( A ) を返す <eos>
1592
src = A = math . sqrt ( B ** 2 + C ** 2 + D ** 2 )
trg = B の 2 乗 に C の 2 乗 を加えた 値に D の 2 乗 を加えた 値の 平 方 根 を A とする
rst = B の 2 乗 に C の 2 乗 を加えた 値に D の 2 乗 を加えた 値の 平 方 根 を A とする <eos>
1593
src = A , B = max ( C , D ) , min ( C , D )
trg = C 、 D の 最大 値 、 C 、 D の 最小 値を A 、 B とする
rst = C 、 D の 最大 値 、 C 、 D の 最小 値を A 、 B とする <eos>
1594
src = A = ( 0 , - 1 , 0 , 1 )
trg = ( 0 、 -1 、 0 、 1 ) の 組 を A とする
rst = ( 0 、 -1 、 0 、 1 ) の 組 を A とする <eos>
1595
src = for A in range ( 1000000 ) :
trg = 0 から 100 0000 未 満 までの 数 列 を 順に A として 、 繰り返す
rst = 0 から 100 0000 未 満 までの 数 列 を 順に A として 、 繰り返す <eos>
1596
src = for A in B . splitlines ( ) :
trg = B . splitlines () を 順に A として 、 繰り返す
rst = B . moves () を 順に A として 、 繰り返す <eos>
1597
src = A . append ( stmt_if ( * B [ 2 : ] ) )
trg = A の 末 尾 に stmt _ if ( * B [ 2 : ] ) を追加する
rst = A の 末 尾 に stmt _ set ( * B [ 2 : ] ) を追加する <eos>
1598
src = A , B = get_co ( C , D + 1 )
trg = get _ co ( C , D + 1 ) を 展開 し 、 それぞれ A 、 B とする
rst = get _ co ( C , D + 1 ) を 展開 し 、 それぞれ A 、 B とする <eos>
1599
src = A += B [ C ] * 2
trg = A を B の C 番 目 に 2 を 掛 け た 値 だけ 増加 させる
rst = A を B の C 番 目 に 2 を 掛 け た 値 だけ 増加 させる <eos>
1600
src = for A in sorted_topological ( B ) :
trg = sorted _ topological ( B ) を 順に A として 、 繰り返す
rst = right _ empty ( B ) を 順に A として 、 繰り返す <eos>
1601
src = if A * 200 + B * 300 + C * 500 == D :
trg = A に 200 を 掛 け た 値に B に 300 を 掛 け た 値 を加えた 値に C に 500 を 掛 け た 値 を加えた 値が D と 等 しい とき 、
rst = A に 200 を 掛 け た 値に B に 300 を 掛 け た 値 を加えた 値に C に 500 を 掛 け た 値 を加えた 値が D と 等 しい とき 、 <eos>
1602
src = if count [ A [ B ] ] == 1 and A [ B ] <= C :
trg = 無限 の 整数 列 の A の B 番 目 番 目 が 1 と 等 しく かつ A の B 番 目 が C 以下の とき 、
rst = 無限 の 整数 列 の A の B 番 目 番 目 が 1 と 等 しく かつ A の B 番 目 が C 以下の とき 、 <eos>
1603
src = A [ B [ C ] ] += 1
trg = A の B の C 番 目 番 目 を 1 だけ 増加 させる
rst = A の B の C 番 目 番 目 を 1 だけ 増加 させる <eos>
1604
src = A [ B ] = min ( C - B * D - E , F [ G + 1 ] )
trg = C から B に D を 掛 け た 値を 引 いた 値 から E を 引 いた 値 、 F の G に 1 を加えた 値 番目の 最小 値を A の B 番 目 にする
rst = C から B に D を 掛 け た 値を 引 いた 値 から E を 引 いた 値 、 F の G に 1 を加えた 値 番目の 最小 値を A の B 番 目 にする <eos>
1605
src = A = 2 * B + 2 * C
trg = 2 に B を 掛 け た 値に 2 に C を 掛 け た 値 を加えた 値を A とする
rst = 2 に B を 掛 け た 値に 2 に C を 掛 け た 値 を加えた 値を A とする <eos>
1606
src = if A <= B - 2 :
trg = A が B から 2 を 引 いた 値 以下の とき 、
rst = A が B から 2 を 引 いた 値 以下の とき 、 <eos>
1607
src = A = [ input ( ) for B in range ( 8 ) ]
trg = 0 から 8 未 満 までの 数 列 の 各要素 を B とし 、 、 つまり 入力された 文字列 の 列 を A とする
rst = 0 から 8 未 満 までの 数 列 の 各要素 を B とし 、 、 つまり 入力された 文字列 の 列 を A とする <eos>
1608
src = return len ( A ) * B . value
trg = A の長さ に B の value を 掛 け た 値を返す
rst = A の長さ に B の value を 掛 け た 値を返す <eos>
1609
src = A = list ( map ( B , set ( map ( C , D + E ) ) ) )
trg = D に E を加えた 値の 各要素 に C を適用した 列 の集合 の 各要素 に B を適用した 列 の リストを A とする
rst = D に E を加えた 値 の集合 の 各要素 に C を適用した 列 の集合 の リストを A とする <eos>
1610
src = path . append ( [ [ 4 , 5 , 6 , 7 , 8 , 9 , 5 , 4 , 3 , 2 ] , [ 4 , 3 , 2 , 1 , 0 ] ] )
trg = os . path の 末 尾 に ( ( 4 、 5 、 6 、 7 、 8 、 9 、 5 、 4 、 3 、 2 ) からなる 列 、 ( 4 、 3 、 2 、 1 、 0 ) からなる 列 ) からなる 列 を追加する
rst = os . path の 末 尾 に ( ( 4 、 5 、 6 、 7 、 8 、 9 、 5 、 4 、 3 、 2 ) からなる 列 、 ( 3 、 2 、 0 、 1 、 0 ) からなる 列 ) からなる 列 を追加する <eos>
1611
src = A = ( A - 1 ) >> 1
trg = A から 1 を 引 いた 値を 1 だけ 右 シフト した 値を A とする
rst = A から 1 を 引 いた 値を 1 だけ 右 シフト した 値を A とする <eos>
1612
src = A . append ( B + str ( C + 1 ) )
trg = A の 末 尾 に B に C に 1 を加えた 値の 文字列 を加えた 値 を追加する
rst = A の 末 尾 に B に C に 1 を加えた 値の 文字列 を加えた 値 を追加する <eos>
1613
src = A = 2 if B == 2 else 2 ** ( B - 2 )
trg = B が 2 と 等 しい とき 2 、 そうでなければ 2 の B から 2 を 引 いた 値 乗 を A とする
rst = B が 2 と 等 しい とき 2 、 そうでなければ 2 の B から 2 を 引 いた 値 乗 を A とする <eos>
1614
src = A = ( 1 , 4 , 1 , 4 , 1 , 2 , 1 , 2 )
trg = ( 1 、 4 、 1 、 4 、 1 、 2 、 1 、 2 ) の 組 を A とする
rst = ( 1 、 4 、 1 、 4 、 1 、 2 、 1 、 2 ) の 組 を A とする <eos>
1615
src = if A . nskip is None :
trg = A の nskip が 、 つまり 未 定 値 と 等 しく ない とき 、
rst = A の nskip が 、 つまり 未 定 値 と 等 しく ない とき 、 <eos>
1616
src = A = [ [ [ 0 ] * [ 7 for B in range ( 7 ) ] ] ]
trg = ( ( ( 0 ) からなる 列 の 0 から 7 未 満 までの 数 列 の 各要素 を B とし 、 7 の 列 回 分 の 列 ) からなる 列 ) からなる 列 を A とする
rst = ( ( 0 ) からなる 列 の 0 から 7 未 満 までの 数 列 の 各要素 を B とし 、 7 の 列 回 分 の 列 ) からなる 列 を A とする <eos>
1617
src = A = int ( B * C + str ( D ) + B * C )
trg = B に C を 掛 け た 値に D の 文字列 を加えた 値に B に C を 掛 け た 値 を加えた 値の 整数値 を A とする
rst = B に C を 掛 け た 値に D の 文字列 を加えた 値に B に C を 掛 け た 値 を加えた 値の 整数値 を A とする <eos>
1618
src = A [ B + 1 ] [ C + 1 ] = A [ B ] [ C + 1 ] + D
trg = A の B 番目の C に 1 を加えた 値 番 目 に D を加えた 値を A の B に 1 を加えた 値 番目の C に 1 を加えた 値 番 目 にする
rst = A の B 番目の C に 1 を加えた 値 番 目 に D を加えた 値を A の B に 1 を加えた 値 番目の C に 1 を加えた 値 番 目 にする <eos>
1619
src = A [ B ] = + ( C == D )
trg = C が D と 等 しい かどうか に [MASK] を加えた 値を A の B 番 目 にする
rst = C が D と 等 しい かどうか に [MASK] を加えた 値を A の B 番 目 にする <eos>
1620
src = while path :
trg = os . path の 間 、 次 を 繰り返す
rst = os . path の 間 、 次 を 繰り返す <eos>
1621
src = A = 2001
trg = 2001 を A とする
rst = 2001 を A とする <eos>
1622
src = A += B . bit [ C ]
trg = A を B の bit の C 番 目 だけ 増加 させる
rst = A を B の bit の C 番 目 だけ 増加 させる <eos>
1623
src = A . hld = HeavyLightDecomposition ( B , C )
trg = HeavyLightDecomposition ( B , C ) を A の hld にする
rst = <unk> ( B , C ) を A の hld . get _ time にする <eos>
1624
src = print ( ( A [ - 1 ] - A [ 0 ] + 1 ) - sum ( B [ : C - 1 ] ) )
trg = A の -1 番 目 から A の 0 番 目 を 引 いた 値に 1 を加えた 値 から B の 、 つまり 先頭 から C から 1 を 引 いた 値 までの 部分 列 の 総 和 を 引 いた 値 を出力する
rst = A の -1 番 目 から A の 0 番 目 を 引 いた 値に 1 を加えた 値 から B の 、 つまり 先頭 から C -1 番 目 までの 部分 列 の 総 和 を 引 いた 値 を出力する <eos>
1625
src = return A [ B ] [ C ] + A [ D ] [ E ] - A [ B ] [ E ] - A [ D ] [ C ]
trg = A の B 番目の C 番 目 に A の D 番目の E 番 目 を加えた 値 から A の B 番目の E 番 目 を 引 いた 値 から A の D 番目の C 番 目 を 引 いた 値を返す
rst = A の B 番目の C 番 目 に A の D 番目の E 番 目 を加えた 値 から A の B 番目の E 番 目 を 引 いた 値 から A の D 番目の C 番 目 を 引 いた 値を返す <eos>
1626
src = A [ B ] [ C ] = ( sum ( A [ B ] ) )
trg = A の B 番目の 総 和 を A の B 番目の C 番 目 にする
rst = A の B 番目の 総 和 を A の B 番目の C 番 目 にする <eos>
1627
src = print ( ' ' . join ( [ A [ 0 ] for A in B ] ) )
trg = 空白 文字 を 間 に 入れ て B の 各要素 を A とし 、 A の 0 番目の 列 を 連結 した 文字列 を出力する
rst = 空白 文字 を 間 に 入れ て B の 各要素 を A とし 、 A の 0 番目の 列 を 連結 した 文字列 を出力する <eos>
1628
src = for A in range ( 3 , 1 + ( B >> 1 ) , 2 ) :
trg = 3 から 1 に B を 1 だけ 右 シフト した 値 を加えた 値 未 満 までの 2 間隔 の 数 列 を 順に A として 、 繰り返す
rst = 3 から 1 に B を 1 だけ 右 シフト した 値 、 2 間隔 の 数 列 を 順に A として 、 繰り返す <eos>
1629
src = while 0 <= A and B <= C :
trg = 0 が A 以下 かつ B が C 以下の 間 、 次 を 繰り返す
rst = 0 が A 以下 かつ B が C 以下の 間 、 次 を 繰り返す <eos>
1630
src = A = - sys . maxsize
trg = - sys の maxsize を A とする
rst = - sys の maxsize を A とする <eos>
1631
src = A . edge [ B ] [ C ] [ 1 ] -= D
trg = A の edge の B 番目の C 番目の 1 番 目 を D だけ 減少 させる
rst = A の edge の B 番目の C 番目の 1 番 目 を D だけ 減少 させる <eos>
1632
src = A . append ( ( B , B + C , D ) )
trg = A の 末 尾 に ( B 、 B に C を加えた 値 、 D ) の 組 を追加する
rst = A の 末 尾 に ( B 、 B に C を加えた 値 、 D ) の 組 を追加する <eos>
1633
src = A . update ( B - 1 , A . query ( B - 1 ) + B )
trg = B から 1 を 引 いた 値 、 A . query ( B -1 ) に B を加えた 値を 追加 して A を 更新 する
rst = B から 1 を 引 いた 値 、 A . query ( B -1 ) に B を加えた 値を 追加 して A を 更新 する <eos>
1634
src = A = list ( set ( ( range ( 1 , 11 ) ) ) - set ( B ) )
trg = 1 から 11 未 満 までの 数 列 の集合 から B の集合 を 引 いた 値の リストを A とする
rst = 1 から 11 未 満 までの 数 列 の集合 の リストを 引 いた 値 から B の集合 を 引 いた 値を A とする <eos>
1635
src = if len ( A ) > len ( B ) or ( len ( A ) == len ( B ) and A > B ) :
trg = A の長さ が B の長さ より 大きく または A の長さ が B の長さ と 等 しく かつ A が B より 大きい とき 、
rst = A の長さ が B の長さ より 大きく または A の長さ が B と 等 しく かつ A が B より 大きい とき 、 <eos>
1636
src = return ( A . hldid [ B ] , A . hldid [ B ] + A . size [ B ] )
trg = ( A の hldid の B 番 目 、 A の hldid の B 番 目 に A の size の B 番 目 を加えた 値 ) の 組 を返す
rst = ( A の hldid の B 番 目 、 A の hldid の B 番 目 に A の size の B 番 目 を加えた 値 ) の 組 を返す <eos>
1637
src = A . cursor . prev . next = B
trg = B を A の cursor の prev の next にする
rst = B を A の cursor の prev の next にする <eos>
1638
src = A [ B ] [ B + C ] |= 1 << D
trg = A の B 番目の B に C を加えた 値 番 目 を 1 を D だけ 左 シフト した 値 と の 論理 和 にする
rst = A の B 番目の B に C を加えた 値 番 目 を 1 を D だけ 左 シフト した 値 と の 論理 和 にする <eos>
1639
src = if A > B [ 0 ] :
trg = A が B の先頭 より 大きい とき 、
rst = A が B の先頭 より 大きい とき 、 <eos>
1640
src = A [ B ] *= C [ D ]
trg = A の B 番 目 を C の D 番 目 倍 にする
rst = A の B 番 目 を C の D 番 目 倍 にする <eos>
1641
src = A = sorted ( [ int ( str ( B [ 0 ] ) + str ( B [ 1 ] ) ) , int ( str ( B [ 1 ] ) + str ( B [ 0 ] ) ) , int ( str ( B [ 0 ] ) + str ( B [ 2 ] ) ) , int ( str ( B [ 2 ] ) + str ( B [ 0 ] ) )
trg = ( B [ 0 ] の 文字列 に B [ 1 ] の 文字列 を加えた 値の 整数値 、 B [ 1 ] の 文字列 に B [ 0 ] の 文字列 を加えた 値の 整数値 、 B [ 0 ] の 文字列 に B [ 2 ] の 文字列 を加えた 値の 整数値 、 B [ 2 ] の 文字列 に B [ 0 ] の 文字列 を加えた 値の 整数値 、 B [ 3 ] の 文字列 に B [ 0 ]
rst = ( B の先頭 の 文字列 に B [ 1 ] の 文字列 を加えた 値の 整数値 、 B [ 0 ] の 文字列 を加えた 値に B の先頭 の 文字列 を加えた 値の 整数値 、 B の 2 番目の 文字列 の 整数値 に B の先頭 の 文字列 を加えた 値の 整数値 、 B の
1642
src = A [ B | ( 1 << C ) ] = 1
trg = 1 を A の B と 1 を C だけ 左 シフト した 値の 論理 和 番 目 にする
rst = 1 を A の B と 1 を C だけ 左 シフト した 値の 論理 和 番 目 にする <eos>
1643
src = e = { A , A [ : : - 1 ] }
trg = ( < __ main __ . Cammaobjectat 0 x 10 a 1 dbb 80 > ) の集合 を ネ イ ピ ア 数 とする
rst = ( ( A , A の 末 尾 を 除 いた 部分 列 ) ) からなる 辞書 を ネ イ ピ ア 数 とする <eos>
1644
src = A += sum ( B )
trg = A を B の 総 和 だけ 増加 させる
rst = A を B の 総 和 だけ 増加 させる <eos>
1645
src = A = ( B - 1 ) * 30 + C - 1
trg = B から 1 を 引 いた 値に 30 を 掛 け た 値に C を加えた 値 から 1 を 引 いた 値を A とする
rst = B から 1 を 引 いた 値に 30 を 掛 け た 値に C を加えた 値 から 1 を 引 いた 値を A とする <eos>
1646
src = path . append ( A [ B ] )
trg = os . path の 末 尾 に A の B 番 目 を追加する
rst = os . path の 末 尾 に A の B 番 目 を追加する <eos>
1647
src = return int ( A [ 0 ] ) // 2 + 1
trg = A の先頭 の 整数値 を 2 で 割 った 商 に 1 を加えた 値を返す
rst = A の先頭 の 整数値 を 2 で 割 った 商 に 1 を加えた 値を返す <eos>
1648
src = while A and ( A [ 0 ] is B or A [ 1 ] is B ) :
trg = A かつ A の 0 番 目 が B と 等 しく なく または A の 1 番 目 が B と 等 しく ない 間 、 次 を 繰り返す
rst = A かつ A の 0 番 目 が B と 等 しく なく または A の 1 番 目 が B と 等 しく ない 間 、 次 を 繰り返す <eos>
1649
src = A . dump ( int ( B ) , int ( C ) )
trg = A . dump ( int ( B ) , int ( C ) )
rst = A . dump ( int ( B ) , int ( C ) ) <eos>
1650
src = if A != inf :
trg = A が 、 つまり 無限大 と 等 しく ない とき 、
rst = A が 、 つまり 無限大 と 等 しく ない とき 、 <eos>
1651
src = while A is not None and B == C [ A ] [ 1 ] :
trg = A が 、 つまり 未 定 値 と 等 しく かつ B が C の A 番目の 1 番 目 と 等 しい 間 、 次 を 繰り返す
rst = A が 、 つまり 未 定 値 と 等 しく かつ B が C の A 番目の 1 番 目 と 等 しい 間 、 次 を 繰り返す <eos>
1652
src = A = sum ( [ B [ C ] != D [ C ] for C in range ( E ) ] )
trg = 0 から E 未 満 までの 数 列 の 各要素 を C とし 、 B の C 番 目 が D の C 番 目 と 等 しく ない かどうか の 列 の 総 和 を A とする
rst = 0 から E 未 満 までの 数 列 の 各要素 を C とし 、 B の C 番 目 が D の C 番 目 と 等 しく ない かどうか の 列 の 総 和 を A とする <eos>
1653
src = A . append ( [ 1 ] + [ 0 ] * B + [ 1 ] )
trg = A の 末 尾 に (1) からなる 列 に ( 0 ) からなる 列 の B に (1) からなる 列 を加えた 値 回 分 の 列 を加えた 値 を追加する
rst = A の 末 尾 に (1) からなる 列 に ( 0 ) からなる 列 の B に [ 1 ] を加えた 値 回 分 の 列 を加えた 値 を追加する <eos>
1654
src = A = math . sqrt ( A / len ( B ) )
trg = A を B の長さ で 割 った 値の 平 方 根 を A とする
rst = A を B の長さ で 割 った 値の 平 方 根 を A とする <eos>
1655
src = return abs ( 2 * A - B ) <= 1
trg = 2 に A を 掛 け た 値 から B を 引 いた 値の 絶対 値が 1 以下 かどうか を返す
rst = 2 に A を 掛 け た 値 から B を 引 いた 値の 絶対 値が 1 以下 かどうか を返す <eos>
1656
src = A [ B ] = min ( A [ B - C ] + D , A [ B ] )
trg = A の B から C を 引 いた 値 番 目 に D を加えた 値 、 A の B 番目の 最小 値を A の B 番 目 にする
rst = A の B から C を 引 いた 値 番 目 に D を加えた 値 、 A の B 番目の 最小 値を A の B 番 目 にする <eos>
1657
src = A . f_key_to_val [ B ] = C
trg = C を A の f _ key _ to _ val の B 番 目 にする
rst = C を A の f _ key の B 番 目 にする <eos>
1658
src = A = log2 ( B )
trg = 2 を 底 とする B の 対 数 を A とする
rst = 2 を 底 とする B の 対 数 を A とする <eos>
1659
src = A = B [ 5 : 7 ]
trg = B の 5 番 目 から 7 番 目 までの 部分 列 を A とする
rst = B の 5 番 目 から 7 番 目 までの 部分 列 を A とする <eos>
1660
src = A . t = B * 60 + C
trg = B に 60 を 掛 け た 値に C を加えた 値を A の t にする
rst = B に 60 を 掛 け た 値に C を加えた 値を A の t にする <eos>
1661
src = A = 10 ** 9 + 7
trg = 10 の 9 乗 に 7 を加えた 値を A とする
rst = 10 の 9 乗 に 7 を加えた 値を A とする <eos>
1662
src = A . num = B
trg = B を A の num にする
rst = B を A の num にする <eos>
1663
src = for A in range ( B + 1 , C - 2 , - 1 ) :
trg = B に 1 を加えた 値 から C から 2 を 引 いた 値 未 満 までの -1 間隔 の 数 列 を 順に A として 、 繰り返す
rst = B に 1 を加えた 値 から C から 2 を 引 いた 値 未 満 までの -1 間隔 の 数 列 を 順に A として 、 繰り返す <eos>
1664
src = A = int ( input ( ) ) // 100
trg = 入力された 文字列 の 整数値 を 100 で 割 った 商 を A とする
rst = 入力された 文字列 の 整数値 を 100 で 割 った 商 を A とする <eos>
1665
src = e = [ 0 ] * 51
trg = ( 0 ) からなる 列 の 5 1 回 分 の 列 を ネ イ ピ ア 数 とする
rst = ( 0 ) からなる 列 の 5 1 回 分 の 列 を ネ イ ピ ア 数 とする <eos>
1666
src = print ( str ( A ) )
trg = A の 文字列 を出力する
rst = A の 文字列 を出力する <eos>
1667
src = for A in [ 0 , 2 ] :
trg = ( 0 、 2 ) からなる 列 を 順に A として 、 繰り返す
rst = ( 0 、 2 ) からなる 列 を 順に A として 、 繰り返す <eos>
1668
src = print ( '' . join ( A [ B : C + 1 ] ) )
trg = 空文字列 を 間 に 入れ て A の B 番 目 から C に 1 を加えた 値 までの 部分 列 を 連結 した 文字列 を出力する
rst = 空文字列 を 間 に 入れ て A の B 番 目 から C に 1 を加えた 値 までの 部分 列 を 連結 した 文字列 を出力する <eos>
1669
src = A = min ( ( B - C * D ) // ( E - C ) , F , B // E )
trg = B から C に D を 掛 け た 値を 引 いた 値を E から C を 引 いた 値 で 割 った 商 、 F 、 B を E で 割 った 商 の 最小 値を A とする
rst = B から C に D を 掛 け た 値を 引 いた 値を E から C を 引 いた 値 で 割 った 商 、 F 、 B を E で 割 った 商 の 最小 値を A とする <eos>
1670
src = A [ B [ 0 ] ] = C
trg = C を A の B の先頭 番 目 にする
rst = C を A の B の先頭 番 目 にする <eos>
1671
src = A = 1989 + B - 1
trg = 1989 に B を加えた 値 から 1 を 引 いた 値を A とする
rst = 1989 に B を加えた 値 から 1 を 引 いた 値を A とする <eos>
1672
src = A , B = A + C [ 0 ] , B + C [ 1 ]
trg = A に C の先頭 を加えた 値 、 B に C の 1 番 目 を加えた 値を A 、 B とする
rst = A に C の先頭 を加えた 値 、 B に C の 1 番 目 を加えた 値を A 、 B とする <eos>
1673
src = A . append ( func[symbol] ( B , C ) )
trg = A の 末 尾 に func [ symbol ] ( B , C ) を追加する
rst = A の 末 尾 に <unk> ( B , C ) を追加する <eos>
1674
src = A [ B + 1 ] [ C | D ] = max ( A [ B + 1 ] [ C | D ] , A [ B ] [ E ] + 1 )
trg = A の B に 1 を加えた 値 番目の C と D の 論理 和 番 目 、 A の B 番目の E 番 目 に 1 を加えた 値の 最大 値を A の B に 1 を加えた 値 番目の C と D の 論理 和 番 目 にする
rst = A の B に 1 を加えた 値 番目の C と D の 論理 和 番 目 、 A の B 番目の E 番 目 に 1 を加えた 値の 最大 値を A の B に 1 を加えた 値 番目の C と D の 論理 和 番 目 にする <eos>
1675
src = for A , B in zip ( e [ : : 2 ] , e [ 1 : : 2 ] ) :
trg = ネ イ ピ ア 数の 、 つまり 先頭 から 、 つまり 末 尾 までの 2 間隔 による 部分 列 、 ネ イ ピ ア 数の 1 番 目 から 、 つまり 末 尾 までの 2 間隔 による 部分 列 の 要素を それぞれ 組 にした 列 を 順に A 、 B として 、 繰り返す
rst = ネ イ ピ ア 数の 、 つまり 先頭 から 、 つまり 末 尾 までの 2 間隔 による 部分 列 、 ネ イ ピ ア 数の 1 番 目 から 、 つまり 末 尾 までの 2 間隔 による 部分 列 の 要素を それぞれ 組 にした 列 を 順に A 、 B
1676
src = A = 0
trg = 0 を A とする
rst = 0 を A とする <eos>
1677
src = print ( A . format ( B ) + ' ' . join ( map ( str , prime_factor ( B ) ) ) )
trg = A を 書式 として B で 整 形 した 文字列 に 空白 文字 を 間 に 入れ て prime _ factor ( B ) の 各要素 に 整数 を適用した 列 を 連結 した 文字列 を加えた 値 を出力する
rst = A を 書式 として B で 整 形 した 文字列 に 空白 文字 を 間 に 入れ て prime _ factor ( B ) の 各要素 に 整数 を適用した 列 を 連結 した 文字列 を加えた 値 を出力する <eos>
1678
src = if A [ B - 1 ] [ C ] == 0 :
trg = A の B から 1 を 引 いた 値 番目の C 番 目 が 0 と 等 しい とき 、
rst = A の B から 1 を 引 いた 値 番目の C 番 目 が 0 と 等 しい とき 、 <eos>
1679
src = for A in range ( ( e - B ) // 2 ) :
trg = 0 から 、 つまり ネ イ ピ ア 数 から B を 引 いた 値を 2 で 割 った 商 未 満 までの 数 列 を 順に A として 、 繰り返す
rst = 0 から 、 つまり ネ イ ピ ア 数 から B を 引 いた 値を 2 で 割 った 商 未 満 までの 数 列 を 順に A として 、 繰り返す <eos>
1680
src = A . insert ( 0 , B . head . next )
trg = A の 0 に B の head の next を挿入する
rst = A の 0 に B の head の next を挿入する <eos>
1681
src = A . maxflow = A . dinic ( B , C )
trg = A . dinic ( B , C ) を A の maxflow にする
rst = A . dinic ( B , C ) を A の dinic にする <eos>
1682
src = A = calc ( )
trg = calc () を A とする
rst = calc () を A とする <eos>
1683
src = A , B = [ 0 ] * 128 , [ 0 ] * 128
trg = ( 0 ) からなる 列 の 1 28 回 分 の 列 、 ( 0 ) からなる 列 の 1 28 回 分 の 列 を A 、 B とする
rst = ( 0 ) からなる 列 の 1 28 回 分 の 列 、 ( 0 ) からなる 列 の 1 28 回 分 の 列 を A 、 B とする <eos>
1684
src = if A [ B ] . right != - 1 :
trg = A の B 番目の right が -1 と 等 しく ない とき 、
rst = A の B 番目の right が -1 と 等 しく ない とき 、 <eos>
1685
src = if A [ 0 ] + A [ 1 ] * 5 + A [ 2 ] * 10 + A [ 3 ] * 50 + A [ 4 ] * 100 + A [ 5 ] * 500 >= 1000 :
trg = A [ 0 ] + A [ 1 ] * 5 に A [ 2 ] * 10 を加えた 値に A [ 3 ] に 50 を 掛 け た 値 を加えた 値に A の 4 番 目 に 100 を 掛 け た 値 を加えた 値に A の 5 番 目 に 500 を 掛 け た 値 を加えた 値が 1000 以上の とき 、
rst = A [ 0 ] + A [ 1 ] * 5 + A [ 2 ] * 10 + A [ 3 ] * 50 ] に A [ 4 ] * A [ 5 ] を加えた 値に A [ 0 ] に 1000 を 掛 け た 値 を加えた
1686
src = A = walk_preorder ( B , C )
trg = walk _ preorder ( B , C ) を A とする
rst = walk _ preorder ( B , C ) を A とする <eos>
1687
src = print ( A . area ( ) )
trg = A . area () を出力する
rst = A . area () を出力する <eos>
1688
src = if { 'J' : B , 'O' : D , 'I' : F } [ G ] :
trg = ( ( A , B ) 、 ( C , D ) 、 ( E , F ) ) からなる 辞書 の G 番目の とき 、
rst = ( ( B , B ) 、 ( C , D ) 、 ( F , G ) ) からなる 辞書 の F 番 目 から G 番 目 までの 部分 列 ) からなる 辞書 の とき 、 <eos>
1689
src = A = [ B + 1 ] * 2
trg = ( B に 1 を加えた 値 ) からなる 列 の 2 回 分 の 列 を A とする
rst = ( B に 1 を加えた 値 ) からなる 列 の 2 回 分 の 列 を A とする <eos>
1690
src = A = add ( A , B [ C ] )
trg = add ( A , B [ C ] ) を A とする
rst = add ( A , B [ C ] ) を A とする <eos>
1691
src = count = int ( A >= 2 ) + sum ( [ B [ C ] for C in range ( 3 , A + 1 , 2 ) ] )
trg = A が 2 以上 かどうか の 整数値 に 3 から A に 1 を加えた 値 未 満 までの 2 間隔 の 数 列 の 各要素 を C とし 、 B の C 番目の 列 の 総 和 を加えた 値を 無限 の 整数 列 とする
rst = A が 2 以上 かどうか に 3 から A に 1 を加えた 値 未 満 までの 数 列 の 各要素 を C とし 、 B の C 番目の 列 の 総 和 を加えた 値を 無限 の 整数 列 とする <eos>
1692
src = A [ B ] . append ( ( e , C ) )
trg = A の B 番目の 末 尾 に ( 、 つまり ネ イ ピ ア 数 、 C ) の 組 を追加する
rst = A の B 番目の 末 尾 に ( 、 つまり ネ イ ピ ア 数 、 C ) の 組 を追加する <eos>
1693
src = A = ( B * C + D * E ) * 0.8
trg = B に C を 掛 け た 値に D に E を 掛 け た 値 を加えた 値に 0 . 8 を 掛 け た 値を A とする
rst = B に C を 掛 け た 値に D に E を 掛 け た 値 を加えた 値に 0 . 8 を 掛 け た 値を A とする <eos>
1694
src = if A [ B ] [ C ] == D :
trg = A の B 番目の C 番 目 が D と 等 しい とき 、
rst = A の B 番目の C 番 目 が D と 等 しい とき 、 <eos>
1695
src = A . delete ( int ( B [ 7 : ] ) )
trg = A . delete ( int ( B [ 7 : ] ) )
rst = A . delete ( int ( B [ 7 : ] ) ) <eos>
1696
src = A = float ( B . readline ( ) )
trg = B から 読み 込 んだ 一行 の 浮動小数点数 を A とする
rst = B から 読み 込 んだ 一行 の 浮動小数点数 を A とする <eos>
1697
src = A = pushback ( A , B [ 1 ] , B [ 2 ] )
trg = pushback ( A , B [ 1 ] , B [ 2 ] ) を A とする
rst = <unk> ( A , B [ 1 ] , B [ 2 ] ) を A とする <eos>
1698
src = A . depth = A . height = 0
trg = 0 を A の height とする を A の depth にする
rst = 0 を A の height とする を A の depth にする <eos>
1699
src = return 1000000
trg = 100 0000 を返す
rst = 100 0000 を返す <eos>
1700
src = return [ 4 , A [ B [ 2 ] ] , A [ B [ 3 ] ] ]
trg = ( 4 、 A の B の 2 番 目 番 目 、 A の B の 3 番 目 番 目 ) からなる 列 を返す
rst = ( 4 、 A の B の 2 番 目 番 目 、 A の B の 3 番 目 番 目 ) からなる 列 を返す <eos>
1701
src = A [ 4 ] = int ( input ( ) )
trg = 入力された 文字列 の 整数値 を A の 4 番 目 にする
rst = 入力された 文字列 の 整数値 を A の 4 番 目 にする <eos>
1702
src = if all ( [ A == 0 for A in B ] ) :
trg = B の 各要素 を A とし 、 A が 0 と 等 しい かどうか の 列 が 全て が 真 の とき 、
rst = B の 各要素 を A とし 、 A が 0 と 等 しい かどうか の 列 が 全て が 真 の とき 、 <eos>
1703
src = A . add_edge ( 0 , B + 1 , 1 , 0 )
trg = A . add _ edge ( 0 , B + 1, 1, 0 )
rst = A . add _ edge ( 0 , B + 1, 1, 0 ) <eos>
1704
src = A = simulate ( )
trg = simulate () を A とする
rst = <unk> () を A とする <eos>
1705
src = return ( A , ( B - C * A ) )
trg = ( A 、 B から C に A を 掛 け た 値を 引 いた 値 ) の 組 を返す
rst = ( A 、 B から C に A を 掛 け た 値を 引 いた 値 ) の 組 を返す <eos>
1706
src = A , B , C = D / E , ( F . real + G . real ) / 2 , ( F . imag + G . imag ) / 2
trg = D を E で 割 った 値 、 F の real に G の real を加えた 値を 2 で 割 った 値 、 F の imag に G の imag を加えた 値を 2 で 割 った 値を A 、 B 、 C とする
rst = D を E で 割 った 値 、 F の real に G の real を加えた 値を 2 で 割 った 値 、 F の imag に G の imag を加えた 値を 2 で 割 った 値 ) の 組 を A 、 B 、 C とする <eos>
1707
src = A = paint ( A , B + 3 , C )
trg = paint ( A , B + 3 , C ) を A とする
rst = paint ( A , B + 3 , C ) を A とする <eos>
1708
src = A += B . data [ C - 1 ]
trg = A を B の data の C から 1 を 引 いた 値 番 目 だけ 増加 させる
rst = A を B の data の C から 1 を 引 いた 値 番 目 だけ 増加 させる <eos>
1709
src = A [ B ] = A [ B ] . upper ( )
trg = A の B 番 目 を 英 大文字 に変換し た 文字列を A の B 番 目 にする
rst = A の B 番 目 を 英 大文字 に変換し た 文字列を A の B 番 目 にする <eos>
1710
src = A [ 4 - B ] [ C ] = D . mp [ C ] [ B ]
trg = D の mp の C 番目の B 番 目 を A の 4 から B を 引 いた 値 番目の C 番 目 にする
rst = D の mp の C 番目の B 番 目 を A の 4 から B を 引 いた 値 番目の C 番 目 にする <eos>
1711
src = A = 3 * B
trg = 3 に B を 掛 け た 値を A とする
rst = 3 に B を 掛 け た 値を A とする <eos>
1712
src = if A [ B ] + C * D + 1 > len ( E ) :
trg = A の B 番 目 に C に D を 掛 け た 値 を加えた 値に 1 を加えた 値が E の長さ より 大きい とき 、
rst = A の B 番 目 に C に D を 掛 け た 値 を加えた 値に 1 を加えた 値が E の長さ より 大きい とき 、 <eos>
1713
src = print ( bubble_sort ( A , B ) )
trg = bubble _ sort ( A , B ) を出力する
rst = bubble _ sort ( A , B ) を出力する <eos>
1714
src = A [ 0 ] = B // 1000
trg = B を 1000 で 割 った 商 を A の 0 番 目 にする
rst = B を 1000 で 割 った 商 を A の 0 番 目 にする <eos>
1715
src = A = A [ : B ] + list ( reversed ( A [ B : e ] ) ) + A [ e : ]
trg = A の 、 つまり 先頭 から B 番 目 までの 部分 列 に A の B 番 目 から e 番 目 までの 部分 列 を 反 転 した 列 のリスト を加えた 値に A の 、 つまり ネ イ ピ ア 数 番 目 から 、 つまり 末 尾 までの 部分 列 を加えた 値を A とする
rst = A の 、 つまり 先頭 から B 番 目 までの 部分 列 に A の B 番 目 から 、 つまり ネ イ ピ ア 数 番 目 までの 部分 列 を 反 転 した 列 のリスト を加えた 値に A の 、 つまり ネ イ ピ ア 数 番 目
1716
src = if A - B <= 180 :
trg = A から B を 引 いた 値が 1 80 以下の とき 、
rst = A から B を 引 いた 値が 1 80 以下の とき 、 <eos>
1717
src = A . roll ( B . WEST )
trg = A . roll ( B . WEST )
rst = A . roll ( B . <unk> ) <eos>
1718
src = A = 120 * 60
trg = 12 0 に 60 を 掛 け た 値を A とする
rst = 12 0 に 60 を 掛 け た 値を A とする <eos>
1719
src = calc_hash ( A , B , C )
trg = calc _ hash ( A , B , C )
rst = calc _ hash ( A , B , C ) <eos>
1720
src = if A . cross ( B , C ) > D . epsilon :
trg = A . cross ( B , C ) が D の epsilon より 大きい とき 、
rst = A . cross ( B , C ) が D の epsilon より 大きい とき 、 <eos>
1721
src = for e in enumerate_dice ( A ) :
trg = enumerate _ dice ( A ) を 順に ネ イ ピ ア 数 として 、 繰り返す
rst = <unk> _ back ( A ) を 順に ネ イ ピ ア 数 として 、 繰り返す <eos>
1722
src = if any ( [ A <= B <= C and D <= E <= F for A , D , C , F in G [ H - 1 ] ] ) :
trg = G の H から 1 を 引 いた 値 番目の 各要素 を A 、 D 、 C 、 F とし 、 A が B 以下 かどうか が C 以下 かつ D が E 以下 かどうか が F 以下 かどうか の 列 が 少なくとも ひとつ は 真 の とき 、
rst = G の H 番目の 各要素 を A 、 D 、 C 、 F とし 、 A が B 以下 かどうか が C 以下 かつ D が E 以下 かどうか の 列 が 少なくとも ひとつ は 真 の とき 、 <eos>
1723
src = A . heappush ( B , ( C [ 1 ] , C [ 0 ] ) )
trg = A . heappush ( B , ( C [ 1 ] , C [ 0 ] ) )
rst = A . heappush ( B , ( C [ 1 ] , C [ 0 ] ) ) <eos>
1724
src = while A in [ B , C ] :
trg = A が ( B 、 C ) からなる 列 に含まれる 間 、 次 を 繰り返す
rst = A が ( B 、 C ) からなる 列 に含まれる 間 、 次 を 繰り返す <eos>
1725
src = A . root . in_order_search ( )
trg = A . root . in _ order _ search ()
rst = A . root . flip _ color () <eos>
1726
src = return A - B < C < A + B
trg = A から B を 引 いた 値が C より 小さい かどうか が A に B を加えた 値 より 小さい かどうか を返す
rst = A から B を 引 いた 値が C より 小さい かどうか が A に B を加えた 値 より 小さい かどうか を返す <eos>
1727
src = A = min ( closest_part1 ( B [ : C ] , C ) , closest_part1 ( B [ C : ] , D - C ) )
trg = closest _ part 1 ( B [ : C ] , C ) 、 closest _ part 1 ( B [ C : ] , D - C ) の 最小 値を A とする
rst = min _ dist ( B [ : C ] , C ) 、 <unk> _ dist ( B [ C : ] , D - C ) の 最小 値を A とする <eos>
1728
src = A . bst . put ( B , C )
trg = A . bst . put ( B , C )
rst = A . bst . put ( B , C ) <eos>
1729
src = A . size = A . _size
trg = A の _ size を A の size にする
rst = A の _ size を A の size にする <eos>
1730
src = A [ 3 ] = 0
trg = 0 を A の 3 番 目 にする
rst = 0 を A の 3 番 目 にする <eos>
1731
src = A *= B
trg = A を B 倍 にする
rst = A を B 倍 にする <eos>
1732
src = A = B . ms [ C ]
trg = B の ms の C 番 目 を A とする
rst = B の ms の C 番 目 を A とする <eos>
1733
src = return [ A , B ]
trg = ( A 、 B ) からなる 列 を返す
rst = ( A 、 B ) からなる 列 を返す <eos>
1734
src = compute_height ( A , 0 )
trg = compute _ height ( A , 0 )
rst = <unk> ( A , 0 ) <eos>
1735
src = print ( int ( A * 100 * ( 100 - B ) / 100 / C ) )
trg = A * 100 に ( 100 - B ) を 掛 け た 値を 100 で 割 った 値を C で 割 った 値の 整数値 を出力する
rst = A に 100 を 掛 け た 値に 100 から B を 引 いた 値を 掛 け た 値を 100 で 割 った 値の 整数値 を出力する <eos>
1736
src = A [ 1 ] += B [ C - 1 ]
trg = A の 1 番 目 を B の C から 1 を 引 いた 値 番 目 だけ 増加 させる
rst = A の 1 番 目 を B の C から 1 を 引 いた 値 番 目 だけ 増加 させる <eos>
1737
src = if A & ( 1 << ( 5 * B + C ) ) :
trg = A と 1 を 5 に B を 掛 け た 値に C を加えた 値 だけ 左 シフト した 値の 論理 積 の とき 、
rst = A と 1 を 5 に B を 掛 け た 値に C を加えた 値 だけ 左 シフト した 値の 論理 積 の とき 、 <eos>
1738
src = [ print ( A ) for A in [ B [ - 1 ] , B [ - 2 ] , B [ - 3 ] ] ]
trg = ( B の 末 尾 、 B の -2 番 目 、 B の -3 番 目 ) からなる 列 の 各要素 を A とし 、 A を出力する の 列
rst = ( B の 末 尾 、 B の -2 番 目 、 B の -3 番 目 、 B の -3 番 目 ) からなる 列 の 列 の 各要素 を A とし 、 A を出力する <eos>
1739
src = return sum ( A ) == B
trg = A の 総 和 が B と 等 しい かどうか を返す
rst = A の 総 和 が B と 等 しい かどうか を返す <eos>
1740
src = A . e [ B ] [ A . e [ C [ B ] ] [ D [ B ] ] . rev ] . cap += E
trg = A の e の B 番目の A . e の C [ B ] 番目の D の B 番 目 番目の rev 番目の cap を E だけ 増加 させる
rst = A の e の B 番目の A . e の C [ B ] 番目の D の B 番 目 番目の rev 番目の cap を E だけ 増加 させる <eos>
1741
src = A += 366
trg = A を 36 6 だけ 増加 させる
rst = A を " { } " だけ 増加 させる <eos>
1742
src = A = ( A + B [ A ] ) % C
trg = A に B の A 番 目 を加えた 値を C で 割 った 余 り を A とする
rst = A に B の A 番 目 を加えた 値を C で 割 った 余 り を A とする <eos>
1743
src = remove ( A + B , C + D )
trg = remove ( A + B , C + D )
rst = remove ( A + B , C + D ) <eos>
1744
src = A = B [ ( C [ D + 1 ] + E ) % F ]
trg = B の C の D に 1 を加えた 値 番 目 に E を加えた 値を F で 割 った 余 り 番 目 を A とする
rst = B の C の D に 1 を加えた 値 番 目 に E を加えた 値を F で 割 った 余 り 番 目 を A とする <eos>
1745
src = return [ 3 , A [ B [ 2 ] ] , A [ B [ 3 ] ] , int ( B [ 4 ] ) ]
trg = ( 3 、 A の B の 2 番 目 番 目 、 A の B の 3 番 目 番 目 、 B の 4 番目の 整数値 ) からなる 列 を返す
rst = ( 3 、 A の B の 2 番 目 番 目 、 A の B の 3 番 目 番 目 、 B の 4 番目の 整数値 ) からなる 列 を返す <eos>
1746
src = A = B . find ( C )
trg = B の先頭 から C を 探 して 見つかった 位置 を A とする
rst = B の先頭 から C を 探 して 見つかった 位置 を A とする <eos>
1747
src = A = list ( map ( float , input ( ) . split ( B ) ) )
trg = 入力された 文字列を B で 分割 した 字句 列 の 各要素 に 浮動小数点数 を適用した 列 の リストを A とする
rst = 入力された 文字列を B で 分割 した 字句 列 の 各要素 に 浮動小数点数 を適用した 列 の リストを A とする <eos>
1748
src = A [ - 2 ] = B [ - 2 ] + 1
trg = B の -2 番 目 に 1 を加えた 値を A の -2 番 目 にする
rst = B の -2 番 目 に 1 を加えた 値を A の -2 番 目 にする <eos>
1749
src = if abs ( A - B ) < C and abs ( D - E ) < C :
trg = A から B を 引 いた 値の 絶対 値が C より 小さく かつ D から E を 引 いた 値の 絶対 値が C より 小さい とき 、
rst = A から B を 引 いた 値の 絶対 値が C より 小さく かつ D から E を 引 いた 値の 絶対 値が C より 小さい とき 、 <eos>
1750
src = if A . sizes [ B ] > A . sizes [ C ] :
trg = A の sizes の B 番 目 が A の sizes の C 番 目 より 大きい とき 、
rst = A の <unk> の B 番 目 が A の <unk> の C 番 目 より 大きい とき 、 <eos>
1751
src = [ print ( A ) for A in range ( 1 , B + 1 ) if C [ A ] == 0 ]
trg = 1 から B に 1 を加えた 値 未 満 までの 数 列 の 各要素 を A とし 、 C の A 番 目 が 0 と 等 しい とき の A を出力する の 列
rst = 1 から B に 1 を加えた 値 未 満 までの 数 列 の 各要素 を A とし 、 C の A 番 目 が 0 と 等 しい とき の A を出力する の 列 <eos>
1752
src = A = E if B and C [ D + 1 ] else 0
trg = B かつ C の D に 1 を加えた 値 番目の とき E 、 そうでなければ 0 を A とする
rst = B かつ C の D に 1 を加えた 値 番目の とき E 、 そうでなければ 0 を A とする <eos>
1753
src = A [ B ] = C = D + E
trg = D に E を加えた 値を C とする を A の B 番 目 にする
rst = D に E を加えた 値を C とする を A の B 番 目 にする <eos>
1754
src = A = ( B [ C + 1 ] , D [ C + 1 ] )
trg = ( B の C に 1 を加えた 値 番 目 、 D の C に 1 を加えた 値 番 目 ) の 組 を A とする
rst = ( B の C に 1 を加えた 値 番 目 、 D の C に 1 を加えた 値 番 目 ) の 組 を A とする <eos>
1755
src = A [ B ] = A [ B ] + C * D
trg = A の B 番 目 に C に D を 掛 け た 値 を加えた 値を A の B 番 目 にする
rst = A の B 番 目 に C に D を 掛 け た 値 を加えた 値を A の B 番 目 にする <eos>
1756
src = print ( trans ( A ) )
trg = trans ( A ) を出力する
rst = <unk> ( A ) を出力する <eos>
1757
src = A . data ^= ( 1 << B ) & A . mask
trg = A の data を 1 を B だけ 左 シフト した 値 と A の mask の 論理 積 と の 排 他 的 論理 和 にする
rst = A の data を 1 を B だけ 左 シフト した 値 と A の mask の 論理 積 と の 排 他 的 論理 和 にする <eos>
1758
src = count += 2
trg = 無限 の 整数 列 を 2 だけ 増加 させる
rst = 無限 の 整数 列 を 2 だけ 増加 させる <eos>
1759
src = print ( * project ( A , B ) )
trg = project ( A , B ) を 展開 して を出力する
rst = project ( A , B ) を 展開 して を出力する <eos>
1760
src = A [ B ] = max ( A [ B ] , A [ C - 1 ] + 1 )
trg = A の B 番 目 、 A の C から 1 を 引 いた 値 番 目 に 1 を加えた 値の 最大 値を A の B 番 目 にする
rst = A の B 番 目 、 A の C から 1 を 引 いた 値 番 目 に 1 を加えた 値の 最大 値を A の B 番 目 にする <eos>
1761
src = if A < 10000000000 :
trg = A が 100 0000 0000 より 小さい とき 、
rst = A が 100 0000 0000 1 より 小さい とき 、 <eos>
1762
src = print ( my_solve ( A ) )
trg = my _ solve ( A ) を出力する
rst = <unk> ( A ) を出力する <eos>
1763
src = A . val = [ A . INF ] * ( 2 * B - 1 )
trg = ( A の INF ) からなる 列 の 2 に B を 掛 け た 値 から 1 を 引 いた 値 回 分 の 列 を A の val にする
rst = ( A の INF ) からなる 列 の 2 に B を 掛 け た 値 から 1 を 引 いた 値 回 分 の 列 を A の val にする <eos>
1764
src = A = [ B for B in range ( 1 , 31 ) ]
trg = 1 から 3 1 未 満 までの 数 列 の 各要素 を B とし 、 B の 列 を A とする
rst = 1 から 3 1 未 満 までの 数 列 の 各要素 を B とし 、 B の 列 を A とする <eos>
1765
src = if A . _size is None :
trg = A の _ size が 、 つまり 未 定 値 と 等 しく ない とき 、
rst = A の _ size が 、 つまり 未 定 値 と 等 しく ない とき 、 <eos>
1766
src = A [ B ] [ 4 ] = sum ( A [ B - 1 ] [ 2 : : 2 ] ) % C
trg = A の B から 1 を 引 いた 値 番目の 2 番 目 から 、 つまり 末 尾 までの 2 間隔 による 部分 列 の 総 和 を C で 割 った 余 り を A の B 番目の 4 番 目 にする
rst = A の B から 1 を 引 いた 値 番目の 2 番 目 から 、 つまり 末 尾 までの 2 間隔 による 部分 列 の 総 和 を C で 割 った 余 り を A の B 番目の 4 番 目 にする <eos>
1767
src = while ( A + 1 ) * B <= C :
trg = A に 1 を加えた 値に B を 掛 け た 値が C 以下の 間 、 次 を 繰り返す
rst = A に 1 を加えた 値に B を 掛 け た 値が C 以下の 間 、 次 を 繰り返す <eos>
1768
src = for A in range ( B + 1 , 2 * C + 1 ) :
trg = B に 1 を加えた 値 から 2 に C を 掛 け た 値に 1 を加えた 値 未 満 までの 数 列 を 順に A として 、 繰り返す
rst = B に 1 を加えた 値 から 2 に C を 掛 け た 値に 1 を加えた 値 未 満 までの 数 列 を 順に A として 、 繰り返す <eos>
1769
src = print ( A if A < B else C )
trg = A が B より 小さい とき A 、 そうでなければ C を出力する
rst = A が B より 小さい とき A 、 そうでなければ C を出力する <eos>
1770
src = for A in topological_sort ( B , C ) :
trg = topological _ sort ( B , C ) を 順に A として 、 繰り返す
rst = topological _ sort ( B , C ) を 順に A として 、 繰り返す <eos>
1771
src = A [ B ] = init ( C * D , E )
trg = init ( C * D , E ) を A の B 番 目 にする
rst = init ( C * D , E ) を A の B 番 目 にする <eos>
1772
src = import _heapq
trg = _ heapq モジュール を用いる
rst = <unk> モジュール を用いる <eos>
1773
src = ino ( A [ B ] [ 2 ] )
trg = ino ( A [ B ] [ 2 ] )
rst = ino ( A [ B ] [ 2 ] ) <eos>
1774
src = [ Point ( x = 1 , y = 3 ) , Point ( x = 1 , y = 4 ) ]
trg = ( Point ( x = 1, y = 3 ) 、 Point ( x = 1, y = 4 ) ) からなる 列
rst = ( Point ( x = 1, y = 3 ) 、 Point ( x = 1 , y = 4 ) ) からなる 列 <eos>
1775
src = A += B [ C [ D : D + 5 ] ]
trg = A を B の C の D 番 目 から D に 5 を加えた 値 までの 部分 列 番 目 だけ 増加 させる
rst = A を B の C の D 番 目 から D に 5 を加えた 値 までの 部分 列 番 目 だけ 増加 させる <eos>
1776
src = A , B , path = C . popleft ( )
trg = C . popleft () を 展開 し 、 それぞれ A 、 B 、 os . path とする
rst = C . popleft () を 展開 し 、 それぞれ A 、 B 、 os . path とする <eos>
1777
src = while A and A [ - 1 ] [ 1 ] <= B :
trg = A かつ A の 末 尾 の 1 番 目 が B 以下の 間 、 次 を 繰り返す
rst = A かつ A の 末 尾 の 1 番 目 が B 以下の 間 、 次 を 繰り返す <eos>
1778
src = if is_dead ( A , B , C ) :
trg = is _ dead ( A , B , C ) の とき 、
rst = <unk> ( A , B , C ) の とき 、 <eos>
1779
src = A [ B [ 0 ] ] = B [ 1 ] * B [ 2 ]
trg = B の 1 番 目 に B の 2 番 目 を 掛 け た 値を A の B の先頭 番 目 にする
rst = B の 1 番 目 に B の 2 番 目 を 掛 け た 値を A の B の先頭 番 目 にする <eos>
1780
src = dfs ( 0 , [ - 1 ] * 26 , [ 0 ] * A )
trg = dfs ( 0 , [ -1 ] * 26 , [ 0 ] * A )
rst = dfs ( 0 , [ -1 ] * 26 , [ 0 ] * A ) <eos>
1781
src = A += calc ( [ B , C - 1 , D , E , F ] ) * G [ 1 ]
trg = A を calc ( [ B , C - 1, D , E , F ] ) に G の 1 番 目 を 掛 け た 値 だけ 増加 させる
rst = A を calc ( [ B , C - 1, D , E , F ] ) に G の 1 番 目 を 掛 け た 値 だけ 増加 させる <eos>
1782
src = A = DoubleLinkedList ( )
trg = DoubleLinkedList () を A とする
rst = <unk> () を A とする <eos>
1783
src = A = 0 if B [ C ] > A else A - B [ C ]
trg = B の C 番 目 が A より 大きい とき 0 、 そうでなければ A から B の C 番 目 を 引 いた 値を A とする
rst = B の C 番 目 が A より 大きい とき 0 、 そうでなければ A から B の C 番 目 を 引 いた 値を A とする <eos>
1784
src = A = [ B [ 0 ] + 2 * C [ 0 ] / 3 , B [ 1 ] + 2 * C [ 1 ] / 3 ]
trg = ( B の 0 番 目 に 2 に C の 0 番 目 を 掛 け た 値を 3 で 割 った 値 を加えた 値 、 B の 1 番 目 に 2 に C の 1 番 目 を 掛 け た 値を 3 で 割 った 値 を加えた 値 ) からなる 列 を A とする
rst = ( B の 0 番 目 に 2 に C の先頭 を 掛 け た 値 を加えた 値を 3 で 割 った 値 、 B の 1 番 目 に 2 に C の 1 番 目 を 掛 け た 値 を加えた 値を 3 で 割 った 値 を加えた
1785
src = if A . mm < 10 :
trg = A の mm が 10 より 小さい とき 、
rst = A の mm が 10 より 小さい とき 、 <eos>
1786
src = if len ( A ) / 7 >= 0.5 :
trg = A の長さ を 7 で 割 った 値が 0.5 以上の とき 、
rst = A の長さ を 7 で 割 った 値が 0.5 以上の とき 、 <eos>
1787
src = if not A [ B ] and C [ D ] [ B ] != - 1 and E [ B ] > C [ D ] [ B ] :
trg = A の B 番 目 で なく かつ C の D 番目の B 番 目 が -1 と 等 しく なく かつ E の B 番 目 が C の D 番目の B 番 目 より 大きい とき 、
rst = A の B 番 目 で なく かつ C の D 番目の B 番 目 が -1 と 等 しく なく かつ E の B 番 目 が C の D 番目の B 番 目 より 大きい とき 、 <eos>
1788
src = A = search ( B , C - 1 , D , E )
trg = C から 1 を 引 いた 値 、 D 、 E において 正規表現 B が 最初 にマッチする 位置 を A とする
rst = C から 1 を 引 いた 値 、 D 、 E において 正規表現 B が 最初 にマッチする 位置 を A とする <eos>
1789
src = A = [ ( B . x , B . y ) ]
trg = ( ( B の x 座標 、 B の y 座標 ) の 組 ) からなる 列 を A とする
rst = ( ( B の x 座標 、 B の y 座標 ) の 組 ) からなる 列 を A とする <eos>
1790
src = A = B [ C + 1 ] [ D ] [ E - 1 ] [ F ] + 1
trg = B の C + 1 番目の D 番目の E から 1 を 引 いた 値 番目の F 番 目 に 1 を加えた 値を A とする
rst = B の C に 1 を加えた 値 番目の D 番目の E から 1 を 引 いた 値 番目の F 番 目 に 1 を加えた 値を A とする <eos>
1791
src = if A [ B + 1 ] == 15 :
trg = A の B に 1 を加えた 値 番 目 が 15 と 等 しい とき 、
rst = A の B に 1 を加えた 値 番 目 が 15 と 等 しい とき 、 <eos>
1792
src = A = [ 0 , 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 ]
trg = ( 0 、 3 1 、 28 、 3 1 、 30 、 3 1 、 30 、 3 1 、 3 1 、 30 、 3 1 、 30 、 3 1 ) からなる 列 を A とする
rst = ( 0 、 3 1 、 28 、 3 1 、 30 、 3 1 、 30 、 3 1 、 3 1 、 30 、 3 1 ) からなる 列 を A とする <eos>
1793
src = if A [ B ] < C and C <= A [ B + 1 ] :
trg = A の B 番 目 が C より 小さく かつ C が A の B に 1 を加えた 値 番 目 以下の とき 、
rst = A の B 番 目 が C より 小さく かつ C が A の B に 1 を加えた 値 番 目 以下の とき 、 <eos>
1794
src = A [ B ] [ C [ 2 * D ] ] = C [ 2 * D + 1 ]
trg = C の 2 に D を 掛 け た 値に 1 を加えた 値 番 目 を A の B 番目の C の 2 に D を 掛 け た 値 番 目 番 目 にする
rst = C の 2 に D を 掛 け た 値に 1 を加えた 値 番 目 を A の B 番目の C の 2 に D を 掛 け た 値 番 目 番 目 にする <eos>
1795
src = print ( A [ - 1 ] [ 0 ] - A [ 0 ] [ 0 ] + 1 , B [ - 1 ] [ 1 ] - B [ 0 ] [ 1 ] + 1 )
trg = A の 末 尾 の 0 番 目 から A の先頭 の先頭 を 引 いた 値に 1 を加えた 値 、 B の 末 尾 の 1 番 目 から B の先頭 の 1 番 目 を 引 いた 値に 1 を加えた 値 を出力する
rst = A の 末 尾 の 0 番 目 から A の 0 番 目 を 引 いた 値に 1 を加えた 値 、 B の 末 尾 の 1 番 目 から B の 0 番 目 を 引 いた 値に 1 を加えた 値 を出力する <eos>
1796
src = if A [ B - 1 ] == 1 and A [ C - 1 ] == 1 :
trg = A の B から 1 を 引 いた 値 番 目 が 1 と 等 しく かつ A の C から 1 を 引 いた 値 番 目 が 1 と 等 しい とき 、
rst = A の B から 1 を 引 いた 値 番 目 が 1 と 等 しく かつ A の C から 1 を 引 いた 値 番 目 が 1 と 等 しい とき 、 <eos>
1797
src = print ( math . floor ( A + 0.5 ) )
trg = A に 0.5 を加えた 値の 切り 捨 て 整数値 を出力する
rst = A に 0.5 を加えた 値の 切り 捨 て 整数値 を出力する <eos>
1798
src = A = A + ( A * 5 ) // 100
trg = A に A に 5 を 掛 け た 値を 100 で 割 った 商 を加えた 値を A とする
rst = A に A に 5 を 掛 け た 値を 100 で 割 った 商 を加えた 値を A とする <eos>
1799
src = if A > 10000 :
trg = A が 1 0000 より 大きい とき 、
rst = A が 1 0000 より 大きい とき 、 <eos>
1800
src = A = [ 0 ] * B
trg = ( 0 ) からなる 列 の B 回 分 の 列 を A とする
rst = ( 0 ) からなる 列 の B 回 分 の 列 を A とする <eos>
1801
src = A = [ Node ( char = B , value = C ) for B , C in D . items ( ) ]
trg = D の キー と 値 の集まり の 各要素 を B 、 C とし 、 Node ( char = B , value = C ) の 列 を A とする
rst = D の キー と 値 の集まり の 各要素 を B 、 C とし 、 Node ( A , B ) の 列 を A とする <eos>
1802
src = if A [ B ] & C [ B ] :
trg = A の B 番 目 と C の B 番目の 論理 積 の とき 、
rst = A の B 番 目 と C の B 番目の 論理 積 の とき 、 <eos>
1803
src = A = - 10000000007
trg = -10 0000 0000 7 を A とする
rst = - 2000 0000 00 を A とする <eos>
1804
src = if A not in [ B , C ] :
trg = A が ( B 、 C ) からなる 列 に 含まれ ない とき 、
rst = A が ( B 、 C ) からなる 列 に 含まれ ない とき 、 <eos>
1805
src = A = [ ( 1 , 1 ) ]
trg = ( ( 1 、 1 ) の 組 ) からなる 列 を A とする
rst = ( ( 1 、 1 ) の 組 ) からなる 列 を A とする <eos>
1806
src = A = B * B + C * C
trg = B に B を 掛 け た 値に C に C を 掛 け た 値 を加えた 値を A とする
rst = B に B を 掛 け た 値に C に C を 掛 け た 値 を加えた 値を A とする <eos>
1807
src = A = B . find
trg = B の先頭 から [MASK] を 探 して 見つかった 位置 を A とする
rst = B の先頭 から [MASK] を 探 して 見つかった 位置 を A とする <eos>
1808
src = A . sort ( key = lambda B : ( len ( B [ 0 ] ) , B [ 0 ] ) )
trg = x を パラメータ として ( B の先頭 の長さ 、 x の先頭 ) の 組 を返す関数 を key として A を ソート する
rst = x を パラメータ として ( x の先頭 の長さ 、 x の先頭 ) の 組 を返す関数 を key として A を ソート する <eos>
1809
src = A [ B ] [ C ] = A [ C ] [ B ] = 1
trg = 1 を A の C 番目の B 番 目 とする を A の B 番目の C 番 目 にする
rst = 1 を A の C 番目の B 番 目 とする を A の B 番目の C 番 目 にする <eos>
1810
src = A = br ( B , B [ C ] + D )
trg = br ( B , B [ C ] + D ) を A とする
rst = br ( B , B [ C ] + D ) を A とする <eos>
1811
src = A = C if B <= 5 else ( D if B <= 10 else ( E if B <= 15 else ( F if B <= 20 else ( G if B <= 25 else H ) ) ) )
trg = B が 5 以下の とき C 、 そうでなければ B が 10 以下の とき D 、 そうでなければ B が 15 以下の とき E 、 そうでなければ B が 20 以下の とき F 、 そうでなければ B < = 25 の とき G 、 そうでなければ H を A とする
rst = B が 5 以下の とき C 、 そうでなければ B が 10 以下の とき D 、 そうでなければ B が 15 以下の とき E 、 そうでなければ B が 20 以下の とき F 、 そうでなければ B < = 25 <unk> ) の とき G 、 そうでなければ H を A とする <eos>
1812
src = delete_node ( A , int ( B [ C ] [ 7 : ] ) )
trg = delete _ node ( A , int ( B [ C ] [ 7 : ] ) )
rst = delete _ node ( A , int ( B [ C ] [ 7 : ] ) ) <eos>
1813
src = A = _remove ( A )
trg = _ remove ( A ) を A とする
rst = _ remove ( A ) を A とする <eos>
1814
src = if A == [ 1 , 4 ] :
trg = A が ( 1 、 4 ) からなる 列 と 等 しい とき 、
rst = A が ( 1 、 4 ) からなる 列 と 等 しい とき 、 <eos>
1815
src = A = B + C [ 2 ]
trg = B に C の 2 番 目 を加えた 値を A とする
rst = B に C の 2 番 目 を加えた 値を A とする <eos>
1816
src = A = [ [ 0 ] * [ B for B in range ( 25 ) ] ]
trg = ( ( 0 ) からなる 列 の 0 から 25 未 満 までの 数 列 の 各要素 を B とし 、 B の 列 回 分 の 列 ) からなる 列 を A とする
rst = ( ( 0 ) からなる 列 の 0 から 25 未 満 までの 数 列 の 各要素 を B とし 、 B の 列 回 分 の 列 ) からなる 列 を A とする <eos>
1817
src = A = func ( B )
trg = func ( B ) を A とする
rst = func ( B ) を A とする <eos>
1818
src = A = { '+' : 0 , '-' : 0 , '/' : 1 , '*' : 1 }
trg = ( ( B , 0 ) 、 ( C , 0 ) 、 ( D , 1 ) 、 ( E , 1 ) ) からなる 辞書 を A とする
rst = ( ( B , 0 ) 、 ( C , 0 ) 、 ( D , 1 ) 、 ( E , 1 ) ) からなる 辞書 を A とする <eos>
1819
src = A . add_edge ( B - 1 , C , 1 , - D )
trg = A . add _ edge ( B - 1, C , 1, - D )
rst = A . add _ edge ( B - 1, C , 1, - D ) <eos>
1820
src = if int ( A ) == 0 :
trg = A の 整数値 が 0 と 等 しい とき 、
rst = A の 整数値 が 0 と 等 しい とき 、 <eos>
1821
src = if A [ B ] > C / 2 :
trg = A の B 番 目 が C を 2 で 割 った 値 より 大きい とき 、
rst = A の B 番 目 が C を 2 で 割 った 値 より 大きい とき 、 <eos>
1822
src = print ( ( datetime . datetime ( A , B , C ) - datetime . datetime ( D , E , F ) ) . days )
trg = A 年 B 月 C 日 の 日 時 から D 年 E 月 F 日 の 日 時 を 引 いた 値の days を出力する
rst = A . datetime から A , B , C ) . datetime . timedelta ( days = D , E , F ) を 引 いた 値の days を出力する <eos>
1823
src = A . append ( dfs ( B , C , D ) )
trg = A の 末 尾 に dfs ( B , C , D ) を追加する
rst = A の 末 尾 に dfs ( B , C , D ) を追加する <eos>
1824
src = print ( A [ B ] [ 2 ] )
trg = A の B 番目の 2 番 目 を出力する
rst = A の B 番目の 2 番 目 を出力する <eos>
1825
src = set_pdt ( A , B , C + 1 )
trg = set _ pdt ( A , B , C + 1 )
rst = <unk> ( A , B , C + 1 ) <eos>
1826
src = A . append ( B [ 1 : : 2 ] )
trg = A の 末 尾 に B の 1 番 目 から 、 つまり 末 尾 までの 2 間隔 による 部分 列 を追加する
rst = A の 末 尾 に B の 1 番 目 から 2 番 目 までの 部分 列 を追加する <eos>
1827
src = if A [ B ] == C and D == E :
trg = A の B 番 目 が C と 等 しく かつ D が E と 等 しい とき 、
rst = A の B 番 目 が C と 等 しく かつ D が E と 等 しい とき 、 <eos>
1828
src = A = complex ( 0 , 1 )
trg = 0 を 実 部 、 1 を 虚 部 とした 複素数 を A とする
rst = 0 を 実 部 、 1 を 虚 部 とした 複素数 を A とする <eos>
1829
src = paint ( A )
trg = paint ( A )
rst = paint ( A ) <eos>
1830
src = A = max ( B ) // C + 1
trg = B の 最大 値を C で 割 った 商 に 1 を加えた 値を A とする
rst = B の 最大 値を C で 割 った 商 に 1 を加えた 値を A とする <eos>
1831
src = A = A . split ( ' ' )
trg = A を 空白 文字 で 分割 した 字句 列 を A とする
rst = A を 空白 文字 で 分割 した 字句 列 を A とする <eos>
1832
src = assert A is not None
trg = A が 、 つまり 未 定 値 と 等 しく なければならない
rst = A が 、 つまり 未 定 値 と 等 しく なければならない <eos>
1833
src = A = B . arg ( )
trg = B . arg () を A とする
rst = B . <unk> () を A とする <eos>
1834
src = print ( ' ' + str ( A [ B ] [ 0 ] ) + C + D . format ( A [ B ] [ 1 ] ) , end = '' )
trg = 改行 せずに 空白 文字 に A [ B ] [ 0 ] の 文字列 を加えた 値に C を加えた 値に D を 書式 として A の B 番目の 1 番 目 で 整 形 した 文字列 を加えた 値 を出力する
rst = 改行 せずに 空白 文字 に A [ B ] [ 0 ] の 文字列 を加えた 値に C を加えた 値に D を加えた 値を 書式 として A の B 番目の 1 番 目 で 整 形 した 文字列 を加えた 値 を出力する <eos>
1835
src = A = [ [ B ] * [ ( C + 1 ) for D in range ( E ) ] ]
trg = ( ( B ) からなる 列 の 0 から E 未 満 までの 数 列 の 各要素 を D とし 、 C に 1 を加えた 値の 列 回 分 の 列 ) からなる 列 を A とする
rst = ( ( B ) からなる 列 の 0 から E 未 満 までの 数 列 の 各要素 を D とし 、 C に 1 を加えた 値の 列 回 分 の 列 ) からなる 列 を A とする <eos>
1836
src = A = ( A + B [ C ] ) % len ( D )
trg = A に B の C 番 目 を加えた 値を D の長さ で 割 った 余 り を A とする
rst = A に B の C 番目の 長さ を加えた 値を D の長さ で 割 った 余 り を A とする <eos>
1837
src = heappush ( A , ( B [ C ] , C ) )
trg = heappush ( A , ( B [ C ] , C ) )
rst = heappush ( A , ( B [ C ] , C ) ) <eos>
1838
src = A . append ( 1 + 3 * A [ - 1 ] )
trg = A の 末 尾 に 1 に 3 に A の 末 尾 を 掛 け た 値 を加えた 値 を追加する
rst = A の 末 尾 に 1 に 3 に A の 末 尾 を 掛 け た 値 を加えた 値 を追加する <eos>
1839
src = A += input ( ) . lower ( )
trg = A を 入力された 文字列を 英 小文字 に変換し た 文字列 だけ 増加 させる
rst = A を 入力された 文字列を 英 小文字 に変換し た 文字列 だけ 増加 させる <eos>
1840
src = print ( sum ( list ( map ( bool , A ) ) ) + 1 )
trg = A の 各要素 に bool を適用した 列 のリスト の 総 和 に 1 を加えた 値 を出力する
rst = A の 各要素 に str を適用した 列 のリスト の 総 和 に 1 を加えた 値 を出力する <eos>
1841
src = sys . exit ( )
trg = プログラムを 正常 終了する
rst = sys . stdin から 読み 込 んだ 一行 <eos>
1842
src = A . p = [ - 1 ] * B
trg = ( -1 ) からなる 列 の B 回 分 の 列 を A の p にする
rst = ( -1 ) からなる 列 の B 回 分 の 列 を A の p にする <eos>
1843
src = A [ B ] [ C ] = A [ B ] . get ( C , 0 ) + e
trg = A の B 番 目 に対応する 値 、 も し 存在 し なければ C 、 0 に ネ イ ピ ア 数 を加えた 値を A の B 番目の C 番 目 にする
rst = A の B 番目の get _ に対応する 値 、 も し 存在 し なければ C 、 0 に ネ イ ピ ア 数 を加えた 値を A の B 番目の C 番 目 にする <eos>
1844
src = A = [ [ 0 ] * [ ( 1 << ( 3 * B ) ) for C in range ( 2 * B + 1 ) ] ]
trg = ( ( 0 ) からなる 列 の 0 から 2 * B に 1 を加えた 値 未 満 までの 数 列 の 各要素 を C とし 、 1 を 3 に B を 掛 け た 値 だけ 左 シフト した 値の 列 回 分 の 列 ) からなる 列 を A とする
rst = ( ( 0 ) からなる 列 の 0 から 2 * B に 1 を加えた 値 未 満 までの 数 列 の 各要素 を C とし 、 1 を 3 に B を 掛 け た 値 だけ 左 シフト した 値の 列 回 分 の 列 ) からなる 列
1845
src = if not - A < B < C + A or not - A < D < C + A :
trg = - A が B より 小さい かどうか が C に A を加えた 値 より 小さく なく または - A が D より 小さい かどうか が C に A を加えた 値 より 小さく ない とき 、
rst = - A が B より 小さい かどうか が C に A を加えた 値 より 小さく なく または - A が D より 小さい かどうか が C に A を加えた 値 より 小さく ない とき 、 <eos>
1846
src = A . _treewalk_preorder ( B . right )
trg = A . _ treewalk _ preorder ( B . right )
rst = A . _ treewalk _ preorder ( B . right ) <eos>
1847
src = E = F [ C ]
trg = F の C 番 目 を E とする
rst = F の C 番 目 を E とする <eos>
1848
src = A [ 6 ] , A [ 7 ] , A [ 8 ] , A [ 21 ] , A [ 22 ] , A [ 23 ] = B [ 21 ] , B [ 22 ] , B [ 23 ] , B [ 6 ] , B [ 7 ] , B [ 8 ]
trg = B の 21 番 目 、 B の 22 番 目 、 B の 23 番 目 、 B の 6 番 目 、 B の 7 番 目 、 B の 8 番 目 を A の 6 番 目 、 A の 7 番 目 、 A の 8 番 目 、 A の 21 番 目 、 A の 22 番 目 、 A の 23 番 目 とする
rst = B の 21 番 目 、 B の 23 番 目 、 B の 8 番 目 、 B の 6 番 目 、 B の 7 番 目 、 B の 8 番 目 を A の 7 番 目 、 A の 8 番 目 、 A の
1849
src = e = [ A - B for B , A in zip ( C , C [ 1 : ] + [ C [ 0 ] ] ) ]
trg = C 、 C の先頭 を 除 いた 部分 列 に ( C の先頭 ) からなる 列 を加えた 値の 要素を それぞれ 組 にした 列 の 各要素 を B 、 A とし 、 A から B を 引 いた 値の 列 を ネ イ ピ ア 数 とする
rst = C 、 C の 1 番 目 から 、 つまり 末 尾 までの 部分 列 、 C の 1 番 目 から 、 つまり 末 尾 までの 部分 列 に ( C の先頭 ) からなる 列 を加えた 値の 要素を それぞれ 組 にした 列 を ネ イ ピ ア 数 とする
1850
src = count = mergeSort ( A , B , C )
trg = mergeSort ( A , B , C ) を 無限 の 整数 列 とする
rst = mergeSort ( A , B , C ) を 無限 の 整数 列 とする <eos>
1851
src = A = B . size
trg = B の size を A とする
rst = B の size を A とする <eos>
1852
src = A [ B ] . add ( coprime ( C , D ) )
trg = A の B 番 目 に coprime ( C , D ) を追加した 集 ま り
rst = A の B 番 目 に coprime ( C , D ) を追加した 集 ま り <eos>
1853
src = A += math . sin ( B ) * C
trg = A を B の 正 弦 に C を 掛 け た 値 だけ 増加 させる
rst = A を B の 正 弦 に C を 掛 け た 値 だけ 増加 させる <eos>
1854
src = A = [ B [ 0 ] + C [ 0 ] / 3 , B [ 1 ] + C [ 1 ] / 3 ]
trg = ( B の 0 番 目 に C の 0 番 目 を 3 で 割 った 値 を加えた 値 、 B の 1 番 目 に C の 1 番 目 を 3 で 割 った 値 を加えた 値 ) からなる 列 を A とする
rst = ( B の 0 番 目 に C の先頭 を 3 で 割 った 値 を加えた 値 、 B の 1 番 目 に C の 1 番 目 を加えた 値を 3 で 割 った 値 ) からなる 列 を A とする <eos>
1855
src = A = vec ( B , C )
trg = vec ( B , C ) を A とする
rst = <unk> ( B , C ) を A とする <eos>
1856
src = if A . is_intersected_with ( B ) :
trg = A . is _ intersected _ with ( B ) の とき 、
rst = A . <unk> ( B ) の とき 、 <eos>
1857
src = print ( A . value , end = '' )
trg = 改行 せずに A の value を出力する
rst = 改行 せずに A の value を出力する <eos>
1858
src = print ( A . format ( chr ( ord ( B ) + C ) , D ) )
trg = A を 書式 として 、 つまり 文字コード B の 順序 数 に C を加えた 値の 文字 、 D で 整 形 した 文字列 を出力する
rst = A を 書式 として 、 つまり 文字コード B の 順序 数 に C を加えた 値の 文字 、 D で 整 形 した 文字列 を出力する <eos>
1859
src = while A + 1 < B and C [ A + 1 ] [ 0 ] <= D :
trg = A に 1 を加えた 値が B より 小さく かつ C の A に 1 を加えた 値 番目の 先頭 が D 以下の 間 、 次 を 繰り返す
rst = A に 1 を加えた 値が B より 小さく かつ C の A に 1 を加えた 値 番目の 0 番 目 が D 以下の 間 、 次 を 繰り返す <eos>
1860
src = A = set ( '' . join ( B ) )
trg = 空文字列 を 間 に 入れ て B を 連結 した 文字列 の集合 を A とする
rst = 空文字列 を 間 に 入れ て B を 連結 した 文字列 の集合 を A とする <eos>
1861
src = A [ B - 1 ] = A [ B - 1 ] + 1
trg = A の B から 1 を 引 いた 値 番 目 に 1 を加えた 値を A の B から 1 を 引 いた 値 番 目 にする
rst = A の B から 1 を 引 いた 値 番 目 に 1 を加えた 値を A の B から 1 を 引 いた 値 番 目 にする <eos>
1862
src = A = B [ C [ D ] [ D ] ]
trg = B の C の D 番目の D 番 目 番 目 を A とする
rst = B の C の D 番目の D 番 目 番 目 を A とする <eos>
1863
src = if len ( A ) > 1 and A [ 0 ] == B :
trg = A の長さ が 1 より 大きく かつ A の 0 番 目 が B と 等 しい とき 、
rst = A の長さ が 1 より 大きく かつ A の 0 番 目 が B と 等 しい とき 、 <eos>
1864
src = if not A . same_check ( e . source , e . target ) :
trg = A . same _ check ( e . source , e . target ) でない とき 、
rst = A . <unk> ( e . source , e . target ) でない とき 、 <eos>
1865
src = A . swim ( len ( A . q ) - 1 )
trg = A . swim ( len ( A . q ) -1 )
rst = A . set _ renew ( A . q ) から 1 を 引 いた 値 <eos>
1866
src = A . sort ( key = lambda B : B [ 3 ] )
trg = x を パラメータ として x の 3 番 目 を返す関数 を key として A を ソート する
rst = x を パラメータ として x の 3 番 目 を返す関数 を key として A を ソート する <eos>
1867
src = A = B [ 1 ] = 2
trg = 2 を B の 1 番 目 とする を A とする
rst = 2 を B の 1 番 目 とする を A とする <eos>
1868
src = A . level [ B ] = 0
trg = 0 を A の level の B 番 目 にする
rst = 0 を A の level の B 番 目 にする <eos>
1869
src = print ( longest_common_subsequence ( A , B ) )
trg = longest _ common _ subsequence ( A , B ) を出力する
rst = <unk> ( A , B ) を出力する <eos>
1870
src = A = max ( [ B [ C ] for C in D ] )
trg = D の 各要素 を C とし 、 B の C 番目の 列 の 最大 値を A とする
rst = D の 各要素 を C とし 、 B の C 番目の 列 の 最大 値を A とする <eos>
1871
src = A -= B [ C - 1 ]
trg = A を B の C から 1 を 引 いた 値 番 目 だけ 減少 させる
rst = A を B の C から 1 を 引 いた 値 番 目 だけ 減少 させる <eos>
1872
src = A . index . append ( B )
trg = A の [MASK] と 等 しい 要素 の最初の 位置 の 末 尾 に B を追加する
rst = A の [MASK] と 等 しい 要素 の最初の 位置 の 末 尾 に B を追加する <eos>
1873
src = A [ B ] = 0.0
trg = 0.0 を A の B 番 目 にする
rst = 0.0 を A の B 番 目 にする <eos>
1874
src = A = index_exsist ( 2 * B )
trg = index _ exsist ( 2 * B ) を A とする
rst = <unk> ( 2 * B ) を A とする <eos>
1875
src = A = ( B [ 0 ] - C [ 0 ] ) * D + ( B [ 1 ] - C [ 1 ] ) * E + C [ 1 ]
trg = B の 0 番 目 から C の先頭 を 引 いた 値に D を 掛 け た 値に B の 1 番 目 から C の 1 番 目 を 引 いた 値に E を 掛 け た 値 を加えた 値に C の 1 番 目 を加えた 値を A とする
rst = B の 0 番 目 から C の先頭 を 引 いた 値に D を 掛 け た 値に B の 1 番 目 から C の 1 番 目 を 引 いた 値に E を 掛 け た 値 を加えた 値を A とする <eos>
1876
src = A . face = [ A . face [ 1 ] , A . face [ 5 ] , A . face [ 2 ] , A . face [ 3 ] , A . face [ 0 ] , A . face [ 4 ] ]
trg = ( A の face の 1 番 目 、 A の face の 5 番 目 、 A の face の 2 番 目 、 A の face の 3 番 目 、 A の face の先頭 、 A の face の 4 番 目 ) からなる 列 を A の face にする
rst = ( A の face の 1 番 目 、 A の face の 5 番 目 、 A の face の 2 番 目 、 A の face の先頭 、 A の face の 4 番 目 、 A の face の 5 番 目 ) からなる 列 を A
1877
src = A . insert ( 0 , [ B ] * ( C + 2 ) )
trg = A の 0 に ( B ) からなる 列 の C に 2 を加えた 値 回 分 の 列 を挿入する
rst = A の 0 に ( B ) からなる 列 の C に 2 を加えた 値 回 分 の 列 を挿入する <eos>
1878
src = A = list ( e )
trg = ネ イ ピ ア 数の リストを A とする
rst = ネ イ ピ ア 数の リストを A とする <eos>
1879
src = A . append ( int ( str ( B [ 1 ] ) + str ( B [ 0 ] ) ) )
trg = A の 末 尾 に B の 1 番目の 文字列 に B の先頭 の 文字列 を加えた 値の 整数値 を追加する
rst = A の 末 尾 に B の 1 番目の 文字列 に B の先頭 の 文字列 を加えた 値の 整数値 を追加する <eos>
1880
src = A = B - 2 if ( B & 1 ) else B - 1
trg = B と 1 の 論理 積 の とき B から 2 を 引 いた 値 、 そうでなければ B から 1 を 引 いた 値を A とする
rst = B と 1 の 論理 積 の とき B から 2 を 引 いた 値 、 そうでなければ B から 1 を 引 いた 値を A とする <eos>
1881
src = return cross ( A - B , C - B ) > 0
trg = cross ( A - B , C - B ) が 0 より 大きい かどうか を返す
rst = cross ( A - B , C - B ) が 0 より 大きい かどうか を返す <eos>
1882
src = [ A . append ( B ) for B in range ( C , D - 1 , - 1 ) ]
trg = C から D から 1 を 引 いた 値 未 満 までの -1 間隔 の 数 列 の 各要素 を B とし 、 A の 末 尾 に B を追加する の 列
rst = C から D から 1 を 引 いた 値 未 満 までの -1 間隔 の 数 列 の 各要素 を B とし 、 A の 末 尾 に B を追加する の 列 <eos>
1883
src = A = Bt ( )
trg = Bt () を A とする
rst = <unk> () を A とする <eos>
1884
src = A += max ( B [ 0 ] - C , 0 )
trg = A を B の 0 番 目 から C を 引 いた 値 、 0 の 最大 値 だけ 増加 させる
rst = A を B の 0 番 目 から C を 引 いた 値 、 0 の 最大 値 だけ 増加 させる <eos>
1885
src = A . heavy [ B ] = C [ B ] [ 1 ]
trg = C の B 番目の 1 番 目 を A の heavy の B 番 目 にする
rst = C の B 番目の 1 番 目 を A の heavy の B 番 目 にする <eos>
1886
src = A [ ( B , C ) ] += 1
trg = A の ( B 、 C ) の 組 番 目 を 1 だけ 増加 させる
rst = A の ( B 、 C ) の 組 番 目 を 1 だけ 増加 させる <eos>
1887
src = A = [ 0 ] * ( max ( B ) + 1 )
trg = ( 0 ) からなる 列 の B の 最大 値に 1 を加えた 値 回 分 の 列 を A とする
rst = ( 0 ) からなる 列 の B の 最大 値に 1 を加えた 値 回 分 の 列 を A とする <eos>
1888
src = for A in range ( 1 , B - C + 2 ) :
trg = 1 から B から C を 引 いた 値に 2 を加えた 値 未 満 までの 数 列 を 順に A として 、 繰り返す
rst = 1 から B から C を 引 いた 値に 2 を加えた 値 未 満 までの 数 列 を 順に A として 、 繰り返す <eos>
1889
src = A = north ( A )
trg = north ( A ) を A とする
rst = north ( A ) を A とする <eos>
1890
src = parse ( 0 )
trg = parse ( 0 )
rst = parse ( 0 ) <eos>
1891
src = count , A = [ int ( B ) for B in input ( ) . split ( ) ]
trg = 入力された 文字列を 空白 で 分割 した 字句 列 の 各要素 を B とし 、 B の 整数値 の 列 を 展開 し 、 それぞれ 、 つまり 無限 の 整数 列 、 A とする
rst = 入力された 文字列を 空白 で 分割 した 字句 列 の 各要素 を B とし 、 B の 整数値 の 列 を 展開 し 、 それぞれ 、 つまり 無限 の 整数 列 、 A とする <eos>
1892
src = A = ord ( B [ 0 ] ) - C
trg = B の先頭 の 順序 数 から C を 引 いた 値を A とする
rst = B の先頭 の 順序 数 から C を 引 いた 値を A とする <eos>
1893
src = A . push_left ( B )
trg = A . push _ left ( B )
rst = A . <unk> ( B ) <eos>
1894
src = A |= ( B << 5 )
trg = A を B を 5 だけ 左 シフト した 値 と の 論理 和 にする
rst = A を B を 5 だけ 左 シフト した 値 と の 論理 和 にする <eos>
1895
src = return { 1 : 1 }
trg = ( ( 1, 1 ) ) からなる 辞書 を返す
rst = ( ( 1, 1 ) ) からなる 辞書 を返す <eos>
1896
src = if A [ B ] + C == A [ D ] :
trg = A の B 番 目 に C を加えた 値が A の D 番 目 と 等 しい とき 、
rst = A の B 番 目 に C を加えた 値が A の D 番 目 と 等 しい とき 、 <eos>
1897
src = print ( [ A , B ] [ ( C * 2 ) . find ( D ) != - 1 ] )
trg = ( A 、 B ) からなる 列 の C に 2 を 掛 け た 値 の先頭 から D を 探 して 見つかった 位置 が -1 と 等 しく ない かどうか 番 目 を出力する
rst = ( A 、 B ) からなる 列 の C に 2 を 掛 け た 値 から D を 探 して 見つかった 位置 が -1 と 等 しく ない かどうか 番 目 を出力する <eos>
1898
src = A , B , C = int ( D ) - 1 , int ( E ) - 1 , int ( F )
trg = D の 整数値 から 1 を 引 いた 値 、 E の 整数値 から 1 を 引 いた 値 、 F の 整数値 を A 、 B 、 C とする
rst = D の 整数値 から 1 を 引 いた 値 、 E の 整数値 から 1 を 引 いた 値 、 F の 整数値 を A 、 B 、 C とする <eos>
1899
src = A . append ( B [ C ] [ D ] + max ( E [ D - 1 ] , E [ D ] ) )
trg = A の 末 尾 に B の C 番目の D 番 目 に E の D から 1 を 引 いた 値 番 目 、 E の D 番目の 最大 値 を加えた 値 を追加する
rst = A の 末 尾 に B の C 番目の D 番 目 に E の D から 1 を 引 いた 値 番 目 、 E の D 番目の 最大 値 を加えた 値 を追加する <eos>
1900
src = if A == 19 and B <= 30 :
trg = A が 19 と 等 しく かつ B が 30 以下の とき 、
rst = A が 19 と 等 しく かつ B が 30 以下の とき 、 <eos>
1901
src = A . append ( [ B , int ( C ) , D ] )
trg = A の 末 尾 に ( B 、 C の 整数値 、 D ) からなる 列 を追加する
rst = A の 末 尾 に ( B 、 C の 整数値 、 D ) からなる 列 を追加する <eos>
1902
src = A , B , C = D . length ( )
trg = D . length () を 展開 し 、 それぞれ A 、 B 、 C とする
rst = D . length () を 展開 し 、 それぞれ A 、 B 、 C とする <eos>
1903
src = print ( dfs ( 0 , A [ 0 ] ) )
trg = dfs ( 0 , A [ 0 ] ) を出力する
rst = dfs ( 0 , A [ 0 ] ) を出力する <eos>
1904
src = A . append ( 10e10 )
trg = A の 末 尾 に 10 e 10 を追加する
rst = A の 末 尾 に 1000 0000 0000 0000 0000 0000 0000 0000 を追加する <eos>
1905
src = A -= B [ C ] * D
trg = A を B の C 番 目 に D を 掛 け た 値 だけ 減少 させる
rst = A を B の C 番 目 に D を 掛 け た 値 だけ 減少 させる <eos>
1906
src = A = B . func ( B . tree [ C ] , A )
trg = B . func ( B . tree [ C ] , A ) を A とする
rst = B . func ( B . tree [ C ] , A ) を A とする <eos>
1907
src = A = [ 20 * 2000 + 1 ]
trg = ( 20 に 2000 を 掛 け た 値に 1 を加えた 値 ) からなる 列 を A とする
rst = ( 20 に 2000 を 掛 け た 値に 1 を加えた 値 ) からなる 列 を A とする <eos>
1908
src = add_parent_node_and_depth ( A , B , C , D + 1 )
trg = add _ parent _ node _ and _ depth ( A , B , C , D + 1 )
rst = <unk> ( A , B , C , D + 1 ) <eos>
1909
src = A = [ B + 1 for B in range ( 10 ) ]
trg = 0 から 10 未 満 までの 数 列 の 各要素 を B とし 、 B に 1 を加えた 値の 列 を A とする
rst = 0 から 10 未 満 までの 数 列 の 各要素 を B とし 、 B に 1 を加えた 値の 列 を A とする <eos>
1910
src = A = [ 3 ** B for B in range ( 21 ) if 2 ** B <= 1000000 ]
trg = 0 から 21 未 満 までの 数 列 の 各要素 を B とし 、 2 の B 乗 が 100 0000 以下の とき の 3 の B 乗 の 列 を A とする
rst = 0 から 21 未 満 までの 数 列 の 各要素 を B とし 、 2 の B 乗 が 100 0000 以下の とき の 3 の B 乗 の 列 を A とする <eos>
1911
src = A = [ [ ( 0 , - 1 ) , ( - 1 , 0 ) , ( 0 , 1 ) ] , [ ( 1 , - 1 ) , ( 2 , 0 ) , ( 1 , 1 ) ] ]
trg = ( ( ( 0 、 -1 ) の 組 、 ( -1 、 0 ) の 組 、 ( 0 、 1 ) の 組 ) からなる 列 、 ( ( 1 、 -1 ) の 組 、 ( 2 、 0 ) の 組 、 ( 1 、 1 ) の 組 ) からなる 列 ) からなる 列 を A とする
rst = ( ( ( 0 、 -1 ) の 組 、 ( -1 、 0 ) の 組 、 ( 0 、 1 ) の 組 、 ( 1 、 1 ) の 組 、 ( 2 、 0 、 1 ) の 組 、 ( 0 、 1 ) の
1912
src = super ( ) . push ( int ( A ) )
trg = super () . push ( int ( A ) )
rst = super () . push ( int ( A ) ) <eos>
1913
src = print ( A , abs ( B ) )
trg = A 、 B の 絶対 値 を出力する
rst = A 、 B の 絶対 値 を出力する <eos>
1914
src = A = B + max ( 0 , C - D ) * E
trg = B に 0 、 C から D を 引 いた 値の 最大 値に E を 掛 け た 値 を加えた 値を A とする
rst = B に 0 、 C から D を 引 いた 値の 最大 値に E を 掛 け た 値 を加えた 値を A とする <eos>
1915
src = A = ( B - C ) . days
trg = B から C を 引 いた 値の days を A とする
rst = B から C を 引 いた 値の days を A とする <eos>
1916
src = A . append ( item ( B , C ) )
trg = A の 末 尾 に item ( B , C ) を追加する
rst = A の 末 尾 に item ( B , C ) を追加する <eos>
1917
src = A = B ** 2 - 4 * C * D
trg = B の 2 乗 から 4 に C を 掛 け た 値に D を 掛 け た 値を 引 いた 値を A とする
rst = B の 2 乗 から 4 に C を 掛 け た 値に D を 掛 け た 値を 引 いた 値を A とする <eos>
1918
src = A , B = [ ] , set ( )
trg = 空 列 、 集合 を A 、 B とする
rst = 空 列 、 集合 を A 、 B とする <eos>
1919
src = A = B // C [ D ] * E [ D ] + ( B % C [ D ] ) // F [ D ] * G [ D ]
trg = B を C の D 番 目 で 割 った 商 に E の D 番 目 を 掛 け た 値に B を C の D 番 目 で 割 った 余 り を F の D 番 目 で 割 った 商 に G の D 番 目 を 掛 け た 値 を加えた 値を A とする
rst = B を C の D 番 目 で 割 った 商 に E の D 番 目 を 掛 け た 値に B を C の D 番 目 で 割 った 余 り に G の D 番 目 を 掛 け た 値 を加えた 値を A とする <eos>
1920
src = A = [ 100000 * 100 + 1 ] * B
trg = ( 10 0000 に 100 を 掛 け た 値に 1 を加えた 値 ) からなる 列 の B 回 分 の 列 を A とする
rst = ( 10 0000 に 100 を 掛 け た 値に 1 を加えた 値 ) からなる 列 の B 回 分 の 列 を A とする <eos>
1921
src = A = fix ( A )
trg = fix ( A ) を A とする
rst = fix ( A ) を A とする <eos>
1922
src = return A - B . size
trg = A から B の size を 引 いた 値を返す
rst = A から B の size を 引 いた 値を返す <eos>
1923
src = A = [ BinaryTreeNode ( ) for B in range ( C ) ]
trg = 0 から C 未 満 までの 数 列 の 各要素 を B とし 、 BinaryTreeNode () の 列 を A とする
rst = 0 から C 未 満 までの 数 列 の 各要素 を B とし 、 BinaryTreeNode () の 列 を A とする <eos>
1924
src = A = [ [ 0 , [ ] ] for B in range ( C ) ]
trg = 0 から C 未 満 までの 数 列 の 各要素 を B とし 、 ( 0 、 空 列 ) からなる 列 の 列 を A とする
rst = 0 から C 未 満 までの 数 列 の 各要素 を B とし 、 ( 0 、 空 列 ) からなる 列 の 列 を A とする <eos>
1925
src = A [ B ] = operator ( C , D , E [ F ] )
trg = operator ( C , D , E [ F ] ) を A の B 番 目 にする
rst = calc _ triangle ( C , D , E [ F ] ) を A の B 番 目 にする <eos>
1926
src = A = int ( B [ 0 ] ) * 1000 + int ( B [ 1 ] ) * 100 + int ( B [ 2 ] ) * 10 + int ( B [ 3 ] )
trg = B [ 0 ] の 整数値 に 1000 を 掛 け た 値に B [ 1 ] の 整数値 に 100 を 掛 け た 値 を加えた 値に B の 2 番目の 整数値 に 10 を 掛 け た 値 を加えた 値に B の 3 番目の 整数値 を加えた 値を A とする
rst = B の先頭 の 整数値 に 1000 を 掛 け た 値に B の 1 番目の 整数値 に 100 を 掛 け た 値 を加えた 値に B の 2 番目の 整数値 に 10 を 掛 け た 値 を加えた 値に B の 3 番目の 整数値 を加えた 値を A とする <eos>
1927
src = A [ B ] = ( C , B )
trg = ( C 、 B ) の 組 を A の B 番 目 にする
rst = ( C 、 B ) の 組 を A の B 番 目 にする <eos>
1928
src = A += B [ - 1 ] - B [ C ]
trg = A を B の -1 番 目 から B の C 番 目 を 引 いた 値 だけ 増加 させる
rst = A を B の 末 尾 から B の C 番 目 を 引 いた 値 だけ 増加 させる <eos>
1929
src = if A [ B ] [ 1 ] <= C [ 1 ] :
trg = A の B 番目の 1 番 目 が C の 1 番 目 以下の とき 、
rst = A の B 番目の 1 番 目 が C の 1 番 目 以下の とき 、 <eos>
1930
src = print ( len ( A . GetConnectedComponents ( ) ) )
trg = A . GetConnectedComponents () の長さ を出力する
rst = A . <unk> () の長さ を出力する <eos>
1931
src = A += list ( B + C . readline ( ) . rstrip ( ) + B )
trg = A を B に C から 読み 込 んだ 一行 の 末 尾 から 空白 改行 を取り 除 いた 文字列 を加えた 値に B を加えた 値 のリスト だけ 増加 させる
rst = A を B に C から 読み 込 んだ 一行 の 末 尾 から 空白 改行 を取り 除 いた 文字列 を加えた 値に B を加えた 値 だけ 増加 させる <eos>
1932
src = A , B = C . diam ( )
trg = C . diam () を 展開 し 、 それぞれ A 、 B とする
rst = C . <unk> () を 展開 し 、 それぞれ A 、 B とする <eos>
1933
src = if A . _is_2node ( B . right ) :
trg = A . _ is _ 2 node ( B . right ) の とき 、
rst = A . minimum ( B . right ) の とき 、 <eos>
1934
src = A . right = insert ( A . right , B , C )
trg = insert ( A . right , B , C ) を A の right にする
rst = insert ( A . right , B , C ) を A の right にする <eos>
1935
src = A [ ( B , 0 ) ] = C
trg = C を A の ( B 、 0 ) の 組 番 目 にする
rst = C を A の ( B 、 0 ) の 組 番 目 にする <eos>
1936
src = A [ B ] . append ( [ C , 0 , - D , len ( A [ C ] ) - 1 ] )
trg = A の B 番目の 末 尾 に ( C 、 0 、 - D 、 A の C 番目の 長さ から 1 を 引 いた 値 ) からなる 列 を追加する
rst = A の B 番目の 末 尾 に ( C 、 0 、 - D 、 A の C 番目の 長さ から 1 を 引 いた 値 ) からなる 列 を追加する <eos>
1937
src = A , B , C , D = e
trg = ネ イ ピ ア 数 を 展開 し 、 それぞれ A 、 B 、 C 、 D とする
rst = ネ イ ピ ア 数 を 展開 し 、 それぞれ A 、 B 、 C 、 D とする <eos>
1938
src = A [ B ] = pow ( 10 , 10 )
trg = 10 の 10 乗 を A の B 番 目 にする
rst = 10 の 10 乗 を A の B 番 目 にする <eos>
1939
src = if A . hldnxt [ B ] is not None :
trg = A の hldnxt の B 番 目 が 、 つまり 未 定 値 と 等 しい とき 、
rst = A の hldnxt の B 番 目 が 、 つまり 未 定 値 と 等 しい とき 、 <eos>
1940
src = A = [ B , C , D , E , F , G , H ] * 2
trg = ( B 、 C 、 D 、 E 、 F 、 G 、 H ) からなる 列 の 2 回 分 の 列 を A とする
rst = ( B 、 C 、 D 、 E 、 F 、 G 、 H ) からなる 列 の 2 回 分 の 列 を A とする <eos>
1941
src = A = [ [ B [ C + 1 ] [ D ] - B [ C ] [ D ] for D in range ( E ) ] for C in range ( F ) ]
trg = 0 から F 未 満 までの 数 列 の 各要素 を C とし 、 0 から E 未 満 までの 数 列 の 各要素 を D とし 、 B の C + 1 番目の D 番 目 から B の C 番目の D 番 目 を 引 いた 値の 列 の 列 を A とする
rst = 0 から F 未 満 までの 数 列 の 各要素 を C とし 、 0 から E 未 満 までの 数 列 の 各要素 を D とし 、 B の C に 1 を加えた 値 番目の D 番 目 から B の C 番目の D 番 目 を 引 いた
1942
src = if A . E [ e . to ] [ e . rev ] . cap == 1 :
trg = A の E の e の to 番目の 、 つまり ネ イ ピ ア 数の rev 番目の cap が 1 と 等 しい とき 、
rst = A の E の 、 つまり ネ イ ピ ア 数の to 番目の 、 つまり ネ イ ピ ア 数の rev 番目の cap が 1 と 等 しい とき 、 <eos>
1943
src = A = [ [ 0 for B in range ( 10 ) ] for B in range ( 10 ) ]
trg = 0 から 10 未 満 までの 数 列 の 各要素 を B とし 、 0 から 10 未 満 までの 数 列 の 各要素 を B とし 、 0 の 列 の 列 を A とする
rst = 0 から 10 未 満 までの 数 列 の 各要素 を B とし 、 0 から 10 未 満 までの 数 列 の 各要素 を B とし 、 0 の 列 の 列 を A とする <eos>
1944
src = A = ( B , 0 , C , D , E )
trg = ( B 、 0 、 C 、 D 、 E ) の 組 を A とする
rst = ( B 、 0 、 C 、 D 、 E ) の 組 を A とする <eos>
1945
src = if root ( A ) == root ( B ) :
trg = root ( A ) が root ( B ) と 等 しい とき 、
rst = root ( A ) が root ( B ) と 等 しい とき 、 <eos>
1946
src = A = ( B - C ) * ( 1 / 3 ) + C
trg = B から C を 引 いた 値に 1 を 3 で 割 った 値を 掛 け た 値に C を加えた 値を A とする
rst = B から C を 引 いた 値に 1 を 3 で 割 った 値を 掛 け た 値に C を加えた 値を A とする <eos>
1947
src = combi ( 2 )
trg = combi ( 2 )
rst = combi ( 2 ) <eos>
1948
src = A = ' ' . join ( [ str ( B ) for B in C [ D + 1 : E ] ] )
trg = 空白 文字 を 間 に 入れ て C の D に 1 を加えた 値 から E 番 目 までの 部分 列 の 各要素 を B とし 、 B の 文字列 の 列 を 連結 した 文字列を A とする
rst = 空白 文字 を 間 に 入れ て C の D に 1 を加えた 値 から E 番 目 までの 部分 列 の 各要素 を B とし 、 B の 文字列 の 列 を 連結 した 文字列を A とする <eos>
1949
src = A = [ B + 1 for B in range ( 2000 ) ]
trg = 0 から 2000 未 満 までの 数 列 の 各要素 を B とし 、 B に 1 を加えた 値の 列 を A とする
rst = 0 から 2000 未 満 までの 数 列 の 各要素 を B とし 、 B に 1 を加えた 値の 列 を A とする <eos>
1950
src = A . append ( str ( query ( B , C + 1 ) ) )
trg = A の 末 尾 に query ( B , C + 1 ) の 文字列 を追加する
rst = A の 末 尾 に query ( B , C + 1 ) の 文字列 を追加する <eos>
1951
src = if abs ( ( A - B ) / ( C - D ) * ( E - F ) / ( G - H ) + 1 ) < 0.0000001 :
trg = ( A - B ) / ( C - D ) に ( E - F ) を 掛 け た 値を G から H を 引 いた 値 で 割 った 値に 1 を加えた 値の 絶対 値が 0.0 0000 01 より 小さい とき 、
rst = A から B を 引 いた 値を C から D を 引 いた 値 で 割 った 値に E から F を 引 いた 値を 掛 け た 値を G から H を 引 いた 値 で 割 った 値に 1 を加えた 値の 絶対 値が 1 より 小さい とき 、
1952
src = A = B ** 0.5
trg = B の 0.5 乗 を A とする
rst = B の 0.5 乗 を A とする <eos>
1953
src = A = calc_d ( B [ C ] , B [ C + 1 ] )
trg = calc _ d ( B [ C ] , B [ C + 1 ] ) を A とする
rst = calc _ a ( B [ C ] , B [ C + 1 ] ) を A とする <eos>
1954
src = print ( search ( ) )
trg = [MASK] において 正規表現 [MASK] が 最初 にマッチする 位置 を出力する
rst = [MASK] において 正規表現 [MASK] が 最初 にマッチする 位置 を出力する <eos>
1955
src = return [ 7 ]
trg = ( 7 ) からなる 列 を返す
rst = ( 7 ) からなる 列 を返す <eos>
1956
src = if A and B == C :
trg = A かつ B が C と 等 しい とき 、
rst = A かつ B が C と 等 しい とき 、 <eos>
1957
src = for A in sorted ( B ^ C ) :
trg = B と C の 排 他 論理 和 を ソート した 列 を 順に A として 、 繰り返す
rst = B と C の 排 他 論理 和 を ソート した 列 を 順に A として 、 繰り返す <eos>
1958
src = swap ( A , B )
trg = swap ( A , B )
rst = swap ( A , B ) <eos>
1959
src = print ( calc ( lambda A , B : C [ A ] [ B ] , D , E ) + calc ( lambda A , B : C [ B ] [ A ] , E , D ) )
trg = calc ( lambdaA , B : C [ A ] [ B ] , D , E ) に calc ( lambdaA , B : C [ B ] [ A ] , E , D ) を加えた 値 を出力する
rst = calc ( A , B , D , E ) に calc ( A [ B ] , D , E ) を加えた 値に calc ( A [ B : C ] , A [ B ] , D ] ) を加えた 値 を出力する <eos>
1960
src = A += cross ( B , C ) / 2
trg = A を cross ( B , C ) を 2 で 割 った 値 だけ 増加 させる
rst = A を cross ( B , C ) を 2 で 割 った 値 だけ 増加 させる <eos>
1961
src = A , path = augment_path ( )
trg = augment _ path () を 展開 し 、 それぞれ A 、 os . path とする
rst = <unk> () を 展開 し 、 それぞれ A 、 os . path とする <eos>
1962
src = for A , B in list ( itertools . combinations ( C , 2 ) ) :
trg = C の 2 個 までの コン ビ ネ ー ション の リストを 順に A 、 B として 、 繰り返す
rst = C の 2 個 までの コン ビ ネ ー ション の リストを 順に A 、 B として 、 繰り返す <eos>
1963
src = A = SSST ( B )
trg = SSST ( B ) を A とする
rst = <unk> ( B ) を A とする <eos>
1964
src = A . size = 2 ** B - 1
trg = 2 の B 乗 から 1 を 引 いた 値を A の size にする
rst = 2 の B 乗 から 1 を 引 いた 値を A の size にする <eos>
1965
src = A = set ( range ( B ) ) - C
trg = 0 から B 未 満 までの 数 列 の集合 から C を 引 いた 値を A とする
rst = 0 から B 未 満 までの 数 列 の集合 から C を 引 いた 値を A とする <eos>
1966
src = A . idx = { }
trg = 空 辞書 を A の idx にする
rst = 空 辞書 を A の idx にする <eos>
1967
src = A = ( B * C + D * E ) * F
trg = B に C を 掛 け た 値に D に E を 掛 け た 値 を加えた 値に F を 掛 け た 値を A とする
rst = B に C を 掛 け た 値に D に E を 掛 け た 値 を加えた 値に F を 掛 け た 値を A とする <eos>
1968
src = if 0 <= A < B . x and 0 <= C < B . y :
trg = 0 が A 以下 かどうか が B の x 座標 より 小さく かつ 0 が C 以下 かどうか が B の y 座標 より 小さい とき 、
rst = 0 が A 以下 かどうか が B の x 座標 より 小さく かつ 0 が C 以下 かどうか が B の y 座標 より 小さい とき 、 <eos>
1969
src = for A in permutations ( range ( 1 , B ) ) :
trg = 1 から B 未 満 までの 数 列 の 順 列 を 順に A として 、 繰り返す
rst = 1 から B 未 満 までの 数 列 の 順 列 を 順に A として 、 繰り返す <eos>
1970
src = A = math . floor ( math . sqrt ( B ) ) + 1
trg = B の 平 方 根 の 切り 捨 て 整数値 に 1 を加えた 値を A とする
rst = B の 平 方 根 の 切り 捨 て 整数値 に 1 を加えた 値を A とする <eos>
1971
src = if A % 7 == 3 :
trg = A を 7 で 割 った 余 り が 3 と 等 しい とき 、
rst = A を 7 で 割 った 余 り が 3 と 等 しい とき 、 <eos>
1972
src = A = int ( B )
trg = B の 整数値 を A とする
rst = B の 整数値 を A とする <eos>
1973
src = print ( count [ A ] [ B ] , count [ A ] [ C ] )
trg = 無限 の 整数 列 の A 番目の B 番 目 、 無限 の 整数 列 の A 番目の C 番 目 を出力する
rst = 無限 の 整数 列 の A 番目の B 番 目 、 無限 の 整数 列 の A 番目の C 番 目 を出力する <eos>
1974
src = print ( A * math . sin ( B / A ) * math . cos ( C * B / A ) / math . cos ( ( C - 1 ) * B / A ) )
trg = A に B / A の 正 弦 を 掛 け た 値に C * B を A で 割 った 値の 余 弦 を 掛 け た 値を ( C -1 ) に B を 掛 け た 値を A で 割 った 値の 余 弦 で 割 った 値 を出力する
rst = A に B を 掛 け た 値を A で 割 った 値の 正 弦 に C に B を 掛 け た 値を A で 割 った 値の 余 弦 を 掛 け た 値を A で 割 った 値を B で 割 った 値の 余 弦 に A
1975
src = A = math . ceil ( B / ( C + 1 ) )
trg = B を C に 1 を加えた 値 で 割 った 値の 切り 上げ 整数値 を A とする
rst = B を C に 1 を加えた 値 で 割 った 値の 切り 上げ 整数値 を A とする <eos>
1976
src = A [ B ] . append ( ( C [ D ] , C [ D + 1 ] ) )
trg = A の B 番目の 末 尾 に ( C の D 番 目 、 C の D に 1 を加えた 値 番 目 ) の 組 を追加する
rst = A の B 番目の 末 尾 に ( C の D 番 目 、 C の D に 1 を加えた 値 番 目 ) の 組 を追加する <eos>
1977
src = A += sum ( B [ : C ] )
trg = A を B の 、 つまり 先頭 から C 番 目 までの 部分 列 の 総 和 だけ 増加 させる
rst = A を B の 、 つまり 先頭 から C 番 目 までの 部分 列 の 総 和 だけ 増加 させる <eos>
1978
src = if A [ B - 1 ] or A [ C - 1 ] :
trg = A の B から 1 を 引 いた 値 番 目 または A の C から 1 を 引 いた 値 番目の とき 、
rst = A の B から 1 を 引 いた 値 番 目 または A の C から 1 を 引 いた 値 番目の とき 、 <eos>
1979
src = if A != B + 1 :
trg = A が B に 1 を加えた 値 と 等 しく ない とき 、
rst = A が B に 1 を加えた 値 と 等 しく ない とき 、 <eos>
1980
src = while A not in B :
trg = A が B に 含まれ ない 間 、 次 を 繰り返す
rst = A が B に 含まれ ない 間 、 次 を 繰り返す <eos>
1981
src = A = [ B for B in range ( 1 , 14 ) ]
trg = 1 から 14 未 満 までの 数 列 の 各要素 を B とし 、 B の 列 を A とする
rst = 1 から 14 未 満 までの 数 列 の 各要素 を B とし 、 B の 列 を A とする <eos>
1982
src = print ( ( A + B ) // 2 )
trg = A に B を加えた 値を 2 で 割 った 商 を出力する
rst = A に B を加えた 値を 2 で 割 った 商 を出力する <eos>
1983
src = A = 10 ** 6
trg = 10 の 6 乗 を A とする
rst = 10 の 6 乗 を A とする <eos>
1984
src = if 0 <= A <= 9 :
trg = 0 が A 以下 かどうか が 9 以下の とき 、
rst = 0 が A 以下 かどうか が 9 以下の とき 、 <eos>
1985
src = A . negativeCycle = True
trg = 真 を A の negativeCycle にする
rst = 真 を A の negativeCycle にする <eos>
1986
src = A += dfs ( B + 1 , C // 10 )
trg = A を dfs ( B + 1, C / / 10 ) だけ 増加 させる
rst = A を dfs ( B + 1, C / 10 ) だけ 増加 させる <eos>
1987
src = for A in range ( bisect_left ( B , C ) , bisect_right ( B , D ) ) :
trg = ソート された 順序 を 保 った まま C を B に 挿入 できる 位置 から 、 つまり ソート された 順序 を 保 った まま D を B に 挿入 できる 最後の 位置 未 満 までの 数 列 を 順に A として 、 繰り返す
rst = ソート された 順序 を 保 った まま C を B に 挿入 できる 位置 から 、 つまり ソート された 順序 を 保 った まま D を B に 挿入 できる 最後の 位置 未 満 までの 数 列 を 順に A として 、 繰り返す <eos>
1988
src = A = ( B [ C ] - B [ D + 1 ] ) + ( E [ D ] - F )
trg = B の C 番 目 から B の D に 1 を加えた 値 番 目 を 引 いた 値に E の D 番 目 から F を 引 いた 値 を加えた 値を A とする
rst = B の C 番 目 から B の D に 1 を加えた 値 番 目 を 引 いた 値に E の D 番 目 から F を 引 いた 値 を加えた 値を A とする <eos>
1989
src = if A > 1 and B [ A - 2 ] [ C ] == D :
trg = A が 1 より 大きく かつ B の A から 2 を 引 いた 値 番目の C 番 目 が D と 等 しい とき 、
rst = A が 1 より 大きく かつ B の A から 2 を 引 いた 値 番目の C 番 目 が D と 等 しい とき 、 <eos>
1990
src = A = 400
trg = 400 を A とする
rst = 400 を A とする <eos>
1991
src = A = B * 7
trg = B に 7 を 掛 け た 値を A とする
rst = B に 7 を 掛 け た 値を A とする <eos>
1992
src = A . inv [ B ] = A . inv [ B + 1 ] * ( B + 1 ) % C
trg = A の inv の B に 1 を加えた 値 番 目 に B に 1 を加えた 値を 掛 け た 値を C で 割 った 余 り を A の inv の B 番 目 にする
rst = A の inv の B に 1 を加えた 値 番 目 に B に 1 を加えた 値を 掛 け た 値を C で 割 った 余 り を A の inv の B 番 目 にする <eos>
1993
src = A = B // 10 - C * 100 - D * 10
trg = B を 10 で 割 った 商 から C に 100 を 掛 け た 値を 引 いた 値 から D に 10 を 掛 け た 値を 引 いた 値を A とする
rst = B を 10 で 割 った 商 から C に 100 を 掛 け た 値を 引 いた 値 から D に 10 を 掛 け た 値を 引 いた 値を A とする <eos>
1994
src = A [ 0 ] [ 0 ] = B
trg = B を A の先頭 の先頭 にする
rst = B を A の先頭 の 0 番 目 にする <eos>
1995
src = if not dfs ( 0 , A , 0 ) :
trg = dfs ( 0 , A , 0 ) でない とき 、
rst = dfs ( 0 , A , 0 ) でない とき 、 <eos>
1996
src = for A in range ( B // 1200 + 1 ) :
trg = 0 から B を 1 200 で 割 った 商 に 1 を加えた 値 未 満 までの 数 列 を 順に A として 、 繰り返す
rst = 0 から B を 1 200 で 割 った 商 に 1 を加えた 値 未 満 までの 数 列 を 順に A として 、 繰り返す <eos>
1997
src = return math . radians ( A )
trg = A の ラ ジ アン を返す
rst = A の ラ ジ アン を返す <eos>
1998
src = A , B = erase ( A , B , C [ 1 ] )
trg = erase ( A , B , C [ 1 ] ) を 展開 し 、 それぞれ A 、 B とする
rst = erase ( A , B , C [ 1 ] ) を 展開 し 、 それぞれ A 、 B とする <eos>
1999
src = A . append ( max ( B . dist ( C , D ) , B . dist ( E , D ) ) )
trg = A の 末 尾 に B . dist ( C , D ) 、 B . dist ( E , D ) の 最大 値 を追加する
rst = A の 末 尾 に B . dist ( C , D ) 、 B . dist ( E , D ) の 最大 値 を追加する <eos>
2000
src = return A . root [ B ]
trg = A の root の B 番 目 を返す
rst = A の root の B 番 目 を返す <eos>
2001
src = A [ 6 ] , A [ 29 ] = A [ 29 ] , A [ 6 ]
trg = A の 29 番 目 、 A の 6 番 目 を A の 6 番 目 、 A の 29 番 目 とする
rst = A の 29 番 目 、 A の 6 番 目 を A の 6 番 目 、 A の 29 番 目 とする <eos>
2002
src = A . add ( B )
trg = A に B を追加した 集 ま り
rst = A に B を追加した 集 ま り <eos>
2003
src = e = A + B
trg = A に B を加えた 値を ネ イ ピ ア 数 とする
rst = A に B を加えた 値を ネ イ ピ ア 数 とする <eos>
2004
src = A [ int ( input ( ) ) - 1 ] += 1
trg = A の 、 つまり 入力された 文字列 の 整数値 から 1 を 引 いた 値 番 目 を 1 だけ 増加 させる
rst = A の 、 つまり 入力された 文字列 の 整数値 から 1 を 引 いた 値 番 目 を 1 だけ 増加 させる <eos>
2005
src = for A in B . edge :
trg = B の edge を 順に A として 、 繰り返す
rst = B の edge を 順に A として 、 繰り返す <eos>
2006
src = while A [ B ] == 0 :
trg = A の B 番 目 が 0 と 等 しい 間 、 次 を 繰り返す
rst = A の B 番 目 が 0 と 等 しい 間 、 次 を 繰り返す <eos>
2007
src = A = [ [ 10 ** 18 ] * [ ( B + 1 ) for C in range ( D + 1 ) ] ]
trg = ( ( 10 の 18 乗 ) からなる 列 の 0 から D に 1 を加えた 値 未 満 までの 数 列 の 各要素 を C とし 、 B に 1 を加えた 値の 列 回 分 の 列 ) からなる 列 を A とする
rst = ( ( 10 の 18 乗 ) からなる 列 の 0 から D に 1 を加えた 値 未 満 までの 数 列 の 各要素 を C とし 、 B に 1 を加えた 値の 列 回 分 の 列 ) からなる 列 を A とする <eos>
2008
src = A = B / ( 0.5 * C )
trg = B を 0.5 に C を 掛 け た 値 で 割 った 値を A とする
rst = B を 0.5 に C を 掛 け た 値 で 割 った 値を A とする <eos>
2009
src = A [ B [ e ] ] = e
trg = ネ イ ピ ア 数 を A の B の 、 つまり ネ イ ピ ア 数 番 目 番 目 にする
rst = ネ イ ピ ア 数 を A の B の 、 つまり ネ イ ピ ア 数 番 目 番 目 にする <eos>
2010
src = while A != 0 or B != 0 :
trg = A が 0 と 等 しく なく または B が 0 と 等 しく ない 間 、 次 を 繰り返す
rst = A が 0 と 等 しく なく または B が 0 と 等 しく ない 間 、 次 を 繰り返す <eos>
2011
src = A = B // _pow ( 10 , 32 )
trg = B を _ pow ( 10 , 32 ) で 割 った 商 を A とする
rst = B を _ pow ( 10 , 32 ) で 割 った 商 を A とする <eos>
2012
src = A [ B - 1 ] += C [ 0 ]
trg = A の B から 1 を 引 いた 値 番 目 を C の先頭 だけ 増加 させる
rst = A の B から 1 を 引 いた 値 番 目 を C の先頭 だけ 増加 させる <eos>
2013
src = add ( A , B [ 0 ] , B [ 2 ] )
trg = add ( A , B [ 0 ] , B [ 2 ] )
rst = add ( A , B [ 0 ] , B [ 2 ] ) <eos>
2014
src = for A in B . split ( C ) :
trg = B を C で 分割 した 字句 列 を 順に A として 、 繰り返す
rst = B を C で 分割 した 字句 列 を 順に A として 、 繰り返す <eos>
2015
src = A = [ 0 , 0 , 0 , 0 ]
trg = ( 0 、 0 、 0 、 0 ) からなる 列 を A とする
rst = ( 0 、 0 、 0 、 0 ) からなる 列 を A とする <eos>
2016
src = A = abs ( ( ( B ) ** 2 + ( C - B ) ** 2 ) ** 0.5 - e )
trg = ( B ) の 2 乗 に ( C - B ) の 2 乗 を加えた 値の 0.5 乗 から 、 つまり ネ イ ピ ア 数 を 引 いた 値の 絶対 値を A とする
rst = B の 絶対 値の 2 乗 に C から B を 引 いた 値の 2 乗 を加えた 値の 絶対 値の - 、 つまり ネ イ ピ ア 数 を A とする <eos>
2017
src = for A in range ( 7 , 10 ) :
trg = 7 から 10 未 満 までの 数 列 を 順に A として 、 繰り返す
rst = 7 から 10 未 満 までの 数 列 を 順に A として 、 繰り返す <eos>
2018
src = if comp ( A , B ) < 0 :
trg = comp ( A , B ) が 0 より 小さい とき 、
rst = loadable _ <unk> ( A , B ) が 0 より 小さい とき 、 <eos>
2019
src = A = A * int ( input ( ) )
trg = A に 入力された 文字列 の 整数値 を 掛 け た 値を A とする
rst = A に 入力された 文字列 の 整数値 を 掛 け た 値を A とする <eos>
2020
src = A . data = [ B ] * ( A . size * 2 + 2 )
trg = ( B ) からなる 列 の A の size に 2 を 掛 け た 値に 2 を加えた 値 回 分 の 列 を A の data にする
rst = ( B ) からなる 列 の A の size に 2 を 掛 け た 値に 2 を加えた 値 回 分 の 列 を A の data にする <eos>
2021
src = if int ( A [ 1 ] ) <= B :
trg = A の 1 番目の 整数値 が B 以下の とき 、
rst = A の 1 番目の 整数値 が B 以下の とき 、 <eos>
2022
src = A [ B - C + 1 ] = D
trg = D を A の B から C を 引 いた 値に 1 を加えた 値 番 目 にする
rst = D を A の B から C を 引 いた 値に 1 を加えた 値 番 目 にする <eos>
2023
src = print ( ' ' . join ( map ( str , A ) ) , B )
trg = 空白 文字 を 間 に 入れ て A の 各要素 に 整数 を適用した 列 を 連結 した 文字列 、 B を出力する
rst = 空白 文字 を 間 に 入れ て A の 各要素 に 整数 を適用した 列 を 連結 した 文字列 、 B を出力する <eos>
2024
src = A [ 4 ] = B % 20
trg = B を 20 で 割 った 余 り を A の 4 番 目 にする
rst = B を 20 で 割 った 余 り を A の 4 番 目 にする <eos>
2025
src = write ( '' . join ( A [ B : ] ) )
trg = write ( ' ' . join ( A [ B : ] ) )
rst = write ( ' ' . join ( A [ B : ] ) ) <eos>
2026
src = print ( 8 * ( A + B ) )
trg = 8 に A に B を加えた 値を 掛 け た 値 を出力する
rst = 8 に A に B を加えた 値を 掛 け た 値 を出力する <eos>
2027
src = A += ( 0 - 3 ) * B
trg = A を 0 から 3 を 引 いた 値に B を 掛 け た 値 だけ 増加 させる
rst = A を 0 から 3 を 引 いた 値に B を 掛 け た 値 だけ 増加 させる <eos>
2028
src = A = min ( A , ( sum ( B . distance [ C ] ) , C ) )
trg = A 、 ( B の distance の C 番目の 総 和 、 C ) の 組 の 最小 値を A とする
rst = A 、 B の distance の C 番目の 総 和 、 C の 最小 値を A とする <eos>
2029
src = A = B = new_node ( int ( readline ( ) ) )
trg = new _ node ( int ( readline () ) ) を B とする を A とする
rst = new _ node ( int ( readline () ) ) を B とする を A とする <eos>
2030
src = A = [ [ B + C for C in range ( len ( D ) + 1 ) ] for B in range ( len ( E ) + 1 ) ]
trg = 0 から E の長さ に 1 を加えた 値 未 満 までの 数 列 の 各要素 を B とし 、 0 から D の長さ に 1 を加えた 値 未 満 までの 数 列 の 各要素 を C とし 、 B に C を加えた 値の 列 の 列 を A とする
rst = 0 から E の長さ に 1 を加えた 値 未 満 までの 数 列 の 各要素 を B とし 、 0 から D の長さ に 1 を加えた 値 未 満 までの 数 列 の 各要素 を C とし 、 B に C を加えた 値の 列 の 列 を A とする <eos>
2031
src = if A [ len ( A ) - 1 ] > 0 and B [ C ] > 0 :
trg = A の A の長さ から 1 を 引 いた 値 番 目 が 0 より 大きく かつ B の C 番 目 が 0 より 大きい とき 、
rst = A の A の長さ から 1 を 引 いた 値 番 目 が 0 より 大きく かつ B の C 番 目 が 0 より 大きい とき 、 <eos>
2032
src = A . appendleft ( B )
trg = A の 先頭に B を追加する
rst = A の 先頭に B を追加する <eos>
2033
src = A = ( ( 0 , - 1 ) , ( 1 , - 1 ) , ( 1 , 0 ) , ( 1 , 1 ) , ( 0 , 1 ) , ( - 1 , 0 ) )
trg = ( ( 0 、 -1 ) の 組 、 ( 1 、 -1 ) の 組 、 ( 1 、 0 ) の 組 、 ( 1 、 1 ) の 組 、 ( 0 、 1 ) の 組 、 ( -1 、 0 ) の 組 ) の 組 を A とする
rst = ( ( 0 、 -1 ) の 組 、 ( 1 、 -1 ) の 組 、 ( 1 、 0 ) の 組 、 ( 0 、 1 ) の 組 、 ( 0 、 1 ) の 組 、 ( 0 、 -1 ) の 組 ) の
2034
src = return A . color == B . BLACK
trg = A の color が B の BLACK と 等 しい かどうか を返す
rst = A の color が B の BLACK と 等 しい かどうか を返す <eos>
2035
src = if A != B and C [ A ] == D - C [ E ] :
trg = A が B と 等 しく なく かつ C の A 番 目 が D から C の E 番 目 を 引 いた 値 と 等 しい とき 、
rst = A が B と 等 しく なく かつ C の A 番 目 が D から C の E 番 目 を 引 いた 値 と 等 しい とき 、 <eos>
2036
src = A = A * ( B [ C - D + E + F + G - 1 ] * H [ C - D ] % I ) % I
trg = A に B の C - D + E + F + G -1 番 目 に H の C - D 番 目 を 掛 け た 値を I で 割 った 余 り を 掛 け た 値を I で 割 った 余 り を A とする
rst = A に B の C - D + E に F を加えた 値に G を加えた 値 から 1 を 引 いた 値を 掛 け た 値を H で 割 った 余 り を I で 割 った 余 り を A とする <eos>
2037
src = if root ( A ) == A :
trg = root ( A ) が A と 等 しい とき 、
rst = root ( A ) が A と 等 しい とき 、 <eos>
2038
src = now = A
trg = A を 現在の 日 時 とする
rst = A を 現在の 日 時 とする <eos>
2039
src = A += B [ C + 1 ] - B [ C ] - 2 * D
trg = A を B の C に 1 を加えた 値 番 目 から B の C 番 目 を 引 いた 値 から 2 に D を 掛 け た 値を 引 いた 値 だけ 増加 させる
rst = A を B の C に 1 を加えた 値 番 目 から B の C 番 目 を 引 いた 値 から 2 に D を 掛 け た 値を 引 いた 値 だけ 増加 させる <eos>
2040
src = A = B [ C : C + len ( D ) ]
trg = B の C 番 目 から C に D の長さ を加えた 値 までの 部分 列 を A とする
rst = B の C 番 目 から C に D の長さ を加えた 値 までの 部分 列 を A とする <eos>
2041
src = A , B , C = [ int ( D ) for D in E . split ( ) ]
trg = E を 空白 で 分割 した 字句 列 の 各要素 を D とし 、 D の 整数値 の 列 を 展開 し 、 それぞれ A 、 B 、 C とする
rst = E を 空白 で 分割 した 字句 列 の 各要素 を D とし 、 D の 整数値 の 列 を 展開 し 、 それぞれ A 、 B 、 C とする <eos>
2042
src = A , B = C . root ( D ) , C . root ( E )
trg = C . root ( D ) 、 C . root ( E ) を A 、 B とする
rst = C . root ( D ) 、 C . root ( E ) を A 、 B とする <eos>
2043
src = if A [ B - 1 ] [ C - 1 ] == 1 :
trg = A の B から 1 を 引 いた 値 番目の C から 1 を 引 いた 値 番 目 が 1 と 等 しい とき 、
rst = A の B から 1 を 引 いた 値 番目の C から 1 を 引 いた 値 番 目 が 1 と 等 しい とき 、 <eos>
2044
src = if A [ B ] [ C ] < D :
trg = A の B 番目の C 番 目 が D より 小さい とき 、
rst = A の B 番目の C 番 目 が D より 小さい とき 、 <eos>
2045
src = A += ( postorder ( B [ C ] [ 1 ] ) )
trg = A を postorder ( B [ C ] [ 1 ] ) だけ 増加 させる
rst = A を postorder ( B [ C ] [ 1 ] ) だけ 増加 させる <eos>
2046
src = A = [ [ None ] * [ 20 for B in range ( C ) ] ]
trg = ( ( 、 つまり 未 定 値 ) からなる 列 の 0 から C 未 満 までの 数 列 の 各要素 を B とし 、 20 の 列 回 分 の 列 ) からなる 列 を A とする
rst = ( ( 、 つまり 未 定 値 ) からなる 列 の 0 から C 未 満 までの 数 列 の 各要素 を B とし 、 20 の 列 回 分 の 列 ) からなる 列 を A とする <eos>
2047
src = return A [ B - 1 ] [ C ]
trg = A の B から 1 を 引 いた 値 番目の C 番 目 を返す
rst = A の B から 1 を 引 いた 値 番目の C 番 目 を返す <eos>
2048
src = A = B . format ( C + 1 , D [ C ] )
trg = B を 書式 として C に 1 を加えた 値 、 D の C 番 目 で 整 形 した 文字列を A とする
rst = B を 書式 として C に 1 を加えた 値 、 D の C 番 目 で 整 形 した 文字列を A とする <eos>
2049
src = A . dp [ B ] [ C ] = min ( A . dp [ B - 1 ] [ C - 1 ] , min ( A . dp [ B - 1 ] [ C ] , A . dp [ B ] [ C - 1 ] ) ) + 1
trg = A の dp の B から 1 を 引 いた 値 番目の C から 1 を 引 いた 値 番 目 、 A . dp の B -1 番目の C 番 目 、 A . dp の B 番目の C から 1 を 引 いた 値 番目の 最小 値の 最小 値に 1 を加えた 値を A の dp の B 番目の C 番 目 にする
rst = A の dp の B から 1 を 引 いた 値 番目の C から 1 を 引 いた 値 番 目 、 A の dp の B から 1 を 引 いた 値 番目の C 番 目 に 1 を加えた 値の 最小 値を A の dp の B 番目の C
2050
src = A = 13 * 3600
trg = 13 に 3 600 を 掛 け た 値を A とする
rst = 13 に 3 600 を 掛 け た 値を A とする <eos>
2051
src = A = [ B for B in range ( 1 , C + 1 ) if C % B == 0 ]
trg = 1 から C に 1 を加えた 値 未 満 までの 数 列 の 各要素 を B とし 、 C を B で 割 った 余 り が 0 と 等 しい とき の B の 列 を A とする
rst = 1 から C に 1 を加えた 値 未 満 までの 数 列 の 各要素 を B とし 、 C が B を 0 で 割 った 余 り と 等 しい とき の B の 列 を A とする <eos>
2052
src = A = [ True for B in range ( C + 2 ) ]
trg = 0 から C に 2 を加えた 値 未 満 までの 数 列 の 各要素 を B とし 、 、 つまり 真 の 列 を A とする
rst = 0 から C に 2 を加えた 値 未 満 までの 数 列 の 各要素 を B とし 、 、 つまり 真 の 列 を A とする <eos>
2053
src = A = { x : [ C for C , B in enumerate ( D ) ] }
trg = ( ( B , D に 番号 付 した 組 の 列 の 各要素 を C 、 B とし 、 C の 列 ) ) からなる 辞書 を A とする
rst = ( ( B , D に 番号 付 した 組 の 列 の 各要素 を C 、 B とし 、 C の 列 ) ) からなる 辞書 を A とする <eos>
2054
src = A . node [ B ] = A . operator_func ( A . node [ 2 * B + 1 ] , A . node [ 2 * B + 2 ] )
trg = A . operator _ func ( A . node [ 2 * B + 1 ] , A . node [ 2 * B + 2 ] ) を A の node の B 番 目 にする
rst = A . operator _ func ( A . node [ 2 * B + 1 ] , A . node [ 2 * B + 2 ] ) を A の node の B 番 目 にする <eos>
2055
src = A = [ [ 0 , 0 ] ]
trg = ( ( 0 、 0 ) からなる 列 ) からなる 列 を A とする
rst = ( ( 0 、 0 ) からなる 列 ) からなる 列 を A とする <eos>
2056
src = clear ( A [ 1 ] )
trg = clear ( A [ 1 ] )
rst = clear ( A [ 1 ] ) <eos>
2057
src = while A != [ ] and A [ 0 ] != B :
trg = A が 、 つまり 空 列 と 等 しく なく かつ A の 0 番 目 が B と 等 しく ない 間 、 次 を 繰り返す
rst = A が 、 つまり 空 列 と 等 しく なく かつ A の 0 番 目 が B と 等 しく ない 間 、 次 を 繰り返す <eos>
2058
src = A = min ( B , C [ 1 ] )
trg = B 、 C の 1 番目の 最小 値を A とする
rst = B 、 C の 1 番目の 最小 値を A とする <eos>
2059
src = return SME ( A )
trg = SME ( A ) を返す
rst = search _ <unk> ( A ) を返す <eos>
2060
src = print ( min ( A * B , C * B * 2 ) + min ( math . ceil ( D / 1000 ) * A , math . ceil ( D / 500 ) * C ) )
trg = A に B を 掛 け た 値 、 C に B を 掛 け た 値に 2 を 掛 け た 値の 最小 値に D / 1000 の 切り 上げ 整数値 に A を 掛 け た 値 、 D / 500 の 切り 上げ 整数値 に C を 掛 け た 値の 最小 値 を加えた 値 を出力する
rst = A に B を 掛 け た 値 、 C に B を 掛 け た 値の 切り 上げ 整数値 に D を 掛 け た 値を 1000 で 割 った 値の 切り 上げ 整数値 に A を 掛 け た 値 を加えた 値 、 D を 500 で 割
2061
src = if check ( A , B , C , D , E ) :
trg = check ( A , B , C , D , E ) の とき 、
rst = check ( A , B , C , D , E ) の とき 、 <eos>
2062
src = A = ( B [ C ] - B [ D + 1 ] ) + ( E - F [ C - 1 ] )
trg = B の C 番 目 から B の D に 1 を加えた 値 番 目 を 引 いた 値に E から F の C から 1 を 引 いた 値 番 目 を 引 いた 値 を加えた 値を A とする
rst = B の C 番 目 から B の D に 1 を加えた 値 番 目 を 引 いた 値に E から F の C から 1 を 引 いた 値 番 目 を 引 いた 値 を加えた 値を A とする <eos>
2063
src = return c ( int ( A ) + int ( B ) )
trg = c ( int ( A ) + int ( B ) ) を返す
rst = c ( int ( A ) + int ( B ) ) を返す <eos>
2064
src = A [ B ] = ( C [ B ] * 2 - sum ( [ A [ D ] for D in range ( 2 , B ) if B % D == 0 ] ) ) % E
trg = C の B 番 目 に 2 を 掛 け た 値 から 2 から B 未 満 までの 数 列 の 各要素 を D とし 、 B % D が 0 と 等 しい とき の A の D 番目の 列 の 総 和 を 引 いた 値を E で 割 った 余 り を A の B 番 目 にする
rst = C の B 番 目 に 2 を 掛 け た 値 から B 未 満 までの 数 列 の 各要素 を D とし 、 B を D で 割 った 余 り が 0 と 等 しい とき の A の D 番目の 列 の 総 和 を E
2065
src = A . append ( ( B , C + D [ B ] ) )
trg = A の 末 尾 に ( B 、 C に D の B 番 目 を加えた 値 ) の 組 を追加する
rst = A の 末 尾 に ( B 、 C に D の B 番 目 を加えた 値 ) の 組 を追加する <eos>
2066
src = A = B [ : C ] + D [ E ] + B [ C + 2 : ]
trg = B の 、 つまり 先頭 から C 番 目 までの 部分 列 に D の E 番 目 を加えた 値に B の C に 2 を加えた 値 から 、 つまり 末 尾 までの 部分 列 を加えた 値を A とする
rst = B の 、 つまり 先頭 から C 番 目 までの 部分 列 に D の E 番 目 を加えた 値に B の C に 2 を加えた 値 から 、 つまり 末 尾 までの 部分 列 を加えた 値を A とする <eos>
2067
src = for A in range ( len ( B ) + 10 ) :
trg = 0 から B の長さ に 10 を加えた 値 未 満 までの 数 列 を 順に A として 、 繰り返す
rst = 0 から B の長さ に 10 を加えた 値 未 満 までの 数 列 を 順に A として 、 繰り返す <eos>
2068
src = A = dist ( B , C )
trg = B と C の ユ ー クリ ッ ド 距 離 を A とする
rst = B と C の ユ ー クリ ッ ド 距 離 を A とする <eos>
2069
src = if A >= B and Sosu ( A ) :
trg = A が B 以上 かつ Sosu ( A ) の とき 、
rst = A が B 以上 かつ Sosu ( A ) の とき 、 <eos>
2070
src = if not A [ B ] [ C ] :
trg = A の B 番目の C 番 目 でない とき 、
rst = A の B 番目の C 番 目 でない とき 、 <eos>
2071
src = return ( A - B ) * ( C - B ) + ( D - E ) * ( F - E )
trg = A から B を 引 いた 値に C から B を 引 いた 値を 掛 け た 値に D から E を 引 いた 値に F から E を 引 いた 値を 掛 け た 値 を加えた 値を返す
rst = A から B を 引 いた 値に C から B を 引 いた 値を 掛 け た 値に D から E を 引 いた 値に F から E を 引 いた 値を 掛 け た 値 を加えた 値を返す <eos>
2072
src = A = 1 << B
trg = 1 を B だけ 左 シフト した 値を A とする
rst = 1 を B だけ 左 シフト した 値を A とする <eos>
2073
src = A = [ B [ 1 ] for B in C ]
trg = C の 各要素 を B とし 、 B の 1 番目の 列 を A とする
rst = C の 各要素 を B とし 、 B の 1 番目の 列 を A とする <eos>
2074
src = A , B , C , D = [ 0 ] * 1002 , [ 0 ] * 1002 , [ 0 ] * 1002 , [ 0 ] * 1002
trg = ( 0 ) からなる 列 の 100 2 回 分 の 列 、 ( 0 ) からなる 列 の 100 2 回 分 の 列 、 ( 0 ) からなる 列 の 100 2 回 分 の 列 、 ( 0 ) からなる 列 の 100 2 回 分 の 列 を A 、 B 、 C 、 D とする
rst = ( 0 ) からなる 列 の 100 2 回 分 の 列 、 ( 0 ) からなる 列 の 100 2 回 分 の 列 、 ( 0 ) からなる 列 の 100 2 回 分 の 列 を A 、 B 、 C 、 D とする <eos>
2075
src = C = ( B // 3 ) % 3
trg = B を 3 で 割 った 商 を 3 で 割 った 余 り を C とする
rst = B を 3 で 割 った 商 を 3 で 割 った 余 り を C とする <eos>
2076
src = if A . checked [ B + C ] [ D + E ] :
trg = A の checked の B に C を加えた 値 番目の D に E を加えた 値 番目の とき 、
rst = A の checked の B に C を加えた 値 番目の D に E を加えた 値 番目の とき 、 <eos>
2077
src = A . number [ 0 ] = B
trg = B を A の number の 0 番 目 にする
rst = B を A の number の 0 番 目 にする <eos>
2078
src = A , B , C , D = map ( lambda F : pi * F / 180. , E )
trg = E の 各要素 に x を パラメータ として 円 周 率 に x を 掛 け た 値を 1 80 . で 割 った 値を返す 関数 を適用した 列 を 展開 し 、 それぞれ A 、 B 、 C 、 D とする
rst = F の 各要素 に x を パラメータ として x に y を 掛 け た 値を x の 1 80 . で 割 った 値 を返す関数 を適用した 列 を 展開 し 、 それぞれ A 、 B 、 C 、 D とする <eos>
2079
src = if ( A - B ) * C != ( D - E ) * F :
trg = A から B を 引 いた 値に C を 掛 け た 値が D から E を 引 いた 値に F を 掛 け た 値 と 等 しく ない とき 、
rst = A から B を 引 いた 値に C を 掛 け た 値が D から E を 引 いた 値に F を 掛 け た 値 と 等 しく ない とき 、 <eos>
2080
src = if A . count ( A [ 0 ] ) == 4 :
trg = A 内の A の先頭 の 出現 回数 が 4 と 等 しい とき 、
rst = A 内の A の先頭 の 出現 回数 が 4 と 等 しい とき 、 <eos>
2081
src = A [ B ] [ C ] = D [ B - 1 ] [ 0 ] + A [ B - 1 ] [ C - D [ B - 1 ] [ 1 ] ]
trg = D の B から 1 を 引 いた 値 番目の 0 番 目 に A の B から 1 を 引 いた 値 番目の C から D の B -1 番目の 1 番 目 を 引 いた 値 番 目 を加えた 値を A の B 番目の C 番 目 にする
rst = D の B から 1 を 引 いた 値 番目の 0 番 目 に A の B から 1 を 引 いた 値 番目の C から D [ B -1 ] の 1 番 目 を 引 いた 値 番 目 を加えた 値を A の B 番目の C 番 目
2082
src = A = ( B - C ) * D - ( E - F ) * G
trg = B から C を 引 いた 値に D を 掛 け た 値 から E から F を 引 いた 値に G を 掛 け た 値を 引 いた 値を A とする
rst = B から C を 引 いた 値に D を 掛 け た 値 から E から F を 引 いた 値に G を 掛 け た 値を 引 いた 値を A とする <eos>
2083
src = A = [ list ( map ( lambda B : ord ( B ) - C , readline ( ) . strip ( ) ) ) for D in range ( E ) ]
trg = 0 から E 未 満 までの 数 列 の 各要素 を D とし 、 readline () の 両 端 から 空白 改行 を取り 除 いた 文字列 の 各要素 に x を パラメータ として ord ( B ) から C を 引 いた 値を返す 関数 を適用した 列 のリスト の 列 を A とする
rst = 0 から E 未 満 までの 数 列 の 各要素 を D とし 、 readline () の 両 端 から 空白 改行 を取り 除 いた 文字列 の 各要素 に x を パラメータ として B の 順序 数 から C を 引 いた 値を返す 関数 を適用した 列 のリスト の 列 を
2084
src = for A in B . neighbor_dict [ C ] :
trg = B の neighbor _ dict の C 番 目 を 順に A として 、 繰り返す
rst = B の neighbor _ dict の C 番 目 を 順に A として 、 繰り返す <eos>
2085
src = print ( A . format ( B , '' . join ( [ C . format ( D ) for D in E ] ) ) )
trg = A を 書式 として B 、 空文字列 を 間 に 入れ て E の 各要素 を D とし 、 C を 書式 として D で 整 形 した 文字列 の 列 を 連結 した 文字列 で 整 形 した 文字列 を出力する
rst = A を 書式 として B 、 空文字列 を 間 に 入れ て E の 各要素 を D とし 、 C を 書式 として D で 整 形 した 文字列 の 列 を 連結 した 文字列 を出力する <eos>
2086
src = if A [ B ] [ C - 1 ] == D :
trg = A の B 番目の C から 1 を 引 いた 値 番 目 が D と 等 しい とき 、
rst = A の B 番目の C から 1 を 引 いた 値 番 目 が D と 等 しい とき 、 <eos>
2087
src = A . delete ( int ( B ) )
trg = A . delete ( int ( B ) )
rst = A . delete ( int ( B ) ) <eos>
2088
src = A [ 0 ] [ 1 ] = B
trg = B を A の先頭 の 1 番 目 にする
rst = B を A の先頭 の 1 番 目 にする <eos>
2089
src = A . append ( { 'up' : C , 'front' : E , 'right' : G , 'left' : I , 'back' : K , 'bottom' : M } )
trg = A の 末 尾 に ( ( B , C ) 、 ( D , E ) 、 ( F , G ) 、 ( H , I ) 、 ( J , K ) 、 ( L , M ) ) からなる 辞書 を追加する
rst = A の 末 尾 に ( ( B , C ) 、 ( D , E ) 、 ( F , G ) 、 ( H , I ) 、 ( J , K ) 、 ( L , M ) ) からなる 辞書 を追加する <eos>
2090
src = A = ( B + C <= D ) and ( B - C >= 0 )
trg = B に C を加えた 値が D 以下 かつ B から C を 引 いた 値が 0 以上 かどうか を A とする
rst = B に C を加えた 値が D 以下 かつ B から C を 引 いた 値が 0 以上 かどうか を A とする <eos>
2091
src = A = number ( )
trg = number () を A とする
rst = number () を A とする <eos>
2092
src = A . Q = deque ( )
trg = [MASK] の 両 端 キュー を A の Q にする
rst = [MASK] の 両 端 キュー を A の Q にする <eos>
2093
src = print ( max ( solve ( A , B ) ) )
trg = solve ( A , B ) の 最大 値 を出力する
rst = solve ( A , B ) の 最大 値 を出力する <eos>
2094
src = print ( A , B [ A ] )
trg = A 、 B の A 番 目 を出力する
rst = A 、 B の A 番 目 を出力する <eos>
2095
src = A = abs ( B - C )
trg = B から C を 引 いた 値の 絶対 値を A とする
rst = B から C を 引 いた 値の 絶対 値を A とする <eos>
2096
src = A = 0.00872664625997164788461845384244
trg = 0.0 0 8 7 26 64 6 25 99 7 1 64 7 88 4 6 18 4 5 38 4 24 4 を A とする
rst = 10 4 6 5 27 を A とする <eos>
2097
src = A = [ list ( B ) for B in zip ( * A ) ]
trg = A を 展開 して の 要素を それぞれ 組 にした 列 の 各要素 を B とし 、 B のリスト の 列 を A とする
rst = A を 展開 して の 要素を それぞれ 組 にした 列 の 各要素 を B とし 、 B のリスト の 列 を A とする <eos>
2098
src = A = min ( count , key = lambda B : ( - len ( B ) * ( count [ B ] > 1 ) , B ) )
trg = x を パラメータ として ( - len ( B ) に count [ B ] が 1 より 大きい かどうか を 掛 け た 値 、 x ) の 組 を返す関数 を key として 無限 の 整数 列 の 最小 値を A とする
rst = w を パラメータ として ( - B の長さ に 無限 の 整数 列 の B 番 目 が 1 より 大きい かどうか を 掛 け た 値 、 B を reverse として 無限 の 整数 列 の 整数 列 とする <eos>
2099
src = if A [ B + 1 ] [ C + 1 ] :
trg = A の B に 1 を加えた 値 番目の C に 1 を加えた 値 番目の とき 、
rst = A の B に 1 を加えた 値 番目の C に 1 を加えた 値 番目の とき 、 <eos>
2100
src = if A . find ( B ) >= 0 :
trg = A の先頭 から B を 探 して 見つかった 位置 が 0 以上の とき 、
rst = A の先頭 から B を 探 して 見つかった 位置 が 0 以上の とき 、 <eos>
2101
src = A = calc_minkowski_distance ( B , C , D )
trg = calc _ minkowski _ distance ( B , C , D ) を A とする
rst = <unk> ( B , C , D ) を A とする <eos>
2102
src = D = add ( D , E [ C ] )
trg = add ( D , E [ C ] ) を D とする
rst = add ( D , E [ C ] ) を D とする <eos>
2103
src = A . q . add ( B , - C )
trg = A の q に B 、 - C を追加した 集 ま り
rst = A の q に B 、 - C を追加した 集 ま り <eos>
2104
src = A . append ( extract ( B ) )
trg = A の 末 尾 に extract ( B ) を追加する
rst = A の 末 尾 に <unk> ( B ) を追加する <eos>
2105
src = A . N = len ( B )
trg = B の長さ を A の N にする
rst = B の長さ を A の N にする <eos>
2106
src = A [ ( 6 , 4 ) ] = [ B + C for B in A [ ( 5 , 4 ) ] ]
trg = A の ( 5 、 4 ) の 組 番目の 各要素 を B とし 、 B に C を加えた 値の 列 を A の ( 6 、 4 ) の 組 番 目 にする
rst = A の ( 5 、 4 ) の 組 番目の 各要素 を B とし 、 B に C を加えた 値の 列 を A の ( 6 、 4 ) の 組 番 目 にする <eos>
2107
src = search_strongly_connection ( A , B , C , D , E )
trg = search _ strongly _ connection ( A , B , C , D , E )
rst = <unk> ( A , B , C , D , E ) <eos>
2108
src = A . bit1 = FenwickTree ( B )
trg = FenwickTree ( B ) を A の bit 1 にする
rst = FenwickTree ( B ) を A の bit 1 にする <eos>
2109
src = delete_node ( A , B . key )
trg = delete _ node ( A , B . key )
rst = delete _ node ( A , B . key ) <eos>
2110
src = if A . p1 . x == A . p2 . x :
trg = A の p 1 の x 座標 が A の p 2 の x 座標 と 等 しい とき 、
rst = A の p 1 の x 座標 が A の p 2 の x 座標 と 等 しい とき 、 <eos>
2111
src = A [ B ] -= 2 * ( A [ B ] // 2 )
trg = A の B 番 目 を 2 に A の B 番 目 を 2 で 割 った 商 を 掛 け た 値 だけ 減少 させる
rst = A の B 番 目 を 2 に A の B 番 目 を 2 で 割 った 商 を 掛 け た 値 だけ 減少 させる <eos>
2112
src = if ( A != '\n' ) :
trg = A が 、 つまり 改行 文字 と 等 しく ない とき 、
rst = A が 、 つまり 改行 文字 と 等 しく ない とき 、 <eos>
2113
src = A = B . format ( C - D )
trg = B を 書式 として C から D を 引 いた 値 で 整 形 した 文字列を A とする
rst = B を 書式 として C から D を 引 いた 値 で 整 形 した 文字列を A とする <eos>
2114
src = A = [ - B , C ]
trg = ( - B 、 C ) からなる 列 を A とする
rst = ( - B 、 C ) からなる 列 を A とする <eos>
2115
src = print ( A [ Zeller ( 2004 , B , C ) ] )
trg = A の Zeller ( 2004 , B , C ) 番 目 を出力する
rst = A の <unk> ( 2004 , B , C ) 番 目 を出力する <eos>
2116
src = return ( A - B ) * C + D + 1
trg = A から B を 引 いた 値に C を 掛 け た 値に D を加えた 値に 1 を加えた 値を返す
rst = A から B を 引 いた 値に C を 掛 け た 値に D を加えた 値に 1 を加えた 値を返す <eos>
2117
src = A [ - 1 ] = A
trg = A を A の -1 番 目 にする
rst = A を A の -1 番 目 にする <eos>
2118
src = return A . zero ( )
trg = A . zero () を返す
rst = A . zero () を返す <eos>
2119
src = A [ B ] = ( B , 0 )
trg = ( B 、 0 ) の 組 を A の B 番 目 にする
rst = ( B 、 0 ) の 組 を A の B 番 目 にする <eos>
2120
src = for A in reversed ( range ( B + 1 , C ) ) :
trg = B に 1 を加えた 値 から C 未 満 までの 数 列 を 反 転 した 列 を 順に A として 、 繰り返す
rst = B に 1 を加えた 値 から C 未 満 までの 数 列 を 反 転 した 列 を 順に A として 、 繰り返す <eos>
2121
src = A = [ '' ] * 100
trg = ( 、 つまり 空文字列 ) からなる 列 の 100 回 分 の 列 を A とする
rst = ( 、 つまり 空文字列 ) からなる 列 の 100 回 分 の 列 を A とする <eos>
2122
src = if A == ( B - C ) ** 2 :
trg = A が B から C を 引 いた 値の 2 乗 と 等 しい とき 、
rst = A が B から C を 引 いた 値の 2 乗 と 等 しい とき 、 <eos>
2123
src = dfs ( A . index ( max ( A ) ) )
trg = dfs ( A . index ( max ( A ) ) )
rst = dfs ( A . max ( A ) ) <eos>
2124
src = if len ( A [ B ] ) % 2 == 1 :
trg = A の B 番目の 長さ を 2 で 割 った 余 り が 1 と 等 しい とき 、
rst = A の B 番目の 長さ を 2 で 割 った 余 り が 1 と 等 しい とき 、 <eos>
2125
src = A , B = 0 , 2 ** ( ( C . n ) . bit_length ( ) - 1 )
trg = 0 、 2 の C の n の ビット 長 から 1 を 引 いた 値 乗 を A 、 B とする
rst = 0 、 2 の C の n の ビット 長 から 1 を 引 いた 値 乗 を A 、 B とする <eos>
2126
src = if A [ B ] [ 1 ] < C :
trg = A の B 番目の 1 番 目 が C より 小さい とき 、
rst = A の B 番目の 1 番 目 が C より 小さい とき 、 <eos>
2127
src = if dfs ( A + 1 , B , C , D , A + 1 , E ) :
trg = dfs ( A + 1, B , C , D , A + 1, E ) の とき 、
rst = dfs ( A + 1, B , C , D , A + 1, E ) の とき 、 <eos>
2128
src = if A > B [ C + 1 ] :
trg = A が B の C に 1 を加えた 値 番 目 より 大きい とき 、
rst = A が B の C に 1 を加えた 値 番 目 より 大きい とき 、 <eos>
2129
src = for A in range ( 1 + ( B >> 1 ) ) :
trg = 0 から 1 に B を 1 だけ 右 シフト した 値 を加えた 値 未 満 までの 数 列 を 順に A として 、 繰り返す
rst = 0 から 1 に B を 1 だけ 右 シフト した 値 を加えた 値 未 満 までの 数 列 を 順に A として 、 繰り返す <eos>
2130
src = A += int ( A * ( 0.05 ) )
trg = A を A に 0.0 5 を 掛 け た 値の 整数値 だけ 増加 させる
rst = A を A に query _ int ( 36 5 ) を 掛 け た 値の 整数値 だけ 増加 させる <eos>
2131
src = A = A * dfs ( B ) % C
trg = A に dfs ( B ) を 掛 け た 値を C で 割 った 余 り を A とする
rst = A に dfs ( B ) を 掛 け た 値を C で 割 った 余 り を A とする <eos>
2132
src = A . append ( ( D if B [ C ] [ D - 1 ] else D - 1 , C , F if B [ E ] [ F + 1 ] else F + 1 , E , G ) )
trg = A の 末 尾 に ( B の C 番目の D から 1 を 引 いた 値 番目の とき D 、 そうでなければ D から 1 を 引 いた 値 、 C 、 B の E 番目の F に 1 を加えた 値 番目の とき F 、 そうでなければ F に 1 を加えた 値 、 E 、 G ) の 組 を追加する
rst = A の 末 尾 に ( B の C 番目の D から 1 を 引 いた 値 番目の とき D 、 そうでなければ D から 1 を 引 いた 値 、 C 、 B の E 番目の F に 1 を加えた 値 番目の とき F 、 そうでなければ F に 1 を加えた
2133
src = if A [ B : B + 5 ] == C :
trg = A の B 番 目 から B に 5 を加えた 値 までの 部分 列 が C と 等 しい とき 、
rst = A の B 番 目 から B に 5 を加えた 値 までの 部分 列 が C と 等 しい とき 、 <eos>
2134
src = if A [ B ] >= B + 1 :
trg = A の B 番 目 が B に 1 を加えた 値 以上の とき 、
rst = A の B 番 目 が B に 1 を加えた 値 以上の とき 、 <eos>
2135
src = print ( ' ' + str ( A [ B ] [ C ] [ D ] ) )
trg = 空白 文字 に A [ B ] の C 番目の D 番目の 文字列 を加えた 値 を出力する
rst = 空白 文字 に A の B 番目の C 番目の D 番目の 文字列 を加えた 値 を出力する <eos>
2136
src = A = 65280
trg = 6 5 2 80 を A とする
rst = 10 4 6 5 27 を A とする <eos>
2137
src = bisect . insort ( A [ B ] , ( C + e . weight , D ) )
trg = ( C に ネ イ ピ ア 数の weight を加えた 値 、 D ) の 組 を A の B 番 目 に ソート 順 で 最後に 挿入 する
rst = ( C に ネ イ ピ ア 数の weight を加えた 値 、 D ) の 組 を A の B 番 目 に ソート 順 で 最後に 挿入 する <eos>
2138
src = assert A != B
trg = A が B と 等 しく なく なければならない
rst = A が B と 等 しく なく なければならない <eos>
2139
src = A [ B ] = C = get ( D )
trg = get ( D ) を C とする を A の B 番 目 にする
rst = get ( D ) を C とする を A の B 番 目 にする <eos>
2140
src = A = Koch ( B , C ) [ : - 1 ] + Koch ( D , C )
trg = Koch ( B , C ) の 末 尾 を 除 いた 部分 列 に Koch ( D , C ) を加えた 値を A とする
rst = Koch ( B , C ) の 、 つまり 先頭 から 、 つまり 末 尾 までの -1 間隔 による 部分 列 に Koch ( D , C ) を加えた 値を A とする <eos>
2141
src = return float ( A )
trg = A の 浮動小数点数 を返す
rst = A の 浮動小数点数 を返す <eos>
2142
src = A = ( - 1 , - 1 )
trg = ( -1 、 -1 ) の 組 を A とする
rst = ( -1 、 -1 ) の 組 を A とする <eos>
2143
src = A . marge_next_wait ( B )
trg = A . marge _ next _ wait ( B )
rst = A . <unk> ( B ) <eos>
2144
src = A . bridges = [ ]
trg = 空 列 を A の bridges にする
rst = 空 列 を A の bridges にする <eos>
2145
src = A = B if B < len ( C ) and C [ B ] > C [ A ] else A
trg = B が C の長さ より 小さく かつ C の B 番 目 が C の A 番 目 より 大きい とき B 、 そうでなければ A を A とする
rst = B が C の長さ より 小さく かつ C の B 番 目 が C の B 番 目 より 大きい とき B 、 そうでなければ A を A とする <eos>
2146
src = A . data = [ [ ] for B in range ( C . bit_length ( ) + 1 ) ]
trg = 0 から C の ビット 長 に 1 を加えた 値 未 満 までの 数 列 の 各要素 を B とし 、 、 つまり 空 列 の 列 を A の data にする
rst = 0 から C の ビット 長 に 1 を加えた 値 未 満 までの 数 列 の 各要素 を B とし 、 、 つまり 空 列 の 列 を A の data にする <eos>
2147
src = heappush ( A , ( B , C , D , E ) )
trg = heappush ( A , ( B , C , D , E ) )
rst = heappush ( A , ( B , C , D , E ) ) <eos>
2148
src = if A + 2 < B [ C + 1 ] [ D ] :
trg = A に 2 を加えた 値が B の C に 1 を加えた 値 番目の D 番 目 より 小さい とき 、
rst = A に 2 を加えた 値が B の C に 1 を加えた 値 番目の D 番 目 より 小さい とき 、 <eos>
2149
src = heappush ( A , - int ( B [ 2 ] ) )
trg = heappush ( A , - int ( B [ 2 ] ) )
rst = heappush ( A , - int ( B [ 2 ] ) ) <eos>
2150
src = dfs ( A , 0 , B )
trg = dfs ( A , 0 , B )
rst = dfs ( A , 0 , B ) <eos>
2151
src = return [ 5 , A [ B [ 2 ] ] , int ( B [ 3 ] ) ]
trg = ( 5 、 A の B の 2 番 目 番 目 、 B の 3 番目の 整数値 ) からなる 列 を返す
rst = ( 5 、 A の B の 2 番 目 番 目 、 B の 3 番目の 整数値 ) からなる 列 を返す <eos>
2152
src = A = int ( '' . join ( sorted ( B , reverse = True ) ) )
trg = 空文字列 を 間 に 入れ て 、 つまり 逆 順に B を ソート した 列 を 連結 した 文字列 の 整数値 を A とする
rst = 空文字列 を 間 に 入れ て 、 つまり 逆 順に B を ソート した 列 を 連結 した 文字列 の 整数値 を A とする <eos>
2153
src = A , B = factor ( )
trg = factor () を 展開 し 、 それぞれ A 、 B とする
rst = factor () を 展開 し 、 それぞれ A 、 B とする <eos>
2154
src = return ( A * 13 ) % B . size
trg = A に 13 を 掛 け た 値を B の size で 割 った 余 り を返す
rst = A に 13 を 掛 け た 値を B の size で 割 った 余 り を返す <eos>
2155
src = if A - B > - 1 :
trg = A から B を 引 いた 値が -1 より 大きい とき 、
rst = A から B を 引 いた 値が -1 より 大きい とき 、 <eos>
2156
src = return gcd ( A , B )
trg = A と B の 最大 公 約 数 を返す
rst = A と B の 最大 公 約 数 を返す <eos>
2157
src = A = max ( A , B [ C ] [ C + 1 ] + B [ C + 1 ] [ D + 1 ] )
trg = A 、 B の C 番目の C に 1 を加えた 値 番 目 に B の C に 1 を加えた 値 番目の D に 1 を加えた 値 番 目 を加えた 値の 最大 値を A とする
rst = A 、 B の C 番目の C に 1 を加えた 値 番 目 に B の C に 1 を加えた 値 番目の D に 1 を加えた 値 番 目 を加えた 値の 最大 値を A とする <eos>
2158
src = return A . front == B . front and A . behind == B . behind and A . left == B . left and A . right == B . right and A . top == B . top and A . bottom == B . bottom
trg = A . front == B . front かつ A . behind == B . behind かつ A . left が B . left と 等 しく かつ A の right が B の right と 等 しく かつ A の top が B の top と 等 しく かつ A の bottom が B の bottom と 等 しい かどうか を返す
rst = A の front が B の front と 等 しく かつ A の behind が B の right と 等 しく かつ A の left が B . と 等 しく かつ A の right が B の front と 等 しく かつ A の bottom が B の front
2159
src = f ( A , B , C , D )
trg = f ( A , B , C , D )
rst = f ( A , B , C , D ) <eos>
2160
src = return _get ( A * 2 + 2 , B + 1 , C )
trg = _ get ( A * 2 + 2 , B + 1, C ) を返す
rst = _ get ( A * 2 + 2 , B + 1, C ) を返す <eos>
2161
src = while len ( A ) == 1 or B <= int ( C [ 1 ] / A [ 1 ] + 1 ) :
trg = A の長さ が 1 と 等 しく または B が C [ 1 ] を A [ 1 ] で 割 った 値に 1 を加えた 値の 整数値 以下の 間 、 次 を 繰り返す
rst = A の長さ が 1 と 等 しく または B が C の 1 番 目 を A の 1 番 目 で 割 った 値の 整数値 に 1 を加えた 値 以下の 間 、 次 を 繰り返す <eos>
2162
src = A = min ( B , min ( [ e [ 0 ] for e in trace_back ( C , D ) ] ) )
trg = B 、 trace _ back ( C , D ) の 各要素 を ネ イ ピ ア 数 とし 、 、 つまり ネ イ ピ ア 数の 0 番目の 列 の 最小 値の 最小 値を A とする
rst = B 、 <unk> ( C , D ) の 各要素 を ネ イ ピ ア 数 とし 、 、 つまり ネ イ ピ ア 数の 0 番目の 列 の 最小 値を A とする <eos>
2163
src = A [ B ] = str ( bisect . bisect_left ( C , int ( D [ B ] ) ) )
trg = ソート された 順序 を 保 った まま D の B 番目の 整数値 を C に 挿入 できる 位置 の 文字列を A の B 番 目 にする
rst = ソート された 順序 を 保 った まま D の B 番目の 整数値 を C に 挿入 できる 位置 の 文字列を A の B 番 目 にする <eos>
2164
src = A += dfs_rev ( e , B , C )
trg = A を dfs _ rev ( e , B , C ) だけ 増加 させる
rst = A を <unk> ( e , B , C ) だけ 増加 させる <eos>
2165
src = A = '' . join ( [ chr ( ord ( B ) + ( C * D + E ) % 26 ) for D in range ( 26 ) ] )
trg = 空文字列 を 間 に 入れ て 0 から 26 未 満 までの 数 列 の 各要素 を D とし 、 、 つまり 文字コード B の 順序 数 に ( C * D + E ) を 26 で 割 った 余 り を加えた 値の 文字 の 列 を 連結 した 文字列を A とする
rst = 空文字列 を 間 に 入れ て 0 から 26 未 満 までの 数 列 の 各要素 を D とし 、 、 つまり 文字コード ( ord ( B ) + C * D + E ) % 26 ) の 列 の 列 を 連結 した 文字列を A とする <eos>
2166
src = A = lambda B : ( B // 100 ) * 60 + ( B % 100 )
trg = t を パラメータ として t を 100 で 割 った 商 に 60 を 掛 け た 値に t を 100 で 割 った 余 り を加えた 値を返す 関数を A とする
rst = x を パラメータ として B を 100 で 割 った 商 に 60 を 掛 け た 値に B を 100 で 割 った 余 り を加えた 値を返す 関数を A とする <eos>
2167
src = print ( A [ B + 2 ] , end = '' )
trg = 改行 せずに A の B に 2 を加えた 値 番 目 を出力する
rst = 改行 せずに A の B に 2 を加えた 値 番 目 を出力する <eos>
2168
src = A [ B + C * D ] += A [ B ]
trg = A の B に C に D を 掛 け た 値 を加えた 値 番 目 を A の B 番 目 だけ 増加 させる
rst = A の B に C に D を 掛 け た 値 を加えた 値 番 目 を A の B 番 目 だけ 増加 させる <eos>
2169
src = return multi_lcm ( A )
trg = multi _ lcm ( A ) を返す
rst = search _ <unk> ( A ) を返す <eos>
2170
src = time ( tuple ( map ( int , input ( ) . split ( ) ) ) )
trg = time ( tuple ( map ( int , input () . split () ) ) )
rst = 入力された 文字列を 空白 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 の 組 <eos>
2171
src = A = ( B [ C + D ] - B [ C ] * E ) % F
trg = B の C に D を加えた 値 番 目 から B の C 番 目 に E を 掛 け た 値を 引 いた 値を F で 割 った 余 り を A とする
rst = B の C に D を加えた 値 番 目 から B の C 番 目 に E を 掛 け た 値を 引 いた 値を F で 割 った 余 り を A とする <eos>
2172
src = A = [ 0 ] * ( B - C + 1 )
trg = ( 0 ) からなる 列 の B から C を 引 いた 値に 1 を加えた 値 回 分 の 列 を A とする
rst = ( 0 ) からなる 列 の B から C を 引 いた 値に 1 を加えた 値 回 分 の 列 を A とする <eos>
2173
src = A . parent . right = A . left
trg = A の left を A の parent の right にする
rst = A の left を A の parent の right にする <eos>
2174
src = A [ B ] [ C ] [ D ] [ E ] = F = F % G
trg = F を G で 割 った 余 り を F とする を A の B 番目の C 番目の D 番目の E 番 目 にする
rst = F を G で 割 った 余 り を A の B 番目の C 番目の D 番目の E 番 目 にする <eos>
2175
src = A = B [ C ] . pop ( D )
trg = B の C 番目の D を取り 出した 値を A とする
rst = B の C 番目の D を取り 出した 値を A とする <eos>
2176
src = return True if A [ B * 2 ] [ C ] == 0 else False
trg = A の B に 2 を 掛 け た 値 番目の C 番 目 が 0 と 等 しい とき 、 つまり 真 、 そうでなければ 、 つまり 偽 を返す
rst = A の B に 2 を 掛 け た 値 番目の C 番 目 が 0 と 等 しい とき 、 つまり 真 、 そうでなければ 、 つまり 偽 を返す <eos>
2177
src = return sorted ( A [ 1 : ] ) + [ A [ 0 ] ]
trg = A の先頭 を 除 いた 部分 列 を ソート した 列 に ( A の先頭 ) からなる 列 を加えた 値を返す
rst = A の先頭 を 除 いた 部分 列 を ソート した 列 に ( A の先頭 ) からなる 列 を加えた 値を返す <eos>
2178
src = for A in B - C [ D ] :
trg = B から C の D 番 目 を 引 いた 値を 順に A として 、 繰り返す
rst = B から C の D 番 目 を 引 いた 値を 順に A として 、 繰り返す <eos>
2179
src = A = B * C * ( D + E )
trg = B に C を 掛 け た 値に D に E を加えた 値を 掛 け た 値を A とする
rst = B に C を 掛 け た 値に D に E を加えた 値を 掛 け た 値を A とする <eos>
2180
src = A . max_width = 0
trg = 0 を A の max _ width にする
rst = 0 を A の max _ width にする <eos>
2181
src = A += 360.0
trg = A を 36 0.0 だけ 増加 させる
rst = A を " { } " だけ 増加 させる <eos>
2182
src = A . degree = None
trg = 未 定 値を A の degree にする
rst = 未 定 値を A の degree にする <eos>
2183
src = A = B [ coprime ( C , D ) + coprime ( E , D ) ]
trg = B の coprime ( C , D ) に coprime ( E , D ) を加えた 値 番 目 を A とする
rst = B の coprime ( C , D ) に coprime ( E , D ) を加えた 値 番 目 を A とする <eos>
2184
src = A [ B ] = max ( A [ 2 * B + 1 ] , A [ 2 * B + 2 ] )
trg = A の 2 に B を 掛 け た 値に 1 を加えた 値 番 目 、 A の 2 に B を 掛 け た 値に 2 を加えた 値 番目の 最大 値を A の B 番 目 にする
rst = A の 2 に B を 掛 け た 値に 1 を加えた 値 番 目 、 A の 2 に B を 掛 け た 値に 2 を加えた 値 番目の 最大 値を A の B 番 目 にする <eos>
2185
src = A [ 1 : ] += B
trg = A の 1 番 目 から 、 つまり 末 尾 までの 部分 列 を B だけ 増加 させる
rst = A の 1 番 目 から 、 つまり 末 尾 までの 部分 列 を B だけ 増加 させる <eos>
2186
src = print ( max ( sum ( A ) , sum ( B ) ) )
trg = A の 総 和 、 B の 総 和 の 最大 値 を出力する
rst = A の 総 和 、 B の 総 和 の 最大 値 を出力する <eos>
2187
src = for A in range ( 100 , 0 , - 1 ) :
trg = 100 から 0 未 満 までの -1 間隔 の 数 列 を 順に A として 、 繰り返す
rst = 100 から 0 未 満 までの -1 間隔 の 数 列 を 順に A として 、 繰り返す <eos>
2188
src = insertionsort ( A , B , C [ D ] )
trg = insertionsort ( A , B , C [ D ] )
rst = <unk> ( A , B , C [ D ] ) <eos>
2189
src = A = ( 1 , A [ 1 ] , A [ 2 ] , B [ 1 ] , B [ 2 ] )
trg = ( 1 、 A の 1 番 目 、 A の 2 番 目 、 B の 1 番 目 、 B の 2 番 目 ) の 組 を A とする
rst = ( 1 、 A の 1 番 目 、 A の 2 番 目 、 B の 1 番 目 、 B の 2 番 目 ) の 組 を A とする <eos>
2190
src = A = bisect . bisect_right ( B , int ( C [ 1 ] ) )
trg = ソート された 順序 を 保 った まま C の 1 番目の 整数値 を B に 挿入 できる 最後の 位置 を A とする
rst = ソート された 順序 を 保 った まま C の 1 番目の 整数値 を B に 挿入 できる 最後の 位置 を A とする <eos>
2191
src = A [ B ] [ C ] += A [ D ] [ E ]
trg = A の B 番目の C 番 目 を A の D 番目の E 番 目 だけ 増加 させる
rst = A の B 番目の C 番 目 を A の D 番目の E 番 目 だけ 増加 させる <eos>
2192
src = A = [ 0 , 0 ] + [ 1 ] * 9999999
trg = ( 0 、 0 ) からなる 列 に (1) からなる 列 の 9 99 99 99 回 分 の 列 を加えた 値を A とする
rst = ( 0 、 0 ) からなる 列 に (1) からなる 列 の 500 20 回 分 の 列 を加えた 値を A とする <eos>
2193
src = print ( ' ' + str ( A . value ) , end = '' )
trg = 改行 せずに 空白 文字 に A の value の 文字列 を加えた 値 を出力する
rst = 改行 せずに 空白 文字 に A の value の 文字列 を加えた 値 を出力する <eos>
2194
src = A = { }
trg = 空 辞書 を A とする
rst = 空 辞書 を A とする <eos>
2195
src = return 0.5 * sum ( [ A . cross ( B [ C - 1 ] , B [ C ] ) for C in range ( len ( B ) ) ] )
trg = 0.5 に 0 から B の長さ 未 満 までの 数 列 の 各要素 を C とし 、 A . cross ( B [ C -1 ] , B [ C ] ) の 列 の 総 和 を 掛 け た 値を返す
rst = 0.5 に 0 から B の長さ 未 満 までの 数 列 の 各要素 を C とし 、 A . cross ( B [ C -1 ] , B [ C ] ) の 列 の 総 和 を 掛 け た 値を返す <eos>
2196
src = A = tuple ( [ B - C for C in range ( B + 1 ) ] )
trg = 0 から B に 1 を加えた 値 未 満 までの 数 列 の 各要素 を C とし 、 B から C を 引 いた 値の 列 の 組 を A とする
rst = 0 から B に 1 を加えた 値 未 満 までの 数 列 の 各要素 を C とし 、 B から C を 引 いた 値の 列 の 組 を A とする <eos>
2197
src = if A [ 1 ] == B [ 0 ] [ 1 ] :
trg = A の 1 番 目 が B の先頭 の 1 番 目 と 等 しい とき 、
rst = A の 1 番 目 が B の先頭 の 1 番 目 と 等 しい とき 、 <eos>
2198
src = if A . isDisjoint ( B , C ) :
trg = A . isDisjoint ( B , C ) の とき 、
rst = A . _ intersect ( B , C ) の とき 、 <eos>
2199
src = if A not in B [ C ] :
trg = A が B の C 番 目 に 含まれ ない とき 、
rst = A が B の C 番 目 に 含まれ ない とき 、 <eos>
2200
src = return A % 4 == 0 and ( A % 100 != 0 or A % 400 == 0 )
trg = A を 4 で 割 った 余 り が 0 と 等 しく かつ A を 100 で 割 った 余 り が 0 と 等 しく なく または A を 400 で 割 った 余 り が 0 と 等 しい かどうか を返す
rst = A を 4 で 割 った 余 り が 0 と 等 しく かつ A を 100 で 割 った 余 り が 0 と 等 しく なく または A を 400 で 割 った 余 り が 0 と 等 しい かどうか を返す <eos>
2201
src = A = [ C [ B // 2 ] if B % 2 else [ D [ B // 2 ] for B in range ( E * 2 ) ] ]
trg = ( B を 2 で 割 った 余 り の とき C の B を 2 で 割 った 商 番 目 、 そうでなければ 0 から E に 2 を 掛 け た 値 未 満 までの 数 列 の 各要素 を B とし 、 D の B を 2 で 割 った 商 番目の 列 ) からなる 列 を A とする
rst = ( B を 2 で 割 った 余 り の とき C の B を 2 で 割 った 商 番 目 、 そうでなければ 0 から E に 2 を 掛 け た 値 未 満 までの 数 列 の 各要素 を B とし 、 D の B を 2
2202
src = A = ( B [ 0 ] [ 0 ] + B [ 2 ] [ 0 ] ) / 2
trg = B の先頭 の 0 番 目 に B の 2 番目の 先頭 を加えた 値を 2 で 割 った 値を A とする
rst = B の先頭 の 0 番 目 に B の 2 番目の 先頭 を加えた 値を 2 で 割 った 値を A とする <eos>
2203
src = print ( A , str ( B + 1 ) + C )
trg = A 、 B に 1 を加えた 値の 文字列 に C を加えた 値 を出力する
rst = A 、 B に 1 を加えた 値の 文字列 に C を加えた 値 を出力する <eos>
2204
src = if A == B - 2 and C < D :
trg = A が B から 2 を 引 いた 値 と 等 しく かつ C が D より 小さい とき 、
rst = A が B から 2 を 引 いた 値 と 等 しく かつ C が D より 小さい とき 、 <eos>
2205
src = A = check ( B )
trg = check ( B ) を A とする
rst = check ( B ) を A とする <eos>
2206
src = A . extend ( [ ( B , C ) for B in D [ C ] if B not in E ] )
trg = D の C 番目の 各要素 を B とし 、 B が E に 含まれ ない とき の ( B 、 C ) の 組 の 列 を追加し て A を拡張する
rst = D の C 番目の 各要素 を B とし 、 B が E に 含まれ ない とき の ( B 、 C ) の 組 の 列 を追加し て A を拡張する <eos>
2207
src = for A in range ( 1 , B + C - 1 ) :
trg = 1 から B に C を加えた 値 から 1 を 引 いた 値 未 満 までの 数 列 を 順に A として 、 繰り返す
rst = 1 から B に C を加えた 値 から 1 を 引 いた 値 未 満 までの 数 列 を 順に A として 、 繰り返す <eos>
2208
src = if A [ B ] % 2 == 0 :
trg = A の B 番 目 を 2 で 割 った 余 り が 0 と 等 しい とき 、
rst = A の B 番 目 を 2 で 割 った 余 り が 0 と 等 しい とき 、 <eos>
2209
src = A . append ( query ( B [ 0 ] , B [ 1 ] + 1 ) )
trg = A の 末 尾 に query ( B [ 0 ] , B [ 1 ] + 1 ) を追加する
rst = A の 末 尾 に query ( B [ 0 ] , B [ 1 ] + 1 ) を追加する <eos>
2210
src = return A <= 0 and B <= 0
trg = A が 0 以下 かつ B が 0 以下 かどうか を返す
rst = A が 0 以下 かつ B が 0 以下 かどうか を返す <eos>
2211
src = A = B // C [ D ]
trg = B を C の D 番 目 で 割 った 商 を A とする
rst = B を C の D 番 目 で 割 った 商 を A とする <eos>
2212
src = A . graph [ e [ 1 ] ] . append ( e [ 0 ] )
trg = A の graph の 、 つまり ネ イ ピ ア 数の 1 番 目 番目の 末 尾 に ネ イ ピ ア 数 の先頭 を追加する
rst = A の graph の 、 つまり ネ イ ピ ア 数の 1 番 目 番目の 末 尾 に ( 、 つまり ネ イ ピ ア 数 の先頭 ) の 組 を追加する <eos>
2213
src = reconstruction ( 0 , len ( A ) )
trg = reconstruction ( 0 , len ( A ) )
rst = reconstruction ( 0 , len ( A ) ) <eos>
2214
src = A = [ array ( B , [ 0 ] * len ( C [ 0 ] ) ) for D in range ( len ( C ) ) ]
trg = 0 から C の長さ 未 満 までの 数 列 の 各要素 を D とし 、 B 、 ( 0 ) からなる 列 の C の先頭 の長さ 回 分 の 列 から の配列 の 列 を A とする
rst = 0 から C の長さ 未 満 までの 数 列 の 各要素 を D とし 、 B 、 ( 0 ) からなる 列 の C の先頭 の長さ 回 分 の 列 の 列 を A とする <eos>
2215
src = A [ tuple ( B ) ] |= 1 << C
trg = A の B の 組 番 目 を 1 を C だけ 左 シフト した 値 と の 論理 和 にする
rst = A の B の 組 番 目 を 1 を C だけ 左 シフト した 値 と の 論理 和 にする <eos>
2216
src = A , B = C + D , E + F
trg = C に D を加えた 値 、 E に F を加えた 値を A 、 B とする
rst = C に D を加えた 値 、 E に F を加えた 値を A 、 B とする <eos>
2217
src = A . find ( int ( B ) )
trg = A の先頭 から B の 整数値 を 探 して 見つかった 位置
rst = A の先頭 から B の 整数値 を 探 して 見つかった 位置 <eos>
2218
src = A [ B ] = C [ 0 ] + C [ 1 ]
trg = C の 0 番 目 に C の 1 番 目 を加えた 値を A の B 番 目 にする
rst = C の 0 番 目 に C の 1 番 目 を加えた 値を A の B 番 目 にする <eos>
2219
src = print ( euler_phi ( A ) )
trg = euler _ phi ( A ) を出力する
rst = <unk> ( A ) を出力する <eos>
2220
src = A = deque ( map ( int , B . readline ( ) . split ( ) ) )
trg = B から 読み 込 んだ 一行 を 空白 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 の 両 端 キュー を A とする
rst = B から 読み 込 んだ 一行 を 空白 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 の 両 端 キュー を A とする <eos>
2221
src = A [ 0 ] [ B ] = A [ 0 ] [ B - 1 ]
trg = A の先頭 の B から 1 を 引 いた 値 番 目 を A の先頭 の B 番 目 にする
rst = A の先頭 の B から 1 を 引 いた 値 番 目 を A の先頭 の B 番 目 にする <eos>
2222
src = print ( str [ 1 : A + 1 ] )
trg = 整数 の 1 番 目 から A に 1 を加えた 値 までの 部分 列 を出力する
rst = 整数 の 1 番 目 から A に 1 を加えた 値 までの 部分 列 を出力する <eos>
2223
src = A [ - 1 ] -= 1
trg = A の -1 番 目 を 1 だけ 減少 させる
rst = A の -1 番 目 を 1 だけ 減少 させる <eos>
2224
src = A = ( B << 9 ) + ( C << 18 )
trg = B を 9 だけ 左 シフト した 値に C を 18 だけ 左 シフト した 値 を加えた 値を A とする
rst = B を 9 だけ 左 シフト した 値に C を 18 だけ 左 シフト した 値 を加えた 値を A とする <eos>
2225
src = A = 39
trg = 3 9 を A とする
rst = 3 9 を A とする <eos>
2226
src = print ( A [ - 1 ] - A [ 0 ] )
trg = A の -1 番 目 から A の先頭 を 引 いた 値 を出力する
rst = A の -1 番 目 から A の先頭 を 引 いた 値 を出力する <eos>
2227
src = print ( A % ( B , C , D ) )
trg = A を ( B 、 C 、 D ) の 組 で 割 った 余 り を出力する
rst = A を ( B 、 C 、 D ) の 組 で 割 った 余 り を出力する <eos>
2228
src = for A in range ( 0 , len ( B ) , 13 ) :
trg = 0 から B の長さ 未 満 までの 13 間隔 の 数 列 を 順に A として 、 繰り返す
rst = 0 から B の長さ 未 満 までの 13 間隔 の 数 列 を 順に A として 、 繰り返す <eos>
2229
src = A . append ( Card ( B , int ( C ) ) )
trg = A の 末 尾 に Card ( B , int ( C ) ) を追加する
rst = A の 末 尾 に <unk> ( B , int ( C ) ) を追加する <eos>
2230
src = ( ( A - 1 , B - 1 ) , ( A , B - 1 ) , ( A - 1 , B ) , ( A + 1 , B ) , ( A - 1 , B + 1 ) , ( A , B + 1 ) )
trg = ( ( A から 1 を 引 いた 値 、 B から 1 を 引 いた 値 ) の 組 、 ( A 、 B から 1 を 引 いた 値 ) の 組 、 ( A から 1 を 引 いた 値 、 B ) の 組 、 ( A に 1 を加えた 値 、 B ) の 組 、 ( A から 1 を 引 いた 値 、 B に 1 を加えた 値 ) の 組 、 (
rst = ( ( A から 1 を 引 いた 値 、 B から 1 を 引 いた 値 ) の 組 、 ( A 、 B から 1 を 引 いた 値 ) の 組 、 ( A 、 B に 1 を加えた 値 ) の 組 、 ( A 、
2231
src = if abs ( A * B - C * D ) < ( E + F ) * G - H :
trg = A に B を 掛 け た 値 から C に D を 掛 け た 値を 引 いた 値の 絶対 値が E に F を加えた 値に G を 掛 け た 値 から H を 引 いた 値 より 小さい とき 、
rst = A に B を 掛 け た 値 から C に D を 掛 け た 値を 引 いた 値の 絶対 値が E に F を加えた 値に G を 掛 け た 値 から H を 引 いた 値 より 小さい とき 、 <eos>
2232
src = return A . value
trg = A の value を返す
rst = A の value を返す <eos>
2233
src = A = B [ C // 2 : C ]
trg = B の C を 2 で 割 った 商 から C 番 目 までの 部分 列 を A とする
rst = B の C を 2 で 割 った 商 から C 番 目 までの 部分 列 を A とする <eos>
2234
src = A [ B ] , path [ B ] = 0 , 1
trg = 0 、 1 を A の B 番 目 、 os . path の B 番 目 とする
rst = 0 、 1 を A の B 番 目 、 os . path の B 番 目 とする <eos>
2235
src = A += B [ C + D ] [ E + F ]
trg = A を B の C に D を加えた 値 番目の E に F を加えた 値 番 目 だけ 増加 させる
rst = A を B の C に D を加えた 値 番目の E に F を加えた 値 番 目 だけ 増加 させる <eos>
2236
src = A [ B ] = C = ( C * 58 + D ) % ( E + 1 )
trg = C に 5 8 を 掛 け た 値に D を加えた 値を E に 1 を加えた 値 で 割 った 余 り を C とする を A の B 番 目 にする
rst = C に 5 を 掛 け た 値に D を加えた 値を E に 1 を加えた 値 で 割 った 余 り を C とする を A の B 番 目 にする <eos>
2237
src = print ( dis ( A , B , 1.0 ) )
trg = dis ( A , B , 1.0 ) を出力する
rst = dis ( A , B , 1.0 ) を出力する <eos>
2238
src = print ( A [ len ( B ) - 1 ] [ len ( C ) - 1 ] )
trg = A の B の長さ から 1 を 引 いた 値 番目の C の長さ から 1 を 引 いた 値 番 目 を出力する
rst = A の B の長さ から 1 を 引 いた 値 番目の C の長さ から 1 を 引 いた 値 番 目 を出力する <eos>
2239
src = if bubbleSort ( A , B ) == selectionSort ( C , B ) :
trg = bubbleSort ( A , B ) が selectionSort ( C , B ) と 等 しい とき 、
rst = bubbleSort ( A , B ) が selectionSort ( C , B ) と 等 しい とき 、 <eos>
2240
src = A = [ '' for B in range ( 26 ) ]
trg = 0 から 26 未 満 までの 数 列 の 各要素 を B とし 、 、 つまり 空文字列 の 列 を A とする
rst = 0 から 26 未 満 までの 数 列 の 各要素 を B とし 、 、 つまり 空文字列 の 列 を A とする <eos>
2241
src = Check ( A , B , C + 1 , D , E )
trg = Check ( A , B , C + 1, D , E )
rst = Check ( A , B , C + 1, D , E ) <eos>
2242
src = print ( A % dist_ll ( ( B , C ) , ( D , E ) , ( F , G ) , ( H , I ) ) )
trg = A を dist _ ll ( ( B , C ) , ( D , E ) , ( F , G ) , ( H , I ) ) で 割 った 余 り を出力する
rst = A を <unk> ( ( B , C ) , ( D , E ) , ( F , G ) , ( H , I ) ) で 割 った 余 り を出力する <eos>
2243
src = if A [ e ] == 0 and B [ e ] == False :
trg = A の 、 つまり ネ イ ピ ア 数 番 目 が 0 と 等 しく かつ B の 、 つまり ネ イ ピ ア 数 番 目 が 、 つまり 偽 と 等 しい とき 、
rst = A の 、 つまり ネ イ ピ ア 数 番 目 が 0 と 等 しく かつ B の 、 つまり ネ イ ピ ア 数 番 目 が 、 つまり 偽 と 等 しい とき 、 <eos>
2244
src = A = [ B [ C ] for C in range ( D + 1 - E ) ]
trg = 0 から D に 1 を加えた 値 から E を 引 いた 値 未 満 までの 数 列 の 各要素 を C とし 、 B の C 番目の 列 を A とする
rst = 0 から D に 1 を加えた 値 から E を 引 いた 値 未 満 までの 数 列 の 各要素 を C とし 、 B の C 番目の 列 を A とする <eos>
2245
src = A . tail . prev = A . head
trg = A の head を A の tail の prev にする
rst = A の head を A の tail の prev にする <eos>
2246
src = A [ 4 ] = A [ 0 ]
trg = A の先頭 を A の 4 番 目 にする
rst = A の先頭 を A の 4 番 目 にする <eos>
2247
src = e . add_flow ( A , B )
trg = e . add _ flow ( A , B )
rst = ネ イ ピ ア 数 . <unk> ( A , B ) <eos>
2248
src = if A - 1 >= 0 and B [ C * 2 ] [ A - 1 ] == 0 and D [ C ] [ A - 1 ] > E + 1 :
trg = A から 1 を 引 いた 値が 0 以上 かつ B の C * 2 番目の A から 1 を 引 いた 値 番 目 が 0 と 等 しく かつ D の C 番目の A から 1 を 引 いた 値 番 目 が E に 1 を加えた 値 より 大きい とき 、
rst = A から 1 を 引 いた 値が 0 以上 かつ B の C * 2 番目の A から 1 を 引 いた 値 番 目 が 0 と 等 しく かつ D の C 番目の A から 1 を 引 いた 値 番 目 が E に 1 を加えた 値
2249
src = if 2 * A + 1 <= B :
trg = 2 に A を 掛 け た 値に 1 を加えた 値が B 以下の とき 、
rst = 2 に A を 掛 け た 値に 1 を加えた 値が B 以下の とき 、 <eos>
2250
src = A [ 0 ] -= 1
trg = A の 0 番 目 を 1 だけ 減少 させる
rst = A の 0 番 目 を 1 だけ 減少 させる <eos>
2251
src = if 0 < A < B - 1 :
trg = 0 が A より 小さい かどうか が B から 1 を 引 いた 値 より 小さい とき 、
rst = 0 が A より 小さい かどうか が B から 1 を 引 いた 値 より 小さい とき 、 <eos>
2252
src = kesu ( ( A [ 0 ] + 1 , A [ 1 ] ) , B , C , D + 1 )
trg = kesu ( ( A [ 0 ] + 1, A [ 1 ] ) , B , C , D + 1 )
rst = kesu ( ( A [ 0 ] + 1, A [ 1 ] ) , B , C , D + 1 ) <eos>
2253
src = if A < B - 1 and C [ A + 1 ] != 0 :
trg = A が B から 1 を 引 いた 値 より 小さく かつ C の A に 1 を加えた 値 番 目 が 0 と 等 しく ない とき 、
rst = A が B から 1 を 引 いた 値 より 小さく かつ C の A に 1 を加えた 値 番 目 が 0 と 等 しく ない とき 、 <eos>
2254
src = A = map ( int , B . readline ( ) )
trg = B から 読み 込 んだ 一行 の 各要素 に 整数 を適用した 列 を A とする
rst = B から 読み 込 んだ 一行 の 各要素 に 整数 を適用した 列 を A とする <eos>
2255
src = A . left_child = B
trg = B を A の left _ child にする
rst = B を A の left _ child にする <eos>
2256
src = A = calc_LIS ( B )
trg = calc _ LIS ( B ) を A とする
rst = <unk> ( B ) を A とする <eos>
2257
src = A = [ [ inf ] * [ B for C in range ( B ) ] ]
trg = ( ( 、 つまり 無限大 ) からなる 列 の 0 から B 未 満 までの 数 列 の 各要素 を C とし 、 B の 列 回 分 の 列 ) からなる 列 を A とする
rst = ( ( 、 つまり 無限大 ) からなる 列 の 0 から B 未 満 までの 数 列 の 各要素 を C とし 、 B の 列 回 分 の 列 ) からなる 列 を A とする <eos>
2258
src = A . append ( int ( str ( B [ 0 ] ) + str ( B [ 1 ] ) ) )
trg = A の 末 尾 に B の先頭 の 文字列 に B の 1 番目の 文字列 を加えた 値の 整数値 を追加する
rst = A の 末 尾 に B の先頭 の 文字列 に B の 1 番目の 文字列 を加えた 値の 整数値 を追加する <eos>
2259
src = A = Counter ( A )
trg = A の 辞書 カウンタ を A とする
rst = A の 辞書 カウンタ を A とする <eos>
2260
src = if A . parent == None :
trg = A の parent が 、 つまり 未 定 値 と 等 しい とき 、
rst = A の parent が 、 つまり 未 定 値 と 等 しい とき 、 <eos>
2261
src = if ( A <= 50 and B [ A ] == 0 ) or B [ A ] > C :
trg = A が 50 以下 かつ B の A 番 目 が 0 と 等 しく または B の A 番 目 が C より 大きい とき 、
rst = A が 50 以下 かつ B の A 番 目 が 0 と 等 しく または B の A 番 目 が C より 大きい とき 、 <eos>
2262
src = print ( bfs ( [ building ( ) , building ( ) ] ) )
trg = bfs ( [ building () , building () ] ) を出力する
rst = bfs ( [ <unk> () , <unk> () ) ] を出力する <eos>
2263
src = if cross ( A , B ) > 0 :
trg = cross ( A , B ) が 0 より 大きい とき 、
rst = cross ( A , B ) が 0 より 大きい とき 、 <eos>
2264
src = A , B , B = map ( int , input ( ) . split ( ) )
trg = 入力された 文字列を 空白 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 を 展開 し 、 それぞれ A 、 B 、 B とする
rst = 入力された 文字列を 空白 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 を 展開 し 、 それぞれ A 、 B 、 B とする <eos>
2265
src = A [ 0 ] [ B ] = C [ B + 1 ] / D
trg = C の B に 1 を加えた 値 番 目 を D で 割 った 値を A の先頭 の B 番 目 にする
rst = C の B に 1 を加えた 値 番 目 を D で 割 った 値を A の先頭 の B 番 目 にする <eos>
2266
src = count += A [ B + 1 ] * C if A [ B + 1 ] > 0 else A [ B + 1 ] * D
trg = 無限 の 整数 列 を A の B に 1 を加えた 値 番 目 が 0 より 大きい とき A の B に 1 を加えた 値 番 目 に C を 掛 け た 値 、 そうでなければ A の B に 1 を加えた 値 番 目 に D を 掛 け た 値 だけ 増加 させる
rst = 無限 の 整数 列 を A の B に 1 を加えた 値 番 目 が 0 より 大きい とき A の B に 1 を加えた 値 番 目 に C を 掛 け た 値 、 そうでなければ A の B に 1 を加えた 値 番 目 に D を 掛
2267
src = A [ B ] [ C ] = D [ C ] * ( C - B + 1 ) - ( E [ C ] - E [ B ] + D [ B ] )
trg = D の C 番 目 に C から B を 引 いた 値に 1 を加えた 値を 掛 け た 値 から E の C 番 目 から E の B 番 目 を 引 いた 値に D の B 番 目 を加えた 値を 引 いた 値を A の B 番目の C 番 目 にする
rst = D の C 番 目 に C から B を 引 いた 値に 1 を加えた 値を 掛 け た 値 から E の C 番 目 から E の B 番 目 を 引 いた 値に D の B 番 目 を加えた 値を 引 いた 値を A の B 番目の
2268
src = return A == str ( B )
trg = A が B の 文字列 と 等 しい かどうか を返す
rst = A が B の 文字列 と 等 しい かどうか を返す <eos>
2269
src = A = [ set ( ) for B in range ( 31 ) ]
trg = 0 から 3 1 未 満 までの 数 列 の 各要素 を B とし 、 、 つまり 集合 の 列 を A とする
rst = 0 から 3 1 未 満 までの 数 列 の 各要素 を B とし 、 、 つまり 集合 の 列 を A とする <eos>
2270
src = A = lcm ( B , C )
trg = B と C の 最小 公 倍 数 を A とする
rst = B と C の 最小 公 倍 数 を A とする <eos>
2271
src = A . dist -= A . v
trg = A の dist を A の v だけ 減少 させる
rst = A の dist を A の v だけ 減少 させる <eos>
2272
src = A = ( B [ 2 ] - B [ 1 ] * C ) / B [ 0 ]
trg = B の 2 番 目 から B の 1 番 目 に C を 掛 け た 値を 引 いた 値を B の先頭 で 割 った 値を A とする
rst = B の 2 番 目 から B の 1 番 目 に C を 掛 け た 値を 引 いた 値を B の先頭 で 割 った 値を A とする <eos>
2273
src = print ( int ( sum ( A ) / B ) )
trg = A の 総 和 を B で 割 った 値の 整数値 を出力する
rst = A の 総 和 を B で 割 った 値の 整数値 を出力する <eos>
2274
src = if A ** 2 + B ** 2 - C <= 1e-8 and D ** 2 + E ** 2 - C <= 1e-8 :
trg = A の 2 乗 に B の 2 乗 を加えた 値 から C を 引 いた 値が 1 e -8 以下 かつ D の 2 乗 に E の 2 乗 を加えた 値 から C を 引 いた 値が 1 e -8 以下の とき 、
rst = A の 2 乗 に B の 2 乗 を加えた 値 から C を 引 いた 値が 1 e - D の 2 乗 に E の 2 乗 を加えた 値 から C の 2 乗 を 引 いた 値が 4 以下の とき 、 <eos>
2275
src = A [ B ] . height = C if C > D else D
trg = C が D より 大きい とき C 、 そうでなければ D を A の B 番目の height にする
rst = C が D より 大きい とき C 、 そうでなければ D を A の B 番目の height にする <eos>
2276
src = return ( findk ( A , B ) , None )
trg = ( findk ( A , B ) 、 未 定 値 ) の 組 を返す
rst = ( <unk> ( A , B ) 、 未 定 値 ) の 組 を返す <eos>
2277
src = A . nodes = [ None ] * A . size
trg = ( 、 つまり 未 定 値 ) からなる 列 の A の size 回 分 の 列 を A の nodes にする
rst = ( 、 つまり 未 定 値 ) からなる 列 の A の size 回 分 の 列 を A の nodes にする <eos>
2278
src = A = [ bin ( B ) . count ( C ) for B in range ( 0x10000 ) ]
trg = 0 から 0 x 1 0000 未 満 までの 数 列 の 各要素 を B とし 、 B の 2 進 数 文字列 内の C の 出現 回数 の 列 を A とする
rst = 0 から <unk> 未 満 までの 数 列 の 各要素 を B とし 、 B の 2 進 数 文字列 内の C の 出現 回数 の 列 を A とする <eos>
2279
src = A = [ B , C , D , E , ' ' ]
trg = ( B 、 C 、 D 、 E 、 空白 文字 ) からなる 列 を A とする
rst = ( B 、 C 、 D 、 E 、 空白 文字 ) からなる 列 を A とする <eos>
2280
src = A = Dice ( * [ int ( B ) for B in input ( ) . split ( ' ' ) ] )
trg = Dice ( * [ int ( B ) forBininput () . split ( ' ' ) ] ) を A とする
rst = Dice ( * [ int ( B ) forBininput () . split () ] ) を A とする <eos>
2281
src = A . union ( B [ C ] , C )
trg = A と B の C 番 目 、 C の 和 集合
rst = A と B の C 番目の 和 集合 <eos>
2282
src = A = A . sibling
trg = A の sibling を A とする
rst = A の sibling を A とする <eos>
2283
src = if A > e . cap :
trg = A が 、 つまり ネ イ ピ ア 数の cap より 大きい とき 、
rst = A が 、 つまり ネ イ ピ ア 数の cap より 大きい とき 、 <eos>
2284
src = return list ( A . values ( ) )
trg = A の値 の集まり のリスト を返す
rst = A の値 の集まり のリスト を返す <eos>
2285
src = A . lpdtop [ A . lpdnxt [ B ] ] = A . lpdtop [ B ]
trg = A の lpdtop の B 番 目 を A の lpdtop の A の lpdnxt の B 番 目 番 目 にする
rst = A の lpdtop の B 番 目 を A の lpdtop の A の lpdnxt の B 番 目 にする <eos>
2286
src = heappush ( A , ( B , C , D , E ^ 1 ) )
trg = heappush ( A , ( B , C , D , E ^ 1 ) )
rst = heappush ( A , ( B , C , D , E ^ 1 ) ) <eos>
2287
src = time += elapsed_time ( A )
trg = time を elapsed _ time ( A ) だけ 増加 させる
rst = time を <unk> ( A ) だけ 増加 させる <eos>
2288
src = A = sum ( [ B * C for B , C in zip ( D , E ) ] )
trg = D 、 E の 要素を それぞれ 組 にした 列 の 各要素 を B 、 C とし 、 B に C を 掛 け た 値の 列 の 総 和 を A とする
rst = D 、 E の 要素を それぞれ 組 にした 列 の 各要素 を B 、 C とし 、 B に C を 掛 け た 値の 列 の 総 和 を A とする <eos>
2289
src = A = [ 0 ] * 6 + [ 1 , 0 , 1 , 0 , 0 , 0 , 0 ] * 42857
trg = ( 0 ) からなる 列 の 6 に ( 1 、 0 、 1 、 0 、 0 、 0 、 0 ) からなる 列 の 4 28 5 7 回 分 の 列 を加えた 値 回 分 の 列 を A とする
rst = ( 0 ) からなる 列 の 6 回 分 の 列 に ( 1 、 0 、 1 、 0 、 0 、 0 、 0 ) からなる 列 の 6 回 分 の 列 を加えた 値 回 分 の 列 を A とする <eos>
2290
src = A += dfs ( 0 , B . difference ( { C } ) )
trg = A を dfs ( 0 , B . difference ( { C } ) ) だけ 増加 させる
rst = A を dfs ( 0 , B . difference ( { C } ) ) だけ 増加 させる <eos>
2291
src = A . shuffle ( B )
trg = A . shuffle ( B )
rst = A . <unk> ( B ) <eos>
2292
src = A , B , C , D , E , F = list ( map ( int , input ( ) . split ( ) ) )
trg = 入力された 文字列を 空白 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 の リストを 展開 し 、 それぞれ A 、 B 、 C 、 D 、 E 、 F とする
rst = 入力された 文字列を 空白 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 の リストを 展開 し 、 それぞれ A 、 B 、 C 、 D 、 E 、 F とする <eos>
2293
src = if int ( A ) % 2 == 0 :
trg = A の 整数値 を 2 で 割 った 余 り が 0 と 等 しい とき 、
rst = A の 整数値 を 2 で 割 った 余 り が 0 と 等 しい とき 、 <eos>
2294
src = A = ( ( B , C ) , ( D , E ) )
trg = ( ( B 、 C ) の 組 、 ( D 、 E ) の 組 ) の 組 を A とする
rst = ( ( B 、 C ) の 組 、 ( D 、 E ) の 組 ) の 組 を A とする <eos>
2295
src = A = ( [ [ c ( d ( B , C ) , D ) , c ( d ( E - B , C ) , D ) ] for B in range ( 1 , E // 2 + 1 ) ] )
trg = 1 から E を 2 で 割 った 商 に 1 を加えた 値 未 満 までの 数 列 の 各要素 を B とし 、 ( c ( d ( B , C ) , D ) 、 c ( d ( E - B , C ) , D ) ) からなる 列 の 列 を A とする
rst = 0 から E に 1 を加えた 値 未 満 までの 数 列 の 各要素 を B とし 、 ( ( B 、 C ) の 組 、 D ) の 組 、 ( d ( B , C ) から D , ( E - B , C ) を
2296
src = A [ 0 ] , A [ 2 ] = A [ 2 ] , A [ 0 ]
trg = A の先頭 と A の 2 番 目 を 入れ替え る
rst = A の 2 番 目 、 A の先頭 を A の先頭 、 A の 2 番 目 とする <eos>
2297
src = A [ B ] [ C ] = ( A [ B - 1 ] [ C ] + A [ B - 1 ] [ C + 1 ] ) % 10
trg = A の B から 1 を 引 いた 値 番目の C 番 目 に A の B から 1 を 引 いた 値 番目の C に 1 を加えた 値 番 目 を加えた 値を 10 で 割 った 余 り を A の B 番目の C 番 目 にする
rst = A の B から 1 を 引 いた 値 番目の C 番 目 に A の B から 1 を 引 いた 値 番目の C に 1 を加えた 値を 10 で 割 った 余 り 番 目 を加えた 値を A の B 番目の C 番 目 にする <eos>
2298
src = while A % 3 == 0 :
trg = A を 3 で 割 った 余 り が 0 と 等 しい 間 、 次 を 繰り返す
rst = A を 3 で 割 った 余 り が 0 と 等 しい 間 、 次 を 繰り返す <eos>
2299
src = A = rolling_hash ( B , C , D )
trg = rolling _ hash ( B , C , D ) を A とする
rst = <unk> ( B , C , D ) を A とする <eos>
2300
src = if A - B == set ( ) :
trg = A から B を 引 いた 値が 、 つまり 集合 と 等 しい とき 、
rst = A から B を 引 いた 値が 、 つまり 集合 と 等 しい とき 、 <eos>
2301
src = if len ( set ( A ) ) > len ( set ( B ) ) :
trg = A の集合 の長さ が B の集合 の長さ より 大きい とき 、
rst = A の集合 の長さ が B の集合 の長さ より 大きい とき 、 <eos>
2302
src = D = 2 * ( E - F )
trg = 2 に E から F を 引 いた 値を 掛 け た 値を D とする
rst = 2 に E から F を 引 いた 値を 掛 け た 値を D とする <eos>
2303
src = heappush ( A , ( B + 1 , 1 , C ) )
trg = heappush ( A , ( B + 1, 1, C ) )
rst = heappush ( A , ( B + 1, C ) ) <eos>
2304
src = A [ len ( B ) - C - 1 ] [ C ] = B [ C ]
trg = B の C 番 目 を A の B の長さ から C を 引 いた 値 から 1 を 引 いた 値 番目の C 番 目 にする
rst = B の C 番 目 を A の B の長さ から C を 引 いた 値 から 1 を 引 いた 値 番目の C 番 目 にする <eos>
2305
src = A = ( B ** 2 + C ** 2 - D ** 2 ) * E ** 2
trg = B の 2 乗 に C の 2 乗 を加えた 値 から D の 2 乗 を 引 いた 値に E の 2 乗 を 掛 け た 値を A とする
rst = B の 2 乗 に C の 2 乗 を加えた 値 から D の 2 乗 を 引 いた 値に E の 2 乗 を 掛 け た 値を A とする <eos>
2306
src = A = [ 0 , 1 , 5 , 4 ]
trg = ( 0 、 1 、 5 、 4 ) からなる 列 を A とする
rst = ( 0 、 1 、 5 、 4 ) からなる 列 を A とする <eos>
2307
src = return 100
trg = 100 を返す
rst = 100 を返す <eos>
2308
src = return sum ( A . values ( ) ) % 10007
trg = A の値 の集まり の 総 和 を 1000 7 で 割 った 余 り を返す
rst = A の値 の集まり の 総 和 を 1000 7 で 割 った 余 り を返す <eos>
2309
src = if A [ B + 1 ] [ C - 1 ] == D - 2 :
trg = A の B に 1 を加えた 値 番目の C から 1 を 引 いた 値 番 目 が D から 2 を 引 いた 値 と 等 しい とき 、
rst = A の B に 1 を加えた 値 番目の C から 1 を 引 いた 値 番 目 が D から 2 を 引 いた 値 と 等 しい とき 、 <eos>
2310
src = A . extend ( [ ( B , C ) ] )
trg = ( ( B 、 C ) の 組 ) からなる 列 を追加し て A を拡張する
rst = ( ( B 、 C ) の 組 ) からなる 列 を追加し て A を拡張する <eos>
2311
src = A = { (0, L-1) : 0 }
trg = ( ( ( 0 、 B から 1 を 引 いた 値 ) の 組 , 0 ) ) からなる 辞書 を A とする
rst = ( ( 0 , 0 ) ) からなる 辞書 を A とする <eos>
2312
src = A [ 0 ] [ 2 ] = 0
trg = 0 を A の先頭 の 2 番 目 にする
rst = 0 を A の先頭 の 2 番 目 にする <eos>
2313
src = A , B = A % B , B % C
trg = A を B で 割 った 余 り 、 B を C で 割 った 余 り を A 、 B とする
rst = A を B で 割 った 余 り 、 B を C で 割 った 余 り を A 、 B とする <eos>
2314
src = if A . get ( B ) :
trg = A に対応する 値 、 も し 存在 し なければ B の とき 、
rst = A に対応する 値 、 も し 存在 し なければ B の とき 、 <eos>
2315
src = A [ chr ( ord ( B ) + C ) ] = D
trg = D を A の 、 つまり 文字コード B の 順序 数 に C を加えた 値の 文字 番 目 にする
rst = D を A の 、 つまり 文字コード B の 順序 数 に C を加えた 値の 文字 番 目 にする <eos>
2316
src = A . heappush ( B , Node[T] ( C , 0 ) )
trg = A . heappush ( B , Node [ T ] ( C , 0 ) )
rst = A . heappush ( B , <unk> ( C , 0 ) ) <eos>
2317
src = A . append ( int ( str ( B [ C ] ) + str ( B [ D ] ) ) )
trg = A の 末 尾 に B の C 番目の 文字列 に B の D 番目の 文字列 を加えた 値の 整数値 を追加する
rst = A の 末 尾 に B [ C ] の 文字列 に B [ D ] の 文字列 を加えた 値の 整数値 を追加する <eos>
2318
src = A . append ( dot ( orthogonal ( B ) , C ) )
trg = A の 末 尾 に dot ( orthogonal ( B ) , C ) を追加する
rst = A の 末 尾 に dot ( orthogonal ( B ) , C ) を追加する <eos>
2319
src = A [ B ] [ C ] += int ( D [ B ] [ E ] ) * int ( F [ E ] [ C ] )
trg = A の B 番目の C 番 目 を D の B 番目の E 番目の 整数値 に F の E 番目の C 番目の 整数値 を 掛 け た 値 だけ 増加 させる
rst = A の B 番目の C 番 目 を D の B 番目の E 番目の 整数値 に F の E 番目の C 番目の 整数値 を 掛 け た 値 だけ 増加 させる <eos>
2320
src = for A in B [ 1 : ] :
trg = B の 1 番 目 から 、 つまり 末 尾 までの 部分 列 を 順に A として 、 繰り返す
rst = B の先頭 を 除 いた 部分 列 を 順に A として 、 繰り返す <eos>
2321
src = if A % 12 != 9 :
trg = A を 12 で 割 った 余 り が 9 と 等 しく ない とき 、
rst = A を 12 で 割 った 余 り が 9 と 等 しく ない とき 、 <eos>
2322
src = A = B - int ( B )
trg = B から B の 整数値 を 引 いた 値を A とする
rst = B から B の 整数値 を 引 いた 値を A とする <eos>
2323
src = A = [ 0 ] + A + [ 0 ]
trg = ( 0 ) からなる 列 に A を加えた 値に ( 0 ) からなる 列 を加えた 値を A とする
rst = ( 0 ) からなる 列 に A を加えた 値に ( 0 ) からなる 列 を加えた 値を A とする <eos>
2324
src = if A [ - 1 ] [ - 1 ] > A [ - 2 ] [ - 1 ] + B - C :
trg = A の 末 尾 の 末 尾 が A の -2 番目の 末 尾 に B を加えた 値 から C を 引 いた 値 より 大きい とき 、
rst = A の 末 尾 の 末 尾 が A の -2 番目の -1 番 目 に B を加えた 値 から C を 引 いた 値 より 大きい とき 、 <eos>
2325
src = return ( A + 1 ) % B
trg = A に 1 を加えた 値を B で 割 った 余 り を返す
rst = A に 1 を加えた 値を B で 割 った 余 り を返す <eos>
2326
src = return A . __class__ ( B , C , D , E , F , G )
trg = A . __ class __ ( B , C , D , E , F , G ) を返す
rst = A . __ class __ ( B , C , D , E , F , G ) を返す <eos>
2327
src = F = ( D * C + B * E )
trg = D に C を 掛 け た 値に B に E を 掛 け た 値 を加えた 値を F とする
rst = D に C を 掛 け た 値に B に E を 掛 け た 値 を加えた 値を F とする <eos>
2328
src = for A in range ( 26 - 3 ) :
trg = 0 から 26 から 3 を 引 いた 値 未 満 までの 数 列 を 順に A として 、 繰り返す
rst = 0 から 26 から 3 を 引 いた 値 未 満 までの 数 列 を 順に A として 、 繰り返す <eos>
2329
src = if A [ B ] [ C ] [ D ] < E or B == F * G :
trg = A の B 番目の C 番目の D 番 目 が E より 小さく または B が F に G を 掛 け た 値 と 等 しい とき 、
rst = A の B 番目の C 番目の D 番 目 が E より 小さく または B が F に G を 掛 け た 値 と 等 しい とき 、 <eos>
2330
src = heappush ( A [ B [ 1 ] ] , - B [ 2 ] )
trg = heappush ( A [ B [ 1 ]] , - B [ 2 ] )
rst = heappush ( A [ B [ 1 ]] , - B [ 2 ] ) <eos>
2331
src = A = [ B . _hash ( C , D ) for C in B . needle ]
trg = B の needle の 各要素 を C とし 、 B . _ hash ( C , D ) の 列 を A とする
rst = B の needle の 各要素 を C とし 、 B . _ hash ( C , D ) の 列 を A とする <eos>
2332
src = A [ B ] [ C ] [ D ] = A [ B ] [ C ] [ D ] + E
trg = A の B 番目の C 番目の D 番 目 に E を加えた 値を A の B 番目の C 番目の D 番 目 にする
rst = A の B 番目の C 番目の D 番 目 に E を加えた 値を A の B 番目の C 番目の D 番 目 にする <eos>
2333
src = A . iter [ B ] = len ( A . graph [ B ] )
trg = A の graph の B 番目の 長さ を A の iter の B 番 目 にする
rst = A の graph の B 番目の 長さ を A の iter の B 番 目 にする <eos>
2334
src = A [ B ] = min ( A [ B ] , C )
trg = A の B 番 目 、 C の 最小 値を A の B 番 目 にする
rst = A の B 番 目 、 C の 最小 値を A の B 番 目 にする <eos>
2335
src = A [ B - 1 - C ] [ C ] = D
trg = D を A の B から 1 を 引 いた 値 から C を 引 いた 値 番目の C 番 目 にする
rst = D を A の B から 1 を 引 いた 値 から C を 引 いた 値 番目の C 番 目 にする <eos>
2336
src = A [ 1 ] = Tree ( 0 , B )
trg = Tree ( 0 , B ) を A の 1 番 目 にする
rst = Tree ( 0 , B ) を A の 1 番 目 にする <eos>
2337
src = print ( A . format ( B + 1 , C [ B ] * D ) )
trg = A を 書式 として B に 1 を加えた 値 、 C の B 番 目 に D を 掛 け た 値 で 整 形 した 文字列 を出力する
rst = A を 書式 として B に 1 を加えた 値 、 C の B 番 目 に D を 掛 け た 値 で 整 形 した 文字列 を出力する <eos>
2338
src = write ( A % min ( count ( B , 2 ) , count ( B , 5 ) ) )
trg = write ( A % min ( count ( B , 2 ) , count ( B , 5 ) ) )
rst = write ( A % min ( count ( B , 2 ) , count ( B , 5 ) ) ) <eos>
2339
src = print ( int ( A / 6 ) )
trg = A を 6 で 割 った 値の 整数値 を出力する
rst = A を 6 で 割 った 値の 整数値 を出力する <eos>
2340
src = A = A + A
trg = A に A を加えた 値を A とする
rst = A に A を加えた 値を A とする <eos>
2341
src = A = [ [ 0 , B + 1 ] for B in range ( 100 ) ]
trg = 0 から 100 未 満 までの 数 列 の 各要素 を B とし 、 ( 0 、 B に 1 を加えた 値 ) からなる 列 の 列 を A とする
rst = 0 から 100 未 満 までの 数 列 の 各要素 を B とし 、 ( 0 、 B に 1 を加えた 値 ) からなる 列 の 列 を A とする <eos>
2342
src = if A + B + C == 0 :
trg = A に B を加えた 値に C を加えた 値が 0 と 等 しい とき 、
rst = A に B を加えた 値に C を加えた 値が 0 と 等 しい とき 、 <eos>
2343
src = process_command ( A , B )
trg = process _ command ( A , B )
rst = <unk> ( A , B ) <eos>
2344
src = A . list_sn = [ B [ 5 ] , B [ 4 ] , B [ 0 ] , B [ 1 ] ]
trg = ( B の 5 番 目 、 B の 4 番 目 、 B の先頭 、 B の 1 番 目 ) からなる 列 を A の list _ sn にする
rst = ( B の 5 番 目 、 B の 4 番 目 、 B の先頭 、 B の 1 番 目 ) からなる 列 を A の list _ we にする <eos>
2345
src = print ( '' . join ( [ C [ A ] if A not in B else [ ( D if C [ A ] == E else E ) for A in range ( F ) ] ] ) )
trg = 空文字列 を 間 に 入れ て ( A が B に 含まれ ない とき C の A 番 目 、 そうでなければ range ( F ) の 各要素 を A とし 、 ( DifC [ A ] == EelseE ) の 列 ) からなる 列 を 連結 した 文字列 を出力する
rst = 空文字列 を 間 に 入れ て ( A が B に含まれる とき C の A 番 目 、 そうでなければ 0 から F 未 満 までの 数 列 の 各要素 を A とし 、 A が E と 等 しい とき C の A 番 目 、 そうでなければ D の 列
2346
src = for A in range ( int ( B ** ( 1 / 2 ) ) , 0 , - 1 ) :
trg = B の 1 を 2 で 割 った 値 乗 の 整数値 から 0 未 満 までの -1 間隔 の 数 列 を 順に A として 、 繰り返す
rst = B の 1 を 2 で 割 った 値 乗 の 整数値 から 0 未 満 までの -1 間隔 の 数 列 を 順に A として 、 繰り返す <eos>
2347
src = for A , B in zip ( C , C [ 1 : ] + [ C [ 0 ] ] ) :
trg = C 、 C の 1 番 目 から 、 つまり 末 尾 までの 部分 列 に ( C の先頭 ) からなる 列 を加えた 値の 要素を それぞれ 組 にした 列 を 順に A 、 B として 、 繰り返す
rst = C 、 C の 1 番 目 から 、 つまり 末 尾 までの 部分 列 に ( C の先頭 ) からなる 列 を加えた 値の 要素を それぞれ 組 にした 列 を 順に A 、 B として 、 繰り返す <eos>
2348
src = return H{Y-1988}
trg = " H { } " を返す
rst = " T { } " を返す <eos>
2349
src = A = [ [ B , C ] for B , C in zip ( D [ : E ] , D [ E : ] ) ]
trg = D の 、 つまり 先頭 から E 番 目 までの 部分 列 、 D の E 番 目 から 、 つまり 末 尾 までの 部分 列 の 要素を それぞれ 組 にした 列 の 各要素 を B 、 C とし 、 ( B 、 C ) からなる 列 の 列 を A とする
rst = D の 、 つまり 先頭 から E 番 目 までの 部分 列 、 D の E 番 目 から 、 つまり 末 尾 までの 部分 列 の 要素を それぞれ 組 にした 列 の 各要素 を B 、 C とし 、 ( B 、 C ) からなる 列 の 列 を
2350
src = A [ 4 ] = [ 5 , 1 ]
trg = ( 5 、 1 ) からなる 列 を A の 4 番 目 にする
rst = ( 5 、 1 ) からなる 列 を A の 4 番 目 にする <eos>
2351
src = return ( A - 1 , B )
trg = ( A から 1 を 引 いた 値 、 B ) の 組 を返す
rst = ( A から 1 を 引 いた 値 、 B ) の 組 を返す <eos>
2352
src = A [ ( B // C ) % D ] = 1
trg = 1 を A の B を C で 割 った 商 を D で 割 った 余 り 番 目 にする
rst = 1 を A の B を C で 割 った 商 を D で 割 った 余 り 番 目 にする <eos>
2353
src = A += getPaintCount ( B [ C ] , D )
trg = A を getPaintCount ( B [ C ] , D ) だけ 増加 させる
rst = A を <unk> ( B [ C ] , D ) だけ 増加 させる <eos>
2354
src = A [ B - 1 ] , A [ C - 1 ] = A [ C - 1 ] , A [ B - 1 ]
trg = A の C から 1 を 引 いた 値 番 目 、 A の B から 1 を 引 いた 値 番 目 を A の B から 1 を 引 いた 値 番 目 、 A の C から 1 を 引 いた 値 番 目 とする
rst = A の C から 1 を 引 いた 値 番 目 、 A の B から 1 を 引 いた 値 番 目 を A の B から 1 を 引 いた 値 番 目 、 A の C から 1 を 引 いた 値 番 目 とする <eos>
2355
src = A = MinCostFlow ( 2 * B + 2 )
trg = MinCostFlow ( 2 * B + 2 ) を A とする
rst = MinCostFlow ( 2 * B + 2 ) を A とする <eos>
2356
src = if A . height :
trg = A の height の とき 、
rst = A の height の とき 、 <eos>
2357
src = A , B , A , C = map ( int , input ( ) . split ( ) )
trg = 入力された 文字列を 空白 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 を 展開 し 、 それぞれ A 、 B 、 A 、 C とする
rst = 入力された 文字列を 空白 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 を 展開 し 、 それぞれ A 、 B 、 A 、 C とする <eos>
2358
src = if A >= 999999 :
trg = A が 99 99 99 以上の とき 、
rst = A が 99 99 以上の とき 、 <eos>
2359
src = A = B * 5 + C * 3
trg = B に 5 を 掛 け た 値に C に 3 を 掛 け た 値 を加えた 値を A とする
rst = B に 5 を 掛 け た 値に C に 3 を 掛 け た 値 を加えた 値を A とする <eos>
2360
src = A [ 0 ] = - B
trg = - B を A の 0 番 目 にする
rst = - B を A の 0 番 目 にする <eos>
2361
src = return A [ B ] > C
trg = A の B 番 目 が C より 大きい かどうか を返す
rst = A の B 番 目 が C より 大きい かどうか を返す <eos>
2362
src = A . add ( B [ C ] [ D ] )
trg = A に B の C 番目の D 番 目 を追加した 集 ま り
rst = A に B の C 番目の D 番 目 を追加した 集 ま り <eos>
2363
src = if ( not is_in_ABC ( A ) ) :
trg = is _ in _ ABC ( A ) でない とき 、
rst = <unk> ( A ) でない とき 、 <eos>
2364
src = if len ( A ) >= len ( B ) :
trg = A の長さ が B の長さ 以上の とき 、
rst = A の長さ が B の長さ 以上の とき 、 <eos>
2365
src = A [ B ] [ C ] == 0
trg = A の B 番目の C 番 目 が 0 と 等 しい かどうか
rst = A の B 番目の C 番 目 が 0 と 等 しい かどうか <eos>
2366
src = A = 45
trg = 4 5 を A とする
rst = 4 5 を A とする <eos>
2367
src = A = [ B , C , D , E , F , G , H , I , J , K , L ]
trg = ( B 、 C 、 D 、 E 、 F 、 G 、 H 、 I 、 J 、 K 、 L ) からなる 列 を A とする
rst = ( B 、 C 、 D 、 E 、 F 、 G 、 H 、 I 、 J 、 K 、 L ) からなる 列 を A とする <eos>
2368
src = A [ B ] = C = C * B % D
trg = C に B を 掛 け た 値を D で 割 った 余 り を C とする を A の B 番 目 にする
rst = C に B を 掛 け た 値を D で 割 った 余 り を C とする を A の B 番 目 にする <eos>
2369
src = A . append ( B [ C . index ( D [ E ] ) ] )
trg = A の 末 尾 に B の C の D の E 番 目 と 等 しい 要素 の最初の 位置 番 目 を追加する
rst = A の 末 尾 に B の C の D の E 番 目 と 等 しい 要素 の最初の 位置 番 目 を追加する <eos>
2370
src = A = calc_d ( B [ 0 ] , B [ C ] )
trg = calc _ d ( B [ 0 ] , B [ C ] ) を A とする
rst = calc _ distance ( B [ 0 ] , B [ C ] ) を A とする <eos>
2371
src = print ( ' ' . join ( map ( str , list ( str ( A ) ) ) ) )
trg = 空白 文字 を 間 に 入れ て A の 文字列 のリスト の 各要素 に 整数 を適用した 列 を 連結 した 文字列 を出力する
rst = 空白 文字 を 間 に 入れ て A の 文字列 のリスト の 各要素 に 整数 を適用した 列 を 連結 した 文字列 を出力する <eos>
2372
src = print ( fibonacci ( int ( input ( ) ) ) )
trg = fibonacci ( int ( input () ) ) を出力する
rst = fibonacci ( int ( input () ) ) を出力する <eos>
2373
src = A . update ( B * 2 + 1 , C , D , E )
trg = B に 2 を 掛 け た 値に 1 を加えた 値 、 C 、 D 、 E を追加し て A を 更新 する
rst = B に 2 を 掛 け た 値に 1 を加えた 値 、 C 、 D 、 E を追加し て A を 更新 する <eos>
2374
src = A = min_capacity ( B , C , D )
trg = min _ capacity ( B , C , D ) を A とする
rst = <unk> ( B , C , D ) を A とする <eos>
2375
src = heappush ( A , ( B + 1 , ( C , D ) ) )
trg = heappush ( A , ( B + 1, ( C , D ) ) )
rst = heappush ( A , ( B + 1, ( C , D ) ) ) <eos>
2376
src = if calc ( A ) == 0 :
trg = calc ( A ) が 0 と 等 しい とき 、
rst = calc ( A ) が 0 と 等 しい とき 、 <eos>
2377
src = A . append ( ( - 1 , + 2 ) )
trg = A の 末 尾 に ( -1 、 2 に [MASK] を加えた 値 ) の 組 を追加する
rst = A の 末 尾 に ( -1 、 2 に [MASK] を加えた 値 ) の 組 を追加する <eos>
2378
src = A = max ( B + 1 , A )
trg = B に 1 を加えた 値 、 A の 最大 値を A とする
rst = B に 1 を加えた 値 、 A の 最大 値を A とする <eos>
2379
src = A = min ( B , C // D )
trg = B 、 C を D で 割 った 商 の 最小 値を A とする
rst = B 、 C を D で 割 った 商 の 最小 値を A とする <eos>
2380
src = A = str ( input ( ) )
trg = 入力された 文字列 の 文字列を A とする
rst = 入力された 文字列 の 文字列を A とする <eos>
2381
src = margeSort ( A , 0 , len ( A ) )
trg = margeSort ( A , 0 , len ( A ) )
rst = <unk> ( A , 0 , len ( A ) ) <eos>
2382
src = A = [ ( 0 , 0 ) , ( - 1 , 1 ) , ( 0 , 1 ) , ( 1 , 1 ) , ( 0 , 2 ) ]
trg = ( ( 0 、 0 ) の 組 、 ( -1 、 1 ) の 組 、 ( 0 、 1 ) の 組 、 ( 1 、 1 ) の 組 、 ( 0 、 2 ) の 組 ) からなる 列 を A とする
rst = ( ( 0 、 0 ) の 組 、 ( -1 、 1 ) の 組 、 ( 0 、 1 ) の 組 、 ( 1 、 1 ) の 組 、 ( 0 、 2 ) の 組 ) からなる 列 を A とする <eos>
2383
src = A = BIT ( dfs ( 0 , 1 ) )
trg = BIT ( dfs ( 0 , 1 ) ) を A とする
rst = BIT ( dfs ( 0 , 1 ) ) を A とする <eos>
2384
src = A . append ( ord ( B ) - C + 27 )
trg = A の 末 尾 に B の 順序 数 から C を 引 いた 値に 27 を加えた 値 を追加する
rst = A の 末 尾 に B の 順序 数 から C を 引 いた 値に 27 を加えた 値 を追加する <eos>
2385
src = A = [ 1 , 5 , 10 , 50 , 100 , 500 , 1000 ]
trg = ( 1 、 5 、 10 、 50 、 100 、 500 、 1000 ) からなる 列 を A とする
rst = ( 1 、 5 、 10 、 50 、 100 、 500 ) からなる 列 を A とする <eos>
2386
src = A . append ( B [ : C ] )
trg = A の 末 尾 に B の 、 つまり 先頭 から C 番 目 までの 部分 列 を追加する
rst = A の 末 尾 に B の 、 つまり 先頭 から C 番 目 までの 部分 列 を追加する <eos>
2387
src = print ( A if A else max ( B ) )
trg = A の とき A 、 そうでなければ B の 最大 値 を出力する
rst = A の とき A 、 そうでなければ B の 最大 値 を出力する <eos>
2388
src = A = [ 0 ] * 2019
trg = ( 0 ) からなる 列 の 2019 回 分 の 列 を A とする
rst = ( 0 ) からなる 列 の 2019 回 分 の 列 を A とする <eos>
2389
src = return A . ListIterator ( B )
trg = A . ListIterator ( B ) を返す
rst = A . _ restore ( B ) を返す <eos>
2390
src = A = [ B for B in range ( 10001 ) if C [ B ] ]
trg = 0 から 1000 1 未 満 までの 数 列 の 各要素 を B とし 、 C の B 番目の とき の B の 列 を A とする
rst = 0 から 1000 1 未 満 までの 数 列 の 各要素 を B とし 、 C の B 番目の とき の B の 列 を A とする <eos>
2391
src = return 0 < A < 1 and 0 < B < 1 and 0 < C < 1
trg = 0 が A より 小さい かどうか が 1 より 小さく かつ 0 が B より 小さい かどうか が 1 より 小さく かつ 0 が C より 小さい かどうか が 1 より 小さい かどうか を返す
rst = 0 が A より 小さい かどうか が 1 より 小さく かつ 0 が B より 小さい かどうか が 1 より 小さく かつ 0 が C より 小さい かどうか が 1 より 小さい かどうか を返す <eos>
2392
src = A = [ B for B , C in enumerate ( D ) if C [ 0 ] == ( E , F ) ] [ 0 ]
trg = D に 番号 付 した 組 の 列 の 各要素 を B 、 C とし 、 C の先頭 が ( E 、 F ) の 組 と 等 しい とき の B の 列 の先頭 を A とする
rst = D に 番号 付 した 組 の 列 の 各要素 を B 、 C とし 、 C の 0 番 目 が E と 等 しい とき の B の 列 の先頭 を A とする <eos>
2393
src = A . push ( 0 , B )
trg = A . push ( 0 , B )
rst = A . push ( 0 , B ) <eos>
2394
src = count = int ( input ( ) )
trg = 入力された 文字列 の 整数値 を 無限 の 整数 列 とする
rst = 入力された 文字列 の 整数値 を 無限 の 整数 列 とする <eos>
2395
src = if value ( A , B ) < value ( A , C ) :
trg = value ( A , B ) が value ( A , C ) より 小さい とき 、
rst = value ( A , B ) が value ( A , C ) より 小さい とき 、 <eos>
2396
src = A . sort ( key = lambda B : B [ 2 ] )
trg = x を パラメータ として x の 2 番 目 を返す関数 を key として A を ソート する
rst = x を パラメータ として x の 2 番 目 を返す関数 を key として A を ソート する <eos>
2397
src = A = ( A / 360 ) * 2 * math . pi
trg = A を 3 60 で 割 った 値に 2 を 掛 け た 値に 円 周 率 を 掛 け た 値を A とする
rst = A を 3 60 で 割 った 値に 2 を 掛 け た 値に 円 周 率 を 掛 け た 値を A とする <eos>
2398
src = A = ( B - 1 ) // 2
trg = B から 1 を 引 いた 値を 2 で 割 った 商 を A とする
rst = B から 1 を 引 いた 値を 2 で 割 った 商 を A とする <eos>
2399
src = A += B [ ( B . index ( C ) * D + E ) % 26 ]
trg = A を B の B の C と 等 しい 要素 の最初の 位置 に D を 掛 け た 値に E を加えた 値を 26 で 割 った 余 り 番 目 だけ 増加 させる
rst = A を B の B の C と 等 しい 要素 の最初の 位置 に D を 掛 け た 値に E を加えた 値を 26 で 割 った 余 り 番 目 だけ 増加 させる <eos>
2400
src = A = A [ B [ 2 ] >= A [ 2 ] ]
trg = A の B の 2 番 目 が A の 2 番 目 以上 かどうか 番 目 を A とする
rst = A の B の 2 番 目 が A の 2 番 目 以上 かどうか 番 目 を A とする <eos>
2401
src = A [ B ] = C = D + 1
trg = D に 1 を加えた 値を C とする を A の B 番 目 にする
rst = D に 1 を加えた 値を C とする を A の B 番 目 にする <eos>
2402
src = A = [ 1 , 1 ] + [ 0 ] * ( int ( input ( ) ) - 1 )
trg = ( 1 、 1 ) からなる 列 に ( 0 ) からなる 列 の 、 つまり 入力された 文字列 の 整数値 から 1 を 引 いた 値 回 分 の 列 を加えた 値を A とする
rst = ( 1 、 1 ) からなる 列 に ( 0 ) からなる 列 の 、 つまり 入力された 文字列 の 整数値 から 1 を 引 いた 値 回 分 の 列 を加えた 値を A とする <eos>
2403
src = print ( max_profit ( A ) )
trg = max _ profit ( A ) を出力する
rst = <unk> ( A ) を出力する <eos>
2404
src = return ( 0 , [ ] )
trg = ( 0 、 空 列 ) の 組 を返す
rst = ( 0 、 空 列 ) の 組 を返す <eos>
2405
src = if A == B [ C ] [ D ] and E [ C ] [ D ] == None :
trg = A が B の C 番目の D 番 目 と 等 しく かつ E の C 番目の D 番 目 が 、 つまり 未 定 値 と 等 しい とき 、
rst = A が B の C 番目の D 番 目 と 等 しく かつ E の C 番目の D 番 目 が 、 つまり 未 定 値 と 等 しい とき 、 <eos>
2406
src = D [ B - C ] += E
trg = D の B から C を 引 いた 値 番 目 を E だけ 増加 させる
rst = D の B から C を 引 いた 値 番 目 を E だけ 増加 させる <eos>
2407
src = if not 0 <= A :
trg = 0 が A 以下 でない とき 、
rst = 0 が A 以下 でない とき 、 <eos>
2408
src = if A <= B . limit and ( A % 12 == 1 or A % 12 == 5 ) :
trg = A が B の limit 以下 かつ A を 12 で 割 った 余 り が 1 と 等 しく または A を 12 で 割 った 余 り が 5 と 等 しい とき 、
rst = A が B の limit 以下 かつ A を 12 で 割 った 余 り が 1 と 等 しく または A を 12 で 割 った 余 り が 5 と 等 しい とき 、 <eos>
2409
src = A , B = 2 , 0
trg = 2 、 0 を A 、 B とする
rst = 2 、 0 を A 、 B とする <eos>
2410
src = A [ B ] [ C ] = D [ B ] [ E + C ]
trg = D の B 番目の E に C を加えた 値 番 目 を A の B 番目の C 番 目 にする
rst = D の B 番目の E に C を加えた 値 番 目 を A の B 番目の C 番 目 にする <eos>
2411
src = else = max ( A , B )
trg = A 、 B の 最大 値を そうでなければ 、 とする
rst = A 、 B の 最大 値を そうでなければ 、 とする <eos>
2412
src = if A . real >= 0 :
trg = A の real が 0 以上の とき 、
rst = A の real が 0 以上の とき 、 <eos>
2413
src = A . mask = 2 ** 64 - 1
trg = 2 の 64 乗 から 1 を 引 いた 値を A の mask にする
rst = 2 の 64 乗 から 1 を 引 いた 値を A の mask にする <eos>
2414
src = A = triangle_check ( B , C , D )
trg = triangle _ check ( B , C , D ) を A とする
rst = <unk> ( B , C , D ) を A とする <eos>
2415
src = print ( ( A [ B ] [ C ] [ D ] [ D ] + A [ B ] [ C ] [ E ] [ E ] ) % 100000 )
trg = A [ B ] [ C ] の D 番目の D 番 目 に A [ B ] [ C ] の E 番目の E 番 目 を加えた 値を 10 0000 で 割 った 余 り を出力する
rst = A [ B ] の C 番目の D 番 目 に A [ B ] の C 番目の E 番 目 を加えた 値を 10 0000 で 割 った 余 り を出力する <eos>
2416
src = A . printl ( 3 )
trg = A . printl ( 3 )
rst = A . postorder _ walk 3 <eos>
2417
src = A . append ( B [ C ] + ' ' + B [ D ] )
trg = A の 末 尾 に B の C 番 目 に 空白 文字 を加えた 値に B の D 番 目 を加えた 値 を追加する
rst = A の 末 尾 に B の C 番 目 に 空白 文字 を加えた 値に B の D 番 目 を加えた 値 を追加する <eos>
2418
src = enqueue ( 1 , A , B , C , D )
trg = enqueue ( 1, A , B , C , D )
rst = enqueue ( 1, A , B , C , D ) <eos>
2419
src = F = ( G + C ) % 60
trg = G に C を加えた 値を 60 で 割 った 余 り を F とする
rst = G に C を加えた 値を 60 で 割 った 余 り を F とする <eos>
2420
src = if A + 1 < B and C [ D ] [ A ] == C [ D ] [ A + 1 ] :
trg = A に 1 を加えた 値が B より 小さく かつ C の D 番目の A 番 目 が C の D 番目の A に 1 を加えた 値 番 目 と 等 しい とき 、
rst = A に 1 を加えた 値が B より 小さく かつ C の D 番目の A 番 目 が C の D 番目の A に 1 を加えた 値 番 目 と 等 しい とき 、 <eos>
2421
src = A = B [ C : C + 3 ]
trg = B の C 番 目 から C に 3 を加えた 値 までの 部分 列 を A とする
rst = B の C 番 目 から C に 3 を加えた 値 までの 部分 列 を A とする <eos>
2422
src = A = 2 ** 31
trg = 2 の 3 1 乗 を A とする
rst = 2 の 3 1 乗 を A とする <eos>
2423
src = A , B , C = D [ 0 ] , D [ 1 ] , E [ 0 ]
trg = D の先頭 、 D の 1 番 目 、 E の先頭 を A 、 B 、 C とする
rst = D の先頭 、 D の 1 番 目 、 E の先頭 を A 、 B 、 C とする <eos>
2424
src = if A + B [ C ] * D <= 1000 :
trg = A に B の C 番 目 に D を 掛 け た 値 を加えた 値が 1000 以下の とき 、
rst = A に B の C 番 目 に D を 掛 け た 値 を加えた 値が 1000 以下の とき 、 <eos>
2425
src = A [ 8 ] += 1
trg = A の 8 番 目 を 1 だけ 増加 させる
rst = A の 8 番 目 を 1 だけ 増加 させる <eos>
2426
src = A = ( B + e + C ) / 2
trg = B に ネ イ ピ ア 数 を加えた 値に C を加えた 値を 2 で 割 った 値を A とする
rst = B に ネ イ ピ ア 数 を加えた 値に C を加えた 値を 2 で 割 った 値を A とする <eos>
2427
src = A . append ( now )
trg = A の 末 尾 に 現在の 日 時 を追加する
rst = A の 末 尾 に 現在の 日 時 を追加する <eos>
2428
src = if A [ 3 ] == 1 :
trg = A の 3 番 目 が 1 と 等 しい とき 、
rst = A の 3 番 目 が 1 と 等 しい とき 、 <eos>
2429
src = A = A . par . to
trg = A の par の to を A とする
rst = A の par の to を A とする <eos>
2430
src = A [ B ] [ : ] = ( [ max ( C , D ) for C , D in zip ( A [ B ] , E ) ] )
trg = A の B 番 目 、 E の 要素を それぞれ 組 にした 列 の 各要素 を C 、 D とし 、 C 、 D の 最大 値の 列 を A の B 番目の 、 つまり 先頭 から 、 つまり 末 尾 までの 部分 列 にする
rst = A の B 番 目 、 E の 要素を それぞれ 組 にした 列 の 各要素 を C 、 D とし 、 C 、 D の 最大 値の 列 を A の B 番目の 、 つまり 先頭 から 、 つまり 末 尾 までの 部分 列 にする <eos>
2431
src = A = int ( B [ C ] [ D ] )
trg = B の C 番目の D 番目の 整数値 を A とする
rst = B の C 番目の D 番目の 整数値 を A とする <eos>
2432
src = print ( '' . join ( map ( str , A ) ) )
trg = 空文字列 を 間 に 入れ て A の 各要素 に 整数 を適用した 列 を 連結 した 文字列 を出力する
rst = 空文字列 を 間 に 入れ て A の 各要素 に 整数 を適用した 列 を 連結 した 文字列 を出力する <eos>
2433
src = for A in range ( 1 , B + 2 ) :
trg = 1 から B に 2 を加えた 値 未 満 までの 数 列 を 順に A として 、 繰り返す
rst = 1 から B に 2 を加えた 値 未 満 までの 数 列 を 順に A として 、 繰り返す <eos>
2434
src = A = 55
trg = 5 5 を A とする
rst = 10 4 6 5 27 を A とする <eos>
2435
src = print ( [ sum ( A ) for A in combinations ( range ( 10 ) , B ) ] . count ( C ) )
trg = 0 から 10 未 満 までの 数 列 の B 個 までの コン ビ ネ ー ション の 各要素 を A とし 、 A の 総 和 の 列 内の C の 出現 回数 を出力する
rst = 0 から 10 未 満 までの 数 列 の B 個 までの コン ビ ネ ー ション の 各要素 を A とし 、 A の 総 和 の 列 内の C の 出現 回数 を出力する <eos>
2436
src = A = B . op ( C , B . rt [ - 1 ] [ 1 ] )
trg = B . op ( C , B . rt [ -1 ] [ 1 ] ) を A とする
rst = B . op ( C , B . rt [ -1 ] [ 1 ] ) を A とする <eos>
2437
src = if A [ B ] [ C ] and D [ C ] == E :
trg = A の B 番目の C 番 目 かつ D の C 番 目 が E と 等 しい とき 、
rst = A の B 番目の C 番 目 かつ D の C 番 目 が E と 等 しい とき 、 <eos>
2438
src = if A < inf :
trg = A が 、 つまり 無限大 より 小さい とき 、
rst = A が 、 つまり 無限大 より 小さい とき 、 <eos>
2439
src = A = [ ( A [ 0 ] , A [ 1 ] ) for A in B if C . count ( [ A [ 0 ] , A [ 1 ] ] ) >= D ]
trg = B の 各要素 を A とし 、 C 内の ( A の先頭 、 A の 1 番 目 ) からなる 列 の 出現 回数 が D 以上の とき の ( A の先頭 、 A の 1 番 目 ) の 組 の 列 を A とする
rst = B の 各要素 を A とし 、 C 内の A の先頭 の 出現 回数 が A の先頭 と 等 しく ない とき の A の 1 番目の 列 を A とする <eos>
2440
src = print ( str ( A [ 0 ] ) + ' ' + str ( A [ B ] ) + ' ' + str ( C ) )
trg = str ( A [ 0 ] ) に ' ' を加えた 値に A [ B ] の 文字列 を加えた 値に 空白 文字 を加えた 値に C の 文字列 を加えた 値 を出力する
rst = str ( A [ 0 ] ) に ' ' を加えた 値に A [ B ] の 文字列 を加えた 値に 空白 文字 を加えた 値に C の 文字列 を加えた 値 を出力する <eos>
2441
src = A = B [ C ] + D - B [ E ]
trg = B の C 番 目 に D を加えた 値 から B の E 番 目 を 引 いた 値を A とする
rst = B の C 番 目 に D を加えた 値 から B の E 番 目 を 引 いた 値を A とする <eos>
2442
src = A = B / 6
trg = B を 6 で 割 った 値を A とする
rst = B を 6 で 割 った 値を A とする <eos>
2443
src = A = B . most_common ( 1 )
trg = B の 上位 1 個の 出現 頻 度 順 の 列 を A とする
rst = B の 上位 1 個の 出現 頻 度 順 の 列 を A とする <eos>
2444
src = A = math . sin ( B ) * math . cos ( C )
trg = B の 正 弦 に C の 余 弦 を 掛 け た 値を A とする
rst = B の 正 弦 に C の 余 弦 を 掛 け た 値を A とする <eos>
2445
src = answer ( A , True )
trg = answer ( A , True )
rst = <unk> ( A , True ) <eos>
2446
src = A , B = C . readline ( ) . strip ( ) . split ( )
trg = C から 読み 込 んだ 一行 の 両 端 から 空白 改行 を取り 除 いた 文字列を 空白 で 分割 した 字句 列 を 展開 し 、 それぞれ A 、 B とする
rst = C から 読み 込 んだ 一行 の 両 端 から 空白 改行 を取り 除 いた 文字列を 空白 で 分割 した 字句 列 を 展開 し 、 それぞれ A 、 B とする <eos>
2447
src = A = dice ( B [ C ] . pip )
trg = dice ( B [ C ] . pip ) を A とする
rst = dice ( B [ C ] . pip ) を A とする <eos>
2448
src = A . append ( B . min ( C [ 0 ] , C [ 1 ] ) )
trg = A の 末 尾 に B . min ( C [ 0 ] , C [ 1 ] ) を追加する
rst = A の 末 尾 に B . min ( C [ 0 ] , C [ 1 ] ) を追加する <eos>
2449
src = A = B * ( C - D ) + E * ( F - G ) + H * ( I - J )
trg = B に C から D を 引 いた 値を 掛 け た 値に E に F から G を 引 いた 値を 掛 け た 値 を加えた 値に H に I から J を 引 いた 値を 掛 け た 値 を加えた 値を A とする
rst = B に C から D を 引 いた 値を 掛 け た 値に E に F から G を 引 いた 値を 掛 け た 値 を加えた 値に H に I から J を 引 いた 値を 掛 け た 値 を加えた 値を A とする <eos>
2450
src = A . append ( sum ( list ( map ( int , input ( ) . split ( ) ) ) ) )
trg = A の 末 尾 に input () を 空白 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 のリスト の 総 和 を追加する
rst = A の 末 尾 に input () を 空白 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 のリスト の 総 和 を追加する <eos>
2451
src = return A . is_orthogonal ( B , C )
trg = A . is _ orthogonal ( B , C ) を返す
rst = A . is _ orthogonal ( B , C ) を返す <eos>
2452
src = print ( [ A , B ] [ dfs ( 7 , 7 , 1 ) ] )
trg = ( A 、 B ) からなる 列 の dfs ( 7 , 7 , 1 ) 番 目 を出力する
rst = ( A 、 B ) からなる 列 の dfs ( 7 , 7 , 1 ) 番 目 を出力する <eos>
2453
src = A = B . rfind ( C )
trg = B の 末 尾 から C を 逆 順に 探 して 見つかった 位置 を A とする
rst = B . <unk> _ from ( C ) を A とする <eos>
2454
src = if ( A + B <= C ) or ( A + B <= D and ( E + F [ A + B ] - G ) == ( A + B - C ) ) :
trg = A に B を加えた 値が C 以下 または A に B を加えた 値が D 以下 かつ E に F [ A + B ] を加えた 値 から G を 引 いた 値が A に B を加えた 値 から C を 引 いた 値 と 等 しい とき 、
rst = A に B を加えた 値が C 以下 または A に B を加えた 値が D 以下 かつ E に F の A + B 番 目 を加えた 値が G から A に B を加えた 値を 引 いた 値 と 等 しい とき 、 <eos>
2455
src = return ( A , B , C , D , E , F )
trg = ( A 、 B 、 C 、 D 、 E 、 F ) の 組 を返す
rst = ( A 、 B 、 C 、 D 、 E 、 F ) の 組 を返す <eos>
2456
src = for A , B in zip ( C , D ) :
trg = C 、 D の 要素を それぞれ 組 にした 列 を 順に A 、 B として 、 繰り返す
rst = C 、 D の 要素を それぞれ 組 にした 列 を 順に A 、 B として 、 繰り返す <eos>
2457
src = A = dfs ( B + 1 , C // 10 )
trg = dfs ( B + 1, C / / 10 ) を A とする
rst = dfs ( B + 1, C / 10 ) を A とする <eos>
2458
src = if not A . connected ( e . src , e . dest ) :
trg = A . connected ( e . src , e . dest ) でない とき 、
rst = A . connected ( e . src , e . dest ) でない とき 、 <eos>
2459
src = A = matrix ( )
trg = matrix () を A とする
rst = <unk> () を A とする <eos>
2460
src = D = - E - F
trg = - E から F を 引 いた 値を D とする
rst = - E から F を 引 いた 値を D とする <eos>
2461
src = if A >= 50 :
trg = A が 50 以上の とき 、
rst = A が 50 以上の とき 、 <eos>
2462
src = A = min ( A , abs ( ( B - C ) * D + ( E - F ) ) )
trg = A 、 B から C を 引 いた 値に D を 掛 け た 値に E から F を 引 いた 値 を加えた 値の 絶対 値の 最小 値を A とする
rst = A 、 B から C を 引 いた 値に D を 掛 け た 値に E から F を 引 いた 値 を加えた 値の 絶対 値の 最小 値を A とする <eos>
2463
src = if A [ : B - C ] != D [ C : B ] :
trg = A の 、 つまり 先頭 から B から C を 引 いた 値 までの 部分 列 が D の C 番 目 から B 番 目 までの 部分 列 と 等 しく ない とき 、
rst = A の 、 つまり 先頭 から B から C を 引 いた 値 までの 部分 列 が D の C 番 目 から B 番 目 までの 部分 列 と 等 しく ない とき 、 <eos>
2464
src = A = C if B == 3 else C + D * ( B - 1 )
trg = B が 3 と 等 しい とき C 、 そうでなければ C に D に B から 1 を 引 いた 値を 掛 け た 値 を加えた 値を A とする
rst = B が 3 と 等 しい とき C 、 そうでなければ C に D に B から 1 を 引 いた 値を 掛 け た 値 を加えた 値を A とする <eos>
2465
src = if A [ : 2 ] == B and A [ - 1 ] == C and D in A :
trg = A の 、 つまり 先頭 から 2 番 目 までの 部分 列 が B と 等 しく かつ A の 末 尾 が C と 等 しく かつ D が A に含まれる とき 、
rst = A の 、 つまり 先頭 から 2 番 目 までの 部分 列 が B と 等 しく かつ A の -1 番 目 が C と 等 しく かつ D が A に含まれる とき 、 <eos>
2466
src = print ( B if A == 1 or A == 6 else C )
trg = A が 1 と 等 しく または A が 6 と 等 しい とき B 、 そうでなければ C を出力する
rst = A が 1 と 等 しく または A が 6 と 等 しい とき B 、 そうでなければ C を出力する <eos>
2467
src = A = int ( math . log ( B , 4 ) )
trg = 4 を 底 とする B の 対 数の 整数値 を A とする
rst = 4 を 底 とする B の 対 数の 整数値 を A とする <eos>
2468
src = A = ( B * ( 100 + C ) // 100 ) + ( D * ( 100 + C ) // 100 )
trg = B に 100 に C を加えた 値を 掛 け た 値を 100 で 割 った 商 に D に 100 に C を加えた 値を 掛 け た 値を 100 で 割 った 商 を加えた 値を A とする
rst = B に 100 に C を加えた 値を 掛 け た 値を 100 で 割 った 商 に D に 100 に C を加えた 値を 掛 け た 値を 100 で 割 った 商 を加えた 値を A とする <eos>
2469
src = A += max ( abs ( B - C ) , abs ( D - E ) ) if ( B - C ) * ( D - E ) > 0 else abs ( B - C ) + abs ( D - E )
trg = A を B から C を 引 いた 値に D から E を 引 いた 値を 掛 け た 値が 0 より 大きい とき B から C を 引 いた 値の 絶対 値 、 D から E を 引 いた 値の 絶対 値の 最大 値 、 そうでなければ B から C を 引 いた 値の 絶対 値に D から E を 引 いた 値の 絶対 値 を加えた 値 だけ 増加 させる
rst = A を B から C を 引 いた 値の 絶対 値が D から E を 引 いた 値の 絶対 値 より 大きい とき B から C を 引 いた 値の 絶対 値 、 D から E を 引 いた 値の 絶対 値を 引 いた 値の 絶対 値が 0 より 大きい
2470
src = A . root = None
trg = 未 定 値を A の root にする
rst = 未 定 値を A の root にする <eos>
2471
src = A = ( ( B & 1 ) > 0 )
trg = B と 1 の 論理 積 が 0 より 大きい かどうか を A とする
rst = B と 1 の 論理 積 が 0 より 大きい かどうか を A とする <eos>
2472
src = for A in range ( len ( B [ 0 ] ) - 2 , - 1 , - 1 ) :
trg = B の先頭 の長さ から 2 を 引 いた 値 から -1 未 満 までの -1 間隔 の 数 列 を 順に A として 、 繰り返す
rst = B の先頭 の長さ から 2 を 引 いた 値 から -1 未 満 までの -1 間隔 の 数 列 を 順に A として 、 繰り返す <eos>
2473
src = A = [ 13 , 17 , 19 , 23 ]
trg = ( 13 、 17 、 19 、 23 ) からなる 列 を A とする
rst = ( 13 、 19 、 23 ) からなる 列 を A とする <eos>
2474
src = if 0 <= A < 8 and 0 <= B < 8 :
trg = 0 が A 以下 かどうか が 8 より 小さく かつ 0 が B 以下 かどうか が 8 より 小さい とき 、
rst = 0 が A 以下 かどうか が 8 より 小さく かつ 0 が B 以下 かどうか が 8 より 小さい とき 、 <eos>
2475
src = A = B [ C ] + B [ C + 1 ]
trg = B の C 番 目 に B の C に 1 を加えた 値 番 目 を加えた 値を A とする
rst = B の C 番 目 に B の C に 1 を加えた 値 番 目 を加えた 値を A とする <eos>
2476
src = if A [ B ] [ C ] [ D ] == 0 :
trg = A の B 番目の C 番目の D 番 目 が 0 と 等 しい とき 、
rst = A の B 番目の C 番目の D 番 目 が 0 と 等 しい とき 、 <eos>
2477
src = A . append ( B . hldnxt [ C ] )
trg = A の 末 尾 に B の hldnxt の C 番 目 を追加する
rst = A の 末 尾 に B の hldnxt の C 番 目 を追加する <eos>
2478
src = if A [ B ] >= C - D - E [ B ] :
trg = A の B 番 目 が C から D を 引 いた 値 から E の B 番 目 を 引 いた 値 以上の とき 、
rst = A の B 番 目 が C から D を 引 いた 値 から E の B 番 目 を 引 いた 値 以上の とき 、 <eos>
2479
src = A , B [ C ] = B [ C ] , None
trg = B の C 番 目 、 未 定 値を A 、 B の C 番 目 とする
rst = B の C 番 目 、 未 定 値を A 、 B の C 番 目 とする <eos>
2480
src = for A in range ( B ) :
trg = 0 から B 未 満 までの 数 列 を 順に A として 、 繰り返す
rst = 0 から B 未 満 までの 数 列 を 順に A として 、 繰り返す <eos>
2481
src = if A == 1 or B == 1 :
trg = A が 1 と 等 しく または B が 1 と 等 しい とき 、
rst = A が 1 と 等 しく または B が 1 と 等 しい とき 、 <eos>
2482
src = A . roll ( B . SOUTH )
trg = A . roll ( B . SOUTH )
rst = A . roll ( B . <unk> ) <eos>
2483
src = A = combinations_with_replacement ( B , 2 )
trg = B の 2 個 までの 重複 コン ビ ネ ー ション を A とする
rst = B の 2 個 までの コン ビ ネ ー ション を A とする <eos>
2484
src = for A in product ( [ 0 , 1 ] , repeat = 10 ) :
trg = 10 を repeat として ( 0 、 1 ) からなる 列 と [MASK] の 直 積 を 順に A として 、 繰り返す
rst = 10 を repeat として ( 0 、 1 ) からなる 列 と [MASK] の 直 積 を 順に A として 、 繰り返す <eos>
2485
src = A = [ - 1 , 0 , 1 , - 2 , - 2 , - 2 , 2 , 2 , 2 , - 1 , 0 , 1 ]
trg = ( -1 、 0 、 1 、 -2 、 -2 、 -2 、 2 、 2 、 2 、 -1 、 0 、 1 ) からなる 列 を A とする
rst = ( -1 、 0 、 1 、 -1 、 -2 、 2 、 2 、 2 、 -1 、 2 、 -1 、 0 、 1 ) からなる 列 を A とする <eos>
2486
src = return solve_gcd ( A [ 0 ] , B )
trg = solve _ gcd ( A [ 0 ] , B ) を返す
rst = <unk> ( A [ 0 ] , B ) を返す <eos>
2487
src = A = [ B * ( C + 2 ) ] + [ B + input ( ) + B for D in range ( E ) ] + [ B * ( C + 2 ) ]
trg = ( B に C に 2 を加えた 値を 掛 け た 値 ) からなる 列 に 0 から E 未 満 までの 数 列 の 各要素 を D とし 、 B に input () を加えた 値に B を加えた 値の 列 を加えた 値に ( B に C に 2 を加えた 値を 掛 け た 値 ) からなる 列 を加えた 値を A とする
rst = ( B に C に 2 を加えた 値を 掛 け た 値 ) からなる 列 に 0 から E 未 満 までの 数 列 の 各要素 を D とし 、 B + input () に B を加えた 値の 列 を加えた 値に ( B に ( C + 2 ) を
2488
src = A . rank = [ ]
trg = 空 列 を A の rank にする
rst = 空 列 を A の rank にする <eos>
2489
src = A = [ [ 0 , 0 ] ] * 6
trg = ( ( 0 、 0 ) からなる 列 ) からなる 列 の 6 回 分 の 列 を A とする
rst = ( ( 0 、 0 ) からなる 列 の 6 回 分 の 列 ) からなる 列 を A とする <eos>
2490
src = A . replace ( B , C , D )
trg = A 内の B を C 、 D で 置き換え た 文字列
rst = A 内の B を C 、 D で 置き換え た 文字列 <eos>
2491
src = A = min ( A , 1 )
trg = A 、 1 の 最小 値を A とする
rst = A 、 1 の 最小 値を A とする <eos>
2492
src = A . push ( None )
trg = A . push ( None )
rst = A . push ( None ) <eos>
2493
src = A [ B ] [ C - D - 1 ] = 0
trg = 0 を A の B 番目の C から D を 引 いた 値 から 1 を 引 いた 値 番 目 にする
rst = 0 を A の B 番目の C から D を 引 いた 値 から 1 を 引 いた 値 番 目 にする <eos>
2494
src = return A - 10
trg = A から 10 を 引 いた 値を返す
rst = A から 10 を 引 いた 値を返す <eos>
2495
src = print ( A , B [ 0 ] - 1989 + 1 , B [ 1 ] , B [ 2 ] )
trg = A 、 B の 0 番 目 から 1989 を 引 いた 値に 1 を加えた 値 、 B の 1 番 目 、 B の 2 番 目 を出力する
rst = A 、 B の 0 番 目 から 1989 を 引 いた 値に 1 を加えた 値 、 B の 1 番 目 、 B の 2 番 目 を出力する <eos>
2496
src = A += calc ( [ B , C , D , E , F - 1 ] ) * G [ 4 ]
trg = A を calc ( [ B , C , D , E , F -1 ] ) に G の 4 番 目 を 掛 け た 値 だけ 増加 させる
rst = A を calc ( [ B , C , D , E , F -1 ] ) に G の 4 番 目 を 掛 け た 値 だけ 増加 させる <eos>
2497
src = for A in range ( 1 , 14 ) :
trg = 1 から 14 未 満 までの 数 列 を 順に A として 、 繰り返す
rst = 1 から 14 未 満 までの 数 列 を 順に A として 、 繰り返す <eos>
2498
src = A = 2 + B
trg = 2 に B を加えた 値を A とする
rst = 2 に B を加えた 値を A とする <eos>
2499
src = A = abs ( B . cross ( Vector ( B . pt1 , C . pt1 ) ) )
trg = B . cross ( Vector ( B . pt 1, C . pt 1 ) ) の 絶対 値を A とする
rst = B . cross ( Vector ( B . pt 1, C . pt 1 ) ) の 絶対 値を A とする <eos>
2500
src = return A . find ( B ) != A . find ( C )
trg = A の先頭 から B を 探 して 見つかった 位置 が A の先頭 から C を 探 して 見つかった 位置 と 等 しく ない かどうか を返す
rst = A の先頭 から B を 探 して 見つかった 位置 が A の先頭 から C を 探 して 見つかった 位置 と 等 しく ない かどうか を返す <eos>
2501
src = if ( A * B + C * D ) % ( A ** 2 + C ** 2 ) < 1 and ( A * D - C * B ) % ( A ** 2 + C ** 2 ) < 1 :
trg = A に B を 掛 け た 値に C に D を 掛 け た 値 を加えた 値を A の 2 乗 に C の 2 乗 を加えた 値 で 割 った 余 り が 1 より 小さく かつ A に D を 掛 け た 値 から C に B を 掛 け た 値を 引 いた 値を A の 2 乗 に C の 2 乗 を加えた 値 で 割 った 余 り が 1 より 小さい とき
rst = A に B を 掛 け た 値に C に D を 掛 け た 値 を加えた 値を A の 2 乗 に C の 2 乗 を加えた 値 で 割 った 余 り が 1 に A に D を 掛 け た 値 から C に B の
2502
src = if A in [ B , C ] :
trg = A が ( B 、 C ) からなる 列 に含まれる とき 、
rst = A が ( B 、 C ) からなる 列 に含まれる とき 、 <eos>
2503
src = A += abs ( B - C ) + abs ( D - E )
trg = A を B から C を 引 いた 値の 絶対 値に D から E を 引 いた 値の 絶対 値 を加えた 値 だけ 増加 させる
rst = A を B から C を 引 いた 値の 絶対 値に D から E を 引 いた 値の 絶対 値 を加えた 値 だけ 増加 させる <eos>
2504
src = post_from_pre_in ( A , B )
trg = post _ from _ pre _ in ( A , B )
rst = <unk> ( A , B ) <eos>
2505
src = if A [ int ( B . imag + C . imag ) ] [ int ( B . real + C . real ) ] :
trg = A の B の imag に C の imag を加えた 値の 整数値 番目の B の real に C の real を加えた 値の 整数値 番目の とき 、
rst = A の B の imag に C の imag を加えた 値の 整数値 番目の B の real に C の real を加えた 値の 整数値 番目の とき 、 <eos>
2506
src = if A - B >= 6 and C [ B ] in D and C [ B + 1 ] and C [ B + 1 ] in E and C [ A - 1 ] in F :
trg = A - B が 6 以上 かつ C [ B ] が D に 含まれ かつ C の B に 1 を加えた 値 番 目 かつ C の B に 1 を加えた 値 番 目 が E に 含まれ かつ C の A から 1 を 引 いた 値 番 目 が F に含まれる とき 、
rst = A から B を 引 いた 値が 6 以上 かつ C の B 番 目 が D に 含まれ かつ C の B に 1 を加えた 値 番 目 が E に 含まれ かつ C の B に 1 を加えた 値 番 目 が C の A から 1 を
2507
src = if A . index ( B ) + 1 < 2020 and A [ A . index ( B ) + 1 ] == 200 :
trg = A の B と 等 しい 要素 の最初の 位置 に 1 を加えた 値が 2020 より 小さく かつ A の A の B と 等 しい 要素 の最初の 位置 に 1 を加えた 値 番 目 が 200 と 等 しい とき 、
rst = A の B と 等 しい 要素 の最初の 位置 に 1 を加えた 値が 2020 より 小さく かつ A の A . index ( B ) に 1 を加えた 値 番 目 が 200 と 等 しい とき 、 <eos>
2508
src = A = abs ( B [ C ] - D [ C ] )
trg = B の C 番 目 から D の C 番 目 を 引 いた 値の 絶対 値を A とする
rst = B の C 番 目 から D の C 番 目 を 引 いた 値の 絶対 値を A とする <eos>
2509
src = print ( A [ B ] if A [ B ] < C else D )
trg = A の B 番 目 が C より 小さい とき A の B 番 目 、 そうでなければ D を出力する
rst = A の B 番 目 が C より 小さい とき A の B 番 目 、 そうでなければ D を出力する <eos>
2510
src = while A and B + 10 <= 21 :
trg = A かつ B に 10 を加えた 値が 21 以下の 間 、 次 を 繰り返す
rst = A かつ B に 10 を加えた 値が 21 以下の 間 、 次 を 繰り返す <eos>
2511
src = for A in range ( 1 , 12 + 1 ) :
trg = 1 から 12 に 1 を加えた 値 未 満 までの 数 列 を 順に A として 、 繰り返す
rst = 1 から 12 に 1 を加えた 値 未 満 までの 数 列 を 順に A として 、 繰り返す <eos>
2512
src = while A != B and C == A . right :
trg = A が B と 等 しく なく かつ C が A の right と 等 しい 間 、 次 を 繰り返す
rst = A が B と 等 しく なく かつ C が A の right と 等 しい 間 、 次 を 繰り返す <eos>
2513
src = for A in range ( ceil ( log ( 1e6 , 5 ) ) + 1 ) :
trg = 0 から 5 を 底 とする 1 e 6 の 対 数の 切り 上げ 整数値 に 1 を加えた 値 未 満 までの 数 列 を 順に A として 、 繰り返す
rst = 0 から 5 を 底 とする 1 e 5 の 対 数の 切り 上げ 整数値 に 1 を加えた 値 未 満 までの 数 列 を 順に A として 、 繰り返す <eos>
2514
src = C = 1
trg = 1 を C とする
rst = 1 を C とする <eos>
2515
src = e = A [ B - C ]
trg = A の B から C を 引 いた 値 番 目 を ネ イ ピ ア 数 とする
rst = A の B から C を 引 いた 値 番 目 を ネ イ ピ ア 数 とする <eos>
2516
src = for A in range ( 2 , len ( B ) , 2 ) :
trg = 2 から B の長さ 未 満 までの 2 間隔 の 数 列 を 順に A として 、 繰り返す
rst = 2 から B の長さ 未 満 までの 2 間隔 の 数 列 を 順に A として 、 繰り返す <eos>
2517
src = if A [ 2 ] [ 1 ] == A [ 0 ] [ 1 ] :
trg = A の 2 番目の 1 番 目 が A の先頭 の 1 番 目 と 等 しい とき 、
rst = A の 2 番目の 1 番 目 が A の先頭 の 1 番 目 と 等 しい とき 、 <eos>
2518
src = for A , B in zip ( range ( C , 0 , - 1 ) , D ) :
trg = C から 0 未 満 までの -1 間隔 の 数 列 、 D の 要素を それぞれ 組 にした 列 を 順に A 、 B として 、 繰り返す
rst = C から 0 未 満 までの -1 間隔 の 数 列 、 D の 要素を それぞれ 組 にした 列 を 順に A 、 B として 、 繰り返す <eos>
2519
src = return ( A * 1.0 , B * 1.0 )
trg = ( A に 1.0 を 掛 け た 値 、 B に 1.0 を 掛 け た 値 ) の 組 を返す
rst = ( A に 1.0 を 掛 け た 値 、 B に 1.0 を 掛 け た 値 ) の 組 を返す <eos>
2520
src = A . slope = float ( B )
trg = B の 浮動小数点数 を A の slope にする
rst = B の 浮動小数点数 を A の slope にする <eos>
2521
src = A = f ( B ) // 10
trg = f ( B ) を 10 で 割 った 商 を A とする
rst = f ( B ) を 10 で 割 った 商 を A とする <eos>
2522
src = A = min ( B , key = lambda C : C . real )
trg = x を パラメータ として x の real を返す関数 を key として B の 最小 値を A とする
rst = x を パラメータ として x の real を返す関数 を key として B の 最小 値を A とする <eos>
2523
src = A = bst_insert ( A , B )
trg = bst _ insert ( A , B ) を A とする
rst = bst _ insert ( A , B ) を A とする <eos>
2524
src = A [ B ] [ C ] . remove ( D )
trg = A の B 番目の C 番 目 内の D と 等 しい 要素を 取り除く
rst = A の B 番目の C 番 目 内の D と 等 しい 要素を 取り除く <eos>
2525
src = A = compute_lcs ( B , C )
trg = compute _ lcs ( B , C ) を A とする
rst = <unk> ( B , C ) を A とする <eos>
2526
src = if 1 < len ( A [ B ] ) :
trg = 1 が A の B 番目の 長さ より 小さい とき 、
rst = 1 が A の B 番目の 長さ より 小さい とき 、 <eos>
2527
src = if A > 2 * B :
trg = A が 2 に B を 掛 け た 値 より 大きい とき 、
rst = A が 2 に B を 掛 け た 値 より 大きい とき 、 <eos>
2528
src = A = 15001
trg = 1 500 1 を A とする
rst = 10 4 6 5 27 を A とする <eos>
2529
src = A = B . index ( min ( B ) )
trg = B の B の 最小 値 と 等 しい 要素 の最初の 位置 を A とする
rst = B の B の 最小 値 と 等 しい 要素 の最初の 位置 を A とする <eos>
2530
src = A . append ( [ A [ B ] [ 0 ] , A [ B ] [ 1 ] + 1 ] )
trg = A の 末 尾 に ( A の B 番目の 先頭 、 A の B 番目の 1 番 目 に 1 を加えた 値 ) からなる 列 を追加する
rst = A の 末 尾 に ( A の B 番目の 先頭 、 A の B 番目の 1 番 目 に 1 を加えた 値 ) からなる 列 を追加する <eos>
2531
src = if A < 5 :
trg = A が 5 より 小さい とき 、
rst = A が 5 より 小さい とき 、 <eos>
2532
src = A [ 0 ] [ B [ C ] ] = 1
trg = 1 を A の先頭 の B の C 番 目 番 目 にする
rst = 1 を A の先頭 の B の C 番 目 番 目 にする <eos>
2533
src = print ( Euc ( A , B , C ) [ 0 ] , Euc ( A , B , C ) [ 1 ] )
trg = Euc ( A , B , C ) の先頭 、 Euc ( A , B , C ) の 1 番 目 を出力する
rst = <unk> ( A , B , C ) の先頭 、 <unk> ( A , B , C ) の 1 番 目 を出力する <eos>
2534
src = return max ( A , B )
trg = A 、 B の 最大 値を返す
rst = A 、 B の 最大 値を返す <eos>
2535
src = A = comb ( B , C , A )
trg = B と C 、 A の コン ビ ネ ー ション を A とする
rst = B 、 C 、 A の コン ビ ネ ー ション を A とする <eos>
2536
src = if A [ 2 * B + 1 ] < 4 :
trg = A の 2 に B を 掛 け た 値に 1 を加えた 値 番 目 が 4 より 小さい とき 、
rst = A の 2 に B を 掛 け た 値に 1 を加えた 値 番 目 が 4 より 小さい とき 、 <eos>
2537
src = print ( max ( max_param ( A ) , max_param ( B ) , max_param ( C ) ) )
trg = max _ param ( A ) 、 max _ param ( B ) 、 max _ param ( C ) の 最大 値 を出力する
rst = <unk> ( A ) 、 <unk> ( B ) 、 <unk> ( C ) の 最大 値 を出力する <eos>
2538
src = if A [ B ] [ 1 ] != A [ B - 1 ] [ 1 ] :
trg = A の B 番目の 1 番 目 が A の B から 1 を 引 いた 値 番目の 1 番 目 と 等 しく ない とき 、
rst = A の B 番目の 1 番 目 が A の B から 1 を 引 いた 値 番目の 1 番 目 と 等 しく ない とき 、 <eos>
2539
src = return A [ B ] - A [ B - C ] - A [ B - D ] - A [ B - E ] + A [ B - ( C + D ) ] + A [ B - ( D + E ) ] + A [ B - ( E + C ) ] - A [ B - ( C + D + E ) ]
trg = A [ B ]- A [ B - C ]- A [ B - D ] から A [ B - E ] を 引 いた 値に A の B - ( C + D ) 番 目 を加えた 値に A の B から ( D + E ) を 引 いた 値 番 目 を加えた 値に A の B から E に C を加えた 値を 引 いた 値 番 目 を加えた 値 から A の B から C に
rst = A の B 番 目 から A の B から C を 引 いた 値 番 目 を 引 いた 値 から A の B から D を 引 いた 値 番 目 を 引 いた 値に A の B から E を 引 いた 値 番 目 を加えた 値に
2540
src = if e == 1 :
trg = ネ イ ピ ア 数が 1 と 等 しい とき 、
rst = ネ イ ピ ア 数が 1 と 等 しい とき 、 <eos>
2541
src = A [ B ] = min ( A [ B ] , A [ C ] + D [ C ] [ B ] )
trg = A の B 番 目 、 A の C 番 目 に D の C 番目の B 番 目 を加えた 値の 最小 値を A の B 番 目 にする
rst = A の B 番 目 、 A の C 番 目 に D の C 番目の B 番 目 を加えた 値の 最小 値を A の B 番 目 にする <eos>
2542
src = return sum ( [ 1 for A in range ( B . size ) if test ( A ) ] )
trg = 0 から B の size 未 満 までの 数 列 の 各要素 を A とし 、 test ( A ) の とき の 1 の 列 の 総 和 を返す
rst = 0 から B の size 未 満 までの 数 列 の 各要素 を A とし 、 test ( A ) の とき の 1 の 列 の 総 和 を返す <eos>
2543
src = return A ** ( 1.0 / B )
trg = A の 1.0 を B で 割 った 値 乗 を返す
rst = A の 1.0 を B で 割 った 値 乗 を返す <eos>
2544
src = A . siz -= 1
trg = A の siz を 1 だけ 減少 させる
rst = A の siz を 1 だけ 減少 させる <eos>
2545
src = A , B = scc ( C , D , E )
trg = scc ( C , D , E ) を 展開 し 、 それぞれ A 、 B とする
rst = parse _ node ( C , D , E ) を 展開 し 、 それぞれ A 、 B とする <eos>
2546
src = A , B , C , D , e , E = [ float ( F ) for F in G [ H ] . split ( ) ]
trg = G の H 番 目 を 空白 で 分割 した 字句 列 の 各要素 を F とし 、 F の 浮動小数点数 の 列 を 展開 し 、 それぞれ A 、 B 、 C 、 D 、 ネ イ ピ ア 数 、 E とする
rst = G の H 番 目 を 空白 で 分割 した 字句 列 の 各要素 を F とし 、 F の 浮動小数点数 の 列 を 展開 し 、 それぞれ A 、 B 、 C 、 D 、 ネ イ ピ ア 数 、 E とする <eos>
2547
src = A += [ 0 , 1 ] [ B == B [ : : - 1 ] ]
trg = A を ( 0 、 1 ) からなる 列 の B が B の 逆 順 と 等 しい かどうか 番 目 だけ 増加 させる
rst = A を ( 0 、 1 ) からなる 列 の B が B の 逆 順 と 等 しい かどうか 番 目 だけ 増加 させる <eos>
2548
src = pop ( )
trg = pop ()
rst = pop () <eos>
2549
src = A [ ( B , C ) ] += [ D + E for D in A [ ( B , C - 1 ) ] ]
trg = A の ( B 、 C ) の 組 番 目 を A の ( B 、 C から 1 を 引 いた 値 ) の 組 番目の 各要素 を D とし 、 D に E を加えた 値の 列 だけ 増加 させる
rst = A の ( B 、 C ) の 組 番 目 を ( A の ( B 、 C から 1 を 引 いた 値 ) の 組 番目の 各要素 を D とし 、 D に E を加えた 値の 列 だけ 増加 させる <eos>
2550
src = if A . a == float ( B ) :
trg = A の a が B の 浮動小数点数 と 等 しい とき 、
rst = A の a が B の 浮動小数点数 と 等 しい とき 、 <eos>
2551
src = A = ( 5 + B ) / 5
trg = 5 に B を加えた 値を 5 で 割 った 値を A とする
rst = 5 に B を加えた 値を 5 で 割 った 値を A とする <eos>
2552
src = return A
trg = A を返す
rst = A を返す <eos>
2553
src = A = B . MAXV
trg = B の MAXV を A とする
rst = B の <unk> を A とする <eos>
2554
src = return len ( A ) - A . count ( B )
trg = A の長さ から A 内の B の 出現 回数 を 引 いた 値を返す
rst = A の長さ から A 内の B の 出現 回数 を 引 いた 値を返す <eos>
2555
src = A = set ( [ B for B in C if B . issubset ( D ) ] )
trg = C の 各要素 を B とし 、 B が D の 部分 集合 の とき の B の 列 の集合 を A とする
rst = C の 各要素 を B とし 、 B が D と 等 しい とき の B の 列 の集合 を A とする <eos>
2556
src = if len ( A ) > 1 :
trg = A の長さ が 1 より 大きい とき 、
rst = A の長さ が 1 より 大きい とき 、 <eos>
2557
src = A = B + C / ( C + D ) * ( E - B )
trg = B に C を C に D を加えた 値 で 割 った 値に E から B を 引 いた 値を 掛 け た 値 を加えた 値を A とする
rst = B に C を C に D を加えた 値 で 割 った 値に E から B を 引 いた 値を 掛 け た 値 を加えた 値を A とする <eos>
2558
src = if collision ( A , B , C , D ) :
trg = collision ( A , B , C , D ) の とき 、
rst = <unk> ( A , B , C , D ) の とき 、 <eos>
2559
src = if A != B - 1 :
trg = A が B から 1 を 引 いた 値 と 等 しく ない とき 、
rst = A が B から 1 を 引 いた 値 と 等 しく ない とき 、 <eos>
2560
src = if A == 1 and B == 1 and C == 1 :
trg = A が 1 と 等 しく かつ B が 1 と 等 しく かつ C が 1 と 等 しい とき 、
rst = A が 1 と 等 しく かつ B が 1 と 等 しく かつ C が 1 と 等 しい とき 、 <eos>
2561
src = if A == [ 1 , 10 , 11 , 12 , 13 ] and B :
trg = A が ( 1 、 10 、 11 、 12 、 13 ) からなる 列 と 等 しく かつ B の とき 、
rst = A が ( 1 、 10 、 11 、 12 、 13 ) からなる 列 と 等 しく かつ B の とき 、 <eos>
2562
src = A = [ ( 0 , 1 ) , ( 1 , 0 ) ]
trg = ( ( 0 、 1 ) の 組 、 ( 1 、 0 ) の 組 ) からなる 列 を A とする
rst = ( ( 0 、 1 ) の 組 、 ( 1 、 0 ) の 組 ) からなる 列 を A とする <eos>
2563
src = A = B + C [ B ]
trg = B に C の B 番 目 を加えた 値を A とする
rst = B に C の B 番 目 を加えた 値を A とする <eos>
2564
src = A = [ [ None ] * [ 8 for B in range ( 14 ) ] ]
trg = ( ( 、 つまり 未 定 値 ) からなる 列 の 0 から 14 未 満 までの 数 列 の 各要素 を B とし 、 8 の 列 回 分 の 列 ) からなる 列 を A とする
rst = ( ( 、 つまり 未 定 値 ) からなる 列 の 0 から 14 未 満 までの 数 列 の 各要素 を B とし 、 8 の 列 回 分 の 列 ) からなる 列 を A とする <eos>
2565
src = if len ( A ) % 3 != 0 :
trg = A の長さ を 3 で 割 った 余 り が 0 と 等 しく ない とき 、
rst = A の長さ を 3 で 割 った 余 り が 0 と 等 しく ない とき 、 <eos>
2566
src = A . articulations . add ( B )
trg = A の articulations に B を追加した 集 ま り
rst = A に B を追加した 集 ま り <eos>
2567
src = if A [ 0 ] % B == 0 and A [ 1 ] % B == 0 and A [ 2 ] % B == 0 :
trg = A の 0 番 目 を B で 割 った 余 り が 0 と 等 しく かつ A の 1 番 目 を B で 割 った 余 り が 0 と 等 しく かつ A の 2 番 目 を B で 割 った 余 り が 0 と 等 しい とき 、
rst = A の 0 番 目 を B で 割 った 余 り が 0 と 等 しく かつ A の 1 番 目 を B で 割 った 余 り が 0 と 等 しく かつ A の 2 番 目 を B で 割 った 余 り が 0
2568
src = A [ B ] . append ( ( B + C [ B ] ) % D )
trg = A の B 番目の 末 尾 に B に C の B 番 目 を加えた 値を D で 割 った 余 り を追加する
rst = A の B 番目の 末 尾 に B に C の B 番 目 を加えた 値を D で 割 った 余 り を追加する <eos>
2569
src = A [ B ] [ C + 1 ] [ D ] -= 1
trg = A の B 番目の C に 1 を加えた 値 番目の D 番 目 を 1 だけ 減少 させる
rst = A の B 番目の C に 1 を加えた 値 番目の D 番 目 を 1 だけ 減少 させる <eos>
2570
src = pre_order_from ( A . root )
trg = pre _ order _ from ( A . root )
rst = pre _ order _ from ( A . root ) <eos>
2571
src = A = B . format ( C ** 2 )
trg = B を 書式 として C の 2 乗 で 整 形 した 文字列を A とする
rst = B を 書式 として C の 2 乗 で 整 形 した 文字列を A とする <eos>
2572
src = print ( A [ now . weekday ( ) ] )
trg = A の 、 つまり 現在の 日 時の 週 番 目 を出力する
rst = A の 、 つまり 現在の 日 時の 週 番 目 を出力する <eos>
2573
src = A = D if cross3 ( B , C , D ) > - E else C
trg = cross 3 ( B , C , D ) が - E より 大きい とき D 、 そうでなければ C を A とする
rst = cross 3 ( B , C , D ) が - E より 大きい とき D 、 そうでなければ C を A とする <eos>
2574
src = A = bisect . bisect_left ( B [ C [ 1 ] ] , C [ 2 ] )
trg = ソート された 順序 を 保 った まま C の 2 番 目 を B の C の 1 番 目 番 目 に 挿入 できる 位置 を A とする
rst = ソート された 順序 を 保 った まま C の 1 番 目 を B の C の 1 番 目 に 挿入 できる 位置 を A とする <eos>
2575
src = if A [ B - 1 ] != C :
trg = A の B から 1 を 引 いた 値 番 目 が C と 等 しく ない とき 、
rst = A の B から 1 を 引 いた 値 番 目 が C と 等 しく ない とき 、 <eos>
2576
src = print ( ( pow ( 2 , A , B ) + 1 ) % B )
trg = 2 の A 乗 に対する B の 剰 余 に 1 を加えた 値を B で 割 った 余 り を出力する
rst = 2 の A 乗 に B を加えた 値の 1 を B で 割 った 余 り を出力する <eos>
2577
src = A = list ( map ( int , sys . stdin . read ( ) . split ( ) ) )
trg = sys の stdin から 読み 込 んだ データを 空白 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 の リストを A とする
rst = sys の stdin から 読み 込 んだ データを 空白 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 の リストを A とする <eos>
2578
src = A += 10
trg = A を 10 だけ 増加 させる
rst = A を 10 だけ 増加 させる <eos>
2579
src = A = B [ 6 : 9 ]
trg = B の 6 番 目 から 9 番 目 までの 部分 列 を A とする
rst = B の 6 番 目 から 9 番 目 までの 部分 列 を A とする <eos>
2580
src = A = chs ( B , B - C , D )
trg = chs ( B , B - C , D ) を A とする
rst = chs ( B , B - C , D ) を A とする <eos>
2581
src = preParse ( A )
trg = preParse ( A )
rst = preParse ( A ) <eos>
2582
src = dfs_tree ( 0 )
trg = dfs _ tree ( 0 )
rst = <unk> ( 0 ) <eos>
2583
src = if A [ B ] == 0 and not C [ B ] :
trg = A の B 番 目 が 0 と 等 しく かつ C の B 番 目 でない とき 、
rst = A の B 番 目 が 0 と 等 しく かつ C の B 番 目 でない とき 、 <eos>
2584
src = if A < abs ( B [ C ] - B [ D ] ) :
trg = A が B の C 番 目 から B の D 番 目 を 引 いた 値の 絶対 値 より 小さい とき 、
rst = A が B の C 番 目 から B の D 番 目 を 引 いた 値の 絶対 値 より 小さい とき 、 <eos>
2585
src = if A == B . index ( C [ A ] ) :
trg = A が B の C の A 番 目 と 等 しい 要素 の最初の 位置 と 等 しい とき 、
rst = A が B の C の A 番 目 と 等 しい 要素 の最初の 位置 と 等 しい とき 、 <eos>
2586
src = return A . flow ( B )
trg = A . flow ( B ) を返す
rst = A . flow ( B ) を返す <eos>
2587
src = for A in range ( int ( B ) , C ) :
trg = B の 整数値 から C 未 満 までの 数 列 を 順に A として 、 繰り返す
rst = B の 整数値 から C 未 満 までの 数 列 を 順に A として 、 繰り返す <eos>
2588
src = _add ( A , B , - C )
trg = _ add ( A , B , - C )
rst = _ add ( A , B , - C ) <eos>
2589
src = A = B . dfs ( e . to , C , min ( D , e . cap ) )
trg = B . dfs ( e . to , C , min ( D , e . cap ) ) を A とする
rst = B . dfs ( e . to , C , min ( D , e . cap ) ) を A とする <eos>
2590
src = if A [ B ] [ C ] <= D :
trg = A の B 番目の C 番 目 が D 以下の とき 、
rst = A の B 番目の C 番 目 が D 以下の とき 、 <eos>
2591
src = A = B . par [ C ]
trg = B の par の C 番 目 を A とする
rst = B の par の C 番 目 を A とする <eos>
2592
src = for A in sorted ( set ( B ) & set ( C ) ) :
trg = B の集合 と C の集合 の 論理 積 を ソート した 列 を 順に A として 、 繰り返す
rst = B の集合 と C の集合 の 論理 積 を ソート した 列 を 順に A として 、 繰り返す <eos>
2593
src = A = [ next ( map ( int , input ( ) . split ( ) ) ) for B in range ( C ) ]
trg = 0 から C 未 満 までの 数 列 の 各要素 を B とし 、 next ( map ( int , input () . split () ) ) の 列 を A とする
rst = 0 から C 未 満 までの 数 列 の 各要素 を B とし 、 next ( input () . split () ) の 各要素 に int を適用した 列 のリスト の 列 を A とする <eos>
2594
src = A . insert ( bl ( A , B ) , B )
trg = A の bl ( A , B ) に B を挿入する
rst = A の bl ( A , B ) に B を挿入する <eos>
2595
src = A += 15 * B + ( 15 - 2 ) * 5 * B
trg = A を 15 に B を 掛 け た 値に 15 から 2 を 引 いた 値に 5 を 掛 け た 値に B を 掛 け た 値 を加えた 値 だけ 増加 させる
rst = A を 15 に B を 掛 け た 値に 15 から 2 を 引 いた 値に 5 を 掛 け た 値 を加えた 値に B を 掛 け た 値 だけ 増加 させる <eos>
2596
src = if A [ B ] [ C ] == D and E [ F ] == 0 :
trg = A の B 番目の C 番 目 が D と 等 しく かつ E の F 番 目 が 0 と 等 しい とき 、
rst = A の B 番目の C 番 目 が D と 等 しく かつ E の F 番 目 が 0 と 等 しい とき 、 <eos>
2597
src = A = max ( A , B [ C - 1 ] - B [ C ] )
trg = A 、 B の C から 1 を 引 いた 値 番 目 から B の C 番 目 を 引 いた 値の 最大 値を A とする
rst = A 、 B の C から 1 を 引 いた 値 番 目 から B の C 番 目 を 引 いた 値の 最大 値を A とする <eos>
2598
src = print ( A . format ( '' . join ( B ) ) )
trg = A を 書式 として 、 つまり 空文字列 を 間 に 入れ て B を 連結 した 文字列 で 整 形 した 文字列 を出力する
rst = A を 書式 として 、 つまり 空文字列 を 間 に 入れ て B を 連結 した 文字列 で 整 形 した 文字列 を出力する <eos>
2599
src = if A - B [ C ] [ 1 ] >= 0 :
trg = A から B の C 番目の 1 番 目 を 引 いた 値が 0 以上の とき 、
rst = A から B の C 番目の 1 番 目 を 引 いた 値が 0 以上の とき 、 <eos>
2600
src = A , B , C = sorted ( [ int ( D ) for D in input ( ) . split ( ) ] )
trg = 入力された 文字列を 空白 で 分割 した 字句 列 の 各要素 を D とし 、 D の 整数値 の 列 を ソート した 列 を 展開 し 、 それぞれ A 、 B 、 C とする
rst = 入力された 文字列を 空白 で 分割 した 字句 列 の 各要素 を D とし 、 D の 整数値 の 列 を ソート した 列 を 展開 し 、 それぞれ A 、 B 、 C とする <eos>
2601
src = A , B , C , D = [ int ( E ) for E in F . split ( ) ]
trg = F を 空白 で 分割 した 字句 列 の 各要素 を E とし 、 E の 整数値 の 列 を 展開 し 、 それぞれ A 、 B 、 C 、 D とする
rst = F を 空白 で 分割 した 字句 列 の 各要素 を E とし 、 E の 整数値 の 列 を 展開 し 、 それぞれ A 、 B 、 C 、 D とする <eos>
2602
src = A = [ ( B - C ) % D for C , B in zip ( E , F ) ]
trg = E 、 F の 要素を それぞれ 組 にした 列 の 各要素 を C 、 B とし 、 B から C を 引 いた 値を D で 割 った 余 り の 列 を A とする
rst = E 、 F の 要素を それぞれ 組 にした 列 の 各要素 を C 、 B とし 、 B から C を 引 いた 値を D で 割 った 余 り の 列 を A とする <eos>
2603
src = A = B . sink
trg = B の sink を A とする
rst = B の sink を A とする <eos>
2604
src = print ( sum ( [ ( A < 40 ) * 40 + ( A >= 40 ) * A for A in B ] ) // 5 )
trg = B の 各要素 を A とし 、 ( A < 40 ) * 40 に ( A > = 40 ) * A を加えた 値の 列 の 総 和 を 5 で 割 った 商 を出力する
rst = B の 各要素 を A とし 、 A が 40 より 小さい かどうか に 60 を 掛 け た 値に A が 40 以上 かどうか に A を 掛 け た 値 を加えた 値の 列 の 総 和 を 5 で 割 った 商 を出力する <eos>
2605
src = if A . mark != B and ( C , D ) in A . path :
trg = A の mark が B と 等 しく なく かつ ( C 、 D ) の 組 が A の path に含まれる とき 、
rst = A の mark が B と 等 しく なく かつ ( C 、 D ) の 組 が A の path に含まれる とき 、 <eos>
2606
src = pushBack ( A [ 1 ] , A [ 2 ] )
trg = pushBack ( A [ 1 ] , A [ 2 ] )
rst = pushBack ( A [ 1 ] , A [ 2 ] ) <eos>
2607
src = B >>= 1
trg = B を 1 だけ 右 シフト する
rst = B <eos>
2608
src = return Point ( A . x / B , A . y / B )
trg = Point ( A . x / B , A . y / B ) を返す
rst = Point ( A . x / B , A . y / B ) を返す <eos>
2609
src = A = 3600 * ( B [ 3 ] - B [ 0 ] ) + 60 * ( B [ 4 ] - B [ 1 ] ) + B [ 5 ] - B [ 2 ]
trg = 3 600 に B [ 3 ] から B [ 0 ] を 引 いた 値を 掛 け た 値に 60 に B [ 4 ] から B [ 1 ] を 引 いた 値を 掛 け た 値 を加えた 値に B の 5 番 目 を加えた 値 から B の 2 番 目 を 引 いた 値を A とする
rst = 3 600 に B の 3 番 目 から B の先頭 を 引 いた 値を 掛 け た 値に 60 に B の 4 番 目 から B の 1 番 目 を 引 いた 値を 掛 け た 値 を加えた 値に B の 5 番 目 から B の
2610
src = print ( ( f ( A , B ) // C [ B ] ) % D )
trg = f ( A , B ) を C の B 番 目 で 割 った 商 を D で 割 った 余 り を出力する
rst = f ( A , B ) を C の B 番 目 で 割 った 商 を D で 割 った 余 り を出力する <eos>
2611
src = A . add_edge ( B , C , D )
trg = A . add _ edge ( B , C , D )
rst = A . add _ edge ( B , C , D ) <eos>
2612
src = A = 0.5
trg = 0.5 を A とする
rst = 0.5 を A とする <eos>
2613
src = A . N0 = B
trg = B を A の N 0 にする
rst = B を A の N 0 にする <eos>
2614
src = if A + e [ B ] < C [ D ] :
trg = A に ネ イ ピ ア 数の B 番 目 を加えた 値が C の D 番 目 より 小さい とき 、
rst = A に ネ イ ピ ア 数の B 番 目 を加えた 値が C の D 番 目 より 小さい とき 、 <eos>
2615
src = A = B - max ( abs ( B - C ) , abs ( B - D ) )
trg = B から B から C を 引 いた 値の 絶対 値 、 B から D を 引 いた 値の 絶対 値の 最大 値を 引 いた 値を A とする
rst = B から B から C を 引 いた 値の 絶対 値 、 B から D を 引 いた 値の 絶対 値の 最大 値を 引 いた 値を A とする <eos>
2616
src = if A [ B ] [ C ] > 0 :
trg = A の B 番目の C 番 目 が 0 より 大きい とき 、
rst = A の B 番目の C 番 目 が 0 より 大きい とき 、 <eos>
2617
src = A . extend ( B )
trg = B を追加し て A を拡張する
rst = B を追加し て A を拡張する <eos>
2618
src = print ( A . format ( B [ C * 2 ] , B [ C * 2 + 1 ] ) , end = '' )
trg = 改行 せずに A を 書式 として B の C に 2 を 掛 け た 値 番 目 、 B の C に 2 を 掛 け た 値に 1 を加えた 値 番 目 で 整 形 した 文字列 を出力する
rst = 改行 せずに A を 書式 として B の C に 2 を 掛 け た 値 番 目 、 B の C に 2 を 掛 け た 値に 1 を加えた 値 番 目 で 整 形 した 文字列 を出力する <eos>
2619
src = A = min ( B , C [ D ] [ 1 ] )
trg = B 、 C の D 番目の 1 番目の 最小 値を A とする
rst = B 、 C の D 番目の 1 番目の 最小 値を A とする <eos>
2620
src = while A != B [ C ] :
trg = A が B の C 番 目 と 等 しく ない 間 、 次 を 繰り返す
rst = A が B の C 番 目 と 等 しく ない 間 、 次 を 繰り返す <eos>
2621
src = A = [ [ 6 , 7 , 8 ] , [ 2 , 5 , 8 ] , [ 0 , 1 , 2 ] , [ 0 , 3 , 6 ] ]
trg = ( ( 6 、 7 、 8 ) からなる 列 、 ( 2 、 5 、 8 ) からなる 列 、 ( 0 、 1 、 2 ) からなる 列 、 ( 0 、 3 、 6 ) からなる 列 ) からなる 列 を A とする
rst = ( ( 6 、 7 、 8 、 8 ) からなる 列 、 ( 2 、 5 、 8 、 0 、 1 、 2 ) からなる 列 、 ( 0 、 3 、 6 ) からなる 列 ) からなる 列 を A とする <eos>
2622
src = if count == 0 :
trg = 無限 の 整数 列 が 0 と 等 しい とき 、
rst = 無限 の 整数 列 が 0 と 等 しい とき 、 <eos>
2623
src = while len ( A ) >= 2 and cross3 ( A [ - 2 ] , A [ - 1 ] , B ) >= 0 :
trg = A の長さ が 2 以上 かつ cross 3 ( A [ -2 ] , A [ -1 ] , B ) が 0 以上の 間 、 次 を 繰り返す
rst = A の長さ が 2 以上 かつ cross 3 ( A [ -2 ] , A [ -1 ] , A [ B ) が 0 以上の 間 、 次 を 繰り返す <eos>
2624
src = A = 0.000001
trg = 0.0 0000 1 を A とする
rst = 10 4 6 5 27 を A とする <eos>
2625
src = A . root = B
trg = B を A の root にする
rst = B を A の root にする <eos>
2626
src = if A [ 1 ] % 2 == 1 and A [ 2 ] % 2 == 1 :
trg = A の 1 番 目 を 2 で 割 った 余 り が 1 と 等 しく かつ A の 2 番 目 を 2 で 割 った 余 り が 1 と 等 しい とき 、
rst = A の 1 番 目 を 2 で 割 った 余 り が 1 と 等 しく かつ A の 2 番 目 を 2 で 割 った 余 り が 1 と 等 しい とき 、 <eos>
2627
src = A . set_value ( 0 )
trg = A . set _ value ( 0 )
rst = A . set _ value ( 0 ) <eos>
2628
src = while A > 1 and B > 0 :
trg = A が 1 より 大きく かつ B が 0 より 大きい 間 、 次 を 繰り返す
rst = A が 1 より 大きく かつ B が 0 より 大きい 間 、 次 を 繰り返す <eos>
2629
src = A = ( 100.0 , 0.0 )
trg = ( 10 0.0 、 0.0 ) の 組 を A とする
rst = ( 0.0 、 0.0 ) の 組 を A とする <eos>
2630
src = A . append ( sum ( B ) )
trg = A の 末 尾 に B の 総 和 を追加する
rst = A の 末 尾 に B の 総 和 を追加する <eos>
2631
src = A = [ int ( B ) - 1 for B in input ( ) . split ( ) ]
trg = 入力された 文字列を 空白 で 分割 した 字句 列 の 各要素 を B とし 、 B の 整数値 から 1 を 引 いた 値の 列 を A とする
rst = 入力された 文字列を 空白 で 分割 した 字句 列 の 各要素 を B とし 、 B の 整数値 から 1 を 引 いた 値の 列 を A とする <eos>
2632
src = return A . stl [ B ] [ C ]
trg = A の stl の B 番目の C 番 目 を返す
rst = A の stl の B 番目の C 番 目 を返す <eos>
2633
src = print ( A , int ( B ) , C - A )
trg = A 、 B の 整数値 、 C から A を 引 いた 値 を出力する
rst = A 、 B の 整数値 、 C から A を 引 いた 値 を出力する <eos>
2634
src = writelines ( [ A % ( B , C [ B ] , D [ B ] , E [ B ] , F [ B ] , G [ B ] , H if C [ B ] == - 1 else I if E [ B ] == 0 else J ) for B in range ( K ) ] )
trg = writelines ( [ A % ( B , C [ B ] , D [ B ] , E [ B ] , F [ B ] , G [ B ] , HifC [ B ] == -1 elseIifE [ B ] == 0 elseJ ) forBinrange ( K ) ] )
rst = writelines ( [ A % ( B , C [ B ] , D [ B ] , ( <unk> [ B ] , F [ B ] , G [ B ] ) == 0 <unk> ) , G [ B ] [ B ] [ 0 ] )
2635
src = for A , B in sorted ( C , reverse = True ) :
trg = 逆 順に C を ソート した 列 を 順に A 、 B として 、 繰り返す
rst = 逆 順に C を ソート した 列 を 順に A 、 B として 、 繰り返す <eos>
2636
src = A = tuple ( map ( int , B . readline ( ) . split ( ) ) )
trg = B から 読み 込 んだ 一行 を 空白 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 の 組 を A とする
rst = B から 読み 込 んだ 一行 を 空白 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 の 組 を A とする <eos>
2637
src = A = sorted ( B . bridges , key = lambda C : ( min ( C ) , max ( C ) ) )
trg = x を パラメータ として ( x の 最小 値 、 x の 最大 値 ) の 組 を返す関数 を キー として B の bridges を ソート した 列 を A とする
rst = x を パラメータ として ( C の 最小 値 、 C の 最大 値 ) の 組 を返す関数 を キー として B の bridges を ソート した 列 を A とする <eos>
2638
src = print_p ( A )
trg = print _ p ( A )
rst = <unk> ( A ) <eos>
2639
src = if ( A . x == 0 and A . y == 0 ) or ( B . x == 0 and B . y == 0 ) :
trg = A の x 座標 が 0 と 等 しく かつ A の y 座標 が 0 と 等 しく または B の x 座標 が 0 と 等 しく かつ B の y 座標 が 0 と 等 しい とき 、
rst = A の x 座標 が 0 と 等 しく かつ A の y 座標 が 0 と 等 しく または B の x 座標 が 0 と 等 しく かつ B の y 座標 が 0 と 等 しい とき 、 <eos>
2640
src = A . extend ( [ B + C for B in A ] )
trg = A の 各要素 を B とし 、 B に C を加えた 値の 列 を追加し て A を拡張する
rst = A の 各要素 を B とし 、 B に C を加えた 値の 列 を追加し て A を拡張する <eos>
2641
src = A = ( B + C - D )
trg = B に C を加えた 値 から D を 引 いた 値を A とする
rst = B に C を加えた 値 から D を 引 いた 値を A とする <eos>
2642
src = A = math . sqrt ( B ** 2 - C ** 2 )
trg = B の 2 乗 から C の 2 乗 を 引 いた 値の 平 方 根 を A とする
rst = B の 2 乗 から C の 2 乗 を 引 いた 値の 平 方 根 を A とする <eos>
2643
src = if ( 999 - A ) % 3 == 1 :
trg = 9 99 から A を 引 いた 値を 3 で 割 った 余 り が 1 と 等 しい とき 、
rst = 9 99 から A を 引 いた 値を 3 で 割 った 余 り が 1 と 等 しい とき 、 <eos>
2644
src = if A >= B * 2 :
trg = A が B に 2 を 掛 け た 値 以上の とき 、
rst = A が B に 2 を 掛 け た 値 以上の とき 、 <eos>
2645
src = for A in range ( 0 , len ( str ) , 2 ) :
trg = 0 から 、 つまり 整数 の長さ 未 満 までの 2 間隔 の 数 列 を 順に A として 、 繰り返す
rst = 0 から 、 つまり 整数 の長さ 未 満 までの 2 間隔 の 数 列 を 順に A として 、 繰り返す <eos>
2646
src = if not A [ B - 1 ] :
trg = A の B から 1 を 引 いた 値 番 目 でない とき 、
rst = A の B から 1 を 引 いた 値 番 目 でない とき 、 <eos>
2647
src = A [ B . parent ] . right = C
trg = C を A の B の parent 番目の right にする
rst = C を A の B の parent 番目の right にする <eos>
2648
src = A , B = C [ D ] [ D ]
trg = C の D 番目の D 番 目 を 展開 し 、 それぞれ A 、 B とする
rst = C の D 番目の D 番 目 を 展開 し 、 それぞれ A 、 B とする <eos>
2649
src = A . tail . next = B . head . next
trg = B の head の next を A の tail の next にする
rst = B の head の next を A の tail の next にする <eos>
2650
src = print ( '' . join ( A ) )
trg = 空文字列 を 間 に 入れ て A を 連結 した 文字列 を出力する
rst = 空文字列 を 間 に 入れ て A を 連結 した 文字列 を出力する <eos>
2651
src = if calc ( A ) :
trg = calc ( A ) の とき 、
rst = calc ( A ) の とき 、 <eos>
2652
src = A = math . sqrt ( B ** 2 + ( C - D * math . cos ( E ) ) ** 2 )
trg = B の 2 乗 に C から D に math . cos ( E ) を 掛 け た 値を 引 いた 値の 2 乗 を加えた 値の 平 方 根 を A とする
rst = B の 2 乗 に C から D に math . cos ( E ) の 余 弦 を 掛 け た 値を 引 いた 値の 2 乗 を加えた 値の 平 方 根 を A とする <eos>
2653
src = e [ sum ( [ A , B , C , D ] ) ] += 1
trg = ネ イ ピ ア 数の ( A 、 B 、 C 、 D ) からなる 列 の 総 和 番 目 を 1 だけ 増加 させる
rst = ネ イ ピ ア 数の A 、 B 、 C 、 D 番目の 総 和 番 目 を 1 だけ 増加 させる <eos>
2654
src = A . pop ( A . index ( max ( A ) ) )
trg = A の A の A の 最大 値 と 等 しい 要素 の最初の 位置 を取り 出した 値
rst = A の A の A の 最大 値 と 等 しい 要素 の最初の 位置 を取り 出した 値 <eos>
2655
src = A = ( - B + C ** .5 ) / D
trg = - B に C の . 5 乗 を加えた 値を D で 割 った 値を A とする
rst = - B に C の . 5 乗 を加えた 値を D で 割 った 値を A とする <eos>
2656
src = if A == None and B [ C ] [ 1 ] :
trg = A が 、 つまり 未 定 値 と 等 しく かつ B の C 番目の 1 番目の とき 、
rst = A が 、 つまり 未 定 値 と 等 しく かつ B の C 番目の 1 番目の とき 、 <eos>
2657
src = A [ B ] [ C ] = max ( D , E , F )
trg = D 、 E 、 F の 最大 値を A の B 番目の C 番 目 にする
rst = D 、 E 、 F の 最大 値を A の B 番目の C 番 目 にする <eos>
2658
src = A = 600
trg = 600 を A とする
rst = 600 を A とする <eos>
2659
src = return sum ( A )
trg = A の 総 和 を返す
rst = A の 総 和 を返す <eos>
2660
src = A = math . sin ( B ) * C
trg = B の 正 弦 に C を 掛 け た 値を A とする
rst = B の 正 弦 に C を 掛 け た 値を A とする <eos>
2661
src = paint ( A - 1 , B )
trg = paint ( A - 1, B )
rst = paint ( A - 1, B ) <eos>
2662
src = if A [ B + 1 ] != C :
trg = A の B に 1 を加えた 値 番 目 が C と 等 しく ない とき 、
rst = A の B に 1 を加えた 値 番 目 が C と 等 しく ない とき 、 <eos>
2663
src = else = A [ B + 2 ] + C
trg = A の B に 2 を加えた 値 番 目 に C を加えた 値を そうでなければ 、 とする
rst = A の B に 2 を加えた 値 番 目 に C を加えた 値を そうでなければ 、 とする <eos>
2664
src = A . heappush ( B , ( C , e , D , E ) )
trg = A . heappush ( B , ( C , e , D , E ) )
rst = A . heappush ( B , ( C , e , D , E ) ) <eos>
2665
src = print ( - heappop ( A ) )
trg = - heappop ( A ) を出力する
rst = - heappop ( A ) を出力する <eos>
2666
src = push ( ( A , B ) )
trg = push ( ( A , B ) )
rst = push ( ( A , B ) ) <eos>
2667
src = A . N = B
trg = B を A の N にする
rst = B を A の N にする <eos>
2668
src = if A in ( 0 , 1 ) :
trg = A が ( 0 、 1 ) の 組 に含まれる とき 、
rst = A が ( 0 、 1 ) の 組 に含まれる とき 、 <eos>
2669
src = A , B = map ( int , B . split ( ) )
trg = B を 空白 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 を 展開 し 、 それぞれ A 、 B とする
rst = B を 空白 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 を 展開 し 、 それぞれ A 、 B とする <eos>
2670
src = A = sqrt ( B / 4.9 )
trg = B を 4 . 9 で 割 った 値の 平 方 根 を A とする
rst = B を 4 . 9 で 割 った 値の 平 方 根 を A とする <eos>
2671
src = A = min ( A , calc ( int ( B + C [ D : ] ) ) - E )
trg = A 、 calc ( int ( B + C [ D : ] ) ) から E を 引 いた 値の 最小 値を A とする
rst = A 、 calc ( int ( B + C [ D : ] ) ) から E を 引 いた 値の 最小 値を A とする <eos>
2672
src = if A * B // C < D :
trg = A に B を 掛 け た 値を C で 割 った 商 が D より 小さい とき 、
rst = A に B を 掛 け た 値を C で 割 った 商 が D より 小さい とき 、 <eos>
2673
src = A = int ( B [ 2 : 6 ] )
trg = B の 2 番 目 から 6 番 目 までの 部分 列 の 整数値 を A とする
rst = B の 2 番 目 から 6 番 目 までの 部分 列 の 整数値 を A とする <eos>
2674
src = A = CP ( B , C , D )
trg = CP ( B , C , D ) を A とする
rst = <unk> ( B , C , D ) を A とする <eos>
2675
src = A -= B [ C ] * ( D [ E ] * F + G [ E ] )
trg = A を B の C 番 目 に D の E 番 目 に F を 掛 け た 値に G の E 番 目 を加えた 値を 掛 け た 値 だけ 減少 させる
rst = A を B の C 番 目 に D の E 番 目 に F を 掛 け た 値に G の E 番 目 を加えた 値を 掛 け た 値 だけ 減少 させる <eos>
2676
src = A = [ [ B , 35.50 , 71.00 ] , [ C , 37.50 , 77.00 ] , [ D , 40.00 , 83.00 ] , [ E , 43.00 , 89.00 ] , [ F , 50.00 , 105.00 ] , [ G , 55.00 , 116.00 ] , [ H , 70.00 , 148.00 ] ]
trg = ( ( B 、 3 5 . 50 、 7 1.0 0 ) からなる 列 、 ( C 、 3 7 . 50 、 77 . 00 ) からなる 列 、 ( D 、 4 0.0 0 、 8 3.0 0 ) からなる 列 、 ( E 、 4 3.0 0 、 89 . 00 ) からなる 列 、 ( F 、 50 . 00 、 10 5.0 0 ) からなる 列 、 ( G 、 5 5.0 0 、
rst = ( ( B 、 1 、 3 14 15 9 、 5 ) からなる 列 、 ( C 、 1 25 5 、 E ) からなる 列 、 ( F 、 100 1 、 15 4 、 E ) からなる 列 、 ( F 、 G 、 H ) からなる
2677
src = print ( 0 , 0 )
trg = 0 、 0 を出力する
rst = 0 、 0 を出力する <eos>
2678
src = A = 6 * B
trg = 6 に B を 掛 け た 値を A とする
rst = 6 に B を 掛 け た 値を A とする <eos>
2679
src = if e [ 0 ] == A :
trg = ネ イ ピ ア 数の 0 番 目 が A と 等 しい とき 、
rst = ネ イ ピ ア 数の 0 番 目 が A と 等 しい とき 、 <eos>
2680
src = print ( min ( A * B + C * D , int ( 0.8 * ( A * max ( 5 , B ) + C * max ( 2 , D ) ) ) ) )
trg = A に B を 掛 け た 値に C に D を 掛 け た 値 を加えた 値 、 0 . 8 に A * max ( 5 , B ) に C * max ( 2 , D ) を加えた 値を 掛 け た 値の 整数値 の 最小 値 を出力する
rst = A に B を 掛 け た 値に C に D を 掛 け た 値 を加えた 値 、 0 . 8 * max ( A * max ( 5 , B ) に C * max ( 2 , D ) を加えた 値の 整数値 を 掛 け た 値
2681
src = A . append ( B [ C ] [ D [ C ] ] )
trg = A の 末 尾 に B の C 番目の D の C 番 目 番 目 を追加する
rst = A の 末 尾 に B の C 番目の D の C 番 目 番 目 を追加する <eos>
2682
src = for A in range ( max ( 0 , B - C ) , min ( B + C , D - 1 ) + 1 ) :
trg = 0 、 B から C を 引 いた 値の 最大 値 から B に C を加えた 値 、 D から 1 を 引 いた 値の 最小 値に 1 を加えた 値 未 満 までの 数 列 を 順に A として 、 繰り返す
rst = 0 から B から C を 引 いた 値の 最大 値 未 満 までの 数 列 、 B に C を加えた 値 、 D から 1 を 引 いた 値の 最小 値に 1 を加えた 値 未 満 までの 数 列 を 順に A として 、 繰り返す <eos>
2683
src = if ( 2 * A + 1 ) * B <= 2 * C :
trg = 2 に A を 掛 け た 値に 1 を加えた 値に B を 掛 け た 値が 2 に C を 掛 け た 値 以下の とき 、
rst = 2 に A を 掛 け た 値に 1 を加えた 値に B を 掛 け た 値が 2 に C を 掛 け た 値 以下の とき 、 <eos>
2684
src = A . append ( abs ( ( B ** 2 + ( C - B ) ** 2 ) ** 0.5 - e ) )
trg = A の 末 尾 に B * * 2 に ( C - B ) * * 2 を加えた 値の 0.5 乗 から 、 つまり ネ イ ピ ア 数 を 引 いた 値の 絶対 値 を追加する
rst = A の 末 尾 に B の 2 乗 に C から B を 引 いた 値の 2 乗 を加えた 値の 絶対 値の - e の 絶対 値 乗 を追加する <eos>
2685
src = A += ( B + e )
trg = A を B に ネ イ ピ ア 数 を加えた 値 だけ 増加 させる
rst = A を B に ネ イ ピ ア 数 を加えた 値 だけ 増加 させる <eos>
2686
src = for A in range ( 2 , int ( B ** 0.5 ) + 2 ) :
trg = 2 から B の 0.5 乗 の 整数値 に 2 を加えた 値 未 満 までの 数 列 を 順に A として 、 繰り返す
rst = 2 から B の 0.5 乗 の 整数値 に 2 を加えた 値 未 満 までの 数 列 を 順に A として 、 繰り返す <eos>
2687
src = print ( A . format ( B - 1925 ) )
trg = A を 書式 として B から 19 25 を 引 いた 値 で 整 形 した 文字列 を出力する
rst = A を 書式 として B から 19 25 を 引 いた 値 で 整 形 した 文字列 を出力する <eos>
2688
src = A [ - 1 ] [ 1 ] += 1
trg = A の 末 尾 の 1 番 目 を 1 だけ 増加 させる
rst = A の 末 尾 の 1 番 目 を 1 だけ 増加 させる <eos>
2689
src = era_transformation ( A , B , C )
trg = era _ transformation ( A , B , C )
rst = <unk> ( A , B , C ) <eos>
2690
src = A = 70000
trg = 7 0000 を A とする
rst = 10 4 6 5 27 を A とする <eos>
2691
src = A [ 1 << B ] = C
trg = C を A の 1 を B だけ 左 シフト した 値 番 目 にする
rst = C を A の 1 を B だけ 左 シフト した 値 番 目 にする <eos>
2692
src = A = distf ( * B [ C - 1 ] )
trg = distf ( * B [ C -1 ] ) を A とする
rst = <unk> ( * B [ C -1 ] ) を A とする <eos>
2693
src = A , re = map ( int , input ( ) . split ( ) )
trg = 入力された 文字列を 空白 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 を 展開 し 、 それぞれ A 、 re とする
rst = 入力された 文字列を 空白 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 を 展開 し 、 それぞれ A 、 入力された 文字列 の 整数値 とする <eos>
2694
src = A . append ( [ max ( B , C ) , D ] )
trg = A の 末 尾 に ( B 、 C の 最大 値 、 D ) からなる 列 を追加する
rst = A の 末 尾 に ( B 、 C の 最大 値 、 D ) からなる 列 を追加する <eos>
2695
src = A [ B - 1 ] [ 1 ] = 1
trg = 1 を A の B から 1 を 引 いた 値 番目の 1 番 目 にする
rst = 1 を A の B から 1 を 引 いた 値 番目の 1 番 目 にする <eos>
2696
src = if A == float ( B ) :
trg = A が B の 浮動小数点数 と 等 しい とき 、
rst = A が B の 浮動小数点数 と 等 しい とき 、 <eos>
2697
src = A [ e . to ] = A [ B ] + 1
trg = A の B 番 目 に 1 を加えた 値を A の 、 つまり ネ イ ピ ア 数の to 番 目 にする
rst = A の B 番 目 に 1 を加えた 値を A の 、 つまり ネ イ ピ ア 数の to 番 目 にする <eos>
2698
src = for A , B in enumerate ( sorted ( C [ D : E + 1 ] , key = itemgetter ( F ) ) ) :
trg = itemgetter ( F ) を キー として C の D 番 目 から E に 1 を加えた 値 までの 部分 列 を ソート した 列 に 番号 付 した 組 の 列 を 順に A 、 B として 、 繰り返す
rst = itemgetter ( F ) を キー として C の D 番 目 から E に 1 を加えた 値 までの 部分 列 を ソート した 列 に 番号 付 した 組 の 列 を 順に A 、 B として 、 繰り返す <eos>
2699
src = A = A - B / ( 3 * C )
trg = A から B を 3 に C を 掛 け た 値 で 割 った 値を 引 いた 値を A とする
rst = A から B を 3 に C を 掛 け た 値 で 割 った 値を 引 いた 値を A とする <eos>
2700
src = for A in range ( B * B , C + 1 , B ) :
trg = B に B を 掛 け た 値 から C に 1 を加えた 値 未 満 までの B 間隔 の 数 列 を 順に A として 、 繰り返す
rst = B に B を 掛 け た 値 から C に 1 を加えた 値 未 満 までの B 間隔 の 数 列 を 順に A として 、 繰り返す <eos>
2701
src = A [ B ] [ C ] += D
trg = A の B 番目の C 番 目 を D だけ 増加 させる
rst = A の B 番目の C 番 目 を D だけ 増加 させる <eos>
2702
src = print ( sum ( [ A * A * B for A in range ( B , 600 , B ) ] ) )
trg = B から 600 未 満 までの B 間隔 の 数 列 の 各要素 を A とし 、 A に A を 掛 け た 値に B を 掛 け た 値の 列 の 総 和 を出力する
rst = B から 600 未 満 までの B 間隔 の 数 列 の 各要素 を A とし 、 A に A を 掛 け た 値に B を 掛 け た 値の 列 の 総 和 を出力する <eos>
2703
src = B = C
trg = C を B とする
rst = C を B とする <eos>
2704
src = A = B . spc_x + C
trg = B の spc _ x に C を加えた 値を A とする
rst = B の spc _ x に C を加えた 値を A とする <eos>
2705
src = A . tree [ A . n + B - 1 ] = C [ B ]
trg = C の B 番 目 を A の tree の A の n に B を加えた 値 から 1 を 引 いた 値 番 目 にする
rst = C の B 番 目 を A の tree の A の n に B を加えた 値 から 1 を 引 いた 値 番 目 にする <eos>
2706
src = if A + B . C [ C - 1 ] [ D - E ] > B . C [ C - 1 ] [ D ] :
trg = A に B の C の C から 1 を 引 いた 値 番目の D から E を 引 いた 値 番 目 を加えた 値が B の C の C から 1 を 引 いた 値 番目の D 番 目 より 大きい とき 、
rst = A に B の C から 1 を 引 いた 値 番目の D から E を 引 いた 値 番 目 を加えた 値が B の C から 1 を 引 いた 値 番目の D 番 目 より 大きい とき 、 <eos>
2707
src = A = A * A % B
trg = A に A を 掛 け た 値を B で 割 った 余 り を A とする
rst = A に A を 掛 け た 値を B で 割 った 余 り を A とする <eos>
2708
src = A , B , C , D , E , F , G , H = [ float ( I ) for I in input ( ) . split ( J ) ]
trg = 入力された 文字列を J で 分割 した 字句 列 の 各要素 を I とし 、 I の 浮動小数点数 の 列 を 展開 し 、 それぞれ A 、 B 、 C 、 D 、 E 、 F 、 G 、 H とする
rst = 入力された 文字列を J で 分割 した 字句 列 の 各要素 を I とし 、 I の 浮動小数点数 の 列 を 展開 し 、 それぞれ A 、 B 、 C 、 D 、 E 、 F 、 G 、 H とする <eos>
2709
src = A . append ( B % ( C in D ) )
trg = A の 末 尾 に B を C が D に含まれる かどうか で 割 った 余 り を追加する
rst = A の 末 尾 に B を C が D に含まれる かどうか で 割 った 余 り を追加する <eos>
2710
src = count += ( A + B )
trg = 無限 の 整数 列 を A に B を加えた 値 だけ 増加 させる
rst = 無限 の 整数 列 を A に B を加えた 値 だけ 増加 させる <eos>
2711
src = A . append ( int ( B * ( B - 1 ) / 2 ) )
trg = A の 末 尾 に B に B から 1 を 引 いた 値を 掛 け た 値を 2 で 割 った 値の 整数値 を追加する
rst = A の 末 尾 に B に B から 1 を 引 いた 値を 掛 け た 値を 2 で 割 った 値の 整数値 を追加する <eos>
2712
src = if A [ B ] [ 2 ] and A [ C ] [ 2 ] :
trg = A の B 番目の 2 番 目 かつ A の C 番目の 2 番目の とき 、
rst = A の B 番目の 2 番 目 かつ A の C 番目の 2 番目の とき 、 <eos>
2713
src = dijkstra ( A )
trg = dijkstra ( A )
rst = dijkstra ( A ) <eos>
2714
src = A = min ( A , B + dfs ( C | ( 1 << D ) , E + F [ D ] , G ) )
trg = A 、 B に dfs ( C | ( 1 < < D ) , E + F [ D ] , G ) を加えた 値の 最小 値を A とする
rst = A 、 B に dfs ( C | ( 1 < D ) , E + F [ D ] , G ) を加えた 値の 最小 値を A とする <eos>
2715
src = A += chr ( 65 + B )
trg = A を 文字コード 6 5 に B を加えた 値の 文字 だけ 増加 させる
rst = A を 文字コード 6 5 に B を加えた 値の 文字 だけ 増加 させる <eos>
2716
src = if A == 100 or B == 100 or C == 100 :
trg = A が 100 と 等 しく または B が 100 と 等 しく または C が 100 と 等 しい とき 、
rst = A が 100 と 等 しく または B が 100 と 等 しく または C が 100 と 等 しい とき 、 <eos>
2717
src = A = B - e
trg = B から 、 つまり ネ イ ピ ア 数 を 引 いた 値を A とする
rst = B から 、 つまり ネ イ ピ ア 数 を 引 いた 値を A とする <eos>
2718
src = A [ B + C * ( C + 1 ) ] = D
trg = D を A の B に C に C に 1 を加えた 値を 掛 け た 値 を加えた 値 番 目 にする
rst = D を A の B に C に 1 を加えた 値を 掛 け た 値 を加えた 値 番 目 にする <eos>
2719
src = A -= 6 * B
trg = A を 6 に B を 掛 け た 値 だけ 減少 させる
rst = A を 6 に B を 掛 け た 値 だけ 減少 させる <eos>
2720
src = A . number = [ B for B in range ( 6 ) ]
trg = 0 から 6 未 満 までの 数 列 の 各要素 を B とし 、 B の 列 を A の number にする
rst = 0 から 6 未 満 までの 数 列 の 各要素 を B とし 、 B の 列 を A の number にする <eos>
2721
src = if A == [ ] :
trg = A が 、 つまり 空 列 と 等 しい とき 、
rst = A が 、 つまり 空 列 と 等 しい とき 、 <eos>
2722
src = insert ( [ None , None , int ( A [ 0 ] ) , None ] )
trg = insert ( [ None , None , int ( A [ 0 ] ) , None ] )
rst = insert ( None , int ( input () , int ( A [ 0 ] ) , None ) <eos>
2723
src = A , B , C = input ( ) . split ( )
trg = 入力された 文字列を 空白 で 分割 した 字句 列 を 展開 し 、 それぞれ A 、 B 、 C とする
rst = 入力された 文字列を 空白 で 分割 した 字句 列 を 展開 し 、 それぞれ A 、 B 、 C とする <eos>
2724
src = for A , B in zip ( [ C ] + D , D + [ E ] ) :
trg = ( C ) からなる 列 に D を加えた 値 、 D に ( E ) からなる 列 を加えた 値の 要素を それぞれ 組 にした 列 を 順に A 、 B として 、 繰り返す
rst = ( C ) からなる 列 に D を加えた 値 、 D に ( E ) からなる 列 を加えた 値の 要素を それぞれ 組 にした 列 を 順に A 、 B として 、 繰り返す <eos>
2725
src = print ( A . format ( B , e , C ) )
trg = A を 書式 として B 、 ネ イ ピ ア 数 、 C で 整 形 した 文字列 を出力する
rst = A を 書式 として B 、 ネ イ ピ ア 数 、 C で 整 形 した 文字列 を出力する <eos>
2726
src = A . y = B . y - C . y
trg = B の y 座標 から C の y 座標 を 引 いた 値を A の y 座標 にする
rst = B の y 座標 から C の y 座標 を 引 いた 値を A の y 座標 にする <eos>
2727
src = if A == 4 :
trg = A が 4 と 等 しい とき 、
rst = A が 4 と 等 しい とき 、 <eos>
2728
src = if math . sqrt ( A ) < B :
trg = A の 平 方 根 が B より 小さい とき 、
rst = A の 平 方 根 が B より 小さい とき 、 <eos>
2729
src = if A < B - 1 and C [ A ] [ D ] == 0 and not E [ A + 1 ] [ D ] :
trg = A が B から 1 を 引 いた 値 より 小さく かつ C の A 番目の D 番 目 が 0 と 等 しく かつ E の A に 1 を加えた 値 番目の D 番 目 でない とき 、
rst = A が B から 1 を 引 いた 値 より 小さく かつ C の A 番目の D 番 目 が 0 と 等 しく かつ E の A に 1 を加えた 値 番目の D 番 目 でない とき 、 <eos>
2730
src = A = len ( { [ B for C , B in D ] } ) == 1
trg = ( < __ main __ . Cammaobjectat 0 x 10 a 1 b 7 a 90 > ) の集合 の長さ が 1 と 等 しい かどうか を A とする
rst = ( < __ main __ . Cammaobjectat 0 x 10 a 1 b 7 4 90 > ) の集合 の長さ が 1 と 等 しい かどうか を A とする <eos>
2731
src = A = A * B + C [ D ] [ E ]
trg = A に B を 掛 け た 値に C の D 番目の E 番 目 を加えた 値を A とする
rst = A に B を 掛 け た 値に C の D 番目の E 番 目 を加えた 値を A とする <eos>
2732
src = A . bel [ B + 1 ] [ C + 1 ] = A . bel [ B + 1 ] [ C ] + A . stl [ B + 1 ] [ C + 1 ] % D
trg = A の bel の B に 1 を加えた 値 番目の C 番 目 に A の stl の B に 1 を加えた 値 番目の C に 1 を加えた 値 番 目 を D で 割 った 余 り を加えた 値を A の bel の B に 1 を加えた 値 番目の C に 1 を加えた 値 番 目 にする
rst = A の bel の B に 1 を加えた 値 番目の C 番 目 に A の stl の B に 1 を加えた 値 番目の C に 1 を加えた 値 番 目 を D で 割 った 余 り を加えた 値を A の bel の B に 1 を加えた 値 番目の
2733
src = print ( A . min ( B , C ) )
trg = A . min ( B , C ) を出力する
rst = A . min ( B , C ) を出力する <eos>
2734
src = A = [ [ 1 for B in range ( C + D - 1 ) ] for E in range ( C + D - 1 ) ]
trg = 0 から C に D を加えた 値 から 1 を 引 いた 値 未 満 までの 数 列 の 各要素 を E とし 、 0 から C に D を加えた 値 から 1 を 引 いた 値 未 満 までの 数 列 の 各要素 を B とし 、 1 の 列 の 列 を A とする
rst = 0 から C に D を加えた 値 から 1 を 引 いた 値 未 満 までの 数 列 の 各要素 を E とし 、 0 から C に D を加えた 値 から 1 を 引 いた 値 未 満 までの 数 列 の 各要素 を B とし 、 1 の
2735
src = A = calc_hash ( B * 2 + C * 2 , B * 2 + C * 3 , C )
trg = calc _ hash ( B * 2 + C * 2 , B * 2 + C * 3 , C ) を A とする
rst = calc _ hash ( B * 2 + C * 2 , B * 2 + C * 3 , C ) を A とする <eos>
2736
src = add_team ( 0 , 1 )
trg = add _ team ( 0 , 1 )
rst = <unk> ( 0 , 1 ) <eos>
2737
src = A . append ( B . count ( 1 ) )
trg = A の 末 尾 に B 内の 1 の 出現 回数 を追加する
rst = A の 末 尾 に B 内の 1 の 出現 回数 を追加する <eos>
2738
src = A . hldtop [ A . root ] = A . root
trg = A の root を A の hldtop の A の root 番 目 にする
rst = A の root を A の hldtop の A の root 番 目 にする <eos>
2739
src = [ print ( classify ( Decimal ( A ) ) ) for A in [ B for B in sys . stdin ] ]
trg = sys の stdin の 各要素 を B とし 、 B の 列 の 各要素 を A とし 、 classify ( Decimal ( A ) ) を出力する の 列
rst = sys の stdin の 各要素 を B とし 、 calc _ largest _ <unk> ( A ) の 列 の 各要素 を A とし 、 Decimal ( A ) を出力する の 列 <eos>
2740
src = A = B [ C ] [ D - C ] % E
trg = B の C 番目の D から C を 引 いた 値 番 目 を E で 割 った 余 り を A とする
rst = B の C 番目の D から C を 引 いた 値 番 目 を E で 割 った 余 り を A とする <eos>
2741
src = A [ 1 ] = B [ C ] [ D ] - B [ E - 1 ] [ D ] - B [ C ] [ F - 1 ] + B [ E - 1 ] [ F - 1 ]
trg = B の C 番目の D 番 目 から B の E -1 番目の D 番 目 を 引 いた 値 から B の C 番目の F から 1 を 引 いた 値 番 目 を 引 いた 値に B の E から 1 を 引 いた 値 番目の F から 1 を 引 いた 値 番 目 を加えた 値を A の 1 番 目 にする
rst = B の C 番目の D 番 目 から B の E -1 番目の D 番 目 を 引 いた 値 から B の C 番目の F から 1 を 引 いた 値 番 目 を 引 いた 値に B の E から 1 を 引 いた 値 番目の F から
2742
src = A , B = 1 , 0
trg = 1 、 0 を A 、 B とする
rst = 1 、 0 を A 、 B とする <eos>
2743
src = A = deepcopy ( B . nums )
trg = B の nums を 深く コピー した結果 を A とする
rst = B の nums を 深く コピー した結果 を A とする <eos>
2744
src = A = ( ( 0 , 0 ) , ( 1 , 0 ) , ( 0 , 1 ) , ( 1 , 1 ) )
trg = ( ( 0 、 0 ) の 組 、 ( 1 、 0 ) の 組 、 ( 0 、 1 ) の 組 、 ( 1 、 1 ) の 組 ) の 組 を A とする
rst = ( ( 0 、 0 ) の 組 、 ( 1 、 0 ) の 組 、 ( 0 、 1 ) の 組 、 ( 1 、 1 ) の 組 ) の 組 を A とする <eos>
2745
src = A [ B ^ C ] = D + 1
trg = D に 1 を加えた 値を A の B と C の 排 他 論理 和 番 目 にする
rst = D に 1 を加えた 値を A の B と C の 排 他 論理 和 番 目 にする <eos>
2746
src = print ( A [ len ( B ) - 1 ] [ len ( C ) - 1 ] % 1000000007 )
trg = A の len ( B ) から 1 を 引 いた 値 番目の C の長さ から 1 を 引 いた 値 番 目 を 1 0000 0000 7 で 割 った 余 り を出力する
rst = A の B の長さ から 1 を 引 いた 値 番目の C の長さ から 1 を 引 いた 値 番 目 を 1 0000 7 で 割 った 余 り を出力する <eos>
2747
src = print ( 0 , end = ' ' )
trg = 空白 文字 を 代わり の 行 末 として 0 を出力する
rst = 空白 文字 を 代わり の 行 末 として 0 を出力する <eos>
2748
src = A [ C ] = B
trg = B を A の C 番 目 にする
rst = B を A の C 番 目 にする <eos>
2749
src = A , B = [ int ( C ) for C in D . strip ( ) . split ( ' ' ) ]
trg = D の 両 端 から 空白 改行 を取り 除 いた 文字列を 空白 文字 で 分割 した 字句 列 の 各要素 を C とし 、 C の 整数値 の 列 を 展開 し 、 それぞれ A 、 B とする
rst = D の 両 端 から 空白 改行 を取り 除 いた 文字列を 空白 文字 で 分割 した 字句 列 の 各要素 を C とし 、 C の 整数値 の 列 を 展開 し 、 それぞれ A 、 B とする <eos>
2750
src = for A in range ( 1 , B [ 0 ] + 1 ) :
trg = 1 から B の 先頭に 1 を加えた 値 未 満 までの 数 列 を 順に A として 、 繰り返す
rst = 1 から B の 先頭に 1 を加えた 値 未 満 までの 数 列 を 順に A として 、 繰り返す <eos>
2751
src = if dict [ A [ B ] ] == 1 :
trg = 辞書 の A の B 番 目 番 目 が 1 と 等 しい とき 、
rst = 辞書 の A の B 番 目 番 目 が 1 と 等 しい とき 、 <eos>
2752
src = A . dump ( B [ 0 ] , B [ 1 ] )
trg = A . dump ( B [ 0 ] , B [ 1 ] )
rst = A . dump ( B [ 0 ] , B [ 1 ] ) <eos>
2753
src = print ( - 1 if isinf ( A ) else A )
trg = A が 無限大 の とき -1 、 そうでなければ A を出力する
rst = A が 無限大 の とき -1 、 そうでなければ A を出力する <eos>
2754
src = A , B = min ( C , D - C ) , max ( C , D - C )
trg = C 、 D から C を 引 いた 値の 最小 値 、 C 、 D から C を 引 いた 値の 最大 値を A 、 B とする
rst = C 、 D から C を 引 いた 値の 最小 値 、 C 、 D から C を 引 いた 値の 最大 値を A 、 B とする <eos>
2755
src = A = B . tree . get ( C )
trg = B の tree に対応する 値 、 も し 存在 し なければ C を A とする
rst = B の tree に対応する 値 、 も し 存在 し なければ C を A とする <eos>
2756
src = if A > B * C :
trg = A が B に C を 掛 け た 値 より 大きい とき 、
rst = A が B に C を 掛 け た 値 より 大きい とき 、 <eos>
2757
src = if A . isupper ( ) :
trg = A の 全て が 英 大文字 の とき 、
rst = A の 全て が 英 大文字 の とき 、 <eos>
2758
src = A += [ B . key ]
trg = A を ( B の key ) からなる 列 だけ 増加 させる
rst = A を ( B の key ) からなる 列 だけ 増加 させる <eos>
2759
src = return A [ B : ]
trg = A の B 番 目 から 、 つまり 末 尾 までの 部分 列 を返す
rst = A の B 番 目 から 、 つまり 末 尾 までの 部分 列 を返す <eos>
2760
src = print ( A [ B + ( 4 - C ) ] , end = '' )
trg = 改行 せずに A の B に 4 から C を 引 いた 値 を加えた 値 番 目 を出力する
rst = 改行 せずに A の B に 4 から C を 引 いた 値 を加えた 値 番 目 を出力する <eos>
2761
src = A = len ( B ) - C - 2
trg = B の長さ から C を 引 いた 値 から 2 を 引 いた 値を A とする
rst = B の長さ から C を 引 いた 値 から 2 を 引 いた 値を A とする <eos>
2762
src = if ( A - B ) ** 2 <= C :
trg = A から B を 引 いた 値の 2 乗 が C 以下の とき 、
rst = A から B を 引 いた 値の 2 乗 が C 以下の とき 、 <eos>
2763
src = A = [ - B ] * ( C + 3 * D )
trg = ( - B ) からなる 列 の C に 3 に D を 掛 け た 値 を加えた 値 回 分 の 列 を A とする
rst = ( - B ) からなる 列 の C に 3 に D を 掛 け た 値 を加えた 値 回 分 の 列 を A とする <eos>
2764
src = A . head += 1
trg = A の head を 1 だけ 増加 させる
rst = A の head を 1 だけ 増加 させる <eos>
2765
src = for A , B in enumerate ( accumulate ( C ) , start = 1 ) :
trg = 1 を 開始 番号 として accumulate ( C ) に 番号 付 した 組 の 列 を 順に A 、 B として 、 繰り返す
rst = accumulate ( C ) 、 1 に 番号 付 した 組 の 列 を 順に A 、 B として 、 繰り返す <eos>
2766
src = A += binarysearch ( B , C [ D ] , E )
trg = A を binarysearch ( B , C [ D ] , E ) だけ 増加 させる
rst = A を <unk> ( B , C [ D ] , E ) だけ 増加 させる <eos>
2767
src = if A != B or C != B :
trg = A が B と 等 しく なく または C が B と 等 しく ない とき 、
rst = A が B と 等 しく なく または C が B と 等 しく ない とき 、 <eos>
2768
src = e = ( A + 60 * B ) - ( ( C + D ) * E + C )
trg = A に 60 に B を 掛 け た 値 を加えた 値 から C に D を加えた 値に E を 掛 け た 値に C を加えた 値を 引 いた 値を ネ イ ピ ア 数 とする
rst = A に 60 に B を 掛 け た 値 を加えた 値 から C に D を加えた 値に E を 掛 け た 値を 引 いた 値に C を加えた 値を ネ イ ピ ア 数 とする <eos>
2769
src = A . d [ 0 ] , A . d [ 3 ] , A . d [ 5 ] , A . d [ 2 ] = A . d [ 3 ] , A . d [ 5 ] , A . d [ 2 ] , A . d [ 0 ]
trg = A の d の 3 番 目 、 A の d の 5 番 目 、 A の d の 2 番 目 、 A の d の先頭 を A の d の先頭 、 A の d の 3 番 目 、 A の d の 5 番 目 、 A の d の 2 番 目 とする
rst = A の d の 3 番 目 、 A の d の 5 番 目 、 A の d の 2 番 目 を A の d の先頭 、 A の d の 3 番 目 、 A の d の 5 番 目 、 A の d の 2
2770
src = if A is B . sink :
trg = A が B の sink と 等 しく ない とき 、
rst = A が B の sink と 等 しく ない とき 、 <eos>
2771
src = if A . par [ B ] < 0 :
trg = A の par の B 番 目 が 0 より 小さい とき 、
rst = A の par の B 番 目 が 0 より 小さい とき 、 <eos>
2772
src = if A [ 0 ] == B :
trg = A の先頭 が B と 等 しい とき 、
rst = A の 0 番 目 が B と 等 しい とき 、 <eos>
2773
src = print ( sum ( [ 1 for A in itertools . combinations ( [ B for B in range ( 10 ) ] , C ) if sum ( A ) == D ] ) )
trg = range ( 10 ) の 各要素 を B とし 、 B の 列 の C 個 までの コン ビ ネ ー ション の 各要素 を A とし 、 A の 総 和 が D と 等 しい とき の 1 の 列 の 総 和 を出力する
rst = 0 から 10 未 満 までの 数 列 の 各要素 を B とし 、 C の D 個 までの コン ビ ネ ー ション の 各要素 を A とし 、 A の 総 和 が D と 等 しい とき の 1 の 列 の 総 和 を出力する <eos>
2774
src = return A . value == B . value
trg = A の value が B の value と 等 しい かどうか を返す
rst = A の value が B の value と 等 しい かどうか を返す <eos>
2775
src = combi ( A , 20 )
trg = combi ( A , 20 )
rst = combi ( A , 20 ) <eos>
2776
src = A [ B - 1 ] . append ( [ C - 1 , D ] )
trg = A の B から 1 を 引 いた 値 番目の 末 尾 に ( C から 1 を 引 いた 値 、 D ) からなる 列 を追加する
rst = A の B から 1 を 引 いた 値 番目の 末 尾 に ( C から 1 を 引 いた 値 、 D ) からなる 列 を追加する <eos>
2777
src = A = str ( A ) [ : B + 2 ]
trg = A の 文字列 の 、 つまり 先頭 から B に 2 を加えた 値 までの 部分 列 を A とする
rst = A の 文字列 の 、 つまり 先頭 から B に 2 を加えた 値 までの 部分 列 を A とする <eos>
2778
src = A . _nodes = [ ]
trg = 空 列 を A の _ nodes にする
rst = 空 列 を A の _ nodes にする <eos>
2779
src = print ( int ( math . log ( int ( input ( ) ) + 1 , 2 ) ) )
trg = 2 を 底 とする input () の 整数値 に 1 を加えた 値の 対 数の 整数値 を出力する
rst = 2 を 底 とする int ( input () ) に 1 を加えた 値の 対 数の 整数値 を出力する <eos>
2780
src = A . distance = [ [ B ] * [ A . V for C in range ( A . V ) ] ]
trg = ( ( B ) からなる 列 の 0 から A の V 未 満 までの 数 列 の 各要素 を C とし 、 A の V の 列 回 分 の 列 ) からなる 列 を A の distance にする
rst = ( ( B ) からなる 列 の 0 から A の V 未 満 までの 数 列 の 各要素 を C とし 、 A の V の 列 回 分 の 列 ) からなる 列 を A の distance にする <eos>
2781
src = A = bisect . bisect ( B , C - B [ D ] , D + 2 )
trg = ソート された 順序 を 保 った まま C から B の D 番 目 を 引 いた 値を B に 挿入 できる 最後の 位置 を A とする
rst = ソート された 順序 を 保 った まま C から B の D 番 目 を 引 いた 値を D に 2 を加えた 値 になる ように ' 0 ' 左 詰 め した 文字列を A とする <eos>
2782
src = A . push_back ( B [ 0 ] )
trg = A . push _ back ( B [ 0 ] )
rst = A . up ( B [ 0 ] ) <eos>
2783
src = A = [ None ] * B
trg = ( 、 つまり 未 定 値 ) からなる 列 の B 回 分 の 列 を A とする
rst = ( 、 つまり 未 定 値 ) からなる 列 の B 回 分 の 列 を A とする <eos>
2784
src = heappush ( A , ( 0 , 0 , B , C , 0 ) )
trg = heappush ( A , ( 0 , 0 , B , C , 0 ) )
rst = heappush ( A , ( 0 , 0 , B , C , 0 ) ) <eos>
2785
src = if A [ 0 ] != 0 :
trg = A の先頭 が 0 と 等 しく ない とき 、
rst = A の 0 番 目 が 0 と 等 しく ない とき 、 <eos>
2786
src = A = fix ( int ( B ) * C )
trg = fix ( int ( B ) * C ) を A とする
rst = fix ( int ( B ) * C ) を A とする <eos>
2787
src = A = max ( A , c ( C ) if B == 1 else s ( C ) )
trg = A 、 B が 1 と 等 しい とき c ( C ) 、 そうでなければ s ( C ) の 最大 値を A とする
rst = B が 1 と 等 しい とき c ( C ) 、 そうでなければ s ( C ) の 最大 値を A とする <eos>
2788
src = A , B , C = 255 , 0 , 255
trg = 25 5 、 0 、 25 5 を A 、 B 、 C とする
rst = 25 5 、 0 、 25 5 を A 、 B 、 C とする <eos>
2789
src = A = paint ( A , B + 2 , C + 2 )
trg = paint ( A , B + 2 , C + 2 ) を A とする
rst = paint ( A , B + 2 , C + 2 ) を A とする <eos>
2790
src = while A < B and C [ A ] == C [ A - 1 ] + 1 :
trg = A が B より 小さく かつ C の A 番 目 が C の A から 1 を 引 いた 値 番 目 に 1 を加えた 値 と 等 しい 間 、 次 を 繰り返す
rst = A が B より 小さく かつ C の A 番 目 が C の A から 1 を 引 いた 値 番 目 に 1 を加えた 値 と 等 しい 間 、 次 を 繰り返す <eos>
2791
src = A . append ( ( B + 1 , C , D - 1 ) )
trg = A の 末 尾 に ( B に 1 を加えた 値 、 C 、 D から 1 を 引 いた 値 ) の 組 を追加する
rst = A の 末 尾 に ( B に 1 を加えた 値 、 C 、 D から 1 を 引 いた 値 ) の 組 を追加する <eos>
2792
src = for A in range ( 1 , len ( B . dp ) ) :
trg = 1 から B の dp の長さ 未 満 までの 数 列 を 順に A として 、 繰り返す
rst = 1 から B の dp の長さ 未 満 までの 数 列 を 順に A として 、 繰り返す <eos>
2793
src = A = B - ( C - B )
trg = B から C から B を 引 いた 値を 引 いた 値を A とする
rst = B から C から B を 引 いた 値を 引 いた 値を A とする <eos>
2794
src = A . propagate ( ( B - 1 ) >> C )
trg = A . propagate ( ( B -1 ) > > C )
rst = A . <unk> ( B -1 ) を C だけ 右 シフト した 値 <eos>
2795
src = A . append ( ( 0 , B , 1 , 0 ) )
trg = A の 末 尾 に ( 0 、 B 、 1 、 0 ) の 組 を追加する
rst = A の 末 尾 に ( 0 、 B 、 1 、 0 ) の 組 を追加する <eos>
2796
src = A . set_range ( B , C , D )
trg = A . set _ range ( B , C , D )
rst = A . set _ range ( B , C , D ) <eos>
2797
src = if A [ B - C ] :
trg = A の B から C を 引 いた 値 番目の とき 、
rst = A の B から C を 引 いた 値 番目の とき 、 <eos>
2798
src = print ( A , B , C , B , D , sep = '' )
trg = 区切り なしで A 、 B 、 C 、 B 、 D を出力する
rst = 区切り なしで A 、 B 、 C 、 B 、 D を出力する <eos>
2799
src = while 2 * A - 1 <= B :
trg = 2 に A を 掛 け た 値 から 1 を 引 いた 値が B 以下の 間 、 次 を 繰り返す
rst = 2 に A を 掛 け た 値 から 1 を 引 いた 値が B 以下の 間 、 次 を 繰り返す <eos>
2800
src = A [ ord ( B ) - C ] = int ( D )
trg = D の 整数値 を A の B の 順序 数 から C を 引 いた 値 番 目 にする
rst = D の 整数値 を A の B の 順序 数 から C を 引 いた 値 番 目 にする <eos>
2801
src = print ( run_length ( A . strip ( ) ) )
trg = run _ length ( A . strip () ) を出力する
rst = roman _ to _ decimal ( A . strip () ) を出力する <eos>
2802
src = for A in range ( 2 , 10 ) :
trg = 2 から 10 未 満 までの 数 列 を 順に A として 、 繰り返す
rst = 2 から 10 未 満 までの 数 列 を 順に A として 、 繰り返す <eos>
2803
src = print ( A . upper ( ) , end = '' )
trg = 改行 せずに A を 英 大文字 に変換し た 文字列 を出力する
rst = 改行 せずに A を 英 大文字 に変換し た 文字列 を出力する <eos>
2804
src = for A in generate_prime_numbers ( num_max = B ) :
trg = generate _ prime _ numbers ( num _ max = B ) を 順に A として 、 繰り返す
rst = <unk> _ back ( B ) を 順に A として 、 繰り返す <eos>
2805
src = A = [ [ False for B in range ( 13 ) ] for C in range ( 4 ) ]
trg = 0 から 4 未 満 までの 数 列 の 各要素 を C とし 、 0 から 13 未 満 までの 数 列 の 各要素 を B とし 、 、 つまり 偽 の 列 の 列 を A とする
rst = 0 から 4 未 満 までの 数 列 の 各要素 を C とし 、 0 から 13 未 満 までの 数 列 の 各要素 を B とし 、 、 つまり 偽 の 列 の 列 を A とする <eos>
2806
src = A [ 5 ] = copy [ 4 ]
trg = copy の 4 番 目 を A の 5 番 目 にする
rst = copy の 4 番 目 を A の 5 番 目 にする <eos>
2807
src = if A >= 19890108 :
trg = A が 1989 0 10 8 以上の とき 、
rst = A が 1 90 0000 以上の とき 、 <eos>
2808
src = if set ( [ A ] ) . issubset ( B ) :
trg = ( A ) からなる 列 の集合 が B の 部分 集合 の とき 、
rst = A の先頭 の 部分 列 の集合 が B の とき 、 <eos>
2809
src = A = [ ( 0 , - 1 ) , ( 1 , 0 ) , ( 0 , 1 ) , ( - 1 , 0 ) ]
trg = ( ( 0 、 -1 ) の 組 、 ( 1 、 0 ) の 組 、 ( 0 、 1 ) の 組 、 ( -1 、 0 ) の 組 ) からなる 列 を A とする
rst = ( ( 0 、 -1 ) の 組 、 ( 1 、 0 ) の 組 、 ( 0 、 1 ) の 組 、 ( -1 、 0 ) の 組 ) からなる 列 を A とする <eos>
2810
src = e , A = map ( float , input ( ) . split ( ) )
trg = 入力された 文字列を 空白 で 分割 した 字句 列 の 各要素 に 浮動小数点数 を適用した 列 を 展開 し 、 それぞれ 、 つまり ネ イ ピ ア 数 、 A とする
rst = 入力された 文字列を 空白 で 分割 した 字句 列 の 各要素 に 浮動小数点数 を適用した 列 を 展開 し 、 それぞれ 、 つまり ネ イ ピ ア 数 、 A とする <eos>
2811
src = A = [ B ] * ( C * ( D + 1 ) + 2 )
trg = ( B ) からなる 列 の C に D に 1 を加えた 値を 掛 け た 値に 2 を加えた 値 回 分 の 列 を A とする
rst = ( B ) からなる 列 の C に D に 1 を加えた 値を 掛 け た 値に 2 を加えた 値 回 分 の 列 を A とする <eos>
2812
src = A = 1e9
trg = 1 e 9 を A とする
rst = 1 e 9 を A とする <eos>
2813
src = A = [ B for B in range ( 7 ) ]
trg = 0 から 7 未 満 までの 数 列 の 各要素 を B とし 、 B の 列 を A とする
rst = 0 から 7 未 満 までの 数 列 の 各要素 を B とし 、 B の 列 を A とする <eos>
2814
src = return A . search ( B , C )
trg = A . search ( B , C ) を返す
rst = A . search ( B , C ) を返す <eos>
2815
src = print ( A . format ( B [ C ] ) , end = '' )
trg = 改行 せずに A を 書式 として B の C 番 目 で 整 形 した 文字列 を出力する
rst = 改行 せずに A を 書式 として B の C 番 目 で 整 形 した 文字列 を出力する <eos>
2816
src = if A == B [ C . FORESIDE ] :
trg = A が B の C の FORESIDE 番 目 と 等 しい とき 、
rst = A が B の C の <unk> 番 目 と 等 しい とき 、 <eos>
2817
src = if ( A , B + 1 ) not in C :
trg = ( A 、 B に 1 を加えた 値 ) の 組 が C に 含まれ ない とき 、
rst = ( A 、 B に 1 を加えた 値 ) の 組 が C に 含まれ ない とき 、 <eos>
2818
src = A [ B ] = C . pop ( )
trg = C の先頭 を取り 出した 値を A の B 番 目 にする
rst = C の先頭 を取り 出した 値を A の B 番 目 にする <eos>
2819
src = A . append ( False )
trg = A の 末 尾 に 偽 を追加する
rst = A の 末 尾 に 偽 を追加する <eos>
2820
src = A = palindrome ( B , C )
trg = palindrome ( B , C ) を A とする
rst = <unk> ( B , C ) を A とする <eos>
2821
src = A [ B ] . c = [ C , D ]
trg = ( C 、 D ) からなる 列 を A の B 番目の c にする
rst = ( C 、 D ) からなる 列 を A の B 番目の c にする <eos>
2822
src = for A , B , C in ( [ map ( int , readline ( ) . split ( ) ) for D in range ( E ) ] ) :
trg = 0 から E 未 満 までの 数 列 の 各要素 を D とし 、 readline () を 空白 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 の 列 を 順に A 、 B 、 C として 、 繰り返す
rst = 0 から E 未 満 までの 数 列 の 各要素 を D とし 、 readline () を 空白 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 の 列 を 順に A 、 B 、 C として 、 繰り返す <eos>
2823
src = A = AhoCorasick ( )
trg = AhoCorasick () を A とする
rst = <unk> () を A とする <eos>
2824
src = A , B , C = Point ( 0.0 , 0.0 ) , Point ( 0.0 , 0.0 ) , Point ( 0.0 , 0.0 )
trg = Point ( 0.0 , 0.0 ) 、 Point ( 0.0 , 0.0 ) 、 Point ( 0.0 , 0.0 ) を A 、 B 、 C とする
rst = Point ( 0.0 , 0.0 ) 、 Point ( 0.0 , 0.0 ) 、 Point ( 0.0 , 0.0 ) を A 、 B 、 C とする <eos>
2825
src = if A [ 0 ] in B and A [ 1 ] in C :
trg = A の 0 番 目 が B に 含まれ かつ A の 1 番 目 が C に含まれる とき 、
rst = A の 0 番 目 が B に 含まれ かつ A の 1 番 目 が C に含まれる とき 、 <eos>
2826
src = if len ( set ( [ A [ : B ] for A in C ] ) ) == D :
trg = C の 各要素 を A とし 、 A の 、 つまり 先頭 から B 番 目 までの 部分 列 の 列 の集合 の長さ が D と 等 しい とき 、
rst = C の 各要素 を A とし 、 A の 、 つまり 先頭 から B 番 目 までの 部分 列 の 列 の集合 の長さ が D と 等 しい とき 、 <eos>
2827
src = A [ 0 ] , A [ 1 ] , A [ 2 ] , A [ 3 ] , A [ 4 ] , A [ 5 ] = A [ 1 ] , A [ 5 ] , A [ 2 ] , A [ 3 ] , A [ 0 ] , A [ 4 ]
trg = A の 1 番 目 、 A の 5 番 目 、 A の 2 番 目 、 A の 3 番 目 、 A の先頭 、 A の 4 番 目 を A の先頭 、 A の 1 番 目 、 A の 2 番 目 、 A の 3 番 目 、 A の 4 番 目 、 A の 5 番 目 とする
rst = A の 1 番 目 、 A の 2 番 目 、 A の 3 番 目 、 A の先頭 、 A の 4 番 目 を A の先頭 、 A の 1 番 目 、 A の 2 番 目 、 A の 3 番 目 、 A の
2828
src = A [ 3 ] [ int ( B ) - 1 ] = True
trg = 真 を A の 3 番目の B の 整数値 から 1 を 引 いた 値 番 目 にする
rst = 真 を A の 3 番目の B の 整数値 から 1 を 引 いた 値 番 目 にする <eos>
2829
src = import array
trg = array モジュール を用いる
rst = string モジュール を用いる <eos>
2830
src = if A * 2 < B :
trg = A に 2 を 掛 け た 値が B より 小さい とき 、
rst = A に 2 を 掛 け た 値が B より 小さい とき 、 <eos>
2831
src = count += ( len ( A ) - 1 ) - B
trg = 無限 の 整数 列 を A の長さ から 1 を 引 いた 値 から B を 引 いた 値 だけ 増加 させる
rst = 無限 の 整数 列 を A の長さ から 1 を 引 いた 値 から B を 引 いた 値 だけ 増加 させる <eos>
2832
src = A = datetime ( B , C , D )
trg = datetime を A とする
rst = B のうち C 個 までの コン ビ ネ ー ション を A とする <eos>
2833
src = A [ 7 + ( B - C ) ] = True
trg = 真 を A の 7 に B から C を 引 いた 値 を加えた 値 番 目 にする
rst = 真 を A の 7 に B から C を 引 いた 値 を加えた 値 番 目 にする <eos>
2834
src = A [ ( B , 0 ) ] = 0
trg = 0 を A の ( B 、 0 ) の 組 番 目 にする
rst = 0 を A の ( B 、 0 ) の 組 番 目 にする <eos>
2835
src = A += dfs ( B + 1 , C )
trg = A を dfs ( B + 1, C ) だけ 増加 させる
rst = A を dfs ( B + 1, C ) だけ 増加 させる <eos>
2836
src = if A - B < 0 or A - B > C - D or B > D :
trg = A から B を 引 いた 値が 0 より 小さく または A から B を 引 いた 値が C から D を 引 いた 値 より 大きく または B が D より 大きい とき 、
rst = A から B を 引 いた 値が 0 より 小さく または A から B を 引 いた 値が C から D を 引 いた 値 より 大きく または B が D より 大きい とき 、 <eos>
2837
src = A = B - check ( C , D )
trg = B から check ( C , D ) を 引 いた 値を A とする
rst = B から check ( C , D ) を 引 いた 値を A とする <eos>
2838
src = A [ 2 ] = str ( A [ 2 ] )
trg = A の 2 番目の 文字列を A の 2 番 目 にする
rst = A の 2 番目の 文字列を A の 2 番 目 にする <eos>
2839
src = for A in range ( 1 , 13 ) :
trg = 1 から 13 未 満 までの 数 列 を 順に A として 、 繰り返す
rst = 1 から 13 未 満 までの 数 列 を 順に A として 、 繰り返す <eos>
2840
src = A = calc_LCM ( A , B )
trg = calc _ LCM ( A , B ) を A とする
rst = <unk> ( A , B ) を A とする <eos>
2841
src = if abs ( A [ B ] - C ) > 0.5 :
trg = A の B 番 目 から C を 引 いた 値の 絶対 値が 0.5 より 大きい とき 、
rst = A の B 番 目 から C を 引 いた 値の 絶対 値が 0.5 より 大きい とき 、 <eos>
2842
src = A = [ ( 1 << B ) - 1 for C in range ( D ) ]
trg = 0 から D 未 満 までの 数 列 の 各要素 を C とし 、 1 を B だけ 左 シフト した 値 から 1 を 引 いた 値の 列 を A とする
rst = 0 から D 未 満 までの 数 列 の 各要素 を C とし 、 1 を B だけ 左 シフト した 値 から 1 を 引 いた 値の 列 を A とする <eos>
2843
src = if A [ - 1 ] >= 0 :
trg = A の -1 番 目 が 0 以上の とき 、
rst = A の -1 番 目 が 0 以上の とき 、 <eos>
2844
src = A = [ None ] * ( B + 2 )
trg = ( 、 つまり 未 定 値 ) からなる 列 の B に 2 を加えた 値 回 分 の 列 を A とする
rst = ( 、 つまり 未 定 値 ) からなる 列 の B に 2 を加えた 値 回 分 の 列 を A とする <eos>
2845
src = assert A in B
trg = A が B に 含まれ なければならない
rst = A が B に 含まれ なければならない <eos>
2846
src = if A > 0 or B [ C ] :
trg = A が 0 より 大きく または B の C 番目の とき 、
rst = A が 0 より 大きく または B の C 番目の とき 、 <eos>
2847
src = print ( A . format ( B [ 0 ] [ 0 ] , time ) )
trg = A を 書式 として B の先頭 の先頭 、 time で 整 形 した 文字列 を出力する
rst = A を 書式 として B の先頭 の先頭 、 time で 整 形 した 文字列 を出力する <eos>
2848
src = A = len ( { v : [ C for C , B in enumerate ( D [ E ] ) ] } )
trg = ( ( B , D [ E ] に 番号 付 した 組 の 列 の 各要素 を C 、 B とし 、 C の 列 ) ) からなる 辞書 の長さ を A とする
rst = ( ( B , D の E 番目の 各要素 を C 、 B とし 、 C の 列 ) ) からなる 辞書 の長さ を A とする <eos>
2849
src = A . next = A . next . next
trg = A の next の next を A の next にする
rst = A の next の next を A の next にする <eos>
2850
src = A = B [ C [ 2 ] ] + B [ C [ 3 ] ]
trg = B の C の 2 番 目 番 目 に B の C の 3 番 目 番 目 を加えた 値を A とする
rst = B の C の 2 番 目 番 目 に B の C の 3 番 目 番 目 を加えた 値を A とする <eos>
2851
src = A [ 2 ] = B * 5
trg = B に 5 を 掛 け た 値を A の 2 番 目 にする
rst = B に 5 を 掛 け た 値を A の 2 番 目 にする <eos>
2852
src = while A > 0 and B [ A - 1 ] == ' ' :
trg = A が 0 より 大きく かつ B の A から 1 を 引 いた 値 番 目 が 、 つまり 空白 文字 と 等 しい 間 、 次 を 繰り返す
rst = A が 0 より 大きく かつ B の A から 1 を 引 いた 値 番 目 が 、 つまり 空白 文字 と 等 しい 間 、 次 を 繰り返す <eos>
2853
src = A [ B ] [ C ] , A [ C ] [ B ] = e , e
trg = ネ イ ピ ア 数 、 ネ イ ピ ア 数 を A の B 番目の C 番 目 、 A の C 番目の B 番 目 とする
rst = ネ イ ピ ア 数 、 ネ イ ピ ア 数 を A の B 番目の C 番 目 、 A の C 番目の B 番 目 とする <eos>
2854
src = A += int ( B [ C ] ) * ( 6 - C )
trg = A を B の C 番目の 整数値 に 6 から C を 引 いた 値を 掛 け た 値 だけ 増加 させる
rst = A を B の C 番目の 整数値 に 6 から C を 引 いた 値を 掛 け た 値 だけ 増加 させる <eos>
2855
src = A += ( 10 - B + 1 ) // 2
trg = A を 10 から B を 引 いた 値に 1 を加えた 値を 2 で 割 った 商 だけ 増加 させる
rst = A を 10 から B を 引 いた 値に 1 を加えた 値を 2 で 割 った 商 だけ 増加 させる <eos>
2856
src = A += int ( B * C [ D ] )
trg = A を B に C の D 番 目 を 掛 け た 値の 整数値 だけ 増加 させる
rst = A を B に C の D 番目の 整数値 を 掛 け た 値 だけ 増加 させる <eos>
2857
src = A += B * 2 + C * 2
trg = A を B に 2 を 掛 け た 値に C に 2 を 掛 け た 値 を加えた 値 だけ 増加 させる
rst = A を B に 2 を 掛 け た 値に C に 2 を 掛 け た 値 を加えた 値 だけ 増加 させる <eos>
2858
src = A = analyze_map ( B )
trg = analyze _ map ( B ) を A とする
rst = <unk> ( B ) を A とする <eos>
2859
src = return A . north
trg = A の north を返す
rst = A の north を返す <eos>
2860
src = if not 0 <= A < B or not 0 <= C < D or E [ A ] [ C ] or F != G [ A ] [ C ] :
trg = 0 < = A が B より 小さく なく または 0 < = C が D より 小さく なく または E の A 番目の C 番 目 または F が G の A 番目の C 番 目 と 等 しく ない とき 、
rst = 0 が A 以下 かどうか が B より 小さく なく または 0 が C 以下 かどうか が D より 小さく なく または E の A 番目の C 番 目 が F と 等 しく なく または G の A 番目の C 番 目 が C と 等 しく ない とき
2861
src = for A in range ( 1 , B - 2 ) :
trg = 1 から B から 2 を 引 いた 値 未 満 までの 数 列 を 順に A として 、 繰り返す
rst = 1 から B から 2 を 引 いた 値 未 満 までの 数 列 を 順に A として 、 繰り返す <eos>
2862
src = A [ B - 1 ] [ C + 1 ] = 0
trg = 0 を A の B から 1 を 引 いた 値 番目の C に 1 を加えた 値 番 目 にする
rst = 0 を A の B から 1 を 引 いた 値 番目の C に 1 を加えた 値 番 目 にする <eos>
2863
src = A . append ( ( B + 1 , C + 1 , 2 ) )
trg = A の 末 尾 に ( B に 1 を加えた 値 、 C に 1 を加えた 値 、 2 ) の 組 を追加する
rst = A の 末 尾 に ( B に 1 を加えた 値 、 C に 1 を加えた 値 、 2 ) の 組 を追加する <eos>
2864
src = 2.000000
trg = 2.0 0000 0
rst = <unk> <eos>
2865
src = A = leftend ( B )
trg = leftend ( B ) を A とする
rst = <unk> ( B ) を A とする <eos>
2866
src = A . show_status ( )
trg = A . show _ status ()
rst = A . <unk> () <eos>
2867
src = time = [ 0 ] * ( 60 * 60 * 24 + 1 )
trg = ( 0 ) からなる 列 の 60 に 60 を 掛 け た 値に 24 を 掛 け た 値に 1 を加えた 値 回 分 の 列 を time とする
rst = ( 0 ) からなる 列 の 60 に 60 を 掛 け た 値に 24 を 掛 け た 値に 1 を加えた 値 回 分 の 列 を time とする <eos>
2868
src = if A [ B : ] == C [ : D ] :
trg = A の B 番 目 から 、 つまり 末 尾 までの 部分 列 が C の 、 つまり 先頭 から D 番 目 までの 部分 列 と 等 しい とき 、
rst = A の B 番 目 から 、 つまり 末 尾 までの 部分 列 が C の 、 つまり 先頭 から D 番 目 までの 部分 列 と 等 しい とき 、 <eos>
2869
src = return ( A - 1 ) % 5
trg = A から 1 を 引 いた 値を 5 で 割 った 余 り を返す
rst = A から 1 を 引 いた 値を 5 で 割 った 余 り を返す <eos>
2870
src = print ( min ( solve ( 0 ) , solve ( 1 ) ) )
trg = solve ( 0 ) 、 solve (1) の 最小 値 を出力する
rst = solve ( 0 ) 、 solve ( 1 ) の 最小 値 を出力する <eos>
2871
src = A , B = heapreplace ( C . _cacheq , ( time . clock ( ) , D ) )
trg = heapreplace ( C . _ cacheq , ( time . clock () , D ) ) を 展開 し 、 それぞれ A 、 B とする
rst = _ cacheq _ cacheq _ <unk> _ point ( C . _ <unk> ( time , ( time . <unk> () , D ) ) を 展開 し 、 それぞれ A 、 B とする <eos>
2872
src = A = koch_curve ( B [ 3 ] , B [ 4 ] , C - 1 )
trg = koch _ curve ( B [ 3 ] , B [ 4 ] , C -1 ) を A とする
rst = koch _ curve ( B [ 3 ] , B [ 4 ] , C -1 ) を A とする <eos>
2873
src = A += get_pro ( B , C )
trg = A を get _ pro ( B , C ) だけ 増加 させる
rst = A を <unk> ( B , C ) だけ 増加 させる <eos>
2874
src = return [ A , path ]
trg = ( A 、 os . path ) からなる 列 を返す
rst = ( A 、 os . path ) からなる 列 を返す <eos>
2875
src = A = A + int ( B [ C ] )
trg = A に B の C 番目の 整数値 を加えた 値を A とする
rst = A に B の C 番目の 整数値 を加えた 値を A とする <eos>
2876
src = print ( 1 + len ( [ A for A in B if A > 0 ] ) )
trg = 1 に B の 各要素 を A とし 、 A が 0 より 大きい とき の A の 列 の長さ を加えた 値 を出力する
rst = 1 に B の 各要素 を A とし 、 A が 0 より 大きい とき の A の 列 の長さ を加えた 値 を出力する <eos>
2877
src = A = 7200 - C if B else ( 7200 - C ) * 3
trg = B の とき 7 200 から C を 引 いた 値 、 そうでなければ 7 200 から C を 引 いた 値に 3 を 掛 け た 値を A とする
rst = B の とき 7 、 そうでなければ 7 200 から C を 引 いた 値に 3 を 掛 け た 値を A とする <eos>
2878
src = check ( input ( ) )
trg = check ( input () )
rst = check ( input () ) <eos>
2879
src = A [ 0 ] = B
trg = B を A の 0 番 目 にする
rst = B を A の 0 番 目 にする <eos>
2880
src = if A [ B ] [ 1 ] <= C :
trg = A の B 番目の 1 番 目 が C 以下の とき 、
rst = A の B 番目の 1 番 目 が C 以下の とき 、 <eos>
2881
src = A = [ float ( B ) for B in C ]
trg = C の 各要素 を B とし 、 B の 浮動小数点数 の 列 を A とする
rst = C の 各要素 を B とし 、 B の 浮動小数点数 の 列 を A とする <eos>
2882
src = A . preprint ( A . root )
trg = A . preprint ( A . root )
rst = A . add _ index ( A . root ) <eos>
2883
src = A . W = B
trg = B を A の W にする
rst = B を A の W にする <eos>
2884
src = A = [ ( B [ 0 ] , int ( B [ 1 : ] ) ) for B in input ( ) . split ( ) ]
trg = 入力された 文字列を 空白 で 分割 した 字句 列 の 各要素 を B とし 、 ( B の先頭 、 B の先頭 を 除 いた 部分 列 の 整数値 ) の 組 の 列 を A とする
rst = 入力された 文字列を 空白 で 分割 した 字句 列 の 各要素 を B とし 、 ( B の先頭 、 B の 1 番 目 から 、 つまり 末 尾 までの 部分 列 の 整数値 ) の 組 の 列 を A とする <eos>
2885
src = A = B [ 4 ] - B [ 1 ]
trg = B の 4 番 目 から B の 1 番 目 を 引 いた 値を A とする
rst = B の 4 番 目 から B の 1 番 目 を 引 いた 値を A とする <eos>
2886
src = if A ^ B >= 0 :
trg = A と B の 排 他 論理 和 が 0 以上の とき 、
rst = A と B の 排 他 論理 和 が 0 以上の とき 、 <eos>
2887
src = if solve ( 0 , A , B ) :
trg = solve ( 0 , A , B ) の とき 、
rst = solve ( 0 , A , B ) の とき 、 <eos>
2888
src = return bin ( A ^ B ) [ 2 : ] . zfill ( 7 )
trg = A と B の 排 他 論理 和 の 2 進 数 文字列 の 2 番 目 から 、 つまり 末 尾 までの 部分 列 を 長さ 7 になる ように ' 0 ' 左 詰 め した 文字列 を返す
rst = A と B の 排 他 論理 和 の 2 進 数 文字列 の 2 番 目 から 、 つまり 末 尾 までの 部分 列 を 長さ 7 になる ように ' 0 ' 左 詰 め した 文字列 を返す <eos>
2889
src = - A * B * C - D * E * F - G * H * I
trg = - A に B を 掛 け た 値に C を 掛 け た 値 から D に E を 掛 け た 値に F を 掛 け た 値を 引 いた 値 から G に H を 掛 け た 値に I を 掛 け た 値を 引 いた 値
rst = - A に B を 掛 け た 値に C を 掛 け た 値 から D に E を 掛 け た 値に F を 掛 け た 値を 引 いた 値 から G に H を 掛 け た 値を 引 いた 値 から I を 引 いた
2890
src = if ( not A [ B ] ) and ( C [ B ] < D ) :
trg = A の B 番 目 で なく かつ C の B 番 目 が D より 小さい とき 、
rst = A の B 番 目 で なく かつ C の B 番 目 が D より 小さい とき 、 <eos>
2891
src = A += ' ' . join ( [ str ( B ) for B in C [ : D ] ] ) + ' '
trg = A を 空白 文字 を 間 に 入れ て C の 、 つまり 先頭 から D 番 目 までの 部分 列 の 各要素 を B とし 、 B の 文字列 の 列 を 連結 した 文字列 に 空白 文字 を加えた 値 だけ 増加 させる
rst = A を 空白 文字 を 間 に 入れ て C の 、 つまり 先頭 から D 番 目 までの 部分 列 の 各要素 を B とし 、 B の 文字列 の 列 を 連結 した 文字列 に 空白 文字 を加えた 値 だけ 増加 させる <eos>
2892
src = A [ ( B , C - 1 ) ] = D [ ( B , C - 1 ) ]
trg = D の ( B 、 C から 1 を 引 いた 値 ) の 組 番 目 を A の ( B 、 C から 1 を 引 いた 値 ) の 組 番 目 にする
rst = D の ( B 、 C から 1 を 引 いた 値 ) の 組 番 目 を A の ( B 、 C から 1 を 引 いた 値 ) の 組 番 目 にする <eos>
2893
src = print ( change ( A , B ) )
trg = change ( A , B ) を出力する
rst = change ( A , B ) を出力する <eos>
2894
src = for A in range ( 1 , max ( B ) + 1 ) :
trg = 1 から B の 最大 値に 1 を加えた 値 未 満 までの 数 列 を 順に A として 、 繰り返す
rst = 1 から B の 最大 値に 1 を加えた 値 未 満 までの 数 列 を 順に A として 、 繰り返す <eos>
2895
src = A [ B ] = op ( merge ( C [ B ] , D [ B ] ) , A [ E ] )
trg = op ( merge ( C [ B ] , D [ B ] ) , A [ E ] ) を A の B 番 目 にする
rst = op ( merge ( C [ B ] , D [ B ] ) , A [ E ] ) を A の B 番 目 にする <eos>
2896
src = A [ B ] . sib = C
trg = C を A の B 番目の sib にする
rst = C を A の B 番目の sib にする <eos>
2897
src = for A in range ( B + 1 , 2 * B + 1 ) :
trg = B に 1 を加えた 値 から 2 に B を 掛 け た 値に 1 を加えた 値 未 満 までの 数 列 を 順に A として 、 繰り返す
rst = B に 1 を加えた 値 から 2 に B を 掛 け た 値に 1 を加えた 値 未 満 までの 数 列 を 順に A として 、 繰り返す <eos>
2898
src = if A == [ 1 , 1 , 1 , 2 ] :
trg = A が ( 1 、 1 、 1 、 2 ) からなる 列 と 等 しい とき 、
rst = A が ( 1 、 1 、 1 、 2 ) からなる 列 と 等 しい とき 、 <eos>
2899
src = A = [ int ( B ) - 1 for B in input ( ) . split ( ' ' ) ]
trg = 入力された 文字列を 空白 文字 で 分割 した 字句 列 の 各要素 を B とし 、 B の 整数値 から 1 を 引 いた 値の 列 を A とする
rst = 入力された 文字列を 空白 文字 で 分割 した 字句 列 の 各要素 を B とし 、 B の 整数値 から 1 を 引 いた 値の 列 を A とする <eos>
2900
src = while 0 <= A < B and 0 <= C < D :
trg = 0 が A 以下 かどうか が B より 小さく かつ 0 が C 以下 かどうか が D より 小さい 間 、 次 を 繰り返す
rst = 0 が A 以下 かどうか が B より 小さく かつ 0 が C 以下 かどうか が D より 小さい 間 、 次 を 繰り返す <eos>
2901
src = A = { B }
trg = ( < __ main __ . Cammaobjectat 0 x 10 a 1 db 7 30 > ) の集合 を A とする
rst = ( < __ main __ . Cammaobjectat 0 x 10 a 1 db 9 a 0 > ) の集合 を A とする <eos>
2902
src = A = - B [ 0 ] [ C ]
trg = - B の先頭 の C 番 目 を A とする
rst = - B の先頭 の C 番 目 を A とする <eos>
2903
src = A . head . next . prev = B
trg = B を A の head の next の prev にする
rst = B を A の head の prev にする <eos>
2904
src = A = ( 5 , 7 , 5 , 7 , 7 )
trg = ( 5 、 7 、 5 、 7 、 7 ) の 組 を A とする
rst = ( 5 、 7 、 5 、 7 、 7 ) の 組 を A とする <eos>
2905
src = A = [ 100.0 , 0.0 ]
trg = ( 10 0.0 、 0.0 ) からなる 列 を A とする
rst = ( 10 0.0 、 0.0 ) からなる 列 を A とする <eos>
2906
src = A = B [ : C // 2 ]
trg = B の 、 つまり 先頭 から C を 2 で 割 った 商 までの 部分 列 を A とする
rst = B の 、 つまり 先頭 から C を 2 で 割 った 商 までの 部分 列 を A とする <eos>
2907
src = A = A + ( int ( B [ C ] ) - D ) ** 2
trg = A に B の C 番目の 整数値 から D を 引 いた 値の 2 乗 を加えた 値を A とする
rst = A に B の C 番目の 整数値 から D を 引 いた 値の 2 乗 を加えた 値を A とする <eos>
2908
src = A = B in C
trg = B が C に含まれる かどうか を A とする
rst = B が C に含まれる かどうか を A とする <eos>
2909
src = now = - 1
trg = -1 を 現在の 日 時 とする
rst = -1 を 現在の 日 時 とする <eos>
2910
src = del A [ B : B + 2 ]
trg = A の B 番 目 から B に 2 を加えた 値 までの 部分 列 を削除する
rst = A の B 番 目 から B に 2 を加えた 値 までの 部分 列 を削除する <eos>
2911
src = A , B = map ( int , input ( ) . split ( ' ' ) )
trg = 入力された 文字列を 空白 文字 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 を 展開 し 、 それぞれ A 、 B とする
rst = 入力された 文字列を 空白 文字 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 を 展開 し 、 それぞれ A 、 B とする <eos>
2912
src = print ( * sorted ( map ( int , input ( ) . split ( ) ) ) )
trg = input () を 空白 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 を ソート した 列 を 展開 して を出力する
rst = input () を 空白 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 を ソート した 列 を 展開 して を出力する <eos>
2913
src = A , B = C * D * E - F * G * H , D * F * E
trg = C に D を 掛 け た 値に E を 掛 け た 値 から F に G を 掛 け た 値に H を 掛 け た 値を 引 いた 値 、 D に F を 掛 け た 値に E を 掛 け た 値を A 、 B とする
rst = C に D を 掛 け た 値に E を 掛 け た 値 から F に G を 掛 け た 値を 引 いた 値 、 D に F を 掛 け た 値を A 、 B とする <eos>
2914
src = if not 0 <= A < B or not 0 <= C < D or E [ C ] [ A ] == 0 or F [ C ] [ A ] == 1 :
trg = 0 < = A が B より 小さく なく または 0 < = C が D より 小さく なく または E の C 番目の A 番 目 が 0 と 等 しく または F の C 番目の A 番 目 が 1 と 等 しい とき 、
rst = 0 が A 以下 かどうか が B より 小さく なく または 0 が C 以下 かどうか が D より 小さく なく または E の C 番目の A 番 目 が 0 と 等 しく または F の C 番目の A 番 目 が 1 と 等 しい とき 、 <eos>
2915
src = A [ B [ 1 ] ] . append ( B [ 0 ] )
trg = A の B の 1 番 目 番目の 末 尾 に B の先頭 を追加する
rst = A の B の 1 番 目 番目の 末 尾 に B の先頭 を追加する <eos>
2916
src = A = min ( B [ C ] + D [ E ] , B [ E ] + D [ C ] ) + 1
trg = B の C 番 目 に D の E 番 目 を加えた 値 、 B の E 番 目 に D の C 番 目 を加えた 値の 最小 値に 1 を加えた 値を A とする
rst = B の C 番 目 に D の E 番 目 を加えた 値 、 B の E 番 目 に D の C 番 目 を加えた 値の 最小 値に 1 を加えた 値を A とする <eos>
2917
src = A = [ [ - 1 ] * [ 3 for B in range ( 3 ) ] ]
trg = ( ( -1 ) からなる 列 の 0 から 3 未 満 までの 数 列 の 各要素 を B とし 、 3 の 列 回 分 の 列 ) からなる 列 を A とする
rst = ( ( -1 ) からなる 列 の 0 から 3 未 満 までの 数 列 の 各要素 を B とし 、 3 の 列 回 分 の 列 ) からなる 列 を A とする <eos>
2918
src = A = A * ( 1 - 1 / B [ 0 ] )
trg = A に 1 から 1 を B の先頭 で 割 った 値を 引 いた 値を 掛 け た 値を A とする
rst = A に 1 から 1 を B の先頭 で 割 った 値を 引 いた 値を 掛 け た 値を A とする <eos>
2919
src = print ( A . format ( B . get_top_value ( ) ) )
trg = A を 書式 として B . get _ top _ value () で 整 形 した 文字列 を出力する
rst = A を 書式 として B . <unk> _ <unk> () で 整 形 した 文字列 を出力する <eos>
2920
src = e , A , B = list ( map ( int , input ( ) . split ( ) ) )
trg = 入力された 文字列を 空白 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 の リストを 展開 し 、 それぞれ 、 つまり ネ イ ピ ア 数 、 A 、 B とする
rst = 入力された 文字列を 空白 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 の リストを 展開 し 、 それぞれ 、 つまり ネ イ ピ ア 数 、 A 、 B とする <eos>
2921
src = A -= B [ 2 ] * 10
trg = A を B の 2 番 目 に 10 を 掛 け た 値 だけ 減少 させる
rst = A を B の 2 番 目 に 10 を 掛 け た 値 だけ 減少 させる <eos>
2922
src = A = sorted ( A , key = lambda B : ( - B [ 1 ] , B [ 0 ] ) )
trg = x を パラメータ として ( - B の 1 番 目 、 x の先頭 ) の 組 を返す関数 を キー として A を ソート した 列 を A とする
rst = x を パラメータ として ( - B の 1 番 目 、 x の先頭 ) の 組 を返す関数 を キー として A を ソート した 列 を A とする <eos>
2923
src = if A [ B ] <= C < A [ B + 1 ] :
trg = A の B 番 目 が C 以下 かどうか が A の B に 1 を加えた 値 番 目 より 小さい とき 、
rst = A の B 番 目 が C 以下 かどうか が A の B に 1 を加えた 値 番 目 より 小さい とき 、 <eos>
2924
src = A = max ( A , solve ( B , C - 1 , D - 1 ) )
trg = A 、 solve ( B , C - 1, D -1 ) の 最大 値を A とする
rst = A 、 solve ( B , C - 1, D -1 ) の 最大 値を A とする <eos>
2925
src = A = B . data & B . masks [ C ]
trg = B の data と B の masks の C 番目の 論理 積 を A とする
rst = B の data と B の masks の C 番目の 論理 積 を A とする <eos>
2926
src = if A . level [ B ] == - 1 :
trg = A の level の B 番 目 が -1 と 等 しい とき 、
rst = A の level の B 番 目 が -1 と 等 しい とき 、 <eos>
2927
src = A = next_survive ( A ) & B
trg = next _ survive ( A ) と B の 論理 積 を A とする
rst = <unk> ( A ) と B の 論理 積 を A とする <eos>
2928
src = return lambda A , C : sqrt ( ( A - B ) ** 2 + ( C - D ) ** 2 )
trg = x 、 y を パラメータ として A から B を 引 いた 値の 2 乗 に C から D を 引 いた 値の 2 乗 を加えた 値の 平 方 根 を返す関数 を返す
rst = x 、 y を パラメータ として A から B を 引 いた 値の 2 乗 に C から D を 引 いた 値の 2 乗 を加えた 値を返す 関数を key として A から B を 引 いた 値の 平 方 根 を返す <eos>
2929
src = A , B , C , D = E . graph [ E . pos [ F ] [ 0 ] ] [ E . pos [ F ] [ 1 ] ]
trg = E の graph の E の pos の F 番目の 先頭 番目の E の pos の F 番目の 1 番 目 番 目 を 展開 し 、 それぞれ A 、 B 、 C 、 D とする
rst = E の graph の E の pos の F 番目の 先頭 番目の E の pos の 1 番 目 番 目 を 展開 し 、 それぞれ A 、 B 、 C 、 D とする <eos>
2930
src = A . sizes [ B ] += A . sizes [ C ]
trg = A の sizes の B 番 目 を A の sizes の C 番 目 だけ 増加 させる
rst = A の <unk> の B 番 目 を A の <unk> の C 番 目 だけ 増加 させる <eos>
2931
src = if A [ 0 ] <= math . fabs ( A [ 1 ] - A [ 2 ] ) :
trg = A の 0 番 目 が A の 1 番 目 から A の 2 番 目 を 引 いた 値の 絶対 値 以下の とき 、
rst = A の 0 番 目 が A の 1 番 目 から A の 2 番 目 を 引 いた 値の 絶対 値 以下の とき 、 <eos>
2932
src = return A [ 0 ] * B [ 1 ] - B [ 0 ] * A [ 1 ]
trg = A の 先頭に B の 1 番 目 を 掛 け た 値 から B の 先頭に A の 1 番 目 を 掛 け た 値を 引 いた 値を返す
rst = A の 先頭に B の 1 番 目 を 掛 け た 値 から B の 先頭に A の 1 番 目 を 掛 け た 値を 引 いた 値を返す <eos>
2933
src = A [ e ] = A [ e ] + B * C
trg = A の 、 つまり ネ イ ピ ア 数 番 目 に B に C を 掛 け た 値 を加えた 値を A の 、 つまり ネ イ ピ ア 数 番 目 にする
rst = A の 、 つまり ネ イ ピ ア 数 番 目 に B に C を 掛 け た 値 を加えた 値を A の 、 つまり ネ イ ピ ア 数 番 目 にする <eos>
2934
src = if A < B or C < D :
trg = A が B より 小さく または C が D より 小さい とき 、
rst = A が B より 小さく または C が D より 小さい とき 、 <eos>
2935
src = A = Point ( 0.0 , 0.0 )
trg = Point ( 0.0 , 0.0 ) を A とする
rst = Point ( 0.0 , 0.0 ) を A とする <eos>
2936
src = A [ B ] [ C + 1 ] = max ( A [ B ] [ C + 1 ] , D + 1 )
trg = A の B 番目の C に 1 を加えた 値 番 目 、 D に 1 を加えた 値の 最大 値を A の B 番目の C に 1 を加えた 値 番 目 にする
rst = A の B 番目の C に 1 を加えた 値 番 目 、 D に 1 を加えた 値の 最大 値を A の B 番目の C に 1 を加えた 値 番 目 にする <eos>
2937
src = A = fmap[t] ( * B )
trg = fmap [ t ] ( * B ) を A とする
rst = <unk> 1000 ( * B ) を A とする <eos>
2938
src = if A [ B ] != 0 :
trg = A の B 番 目 が 0 と 等 しく ない とき 、
rst = A の B 番 目 が 0 と 等 しく ない とき 、 <eos>
2939
src = if A == 27 :
trg = A が 27 と 等 しい とき 、
rst = A が 27 と 等 しい とき 、 <eos>
2940
src = return ( [ A [ 0 ] , B , C , D , A [ 1 ] ] )
trg = ( A の先頭 、 B 、 C 、 D 、 A の 1 番 目 ) からなる 列 を返す
rst = ( A の先頭 、 B 、 C 、 D 、 A の 1 番 目 ) からなる 列 を返す <eos>
2941
src = if A [ B ] [ C ] + A [ B + 1 ] [ C - 1 ] + A [ B + 1 ] [ C ] + A [ B + 2 ] [ C - 1 ] == 4 :
trg = A [ B ] の C 番 目 に A [ B + 1 ] の C -1 番 目 を加えた 値に A の B + 1 番目の C 番 目 を加えた 値に A の B に 2 を加えた 値 番目の C から 1 を 引 いた 値 番 目 を加えた 値が 4 と 等 しい とき 、
rst = A [ B ] の C 番 目 に A [ B + 1 ] の C から 1 を 引 いた 値 番 目 を加えた 値に A の B + 1 番目の C 番 目 を加えた 値に A の B に 1 を加えた 値 番目の C に 1 を加えた
2942
src = if A [ B ] and not C [ B ] :
trg = A の B 番 目 かつ C の B 番 目 でない とき 、
rst = A の B 番 目 かつ C の B 番 目 でない とき 、 <eos>
2943
src = A , B , C = list ( map ( int , input ( ) . split ( ) ) ) , list ( map ( int , input ( ) . split ( ) ) ) , set ( )
trg = 入力された 文字列を 空白 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 のリスト 、 入力された 文字列を 空白 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 のリスト 、 集合 を A 、 B 、 C とする
rst = 入力された 文字列を 空白 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 のリスト 、 入力された 文字列を 空白 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 のリスト を 展開 し 、 それぞれ A 、 B 、 C とする <eos>
2944
src = A [ 0 ] = input ( ) . strip ( )
trg = 入力された 文字列 の 両 端 から 空白 改行 を取り 除 いた 文字列を A の 0 番 目 にする
rst = 入力された 文字列 の 両 端 から 空白 改行 を取り 除 いた 文字列を A の 0 番 目 にする <eos>
2945
src = A = sum ( B ) - C
trg = B の 総 和 から C を 引 いた 値を A とする
rst = B の 総 和 から C を 引 いた 値を A とする <eos>
2946
src = A = [ [ ] for B in range ( 2 * C ) ]
trg = 0 から 2 に C を 掛 け た 値 未 満 までの 数 列 の 各要素 を B とし 、 、 つまり 空 列 の 列 を A とする
rst = 0 から 2 に C を 掛 け た 値 未 満 までの 数 列 の 各要素 を B とし 、 、 つまり 空 列 の 列 を A とする <eos>
2947
src = e = A [ root ( B ) ]
trg = A の root ( B ) 番 目 を ネ イ ピ ア 数 とする
rst = A の root ( B ) 番 目 を ネ イ ピ ア 数 とする <eos>
2948
src = A = max ( A , B [ C ] [ D ] + B [ D ] [ D + 1 ] )
trg = A 、 B の C 番目の D 番 目 に B の D 番目の D に 1 を加えた 値 番 目 を加えた 値の 最大 値を A とする
rst = A 、 B の C 番目の D 番 目 に B の D 番目の D に 1 を加えた 値 番 目 を加えた 値の 最大 値を A とする <eos>
2949
src = A = str ( int ( B ) - int ( C ) ) . zfill ( 4 )
trg = B の 整数値 から C の 整数値 を 引 いた 値の 文字列を 長さ 4 になる ように ' 0 ' 左 詰 め した 文字列を A とする
rst = B の 整数値 から C の 整数値 を 引 いた 値の 文字列を 長さ 4 になる ように ' 0 ' 左 詰 め した 文字列を A とする <eos>
2950
src = A [ B ] . children . append ( C )
trg = A の B 番目の children の 末 尾 に C を追加する
rst = A の B 番目の children の 末 尾 に C を追加する <eos>
2951
src = while len ( A ) and B [ A [ - 1 ] ] >= 0 :
trg = A の長さ かつ B の A の 末 尾 番 目 が 0 以上の 間 、 次 を 繰り返す
rst = A の長さ かつ B の A の 末 尾 番 目 が 0 以上の 間 、 次 を 繰り返す <eos>
2952
src = if 0 <= A - 1 < B and 0 <= C < D and E [ C ] [ A - 1 ] == F :
trg = 0 が A から 1 を 引 いた 値 以下 かどうか が B より 小さく かつ 0 が C 以下 かどうか が D より 小さく かつ E の C 番目の A から 1 を 引 いた 値 番 目 が F と 等 しい とき 、
rst = 0 が A から 1 を 引 いた 値 以下 かどうか が B より 小さく かつ 0 が C 以下 かどうか が D より 小さく かつ E の C 番目の A から 1 を 引 いた 値 番 目 が F と 等 しい とき 、 <eos>
2953
src = print ( max ( A , key = B . itemgetter ( 1 ) ) [ 0 ] )
trg = B . itemgetter (1) を key として A の 最大 値 の先頭 を出力する
rst = B . itemgetter (1) を key として A 、 key として A の 最大 値 の先頭 を出力する <eos>
2954
src = A [ B ] [ 0 ] = 0.0
trg = 0.0 を A の B 番目の 0 番 目 にする
rst = 0.0 を A の B 番目の 0 番 目 にする <eos>
2955
src = return A [ B ] == C
trg = A の B 番 目 が C と 等 しい かどうか を返す
rst = A の B 番 目 が C と 等 しい かどうか を返す <eos>
2956
src = if A . next is not None :
trg = A の next が 、 つまり 未 定 値 と 等 しい とき 、
rst = A の next が 、 つまり 未 定 値 と 等 しい とき 、 <eos>
2957
src = E = F [ G - H ]
trg = F の G から H を 引 いた 値 番 目 を E とする
rst = F の G から H を 引 いた 値 番 目 を E とする <eos>
2958
src = print ( chr ( A . index ( 1 ) + 65 ) )
trg = 文字コード A の 1 と 等 しい 要素 の最初の 位置 に 6 5 を加えた 値の 文字 を出力する
rst = 文字コード A の 1 と 等 しい 要素 の最初の 位置 に 6 5 を加えた 値の 文字 を出力する <eos>
2959
src = A = [ [ 99999999 ] * [ ( B // 100 + 1 ) for C in range ( len ( D ) ) ] ]
trg = ( ( 99 99 99 99 ) からなる 列 の 0 から D の長さ 未 満 までの 数 列 の 各要素 を C とし 、 B を 100 で 割 った 商 に 1 を加えた 値の 列 回 分 の 列 ) からなる 列 を A とする
rst = ( ( 3 80 ) からなる 列 の 0 から D の長さ 未 満 までの 数 列 の 各要素 を C とし 、 B を 100 で 割 った 商 に 1 を加えた 値の 列 回 分 の 列 ) からなる 列 を A とする <eos>
2960
src = for A in range ( B , e ) :
trg = B から 、 つまり ネ イ ピ ア 数 未 満 までの 数 列 を 順に A として 、 繰り返す
rst = B から 、 つまり ネ イ ピ ア 数 未 満 までの 数 列 を 順に A として 、 繰り返す <eos>
2961
src = A = cross ( B - C , B - D )
trg = cross ( B - C , B - D ) を A とする
rst = cross ( B - C , B - D ) を A とする <eos>
2962
src = print ( math . sqrt ( sum ( [ ( A - B ) ** 2 for A in C ] ) / D ) )
trg = C の 各要素 を A とし 、 ( A - B ) * * 2 の 列 の 総 和 を D で 割 った 値の 平 方 根 を出力する
rst = C の 各要素 を A とし 、 ( A - B ) * 2 の 列 の 総 和 を D で 割 った 値の 平 方 根 を出力する <eos>
2963
src = print ( {i} , end = '' )
trg = 改行 せずに " { } " を出力する
rst = 改行 せずに " { } " を出力する <eos>
2964
src = A = 2000000000
trg = 2000 0000 00 を A とする
rst = 10 4 6 5 27 を A とする <eos>
2965
src = A += r_a ( B ) - r_a ( C )
trg = A を r _ a ( B ) から r _ a ( C ) を 引 いた 値 だけ 増加 させる
rst = A を r _ a ( B ) から r _ a ( C ) を 引 いた 値 だけ 増加 させる <eos>
2966
src = [ print ( A . format ( B + 1 , C ) ) for B , C in enumerate ( D ) ]
trg = D に 番号 付 した 組 の 列 の 各要素 を B 、 C とし 、 A を 書式 として B に 1 を加えた 値 、 C で 整 形 した 文字列 を出力する の 列
rst = D に 番号 付 した 組 の 列 の 各要素 を B 、 C とし 、 A を 書式 として B に 1 を加えた 値 、 C で 整 形 した 文字列 を出力する の 列 <eos>
2967
src = A [ B + C ] [ D + E ] = 1
trg = 1 を A の B に C を加えた 値 番目の D に E を加えた 値 番 目 にする
rst = 1 を A の B に C を加えた 値 番目の D に E を加えた 値 番 目 にする <eos>
2968
src = if A % 7 == 0 :
trg = A を 7 で 割 った 余 り が 0 と 等 しい とき 、
rst = A を 7 で 割 った 余 り が 0 と 等 しい とき 、 <eos>
2969
src = if A [ B + 2 ] == C :
trg = A の B に 2 を加えた 値 番 目 が C と 等 しい とき 、
rst = A の B に 2 を加えた 値 番 目 が C と 等 しい とき 、 <eos>
2970
src = if 0 <= A < 60 * B :
trg = 0 が A 以下 かどうか が 60 に B を 掛 け た 値 より 小さい とき 、
rst = 0 が A 以下 かどうか が 60 に B を 掛 け た 値 より 小さい とき 、 <eos>
2971
src = return _dfs ( A , set ( ) )
trg = _ dfs ( A , set () ) を返す
rst = _ dfs ( A , set () ) を返す <eos>
2972
src = dfs ( 0 , 0 , A [ 0 ] [ 0 ] , - 1 )
trg = dfs ( 0 , 0 , A [ 0 ] [ 0 ] , -1 )
rst = dfs ( 0 , 0 , A [ 0 ] [ 0 ] , -1 ) <eos>
2973
src = print ( 2 * ( A + B ) )
trg = 2 に A に B を加えた 値を 掛 け た 値 を出力する
rst = 2 に A に B を加えた 値を 掛 け た 値 を出力する <eos>
2974
src = A . append ( walk_postorder ( B , B [ C ] . left ) )
trg = A の 末 尾 に walk _ postorder ( B , B [ C ] . left ) を追加する
rst = A の 末 尾 に walk _ postorder ( B , B [ C ] . left ) を追加する <eos>
2975
src = E = F + C [ D + 1 ]
trg = F に C の D に 1 を加えた 値 番 目 を加えた 値を E とする
rst = F に C の D に 1 を加えた 値 番 目 を加えた 値を E とする <eos>
2976
src = A = list ( filter ( lambda D : D in B , C ) )
trg = C の 各 値を n を パラメータ として n が B に含まれる かどうか を返す関数 で フィルタ ー した 列 の リストを A とする
rst = C の 各 値を x を パラメータ として x が B に含まれる かどうか を返す関数 で フィルタ ー した 列 の リストを A とする <eos>
2977
src = if A [ 4 ] <= A [ 2 ] <= A [ 0 ] - A [ 4 ] and A [ 4 ] <= A [ 3 ] <= A [ 1 ] - A [ 4 ] :
trg = A の 4 番 目 が A の 2 番 目 以下 かどうか が A の先頭 から A の 4 番 目 を 引 いた 値 以下 かつ A の 4 番 目 が A の 3 番 目 以下 かどうか が A の 1 番 目 から A の 4 番 目 を 引 いた 値 以下の とき 、
rst = A の 4 番 目 が A の 2 番 目 以下 かどうか が A の 0 番 目 から A の 4 番 目 を 引 いた 値 以下 かつ A の 4 番 目 が A の 3 番 目 以下 かつ A の 1 番 目 が
2978
src = print ( '\n' . join ( map ( str , A ) ) if len ( A ) else B )
trg = A の長さ の とき 、 つまり 改行 文字 を 間 に 入れ て A の 各要素 に 整数 を適用した 列 を 連結 した 文字列 、 そうでなければ B を出力する
rst = A の長さ の とき 、 つまり 改行 文字 を 間 に 入れ て A の 各要素 に 整数 を適用した 列 を 連結 した 文字列 、 そうでなければ B を出力する <eos>
2979
src = if A * B * C * D < 0 :
trg = A に B を 掛 け た 値に C を 掛 け た 値に D を 掛 け た 値が 0 より 小さい とき 、
rst = A に B を 掛 け た 値に C を 掛 け た 値に D を 掛 け た 値が 0 より 小さい とき 、 <eos>
2980
src = A = [ int ( input ( ) ) for B in range ( 6 ) ]
trg = 0 から 6 未 満 までの 数 列 の 各要素 を B とし 、 、 つまり 入力された 文字列 の 整数値 の 列 を A とする
rst = 0 から 6 未 満 までの 数 列 の 各要素 を B とし 、 、 つまり 入力された 文字列 の 整数値 の 列 を A とする <eos>
2981
src = if A > B [ - 1 ] :
trg = A が B の 末 尾 より 大きい とき 、
rst = A が B の 末 尾 より 大きい とき 、 <eos>
2982
src = A = max ( B - C , A )
trg = B から C を 引 いた 値 、 A の 最大 値を A とする
rst = B から C を 引 いた 値 、 A の 最大 値を A とする <eos>
2983
src = A [ 0 ] , A [ 1 ] = A [ 1 ] , A [ 0 ]
trg = A の先頭 と A の 1 番 目 を 入れ替え る
rst = A の 1 番 目 、 A の先頭 を A の先頭 、 A の 1 番 目 とする <eos>
2984
src = if intersect ( A , B , C , D , E , F , G , H ) :
trg = intersect ( A , B , C , D , E , F , G , H ) の とき 、
rst = intersect ( A , B , C , D , E , F , G , H ) の とき 、 <eos>
2985
src = A = [ 25 , 10 , 5 , 1 ]
trg = ( 25 、 10 、 5 、 1 ) からなる 列 を A とする
rst = ( 25 、 10 、 5 、 1 ) からなる 列 を A とする <eos>
2986
src = A = ( B + C [ 0 ] * D , E + C [ 1 ] * D )
trg = ( B に C の 0 番 目 に D を 掛 け た 値 を加えた 値 、 E に C の 1 番 目 に D を 掛 け た 値 を加えた 値 ) の 組 を A とする
rst = ( B に C の 先頭に D を 掛 け た 値 を加えた 値 、 E に C の 1 番 目 に D を 掛 け た 値 を加えた 値 ) の 組 を A とする <eos>
2987
src = A += [ B * C for C in D ]
trg = A を D の 各要素 を C とし 、 B に C を 掛 け た 値の 列 だけ 増加 させる
rst = A を D の 各要素 を C とし 、 B に C を 掛 け た 値の 列 だけ 増加 させる <eos>
2988
src = A . official_house [ B ] [ C ] [ D ] = 0
trg = 0 を A の official _ house の B 番目の C 番目の D 番 目 にする
rst = 0 を A の official _ house の B 番目の C 番目の D 番 目 にする <eos>
2989
src = print ( - ( - A // B ) * C )
trg = -- A を B で 割 った 商 に C を 掛 け た 値 を出力する
rst = -- A を B で 割 った 商 に C を 掛 け た 値 を出力する <eos>
2990
src = A . append ( B )
trg = A の 末 尾 に B を追加する
rst = A の 末 尾 に B を追加する <eos>
2991
src = return abs ( A ) > 1
trg = A の 絶対 値が 1 より 大きい かどうか を返す
rst = A の 絶対 値が 1 より 大きい かどうか を返す <eos>
2992
src = A += B [ C + 1 ] [ D ]
trg = A を B の C に 1 を加えた 値 番目の D 番 目 だけ 増加 させる
rst = A を B の C に 1 を加えた 値 番目の D 番 目 だけ 増加 させる <eos>
2993
src = A = rotate_vector ( A , B )
trg = rotate _ vector ( A , B ) を A とする
rst = <unk> ( A , B ) を A とする <eos>
2994
src = for A in range ( B - 2000 , 2001 ) :
trg = B から 2000 を 引 いた 値 から 2001 未 満 までの 数 列 を 順に A として 、 繰り返す
rst = B から 2000 を 引 いた 値 から 2001 未 満 までの 数 列 を 順に A として 、 繰り返す <eos>
2995
src = if A . M [ B ] [ C ] < D :
trg = A の M の B 番目の C 番 目 が D より 小さい とき 、
rst = A の M の B 番目の C 番 目 が D より 小さい とき 、 <eos>
2996
src = A = solve ( 4 , B )
trg = solve ( 4 , B ) を A とする
rst = solve ( 4 , B ) を A とする <eos>
2997
src = A [ B ] . add ( C )
trg = A の B 番 目 に C を追加した 集 ま り
rst = A の B 番 目 に C を追加した 集 ま り <eos>
2998
src = A = A [ 5 : ]
trg = A の 5 番 目 から 、 つまり 末 尾 までの 部分 列 を A とする
rst = A の 5 番 目 から 、 つまり 末 尾 までの 部分 列 を A とする <eos>
2999
src = if 0 not in A or 0 not in B :
trg = 0 が A に 含まれ なく または 0 が B に 含まれ ない とき 、
rst = 0 が A に 含まれ なく または 0 が B に 含まれ ない とき 、 <eos>
3000
src = A = [ 0 ] * 7
trg = ( 0 ) からなる 列 の 7 回 分 の 列 を A とする
rst = ( 0 ) からなる 列 の 7 回 分 の 列 を A とする <eos>
3001
src = ( [ 1 , 2 , 3 , 4 , 5 , 6 ] , 4 )
trg = ( ( 1 、 2 、 3 、 4 、 5 、 6 ) からなる 列 、 4 ) の 組
rst = ( ( 1 、 2 、 3 、 4 、 5 、 6 ) からなる 列 、 4 ) の 組 <eos>
3002
src = A [ ( B ^ C ) . bit_length ( ) ] . append ( D )
trg = A の B と C の 排 他 論理 和 の ビット 長 番目の 末 尾 に D を追加する
rst = A の B と C の 排 他 論理 和 番目の ビット 長 番目の 末 尾 に D を追加する <eos>
3003
src = if get ( A , B ) - get ( A , C ) :
trg = get ( A , B ) から get ( A , C ) を 引 いた 値の とき 、
rst = get ( A , B ) から get ( A , C ) を 引 いた 値の とき 、 <eos>
3004
src = A [ B ] = str ( C )
trg = C の 文字列を A の B 番 目 にする
rst = C の 文字列を A の B 番 目 にする <eos>
3005
src = A [ B ] [ 0 ] = None
trg = 未 定 値を A の B 番目の 0 番 目 にする
rst = 未 定 値を A の B 番目の 0 番 目 にする <eos>
3006
src = update ( 2 , [ ( - 1 , - 1 ) , ( 1 , - 1 ) , ( - 1 , 1 ) , ( 1 , 1 ) ] )
trg = update ( 2 , [ ( - 1, -1 ) , ( 1, -1 ) , ( - 1, 1 ) , ( 1, 1 ) ] )
rst = update ( 2 , [ ( - 1, -1 ) , ( 1, -1 ) , ( -1 , 1 ) , ( 1 、 1 ) ] ) <eos>
3007
src = A //= 4
trg = A を 4 分 の 一 にする
rst = A を 4 分 の 一 にする <eos>
3008
src = if - A - B > 0 :
trg = - A から B を 引 いた 値が 0 より 大きい とき 、
rst = - A から B を 引 いた 値が 0 より 大きい とき 、 <eos>
3009
src = A = int ( B ) % C
trg = B の 整数値 を C で 割 った 余 り を A とする
rst = B の 整数値 を C で 割 った 余 り を A とする <eos>
3010
src = A [ B + C ] [ D ] = E + F
trg = E に F を加えた 値を A の B に C を加えた 値 番目の D 番 目 にする
rst = E に F を加えた 値を A の B に C を加えた 値 番目の D 番 目 にする <eos>
3011
src = A = [ [ ] for B in range ( 7 ) ]
trg = 0 から 7 未 満 までの 数 列 の 各要素 を B とし 、 、 つまり 空 列 の 列 を A とする
rst = 0 から 7 未 満 までの 数 列 の 各要素 を B とし 、 、 つまり 空 列 の 列 を A とする <eos>
3012
src = if A == e == 0 :
trg = A が 、 つまり ネ イ ピ ア 数 と 等 しい かどうか が 0 と 等 しい とき 、
rst = A が 、 つまり ネ イ ピ ア 数 と 等 しい かどうか が 0 と 等 しい とき 、 <eos>
3013
src = A = ( B [ C ] , D [ C ] )
trg = ( B の C 番 目 、 D の C 番 目 ) の 組 を A とする
rst = ( B の C 番 目 、 D の C 番 目 ) の 組 を A とする <eos>
3014
src = A = [ False ] * 53
trg = ( 、 つまり 偽 ) からなる 列 の 5 3 回 分 の 列 を A とする
rst = ( 、 つまり 偽 ) からなる 列 の 5 3 回 分 の 列 を A とする <eos>
3015
src = return A . count
trg = A 内の [MASK] の 出現 回数 を返す
rst = A 内の [MASK] の 出現 回数 を返す <eos>
3016
src = print ( - A * B + C + D * e )
trg = - A に B を 掛 け た 値に C を加えた 値に D に ネ イ ピ ア 数 を 掛 け た 値 を加えた 値 を出力する
rst = - A に B を 掛 け た 値に C を加えた 値に D に ネ イ ピ ア 数 を 掛 け た 値 を加えた 値 を出力する <eos>
3017
src = A = search ( B , C + 1 , D , E )
trg = C に 1 を加えた 値 、 D 、 E において 正規表現 B が 最初 にマッチする 位置 を A とする
rst = C に 1 を加えた 値 、 D 、 E において 正規表現 B が 最初 にマッチする 位置 を A とする <eos>
3018
src = A [ C ] = 0
trg = 0 を A の C 番 目 にする
rst = 0 を A の C 番 目 にする <eos>
3019
src = check ( )
trg = check ()
rst = check () <eos>
3020
src = if ( A < 0 and B [ C ] == 2 ) or ( A > 0 and B [ C ] == 0 ) :
trg = A が 0 より 小さく かつ B の C 番 目 が 2 と 等 しく または A が 0 より 大きく かつ B の C 番 目 が 0 と 等 しい とき 、
rst = A が 0 より 小さく かつ B の C 番 目 が 2 と 等 しく または A が 0 より 大きく かつ B の C 番 目 が 0 と 等 しい とき 、 <eos>
3021
src = A = min ( int ( B / 2 ) , C )
trg = B を 2 で 割 った 値の 整数値 、 C の 最小 値を A とする
rst = B を 2 で 割 った 値の 整数値 、 C の 最小 値を A とする <eos>
3022
src = A = calc ( B , C )
trg = calc ( B , C ) を A とする
rst = calc ( B , C ) を A とする <eos>
3023
src = if A - ( A // B * B ) <= e or abs ( A - ( ( A // B + 1 ) * B ) ) <= e :
trg = A から A を B で 割 った 商 に B を 掛 け た 値を 引 いた 値が 、 つまり ネ イ ピ ア 数 以下 または A から ( A / / B + 1 ) に B を 掛 け た 値を 引 いた 値の 絶対 値が 、 つまり ネ イ ピ ア 数 以下の とき 、
rst = A から A を B で 割 った 商 に B を 掛 け た 値を 引 いた 値の 絶対 値が 、 つまり ネ イ ピ ア 数 以下 または A から A を B で 割 った 商 に 1 を加えた 値を 引 いた 値の 絶対 値が 、 つまり
3024
src = A . append ( item ( int ( input ( ) ) , B ) )
trg = A の 末 尾 に item ( int ( input () ) , B ) を追加する
rst = A の 末 尾 に item ( int ( input () ) , B ) を追加する <eos>
3025
src = if 1 <= A - B :
trg = 1 が A から B を 引 いた 値 以下の とき 、
rst = 1 が A から B を 引 いた 値 以下の とき 、 <eos>
3026
src = A = perm ( B . lt )
trg = perm ( B . lt ) を A とする
rst = <unk> ( B . lt ) を A とする <eos>
3027
src = if abs ( A ) < B :
trg = A の 絶対 値が B より 小さい とき 、
rst = A の 絶対 値が B より 小さい とき 、 <eos>
3028
src = return ( ( A - B ) ** 2 + ( C - D ) ** 2 < ( E + F ) ** 2 , E , F )
trg = ( A から B を 引 いた 値の 2 乗 に C から D を 引 いた 値の 2 乗 を加えた 値が E に F を加えた 値の 2 乗 より 小さい かどうか 、 E 、 F ) の 組 を返す
rst = ( A から B を 引 いた 値の 2 乗 に C から D を 引 いた 値の 2 乗 を加えた 値が E に F を加えた 値の 2 乗 より 小さい かどうか 、 E 、 F ) の 組 を返す <eos>
3029
src = A . append ( ( B + 1 , C , D , E ) )
trg = A の 末 尾 に ( B に 1 を加えた 値 、 C 、 D 、 E ) の 組 を追加する
rst = A の 末 尾 に ( B に 1 を加えた 値 、 C 、 D 、 E ) の 組 を追加する <eos>
3030
src = A . append ( conv2 ( conv1 ( B ) + conv1 ( C ) ) )
trg = A の 末 尾 に conv 2 ( conv 1 ( B ) + conv 1 ( C ) ) を追加する
rst = A の 末 尾 に <unk> ( B ) に <unk> ( C ) を加えた 値 を追加する <eos>
3031
src = if A [ B + C ] < A [ B ] + D :
trg = A の B に C を加えた 値 番 目 が A の B 番 目 に D を加えた 値 より 小さい とき 、
rst = A の B に C を加えた 値 番 目 が A の B 番 目 に D を加えた 値 より 小さい とき 、 <eos>
3032
src = A = B . val [ C ]
trg = B の val の C 番 目 を A とする
rst = B の val の C 番 目 を A とする <eos>
3033
src = pos ( A [ B ] [ 1 ] )
trg = pos ( A [ B ] [ 1 ] )
rst = pos ( A [ B ] [ 1 ] ) <eos>
3034
src = A . table [ B ] = C
trg = C を A の table の B 番 目 にする
rst = C を A の table の B 番 目 にする <eos>
3035
src = if A <= count :
trg = A が 、 つまり 無限 の 整数 列 以下の とき 、
rst = A が 、 つまり 無限 の 整数 列 以下の とき 、 <eos>
3036
src = for A in range ( 1001 ) :
trg = 0 から 100 1 未 満 までの 数 列 を 順に A として 、 繰り返す
rst = 0 から 100 1 未 満 までの 数 列 を 順に A として 、 繰り返す <eos>
3037
src = print ( ' ' . join ( map ( str , A [ : B ] ) ) , end = ' ' )
trg = 空白 文字 を 代わり の 行 末 として 空白 文字 を 間 に 入れ て A の 、 つまり 先頭 から B 番 目 までの 部分 列 の 各要素 に 整数 を適用した 列 を 連結 した 文字列 を出力する
rst = 空白 文字 を 代わり の 行 末 として 空白 文字 を 間 に 入れ て A の 、 つまり 先頭 から B 番 目 までの 部分 列 の 各要素 に 整数 を適用した 列 を 連結 した 文字列 を出力する <eos>
3038
src = A , B = divmod ( B , C [ D ] )
trg = B と C の D 番 目 を 割 った とき の ( 商 を 展開 し 、 それぞれ A 、 B とする
rst = B と C の D 番 目 を 割 った とき の ( 商 を 展開 し 、 それぞれ A 、 B とする <eos>
3039
src = A = { "yotta" : 24 , "zetta" : 21 , "exa" : 18 , "peta" : 15 , "tera" : 12 , "giga" : 9 , "mega" : 6 , "kilo" : 3 , "hecto" : 2 , "deca" : 1 , "deci" : - 1 , "centi" : - 2 , "milli" : - 3 , "micro" : - 6 , "nano" : - 9 , "pico" : - 12 , "femto" : - 15 , "ato" :
trg = ( ( B , 24 ) 、 ( C , 21 ) 、 ( D , 18 ) 、 ( E , 15 ) 、 ( F , 12 ) 、 ( G , 9 ) 、 ( H , 6 ) 、 ( I , 3 ) 、 ( J , 2 ) 、 ( K , 1 ) 、 ( L , -1 ) 、 ( M , -2 ) 、 ( N , -3 ) 、 (
rst = ( ( B , 24 ) 、 ( C , 2 ) 、 ( D , 3 ) 、 ( E , 15 ) 、 ( F , 6 ) 、 ( G , 7 ) 、 ( H , 8 ) 、 ( I , 9 ) 、 (
3040
src = if A [ B - 1 ] + 1 == A [ B ] :
trg = A の B から 1 を 引 いた 値 番 目 に 1 を加えた 値が A の B 番 目 と 等 しい とき 、
rst = A の B から 1 を 引 いた 値 番 目 に 1 を加えた 値が A の B 番 目 と 等 しい とき 、 <eos>
3041
src = A [ B ] = A [ C ] = D
trg = D を A の C 番 目 とする を A の B 番 目 にする
rst = D を A の C 番 目 とする を A の B 番 目 にする <eos>
3042
src = A = A | { B , C }
trg = A と ( < __ main __ . Cammaobjectat 0 x 10 a 4 f 1 be 0 > ) の集合 の 論理 和 を A とする
rst = A と ( < __ main __ . Cammaobjectat 0 x 10 a 1 b 7 1 60 > ) の集合 の 論理 和 を A とする <eos>
3043
src = dfs ( A [ 0 ] )
trg = dfs ( A [ 0 ] )
rst = dfs ( A [ 0 ] ) <eos>
3044
src = A , B , C , D , E = [ int ( F ) for F in input ( ) . split ( ) ]
trg = 入力された 文字列を 空白 で 分割 した 字句 列 の 各要素 を F とし 、 F の 整数値 の 列 を 展開 し 、 それぞれ A 、 B 、 C 、 D 、 E とする
rst = 入力された 文字列を 空白 で 分割 した 字句 列 の 各要素 を F とし 、 F の 整数値 の 列 を 展開 し 、 それぞれ A 、 B 、 C 、 D 、 E とする <eos>
3045
src = A += input ( )
trg = A を 入力された 文字列 だけ 増加 させる
rst = A を 入力された 文字列 だけ 増加 させる <eos>
3046
src = A = max ( A , max ( B [ C + 1 : ] ) - B [ C ] )
trg = A 、 B の C に 1 を加えた 値 から 、 つまり 末 尾 までの 部分 列 の 最大 値 から B の C 番 目 を 引 いた 値の 最大 値を A とする
rst = A 、 B の C に 1 を加えた 値 から 、 つまり 末 尾 までの 部分 列 の 最大 値 から B の C 番 目 までの 部分 列 の 最大 値を A とする <eos>
3047
src = A [ e - 1 ] . append ( B )
trg = A の 、 つまり ネ イ ピ ア 数 から 1 を 引 いた 値 番目の 末 尾 に B を追加する
rst = A の 、 つまり ネ イ ピ ア 数 から 1 を 引 いた 値 番目の 末 尾 に B を追加する <eos>
3048
src = A [ B . index ( C ) ] -= 1
trg = A の B の C と 等 しい 要素 の最初の 位置 番 目 を 1 だけ 減少 させる
rst = A の B の C と 等 しい 要素 の最初の 位置 番 目 を 1 だけ 減少 させる <eos>
3049
src = A = B . format ( C , 0 )
trg = B を 書式 として C 、 0 で 整 形 した 文字列を A とする
rst = B を 書式 として C 、 0 で 整 形 した 文字列を A とする <eos>
3050
src = A = list ( map ( int , input ( ) . split ( ) ) ) * 16
trg = 入力された 文字列を 空白 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 のリスト に 16 を 掛 け た 値を A とする
rst = 入力された 文字列を 空白 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 のリスト に 16 を 掛 け た 値を A とする <eos>
3051
src = A = min ( paint ( B , C ) , A )
trg = paint ( B , C ) 、 A の 最小 値を A とする
rst = paint ( B , C ) 、 A の 最小 値を A とする <eos>
3052
src = A , B = [ 0 ] * 202 , [ 0 ] * 202
trg = ( 0 ) からなる 列 の 20 2 回 分 の 列 、 ( 0 ) からなる 列 の 20 2 回 分 の 列 を A 、 B とする
rst = ( 0 ) からなる 列 の 3 0000 5 回 分 の 列 、 ( 0 ) からなる 列 の 3 回 分 の 列 を A 、 B とする <eos>
3053
src = for A , B , B in C :
trg = C を 順に A 、 B 、 B として 、 繰り返す
rst = C を 順に A 、 B 、 B として 、 繰り返す <eos>
3054
src = A . x = B . x
trg = B の x 座標 を A の x 座標 にする
rst = B の x 座標 を A の x 座標 にする <eos>
3055
src = print ( B if A == 1 else ( C if A == 2 else D ) )
trg = A が 1 と 等 しい とき B 、 そうでなければ A が 2 と 等 しい とき C 、 そうでなければ D を出力する
rst = A が 1 と 等 しい とき B 、 そうでなければ A が 2 と 等 しい とき C 、 そうでなければ D を出力する <eos>
3056
src = A [ B ] [ C ] = D [ C ] [ 7 - B ]
trg = D の C 番目の 7 から B を 引 いた 値 番 目 を A の B 番目の C 番 目 にする
rst = D の C 番目の 7 から B を 引 いた 値 番 目 を A の B 番目の C 番 目 にする <eos>
3057
src = A = { 0 : B , 1 : C , 2 : D , 3 : E , 4 : F , 5 : G , 6 : H }
trg = ( ( 0 , B ) 、 ( 1, C ) 、 ( 2 , D ) 、 ( 3 , E ) 、 ( 4 , F ) 、 ( 5 , G ) 、 ( 6 , H ) ) からなる 辞書 を A とする
rst = ( ( 0 , B ) 、 ( 1, C ) 、 ( 2 , D ) 、 ( 3 , E ) 、 ( 4 , F ) 、 ( 5 , G ) 、 ( 6 , H ) ) からなる 辞書 を A とする <eos>
3058
src = A = 17
trg = 17 を A とする
rst = 17 を A とする <eos>
3059
src = for A in range ( 2 , B + 2 ) :
trg = 2 から B に 2 を加えた 値 未 満 までの 数 列 を 順に A として 、 繰り返す
rst = 2 から B に 2 を加えた 値 未 満 までの 数 列 を 順に A として 、 繰り返す <eos>
3060
src = for A in B [ 1 : ] [ : : - 1 ] :
trg = B の先頭 を 除 いた 部分 列 の 逆 順 を 順に A として 、 繰り返す
rst = B の先頭 を 除 いた 部分 列 の 逆 順 を 順に A として 、 繰り返す <eos>
3061
src = print ( 1 * ( A in B ) )
trg = 1 に A が B に含まれる かどうか を 掛 け た 値 を出力する
rst = 1 に A が B に含まれる かどうか を 掛 け た 値 を出力する <eos>
3062
src = if not A [ B - 1 ] [ C ] :
trg = A の B から 1 を 引 いた 値 番目の C 番 目 でない とき 、
rst = A の B から 1 を 引 いた 値 番目の C 番 目 でない とき 、 <eos>
3063
src = return 0 <= ( A - B ) <= C
trg = 0 が A から B を 引 いた 値 以下 かどうか が C 以下 かどうか を返す
rst = 0 が A から B を 引 いた 値 以下 かどうか が C 以下 かどうか を返す <eos>
3064
src = A = ( B | C ) & 0b11111111111111111111111111111111
trg = B と C の 論理 和 と 0 b 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 の 論理 積 を A とする
rst = B と C の 論理 和 と 0 b 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11
3065
src = A += B * 100
trg = A を B に 100 を 掛 け た 値 だけ 増加 させる
rst = A を B に 100 を 掛 け た 値 だけ 増加 させる <eos>
3066
src = A . nodeid = B
trg = B を A の nodeid にする
rst = B を A の nodeid にする <eos>
3067
src = while A < B - 1 and C [ A ] [ 2 ] == C [ A + 1 ] [ 2 ] :
trg = A が B から 1 を 引 いた 値 より 小さく かつ C の A 番目の 2 番 目 が C の A に 1 を加えた 値 番目の 2 番 目 と 等 しい 間 、 次 を 繰り返す
rst = A が B から 1 を 引 いた 値 より 小さく かつ C の A 番目の 2 番 目 が C の A に 1 を加えた 値 番目の 2 番 目 と 等 しい 間 、 次 を 繰り返す <eos>
3068
src = return A . index ( B )
trg = A の B と 等 しい 要素 の最初の 位置 を返す
rst = A の B と 等 しい 要素 の最初の 位置 を返す <eos>
3069
src = if A == B or A == 1 :
trg = A が B と 等 しく または A が 1 と 等 しい とき 、
rst = A が B と 等 しく または A が 1 と 等 しい とき 、 <eos>
3070
src = A . append ( ( B , C , 1 ) )
trg = A の 末 尾 に ( B 、 C 、 1 ) の 組 を追加する
rst = A の 末 尾 に ( B 、 C 、 1 ) の 組 を追加する <eos>
3071
src = A = [ 2 ** B for B in range ( 20 ) ]
trg = 0 から 20 未 満 までの 数 列 の 各要素 を B とし 、 2 の B 乗 の 列 を A とする
rst = 0 から 20 未 満 までの 数 列 の 各要素 を B とし 、 2 の B 乗 の 列 を A とする <eos>
3072
src = paint ( A , B + 1 )
trg = paint ( A , B + 1 )
rst = paint ( A , B + 1 ) <eos>
3073
src = A . weight [ B ] += A . weight [ A . par [ B ] ]
trg = A の weight の B 番 目 を A の weight の A の par の B 番 目 番 目 だけ 増加 させる
rst = A の weight の B 番 目 を A の weight の A の par の B 番 目 番 目 だけ 増加 させる <eos>
3074
src = paint ( A + 2 , B )
trg = paint ( A + 2 , B )
rst = paint ( A + 2 , B ) <eos>
3075
src = A = trans ( A )
trg = trans ( A ) を A とする
rst = <unk> ( A ) を A とする <eos>
3076
src = for A in range ( 51 ) :
trg = 0 から 5 1 未 満 までの 数 列 を 順に A として 、 繰り返す
rst = 0 から 5 1 未 満 までの 数 列 を 順に A として 、 繰り返す <eos>
3077
src = A = [ B [ C ] for C in range ( D ) if not E [ C ] ]
trg = 0 から D 未 満 までの 数 列 の 各要素 を C とし 、 E の C 番 目 でない とき の B の C 番目の 列 を A とする
rst = 0 から D 未 満 までの 数 列 の 各要素 を C とし 、 E の C 番 目 でない とき の B の C 番目の 列 を A とする <eos>
3078
src = A = [ int ( B [ C ] ) for C in range ( 6 ) ]
trg = 0 から 6 未 満 までの 数 列 の 各要素 を C とし 、 B の C 番目の 整数値 の 列 を A とする
rst = 0 から 6 未 満 までの 数 列 の 各要素 を C とし 、 B の C 番目の 整数値 の 列 を A とする <eos>
3079
src = A = namedtuple ( B , [ C , D , E ] )
trg = namedtuple ( B , [ C , D , E ] ) を A とする
rst = namedtuple ( B , [ C , D , E ] ) を A とする <eos>
3080
src = A , B = bublleSort ( C )
trg = bublleSort ( C ) を 展開 し 、 それぞれ A 、 B とする
rst = <unk> ( C ) を 展開 し 、 それぞれ A 、 B とする <eos>
3081
src = A /= int ( B [ C + 1 ] )
trg = A を B の C に 1 を加えた 値 番目の 整数値 分 の 一 にする
rst = A を B の C に 1 を加えた 値 番目の 整数値 分 の 一 にする <eos>
3082
src = A = min ( B + C , D )
trg = B に C を加えた 値 、 D の 最小 値を A とする
rst = B に C を加えた 値 、 D の 最小 値を A とする <eos>
3083
src = for A in B [ 3 ] :
trg = B の 3 番 目 を 順に A として 、 繰り返す
rst = B の 3 番 目 を 順に A として 、 繰り返す <eos>
3084
src = A [ B ] [ B + 1 ] = A [ B + 1 ] [ B ] = 1
trg = 1 を A の B に 1 を加えた 値 番目の B 番 目 とする を A の B 番目の B に 1 を加えた 値 番 目 にする
rst = 1 を A の B に 1 を加えた 値 番目の B 番 目 とする を A の B 番目の B に 1 を加えた 値 番 目 にする <eos>
3085
src = for A in range ( - B + 1 , C + D - B + 1 ) :
trg = - B に 1 を加えた 値 から C に D を加えた 値 から B を 引 いた 値に 1 を加えた 値 未 満 までの 数 列 を 順に A として 、 繰り返す
rst = - B に 1 を加えた 値 から C に D を加えた 値 から B を 引 いた 値に 1 を加えた 値 未 満 までの 数 列 を 順に A として 、 繰り返す <eos>
3086
src = A . _currentIndex = 0
trg = 0 を A の _ currentIndex にする
rst = 0 を A の _ currentIndex にする <eos>
3087
src = A = A [ : B [ 1 ] ] + A [ B [ 1 ] : B [ 2 ] + 1 ] [ : : - 1 ] + A [ B [ 2 ] + 1 : ]
trg = A の 、 つまり 先頭 から B の 1 番 目 までの 部分 列 に A の B の 1 番 目 から B [ 2 ] に 1 を加えた 値 までの 部分 列 の 逆 順 を加えた 値に A の B の 2 番 目 に 1 を加えた 値 から 、 つまり 末 尾 までの 部分 列 を加えた 値を A とする
rst = A の 、 つまり 先頭 から B の 1 番 目 までの 部分 列 に A の B [ 1 : ] に B [ 2 ] を加えた 値 から 、 つまり 末 尾 までの 部分 列 を加えた 値に A の B の 2 番 目 から 、 つまり 末
3088
src = A . append ( A [ B - 1 ] )
trg = A の 末 尾 に A の B から 1 を 引 いた 値 番 目 を追加する
rst = A の 末 尾 に A の B から 1 を 引 いた 値 番 目 を追加する <eos>
3089
src = A = [ [ 0 for B in range ( C ) ] for B in range ( C ) ]
trg = 0 から C 未 満 までの 数 列 の 各要素 を B とし 、 0 から C 未 満 までの 数 列 の 各要素 を B とし 、 0 の 列 の 列 を A とする
rst = 0 から C 未 満 までの 数 列 の 各要素 を B とし 、 0 から C 未 満 までの 数 列 の 各要素 を B とし 、 0 の 列 の 列 を A とする <eos>
3090
src = for A in range ( B + C - D + 1 , D ) :
trg = B に C を加えた 値 から D を 引 いた 値に 1 を加えた 値 から D 未 満 までの 数 列 を 順に A として 、 繰り返す
rst = B に C を加えた 値 から D を 引 いた 値に 1 を加えた 値 から D 未 満 までの 数 列 を 順に A として 、 繰り返す <eos>
3091
src = A = [ [ B , C , None ] for C , B in enumerate ( map ( int , input ( ) . split ( ) ) ) ]
trg = 入力された 文字列を 空白 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 に 番号 付 した 組 の 列 の 各要素 を C 、 B とし 、 ( B 、 C 、 未 定 値 ) からなる 列 の 列 を A とする
rst = 入力された 文字列を 空白 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 の 各要素 を C 、 B とし 、 ( B 、 C 、 未 定 値 ) からなる 列 の 列 を A とする <eos>
3092
src = A . remove ( - ( B ) )
trg = A 内の - B と 等 しい 要素を 取り除く
rst = A 内の - B と 等 しい 要素を 取り除く <eos>
3093
src = A = 10 * A + 9
trg = 10 に A を 掛 け た 値に 9 を加えた 値を A とする
rst = 10 に A を 掛 け た 値に 9 を加えた 値を A とする <eos>
3094
src = A = max ( B [ C - D [ E ] ] + F [ E ] , A )
trg = B の C から D の E 番 目 を 引 いた 値 番 目 に F の E 番 目 を加えた 値 、 A の 最大 値を A とする
rst = B の C から D の E 番 目 を 引 いた 値 番 目 に F の E 番 目 を加えた 値 、 A の 最大 値を A とする <eos>
3095
src = print ( A [ 4 - B ] , end = ' ' )
trg = 空白 文字 を 代わり の 行 末 として A の 4 から B を 引 いた 値 番 目 を出力する
rst = 空白 文字 を 代わり の 行 末 として A の 4 から B を 引 いた 値 番 目 を出力する <eos>
3096
src = A [ B : ] = C [ B ] [ D ] + '' . join ( E )
trg = C の B 番目の D 番 目 に 空文字列 を 間 に 入れ て E を 連結 した 文字列 を加えた 値を A の B 番 目 から 、 つまり 末 尾 までの 部分 列 にする
rst = C の B 番目の D 番 目 に 空文字列 を 間 に 入れ て E を 連結 した 文字列 を加えた 値を A の B 番 目 から 、 つまり 末 尾 までの 部分 列 にする <eos>
3097
src = A = [ [ [ B ] * [ 4 for C in range ( D ) ] ] for E in range ( F ) ]
trg = 0 から F 未 満 までの 数 列 の 各要素 を E とし 、 ( ( B ) からなる 列 の 0 から D 未 満 までの 数 列 の 各要素 を C とし 、 4 の 列 回 分 の 列 ) からなる 列 の 列 を A とする
rst = 0 から F 未 満 までの 数 列 の 各要素 を E とし 、 ( ( B ) からなる 列 の 0 から D 未 満 までの 数 列 の 各要素 を C とし 、 4 の 列 回 分 の 列 ) からなる 列 の 列 を A とする
3098
src = A , B , C = int ( D [ 0 ] ) , float ( D [ 1 ] ) , int ( D [ 2 ] )
trg = D の先頭 の 整数値 、 D の 1 番目の 浮動小数点数 、 D の 2 番目の 整数値 を A 、 B 、 C とする
rst = D の先頭 の 整数値 、 D の 1 番目の 整数値 、 D の 2 番目の 整数値 を A 、 B 、 C とする <eos>
3099
src = A = min ( [ B [ C ] [ C ] for C in range ( D + 1 ) ] )
trg = 0 から D に 1 を加えた 値 未 満 までの 数 列 の 各要素 を C とし 、 B の C 番目の C 番目の 列 の 最小 値を A とする
rst = 0 から D に 1 を加えた 値 未 満 までの 数 列 の 各要素 を C とし 、 B の C 番目の C 番目の 列 の 最小 値を A とする <eos>
3100
src = A . right . flip_color ( )
trg = A . right . flip _ color ()
rst = A . right . <unk> () <eos>
3101
src = print ( get_quad ( A , B ) )
trg = get _ quad ( A , B ) を出力する
rst = <unk> ( A , B ) を出力する <eos>
3102
src = A += [ 3 , 7 ] [ B [ A ] == C ]
trg = A を ( 3 、 7 ) からなる 列 の B の A 番 目 が C と 等 しい かどうか 番 目 だけ 増加 させる
rst = A を ( 3 、 7 ) からなる 列 の B の A 番 目 が C と 等 しい かどうか 番 目 だけ 増加 させる <eos>
3103
src = print ( A [ 0 ] . index ( max ( A [ 0 ] ) ) )
trg = A の先頭 の A の先頭 の 最大 値 と 等 しい 要素 の最初の 位置 を出力する
rst = A の先頭 の A の先頭 の 最大 値 と 等 しい 要素 の最初の 位置 を出力する <eos>
3104
src = if A . intersection ( B ) :
trg = A と B の 共通 部分 の とき 、
rst = A と B の 共通 部分 の とき 、 <eos>
3105
src = A . hldnxt [ B ] = C
trg = C を A の hldnxt の B 番 目 にする
rst = C を A の hldnxt の B 番 目 にする <eos>
3106
src = A , time = B . get ( )
trg = B に対応する 値を 展開 し 、 それぞれ A 、 time とする
rst = B に対応する 値を 展開 し 、 それぞれ A 、 time とする <eos>
3107
src = for A , B , C , D , E in sorted ( F ) :
trg = F を ソート した 列 を 順に A 、 B 、 C 、 D 、 E として 、 繰り返す
rst = F を ソート した 列 を 順に A 、 B 、 C 、 D 、 E として 、 繰り返す <eos>
3108
src = A = B . Node ( C , D , D . next )
trg = B . Node ( C , D , D . next ) を A とする
rst = B . Node ( C , D , D . next ) を A とする <eos>
3109
src = print ( Decimal ( str ( A ) ) . quantize ( Decimal ( B ) , rounding = C ) )
trg = Decimal ( str ( A ) ) . quantize ( Decimal ( B ) , rounding = C ) を出力する
rst = Decimal ( str ( A ) ) . quantize ( Decimal ( B ) , rounding = C ) を出力する <eos>
3110
src = A = B [ 1 ]
trg = B の 1 番 目 を A とする
rst = B の 1 番 目 を A とする <eos>
3111
src = print ( A . format ( ' ' . join ( [ str ( B ) for B in C . preorder ( ) ] ) ) )
trg = A を 書式 として 、 つまり 空白 文字 を 間 に 入れ て C . preorder () の 各要素 を B とし 、 B の 文字列 の 列 を 連結 した 文字列 で 整 形 した 文字列 を出力する
rst = A を 書式 として 、 つまり 空白 文字 を 間 に 入れ て C . preorder () の 各要素 を B とし 、 B の 文字列 の 列 を 連結 した 文字列 で 整 形 した 文字列 を出力する <eos>
3112
src = A . left = Node ( B )
trg = Node ( B ) を A の left にする
rst = Node ( B ) を A の left にする <eos>
3113
src = plist ( A )
trg = plist ( A )
rst = <unk> ( A ) <eos>
3114
src = A [ B : ] += 1
trg = A の B 番 目 から 、 つまり 末 尾 までの 部分 列 を 1 だけ 増加 させる
rst = A の B 番 目 から 、 つまり 末 尾 までの 部分 列 を 1 だけ 増加 させる <eos>
3115
src = if ( A [ 1 ] & 1 ) and ( A [ 2 ] & 1 ) :
trg = A の 1 番 目 と 1 の 論理 積 かつ A の 2 番 目 と 1 の 論理 積 の とき 、
rst = A の 1 番 目 と 1 の 論理 積 かつ A の 2 番 目 と 1 の 論理 積 の とき 、 <eos>
3116
src = A . root = A . _delete_max ( A . root )
trg = A . _ delete _ max ( A . root ) を A の root にする
rst = A . _ find _ max ( A . root ) を A の root にする <eos>
3117
src = C = [ '' ] * A
trg = ( 、 つまり 空文字列 ) からなる 列 の A 回 分 の 列 を C とする
rst = ( 、 つまり 空文字列 ) からなる 列 の A 回 分 の 列 を C とする <eos>
3118
src = A = 100000 ** 2
trg = 10 0000 の 2 乗 を A とする
rst = 10 0000 の 2 乗 を A とする <eos>
3119
src = A [ B : C ] = D
trg = D を A の B 番 目 から C 番 目 までの 部分 列 にする
rst = D を A の B 番 目 から C 番 目 までの 部分 列 にする <eos>
3120
src = A , B , C , D , E , F = map ( float , readline ( ) . split ( ) )
trg = readline () を 空白 で 分割 した 字句 列 の 各要素 に 浮動小数点数 を適用した 列 を 展開 し 、 それぞれ A 、 B 、 C 、 D 、 E 、 F とする
rst = readline () を 空白 で 分割 した 字句 列 の 各要素 に 浮動小数点数 を適用した 列 を 展開 し 、 それぞれ A 、 B 、 C 、 D 、 E 、 F とする <eos>
3121
src = A . d [ 4 ] , A . d [ 2 ] , A . d [ 3 ] , A . d [ 5 ] = A . d [ 2 ] , A . d [ 3 ] , A . d [ 5 ] , A . d [ 4 ]
trg = A の d の 2 番 目 、 A の d の 3 番 目 、 A の d の 5 番 目 、 A の d の 4 番 目 を A の d の 4 番 目 、 A の d の 2 番 目 、 A の d の 3 番 目 、 A の d の 5 番 目 とする
rst = A の d の 2 番 目 、 A の d の 3 番 目 、 A の d の 5 番 目 、 A の d の 4 番 目 を A の d の 4 番 目 、 A の d の 2 番 目 、 A の
3122
src = print ( A [ B ] - A [ C - 1 ] )
trg = A の B 番 目 から A の C から 1 を 引 いた 値 番 目 を 引 いた 値 を出力する
rst = A の B 番 目 から A の C から 1 を 引 いた 値 番 目 を 引 いた 値 を出力する <eos>
3123
src = if not A . has_right ( ) :
trg = A . has _ right () でない とき 、
rst = A . <unk> () でない とき 、 <eos>
3124
src = A = [ B ] + [ - 1 ] * 4000000
trg = ( B ) からなる 列 に ( -1 ) からなる 列 の 400 0000 回 分 の 列 を加えた 値を A とする
rst = ( B ) からなる 列 に ( -1 ) からなる 列 の 500 1 回 分 の 列 を加えた 値を A とする <eos>
3125
src = print ( E if abs ( A * B - C * D ) < 1e-10 else F )
trg = A * B から C * D を 引 いた 値の 絶対 値が 1 e -10 より 小さい とき E 、 そうでなければ F を出力する
rst = A * B - C * D の 絶対 値が 1 e -10 より 小さい とき E 、 そうでなければ F を出力する <eos>
3126
src = dfs ( A , B )
trg = dfs ( A , B )
rst = dfs ( A , B ) <eos>
3127
src = preorder_tree_walk ( A , A [ B ] . left_node_no , C )
trg = preorder _ tree _ walk ( A , A [ B ] . left _ node _ no , C )
rst = preorder _ tree _ walk ( A , A [ B ] . left _ node _ no , C ) <eos>
3128
src = A = closest_pair_distance ( B . copy ( ) )
trg = closest _ pair _ distance ( B . copy () ) を A とする
rst = closest _ pair _ distance ( B . copy () ) を A とする <eos>
3129
src = A . append ( str ( ( int ( B ) + 1 ) % 10 ) )
trg = A の 末 尾 に B の 整数値 に 1 を加えた 値を 10 で 割 った 余 り の 文字列 を追加する
rst = A の 末 尾 に B の 整数値 に 1 を加えた 値を 10 で 割 った 余 り の 文字列 を追加する <eos>
3130
src = for A in B [ C ] [ 3 ] :
trg = B の C 番目の 3 番 目 を 順に A として 、 繰り返す
rst = B の C 番目の 3 番 目 を 順に A として 、 繰り返す <eos>
3131
src = print ( A , count )
trg = A 、 無限 の 整数 列 を出力する
rst = A 、 無限 の 整数 列 を出力する <eos>
3132
src = for e in A :
trg = A を 順に ネ イ ピ ア 数 として 、 繰り返す
rst = A を 順に ネ イ ピ ア 数 として 、 繰り返す <eos>
3133
src = A . tail = B . tail
trg = B の tail を A の tail にする
rst = B の tail を A の tail にする <eos>
3134
src = A = 86400
trg = 86 400 を A とする
rst = 10 4 6 5 27 を A とする <eos>
3135
src = if 2 * A == B :
trg = 2 に A を 掛 け た 値が B と 等 しい とき 、
rst = 2 に A を 掛 け た 値が B と 等 しい とき 、 <eos>
3136
src = A . append ( ( 1 , 0 , 0 ) )
trg = A の 末 尾 に ( 1 、 0 、 0 ) の 組 を追加する
rst = A の 末 尾 に ( 1 、 0 、 0 ) の 組 を追加する <eos>
3137
src = A = ( [ map ( int , readline ( ) . split ( ) ) for B in range ( 4 ) ] )
trg = 0 から 4 未 満 までの 数 列 の 各要素 を B とし 、 readline () を 空白 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 の 列 を A とする
rst = 0 から 4 未 満 までの 数 列 の 各要素 を B とし 、 readline () を 空白 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 の 列 を A とする <eos>
3138
src = A . append ( B % ( C , D [ C ] ) )
trg = A の 末 尾 に B を ( C 、 D の C 番 目 ) の 組 で 割 った 余 り を追加する
rst = A の 末 尾 に B を ( C 、 D の C 番 目 ) の 組 で 割 った 余 り を追加する <eos>
3139
src = A = B . max_flow ( 0 , C - 1 )
trg = B . max _ flow ( 0 , C -1 ) を A とする
rst = B . max _ flow ( 0 , C -1 ) を A とする <eos>
3140
src = A = getSum ( B , C , 0 , 1 , D )
trg = getSum ( B , C , 0 , 1, D ) を A とする
rst = getSum ( B , C , 0 , 1, D ) を A とする <eos>
3141
src = A [ B ] += C [ 0 ]
trg = A の B 番 目 を C の先頭 だけ 増加 させる
rst = A の B 番 目 を C の先頭 だけ 増加 させる <eos>
3142
src = A = { i : [ C . format ( D ) for B , D in zip ( E . ascii_uppercase + F , range ( 32 ) ) ] }
trg = ( ( B , E . ascii _ uppercase に F を加えた 値 、 0 から 32 未 満 までの 数 列 の 要素を それぞれ 組 にした 列 の 各要素 を B 、 D とし 、 C を 書式 として D で 整 形 した 文字列 の 列 ) ) からなる 辞書 を A とする
rst = ( ( B , 0 から C に F を加えた 値 未 満 までの 数 列 の 各要素 を B 、 D とし 、 C を 書式 として D で 整 形 した 文字列 の 列 ) ) からなる 辞書 を A とする <eos>
3143
src = if abs ( A ) < 1e-9 and abs ( B ) < 1e-9 :
trg = A の 絶対 値が 1 e - 9 より 小さく かつ B の 絶対 値が 1 e - 9 より 小さい とき 、
rst = A の 絶対 値が 1 e - 9 より 小さく かつ B の 絶対 値が 1 e - 9 より 小さい とき 、 <eos>
3144
src = A = 2 ** math . ceil ( math . log ( len ( B ) , 2 ) )
trg = 2 の 2 を 底 とする B の長さ の 対 数の 切り 上げ 整数値 乗 を A とする
rst = 2 の 2 を 底 とする B の長さ の 対 数の 切り 上げ 整数値 乗 を A とする <eos>
3145
src = print ( A % poly_area ( B , len ( B ) ) )
trg = A を poly _ area ( B , len ( B ) ) で 割 った 余 り を出力する
rst = A を <unk> ( B , len ( B ) ) で 割 った 余 り を出力する <eos>
3146
src = for A in range ( 32 ) :
trg = 0 から 32 未 満 までの 数 列 を 順に A として 、 繰り返す
rst = 0 から 32 未 満 までの 数 列 を 順に A として 、 繰り返す <eos>
3147
src = for A , B in sorted ( C . items ( ) , key = lambda D : D [ 0 ] ) :
trg = x を パラメータ として x の先頭 を返す関数 を キー として C の キー と 値 の集まり を ソート した 列 を 順に A 、 B として 、 繰り返す
rst = x を パラメータ として x の先頭 を返す関数 を キー として C の キー と 値 の集まり を ソート した 列 を 順に A 、 B として 、 繰り返す <eos>
3148
src = A = [ [ - 1 ] * [ ( B * 2 + 1 ) for C in range ( B * 2 + 1 ) ] ]
trg = ( ( -1 ) からなる 列 の 0 から B * 2 に 1 を加えた 値 未 満 までの 数 列 の 各要素 を C とし 、 B に 2 を 掛 け た 値に 1 を加えた 値の 列 回 分 の 列 ) からなる 列 を A とする
rst = ( ( -1 ) からなる 列 の 0 から B * 2 に 1 を加えた 値 未 満 までの 数 列 の 各要素 を C とし 、 B に 2 を 掛 け た 値に 1 を加えた 値の 列 回 分 の 列 ) からなる 列 を A とする <eos>
3149
src = A . _nodes = [ [ 0 ] * [ ( B + 1 ) for C in range ( B + 1 ) ] ]
trg = ( ( 0 ) からなる 列 の 0 から B に 1 を加えた 値 未 満 までの 数 列 の 各要素 を C とし 、 B に 1 を加えた 値の 列 回 分 の 列 ) からなる 列 を A の _ nodes にする
rst = ( ( 0 ) からなる 列 の 0 から B に 1 を加えた 値 未 満 までの 数 列 の 各要素 を C とし 、 B に 1 を加えた 値の 列 回 分 の 列 ) からなる 列 を A の _ nodes にする <eos>
3150
src = A [ B [ 0 ] ] += B [ 1 : ]
trg = A の B の先頭 番 目 を B の先頭 を 除 いた 部分 列 だけ 増加 させる
rst = A の B の先頭 番 目 を B の先頭 を 除 いた 部分 列 だけ 増加 させる <eos>
3151
src = return A * B + C * D
trg = A に B を 掛 け た 値に C に D を 掛 け た 値 を加えた 値を返す
rst = A に B を 掛 け た 値に C に D を 掛 け た 値 を加えた 値を返す <eos>
3152
src = A . bit1 = BinaryIndexedTree ( B )
trg = BinaryIndexedTree ( B ) を A の bit 1 にする
rst = BinaryIndexedTree ( B ) を A の bit 1 にする <eos>
3153
src = return ( A - B ) * ( C - D ) - ( E - B ) * ( F - D )
trg = A から B を 引 いた 値に C から D を 引 いた 値を 掛 け た 値 から E から B を 引 いた 値に F から D を 引 いた 値を 掛 け た 値を 引 いた 値を返す
rst = A から B を 引 いた 値に C から D を 引 いた 値を 掛 け た 値 から E から B を 引 いた 値に F から D を 引 いた 値を 掛 け た 値を 引 いた 値を返す <eos>
3154
src = A . depth = A . parent . get_depth ( ) + 1
trg = A . parent . get _ depth () に 1 を加えた 値を A の depth にする
rst = A . parent . <unk> () に 1 を加えた 値を A の depth にする <eos>
3155
src = A = [ 0 ] * 4
trg = ( 0 ) からなる 列 の 4 回 分 の 列 を A とする
rst = ( 0 ) からなる 列 の 4 回 分 の 列 を A とする <eos>
3156
src = if A == [ ( 0 , 0 ) , ( 1 , 0 ) , ( 2 , 0 ) , ( 3 , 0 ) ] :
trg = A が ( ( 0 、 0 ) の 組 、 ( 1 、 0 ) の 組 、 ( 2 、 0 ) の 組 、 ( 3 、 0 ) の 組 ) からなる 列 と 等 しい とき 、
rst = A が ( ( 0 、 0 ) の 組 、 ( 1 、 0 ) の 組 、 ( 2 、 0 ) の 組 、 ( 3 、 0 ) の 組 ) からなる 列 と 等 しい とき 、 <eos>
3157
src = A [ B - C ] [ D + C ] = 1
trg = 1 を A の B から C を 引 いた 値 番目の D に C を加えた 値 番 目 にする
rst = 1 を A の B から C を 引 いた 値 番目の D に C を加えた 値 番 目 にする <eos>
3158
src = print ( A . get_d2 ( B , C ) )
trg = A . get _ d 2 ( B , C ) を出力する
rst = A . miny ( B , C ) を出力する <eos>
3159
src = if A [ A [ B ] . parent ] . left != B and A [ A [ B ] . parent ] . left != C :
trg = A の A [ B ] の parent 番目の left が B と 等 しく なく かつ A の A [ B ] の parent 番目の left が C と 等 しく ない とき 、
rst = A の A [ B ] の parent 番目の left が B と 等 しく なく かつ A の A [ B ] の parent 番目の left が C と 等 しく ない とき 、 <eos>
3160
src = A . dice = [ B [ 2 ] , B [ 1 ] , B [ 5 ] , B [ 0 ] , B [ 4 ] , B [ 3 ] ]
trg = ( B の 2 番 目 、 B の 1 番 目 、 B の 5 番 目 、 B の先頭 、 B の 4 番 目 、 B の 3 番 目 ) からなる 列 を A の dice にする
rst = ( B の 2 番 目 、 B の 1 番 目 、 B の 5 番 目 、 B の先頭 、 B の 4 番 目 、 B の 3 番 目 ) からなる 列 を A の dice にする <eos>
3161
src = if A [ B ] [ C ] != inf :
trg = A の B 番目の C 番 目 が 、 つまり 無限大 と 等 しく ない とき 、
rst = A の B 番目の C 番 目 が 、 つまり 無限大 と 等 しく ない とき 、 <eos>
3162
src = A , B , C = { } , { } , { }
trg = 空 辞書 、 空 辞書 、 空 辞書 を A 、 B 、 C とする
rst = 空 辞書 、 空 辞書 を A 、 B 、 C とする <eos>
3163
src = A [ B + C ] [ 0 ] = D
trg = D を A の B に C を加えた 値 番目の 0 番 目 にする
rst = D を A の B に C を加えた 値 番目の 0 番 目 にする <eos>
3164
src = A [ 1 ] [ B ] = - C
trg = - C を A の 1 番目の B 番 目 にする
rst = - C を A の 1 番目の B 番 目 にする <eos>
3165
src = A = [ [ B for C in range ( 10 ) ] for D in range ( 10 ) ]
trg = 0 から 10 未 満 までの 数 列 の 各要素 を D とし 、 0 から 10 未 満 までの 数 列 の 各要素 を C とし 、 B の 列 の 列 を A とする
rst = 0 から 10 未 満 までの 数 列 の 各要素 を D とし 、 0 から 10 未 満 までの 数 列 の 各要素 を C とし 、 B の 列 の 列 を A とする <eos>
3166
src = A [ 5 ] += 1
trg = A の 5 番 目 を 1 だけ 増加 させる
rst = A の 5 番 目 を 1 だけ 増加 させる <eos>
3167
src = if not any ( A ) :
trg = A が 少なくとも ひとつ は 真 でない とき 、
rst = A が 少なくとも ひとつ は 真 でない とき 、 <eos>
3168
src = A , B , C , D = [ E ] , [ F ] , [ F // E ] , [ F % E ]
trg = ( E ) からなる 列 、 ( F ) からなる 列 、 ( F を E で 割 った 商 ) からなる 列 、 ( F を E で 割 った 余 り ) からなる 列 を A 、 B 、 C 、 D とする
rst = ( E ) からなる 列 、 ( F ) からなる 列 、 ( F / E ) からなる 列 、 ( F % E ) からなる 列 を A 、 B 、 C 、 D とする <eos>
3169
src = if not A [ B + 1 ] [ C ] :
trg = A の B に 1 を加えた 値 番目の C 番 目 でない とき 、
rst = A の B に 1 を加えた 値 番目の C 番 目 でない とき 、 <eos>
3170
src = A = [ - 2 , - 2 , - 2 , - 1 , 0 , 1 , - 1 , 0 , 1 , 2 , 2 , 2 ]
trg = ( -2 、 -2 、 -2 、 -1 、 0 、 1 、 -1 、 0 、 1 、 2 、 2 、 2 ) からなる 列 を A とする
rst = ( -2 、 -2 、 -2 、 -1 、 0 、 1 、 -1 、 0 、 1 、 0 、 2 ) からなる 列 を A とする <eos>
3171
src = if A [ B + C ] [ D + E ] == 1 and not F [ B + C ] [ D + E ] :
trg = A の B に C を加えた 値 番目の D に E を加えた 値 番 目 が 1 と 等 しく かつ F の B に C を加えた 値 番目の D に E を加えた 値 番 目 でない とき 、
rst = A の B に C を加えた 値 番目の D に E を加えた 値 番 目 が 1 と 等 しく かつ F の B に C を加えた 値 番目の D に E を加えた 値 番 目 でない とき 、 <eos>
3172
src = A [ not B // 5 ] [ C ] = ' '
trg = 空白 文字 を A の B を 5 で 割 った 商 でない 番目の C 番 目 にする
rst = 空白 文字 を A の B を 5 で 割 った 商 番目の C 番 目 にする <eos>
3173
src = A = 1500000
trg = 1 50 0000 を A とする
rst = 10 4 6 5 27 を A とする <eos>
3174
src = A = B [ C ] [ 0 ] + ( D [ E ] + F ) * ( D [ E ] > F )
trg = B の C 番目の 0 番 目 に D の E 番 目 に F を加えた 値に D の E 番 目 が F より 大きい かどうか を 掛 け た 値 を加えた 値を A とする
rst = B の C 番目の 0 番 目 に D の E 番 目 に F を加えた 値に D の E 番 目 が F より 大きい かどうか を 掛 け た 値 を加えた 値を A とする <eos>
3175
src = A [ 0 ] = ( 1 / 3 ) ** B
trg = 1 を 3 で 割 った 値の B 乗 を A の 0 番 目 にする
rst = 1 を 3 で 割 った 値の B 乗 を A の 0 番 目 にする <eos>
3176
src = print ( ' ' , end = '' )
trg = 改行 せずに 空白 文字 を出力する
rst = 改行 せずに 空白 文字 を出力する <eos>
3177
src = for A in range ( B , B + C ) :
trg = B から B に C を加えた 値 未 満 までの 数 列 を 順に A として 、 繰り返す
rst = B から B に C を加えた 値 未 満 までの 数 列 を 順に A として 、 繰り返す <eos>
3178
src = A = add ( A , ( - B * C , D ) )
trg = add ( A , ( - B * C , D ) ) を A とする
rst = add ( A , ( - B * C , D ) ) を A とする <eos>
3179
src = A = { e : [ B + 1 for B , e in enumerate ( sorted ( C ) ) ] }
trg = ( ( ネ イ ピ ア 数 , C を ソート した 列 に 番号 付 した 組 の 列 の 各要素 を B 、 ネ イ ピ ア 数 とし 、 B に 1 を加えた 値の 列 ) ) からなる 辞書 を A とする
rst = ( ( ネ イ ピ ア 数 , C を ソート した 列 に 番号 付 した 組 の 列 の 各要素 を B 、 ネ イ ピ ア 数 とし 、 B に 1 を加えた 値の 列 ) ) からなる 辞書 を A とする <eos>
3180
src = count -= A [ B + 1 ] * C if A [ B + 1 ] > 0 else A [ B + 1 ] * D
trg = 無限 の 整数 列 を A の B に 1 を加えた 値 番 目 が 0 より 大きい とき A の B に 1 を加えた 値 番 目 に C を 掛 け た 値 、 そうでなければ A の B に 1 を加えた 値 番 目 に D を 掛 け た 値 だけ 減少 させる
rst = 無限 の 整数 列 を A の B に 1 を加えた 値 番 目 が 0 より 大きい とき A の B に 1 を加えた 値 番 目 に C を 掛 け た 値 、 そうでなければ A の B に 1 を加えた 値 番 目 に D を 掛
3181
src = print ( ( A * ( 4 * B * B - A * A ) ** .5 + 2 * B * ( ( B + C ) ** 2 - B * B ) ** .5 ) / 4 )
trg = A に ( 4 * B * B - A * A ) の . 5 乗 を 掛 け た 値に 2 に B を 掛 け た 値に ( ( B + C ) * * 2 - B * B ) の . 5 乗 を 掛 け た 値 を加えた 値を 4 で 割 った 値 を出力する
rst = A に 4 * B から A * B を 引 いた 値を 掛 け た 値 から A * * . 5 に B * C * 2 を加えた 値 から B * * * * 4 を 引 いた 値を 掛 け た 値を 引 いた 値を 4
3182
src = if A [ B ] & 2 :
trg = A の B 番 目 と 2 の 論理 積 の とき 、
rst = A の B 番 目 と 2 の 論理 積 の とき 、 <eos>
3183
src = app ( ( A [ 0 ] , A [ 1 ] , B [ 0 ] , B [ 1 ] ) )
trg = app ( ( A [ 0 ] , A [ 1 ] , B [ 0 ] , B [ 1 ] ) )
rst = app ( ( A [ 0 ] , A [ 1 ] , B [ 0 ] , B [ 1 ] ) ) <eos>
3184
src = A = combinations_with_replacement ( B , 4 )
trg = B の 4 個 までの 重複 コン ビ ネ ー ション を A とする
rst = B の 4 個 までの コン ビ ネ ー ション を A とする <eos>
3185
src = print ( A . format ( B + C * 2 ) )
trg = A を 書式 として B に C に 2 を 掛 け た 値 を加えた 値 で 整 形 した 文字列 を出力する
rst = A を 書式 として B に C に 2 を 掛 け た 値 を加えた 値 で 整 形 した 文字列 を出力する <eos>
3186
src = A , B = C [ 0 ] [ 1 ] , C [ 1 ] [ 1 ] + 1
trg = C の先頭 の 1 番 目 、 C の 1 番目の 1 番 目 に 1 を加えた 値を A 、 B とする
rst = C の先頭 の 1 番 目 、 C の 1 番目の 1 番 目 に 1 を加えた 値を A 、 B とする <eos>
3187
src = A = Dinic ( B )
trg = Dinic ( B ) を A とする
rst = Dinic ( B ) を A とする <eos>
3188
src = A = B [ C - 1 ] [ D - E [ C ] ] + E [ C ]
trg = B の C から 1 を 引 いた 値 番目の D から E の C 番 目 を 引 いた 値 番 目 に E の C 番 目 を加えた 値を A とする
rst = B の C から 1 を 引 いた 値 番目の D から E の C 番 目 を 引 いた 値 番 目 に E の C 番 目 を加えた 値を A とする <eos>
3189
src = A = B [ - 1 ] [ 0 ]
trg = B の 末 尾 の先頭 を A とする
rst = B の 末 尾 の先頭 を A とする <eos>
3190
src = A , B , C = C [ 0 ] , [ C [ 0 ] ] , C [ 1 : ]
trg = C の先頭 、 ( C の先頭 ) からなる 列 、 C の先頭 を 除 いた 部分 列 を A 、 B 、 C とする
rst = C の先頭 、 ( C の先頭 ) からなる 列 、 C の先頭 を 除 いた 部分 列 を A 、 B 、 C とする <eos>
3191
src = e = list ( map ( int , input ( ) . split ( ) ) )
trg = 入力された 文字列を 空白 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 の リストを ネ イ ピ ア 数 とする
rst = 入力された 文字列を 空白 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 の リストを ネ イ ピ ア 数 とする <eos>
3192
src = A . list [ 0 ] , A . list [ 4 ] , A . list [ 5 ] , A . list [ 1 ] = A . list [ 4 ] , A . list [ 5 ] , A . list [ 1 ] , A . list [ 0 ]
trg = A の list の 4 番 目 、 A の list の 5 番 目 、 A の list の 1 番 目 、 A の list の先頭 を A の list の先頭 、 A の list の 4 番 目 、 A の list の 5 番 目 、 A の list の 1 番 目 とする
rst = A の list の 4 番 目 、 A の list の 5 番 目 、 A の list の先頭 を A の list の先頭 、 A の list の 4 番 目 、 A の list の 5 番 目 とする <eos>
3193
src = A = B . _find_min ( C )
trg = B . _ find _ min ( C ) を A とする
rst = B . _ find _ min ( C ) を A とする <eos>
3194
src = A = tuple ( map ( lambda B : int ( B ) , input ( ) . split ( ) ) )
trg = 入力された 文字列を 空白 で 分割 した 字句 列 の 各要素 に x を パラメータ として x の 整数値 を返す関数 を適用した 列 の 組 を A とする
rst = 入力された 文字列を 空白 で 分割 した 字句 列 の 各要素 に x を パラメータ として x の 整数値 を返す関数 を適用した 列 の 組 を A とする <eos>
3195
src = while int ( input ( ) ) :
trg = 入力された 文字列 の 整数値 の 間 、 次 を 繰り返す
rst = 入力された 文字列 の 整数値 の 間 、 次 を 繰り返す <eos>
3196
src = A . extend ( get_t ( B - C , D - E , F - C , G - E ) )
trg = get _ t ( B - C , D - E , F - C , G - E ) を追加し て A を拡張する
rst = <unk> _ move ( B - C , D - E , F - C , G - E ) を追加し て A を拡張する <eos>
3197
src = A = B << C
trg = B を C だけ 左 シフト した 値を A とする
rst = B を C だけ 左 シフト した 値を A とする <eos>
3198
src = A = cycle ( [ int ( B ) for B in input ( ) . split ( ' ' ) ] )
trg = 入力された 文字列を 空白 文字 で 分割 した 字句 列 の 各要素 を B とし 、 B の 整数値 の 列 を 無限 に 繰り返し た 列 を A とする
rst = 入力された 文字列を 空白 文字 で 分割 した 字句 列 の 各要素 を B とし 、 B の 整数値 の 列 を 無限 に 繰り返し た 列 を A とする <eos>
3199
src = assert 0
trg = 0 でなければならない
rst = 0 でなければならない <eos>
3200
src = A . edges [ B . src ] . append ( B )
trg = A の edges の B の src 番目の 末 尾 に B を追加する
rst = A の edges の B の src 番目の 末 尾 に B を追加する <eos>
3201
src = find ( A , int ( B [ 0 ] ) )
trg = find ( A , int ( B [ 0 ] ) )
rst = find ( A , int ( B [ 0 ] ) ) <eos>
3202
src = print ( sum ( A ) % 60 )
trg = A の 総 和 を 60 で 割 った 余 り を出力する
rst = A の 総 和 を 60 で 割 った 余 り を出力する <eos>
3203
src = print ( * sorted ( A ) )
trg = A を ソート した 列 を 展開 して を出力する
rst = A を ソート した 列 を 展開 して を出力する <eos>
3204
src = print ( 0 , 3 )
trg = 0 、 3 を出力する
rst = 0 、 3 を出力する <eos>
3205
src = print ( int ( '' . join ( A [ : : - 1 ] ) ) - int ( '' . join ( A ) ) )
trg = 空文字列 を 間 に 入れ て A の 逆 順 を 連結 した 文字列 の 整数値 から 、 つまり 空文字列 を 間 に 入れ て A を 連結 した 文字列 の 整数値 を 引 いた 値 を出力する
rst = 空文字列 を 間 に 入れ て A の 逆 順 を 連結 した 文字列 の 整数値 から 、 つまり 空文字列 を 間 に 入れ て A を ソート した 列 を 連結 した 文字列 の 整数値 を 引 いた 値 を出力する <eos>
3206
src = A = B = 10
trg = 10 を B とする を A とする
rst = 10 を B とする を A とする <eos>
3207
src = A = 4 * B + 3 + 4 * ( 3 * ( 4 * ( B + 1 ) // 146097 + 1 ) // 4 )
trg = 4 に B を 掛 け た 値に 3 を加えた 値に 4 に 3 に 4 * ( B + 1 ) / / 14 60 9 7 に 1 を加えた 値を 掛 け た 値を 4 で 割 った 商 を 掛 け た 値 を加えた 値を A とする
rst = 4 に B を 掛 け た 値に 3 に 4 を 掛 け た 値 を加えた 値に 3 に 4 * ( B + 1 ) を 掛 け た 値を 3 で 割 った 商 を加えた 値に 1 を加えた 値を 4 で 割 った 商 を加えた 値を A
3208
src = bst_preorder ( A . right )
trg = bst _ preorder ( A . right )
rst = <unk> ( A . right ) <eos>
3209
src = A [ 0 ] [ 0 ] [ 0 ] = 1
trg = 1 を A の先頭 の先頭 の 0 番 目 にする
rst = 1 を A の先頭 の先頭 の 0 番 目 にする <eos>
3210
src = A = gcd ( abs ( B ) , abs ( C ) )
trg = B の 絶対 値 と C の 絶対 値の 最大 公 約 数 を A とする
rst = B の 絶対 値 と C の 絶対 値の 最大 公 約 数 を A とする <eos>
3211
src = A = deque ( B . ord )
trg = B の ord の 両 端 キュー を A とする
rst = B の ord の 両 端 キュー を A とする <eos>
3212
src = return ( 1 , 0 , 2 )
trg = ( 1 、 0 、 2 ) の 組 を返す
rst = ( 1 、 0 、 2 ) の 組 を返す <eos>
3213
src = A . par = [ B for B in range ( C + 1 ) ]
trg = 0 から C に 1 を加えた 値 未 満 までの 数 列 の 各要素 を B とし 、 B の 列 を A の par にする
rst = 0 から C に 1 を加えた 値 未 満 までの 数 列 の 各要素 を B とし 、 B の 列 を A の par にする <eos>
3214
src = A = Node ( B , C )
trg = Node ( B , C ) を A とする
rst = Node ( B , C ) を A とする <eos>
3215
src = print ( [ A . sum ( B ) for B in range ( C + 1 ) ] )
trg = 0 から C に 1 を加えた 値 未 満 までの 数 列 の 各要素 を B とし 、 A 、 B の 総 和 の 列 を出力する
rst = 0 から C に 1 を加えた 値 未 満 までの 数 列 の 各要素 を B とし 、 A 、 B の 総 和 の 列 を出力する <eos>
3216
src = if A != 3 :
trg = A が 3 と 等 しく ない とき 、
rst = A が 3 と 等 しく ない とき 、 <eos>
3217
src = if [ ] == A :
trg = 空 列 が A と 等 しい とき 、
rst = 空 列 が A と 等 しい とき 、 <eos>
3218
src = print ( str ( A [ - 1 * B ] ) )
trg = A の -1 に B を 掛 け た 値 番目の 文字列 を出力する
rst = A の -1 に B を 掛 け た 値 番目の 文字列 を出力する <eos>
3219
src = A = B . get ( C , - 1 )
trg = B に対応する 値 、 も し 存在 し なければ C 、 -1 を A とする
rst = B に対応する 値 、 も し 存在 し なければ C 、 -1 を A とする <eos>
3220
src = A . d [ 4 ] , A . d [ 0 ] , A . d [ 1 ] , A . d [ 5 ] = A . d [ 0 ] , A . d [ 1 ] , A . d [ 5 ] , A . d [ 4 ]
trg = A の d の先頭 、 A の d の 1 番 目 、 A の d の 5 番 目 、 A の d の 4 番 目 を A の d の 4 番 目 、 A の d の先頭 、 A の d の 1 番 目 、 A の d の 5 番 目 とする
rst = A の d の 0 番 目 、 A の d の 1 番 目 、 A の d の 5 番 目 、 A の d の 4 番 目 を A の d の 4 番 目 、 A の d の先頭 、 A の d の 1
3221
src = for A in B . split ( ) :
trg = B を 空白 で 分割 した 字句 列 を 順に A として 、 繰り返す
rst = B を 空白 で 分割 した 字句 列 を 順に A として 、 繰り返す <eos>
3222
src = return ( A , B , gcd ( C , D ) )
trg = ( A 、 B 、 C と D の 最大 公 約 数 ) の 組 を返す
rst = ( A 、 B 、 C と D の 最大 公 約 数 ) の 組 を返す <eos>
3223
src = A , B , C , D , E , F = map ( float , input ( ) . split ( ' ' ) )
trg = 入力された 文字列を 空白 文字 で 分割 した 字句 列 の 各要素 に 浮動小数点数 を適用した 列 を 展開 し 、 それぞれ A 、 B 、 C 、 D 、 E 、 F とする
rst = 入力された 文字列を 空白 文字 で 分割 した 字句 列 の 各要素 に 浮動小数点数 を適用した 列 を 展開 し 、 それぞれ A 、 B 、 C 、 D 、 E 、 F とする <eos>
3224
src = return ( ( A + B ) ** 2 - ( A - B ) ** 2 ) ** ( 1 / 2 )
trg = A に B を加えた 値の 2 乗 から A から B を 引 いた 値の 2 乗 を 引 いた 値の 1 を 2 で 割 った 値 乗 を返す
rst = A に B を加えた 値の 2 乗 から A から B を 引 いた 値の 2 乗 を 引 いた 値の 1 を 2 で 割 った 値 乗 を返す <eos>
3225
src = A = [ B if B != C else [ D for B in E ] ]
trg = ( B が C と 等 しく ない とき B 、 そうでなければ E の 各要素 を B とし 、 D の 列 ) からなる 列 を A とする
rst = ( B が C と 等 しく ない とき B 、 そうでなければ E の 各要素 を B とし 、 D の 列 ) からなる 列 を A とする <eos>
3226
src = A = ( 0 , 1 , 0 , 1 , 1 , 0 , 1 , 0 , 0 , 1 , 0 , 1 , 1 , 0 , 1 , 0 )
trg = ( 0 、 1 、 0 、 1 、 1 、 0 、 1 、 0 、 0 、 1 、 0 、 1 、 1 、 0 、 1 、 0 ) の 組 を A とする
rst = ( 0 、 1 、 1 、 0 、 1 、 0 、 1 、 0 、 0 、 1 、 0 、 0 ) の 組 を A とする <eos>
3227
src = A [ B ] . append ( ( B + 1 , C ) )
trg = A の B 番目の 末 尾 に ( B に 1 を加えた 値 、 C ) の 組 を追加する
rst = A の B 番目の 末 尾 に ( B に 1 を加えた 値 、 C ) の 組 を追加する <eos>
3228
src = A = get_childs ( B )
trg = get _ childs ( B ) を A とする
rst = <unk> ( B ) を A とする <eos>
3229
src = A += B . n
trg = A を B の n だけ 増加 させる
rst = A を B の n だけ 増加 させる <eos>
3230
src = if A [ 1 ] [ B ] == C :
trg = A の 1 番目の B 番 目 が C と 等 しい とき 、
rst = A の 1 番目の B 番 目 が C と 等 しい とき 、 <eos>
3231
src = print ( '' , ' ' . join ( [ str ( A . key ) for A in B . preorder ( ) ] ) )
trg = 空文字列 、 空白 文字 を 間 に 入れ て B . preorder () の 各要素 を A とし 、 A の key の 文字列 の 列 を 連結 した 文字列 を出力する
rst = 空文字列 、 空白 文字 を 間 に 入れ て B . preorder () の 各要素 を A とし 、 A . key の 文字列 の 列 を 連結 した 文字列 を出力する <eos>
3232
src = if A % 500 == 0 :
trg = A を 500 で 割 った 余 り が 0 と 等 しい とき 、
rst = A を 500 で 割 った 余 り が 0 と 等 しい とき 、 <eos>
3233
src = print ( {elem[0]} {elem[1]} {elem[2]} {elem[3]} {elem[4]} )
trg = " { } { } { } { } { } " を出力する
rst = " { } { } " を出力する <eos>
3234
src = A = [ B for B in C if B <= D ]
trg = C の 各要素 を B とし 、 B が D 以下の とき の B の 列 を A とする
rst = C の 各要素 を B とし 、 B が D 以下の とき の B の 列 を A とする <eos>
3235
src = A = ( B + C - 1 ) // C
trg = B に C を加えた 値 から 1 を 引 いた 値を C で 割 った 商 を A とする
rst = B に C を加えた 値 から 1 を 引 いた 値を C で 割 った 商 を A とする <eos>
3236
src = search ( A , B , C )
trg = B 、 C において 正規表現 A が 最初 にマッチする 位置
rst = B 、 C において 正規表現 A が 最初 にマッチする 位置 <eos>
3237
src = if A . date < B . date :
trg = A の 日付 が B の 日付 より 小さい とき 、
rst = A の 日付 が B の 日付 より 小さい とき 、 <eos>
3238
src = A = [ sum ( B ) for B in C ]
trg = C の 各要素 を B とし 、 B の 総 和 の 列 を A とする
rst = C の 各要素 を B とし 、 B の 総 和 の 列 を A とする <eos>
3239
src = A . append ( B + ( C - D ) )
trg = A の 末 尾 に B に C から D を 引 いた 値 を加えた 値 を追加する
rst = A の 末 尾 に B に C から D を 引 いた 値 を加えた 値 を追加する <eos>
3240
src = if A * 2 <= B and A * 2 <= C and A * 2 <= D :
trg = A に 2 を 掛 け た 値が B 以下 かつ A に 2 を 掛 け た 値が C 以下 かつ A に 2 を 掛 け た 値が D 以下の とき 、
rst = A に 2 を 掛 け た 値が B 以下 かつ A に 2 を 掛 け た 値が C 以下 かつ A に 2 を 掛 け た 値が D 以下の とき 、 <eos>
3241
src = A = B . index ( C [ 0 ] )
trg = B の C の先頭 と 等 しい 要素 の最初の 位置 を A とする
rst = B の C の先頭 と 等 しい 要素 の最初の 位置 を A とする <eos>
3242
src = A += prod ( B )
trg = A を prod ( B ) だけ 増加 させる
rst = A を prod ( B ) だけ 増加 させる <eos>
3243
src = if A + 1 < B and C [ A * 2 + 1 ] [ D ] == 0 and E [ A + 1 ] [ D ] > F + 1 :
trg = A に 1 を加えた 値が B より 小さく かつ C の A * 2 + 1 番目の D 番 目 が 0 と 等 しく かつ E の A に 1 を加えた 値 番目の D 番 目 が F に 1 を加えた 値 より 大きい とき 、
rst = A に 1 を加えた 値が B より 小さく かつ C の A * 2 に 1 を加えた 値 番目の D 番 目 が 0 と 等 しく かつ E の A に 1 を加えた 値 番目の D 番 目 が F に 1 を加えた 値 より 大きい とき 、 <eos>
3244
src = A = [ 0 ] * 32
trg = ( 0 ) からなる 列 の 32 回 分 の 列 を A とする
rst = ( 0 ) からなる 列 の 32 回 分 の 列 を A とする <eos>
3245
src = A , B = [ C [ D ] for D in E . strip ( ) . split ( F ) ]
trg = E の 両 端 から 空白 改行 を取り 除 いた 文字列を F で 分割 した 字句 列 の 各要素 を D とし 、 C の D 番目の 列 を 展開 し 、 それぞれ A 、 B とする
rst = E の 両 端 から 空白 改行 を取り 除 いた 文字列を F で 分割 した 字句 列 の 各要素 を D とし 、 C の D 番目の 列 を 展開 し 、 それぞれ A 、 B とする <eos>
3246
src = for A in permutations ( map ( str , range ( 1 , B + 1 ) ) , r = B ) :
trg = B を r として 1 から B に 1 を加えた 値 未 満 までの 数 列 の 各要素 に 整数 を適用した 列 の 順 列 を 順に A として 、 繰り返す
rst = B を r として 1 から B に 1 を加えた 値 未 満 までの 数 列 の 各要素 に 整数 を適用した 列 の 順 列 を 順に A として 、 繰り返す <eos>
3247
src = if A + 1 < B :
trg = A に 1 を加えた 値が B より 小さい とき 、
rst = A に 1 を加えた 値が B より 小さい とき 、 <eos>
3248
src = A = [ tuple ( map ( int , B . split ( ) ) ) for B in C ]
trg = C の 各要素 を B とし 、 B を 空白 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 の 組 の 列 を A とする
rst = C の 各要素 を B とし 、 B を 空白 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 の 組 の 列 を A とする <eos>
3249
src = A [ B [ C ] [ 0 ] - 1 ] [ B [ C ] [ D + 2 ] - 1 ] = 1
trg = 1 を A の B の C 番目の 先頭 から 1 を 引 いた 値 番目の B の C 番目の D に 2 を加えた 値 番 目 から 1 を 引 いた 値 番 目 にする
rst = 1 を A の B の C 番目の 0 番 目 から 1 を 引 いた 値 番目の B の C 番目の D に 2 を加えた 値 番 目 から 1 を 引 いた 値 番 目 にする <eos>
3250
src = print ( min ( A * B , C + max ( 0 , B - D ) * E ) )
trg = A に B を 掛 け た 値 、 C に 0 、 B - D の 最大 値に E を 掛 け た 値 を加えた 値の 最小 値 を出力する
rst = A に B を 掛 け た 値 、 C に 0 、 B から D を 引 いた 値の 最大 値に E を 掛 け た 値 を加えた 値の 最小 値 を出力する <eos>
3251
src = A = B . find ( C , A )
trg = B の位置 A から C を 探 して 見つかった 位置 を A とする
rst = B の位置 A から C を 探 して 見つかった 位置 を A とする <eos>
3252
src = A = max ( - 3 , min ( 3 , B [ 1 ] - B [ 2 ] ) )
trg = -3 、 3 、 B の 1 番 目 から B の 2 番 目 を 引 いた 値の 最小 値の 最大 値を A とする
rst = -3 、 3 、 B の 1 番 目 から B の 2 番 目 を 引 いた 値の 最小 値を A とする <eos>
3253
src = A [ 0 ] += B [ 0 ] * C
trg = A の 0 番 目 を B の 0 番 目 に C を 掛 け た 値 だけ 増加 させる
rst = A の 0 番 目 を B の 先頭に C を 掛 け た 値 だけ 増加 させる <eos>
3254
src = A += B / C * D
trg = A を B を C で 割 った 値に D を 掛 け た 値 だけ 増加 させる
rst = A を B を C で 割 った 値に D を 掛 け た 値 だけ 増加 させる <eos>
3255
src = if A [ B ] > 0 :
trg = A の B 番 目 が 0 より 大きい とき 、
rst = A の B 番 目 が 0 より 大きい とき 、 <eos>
3256
src = A += sum ( map ( lambda E : E == B , C . strip ( D ) . lower ( ) . split ( ) ) )
trg = A を C の 両 端 から D を取り 除 いた 文字列を 英 小文字 に変換し た 文字列を 空白 で 分割 した 字句 列 の 各要素 に w を パラメータ として w が B と 等 しい かどうか を返す関数 を適用した 列 の 総 和 だけ 増加 させる
rst = A を C の 両 端 から 空白 改行 を取り 除 いた 文字列を 英 小文字 に変換し た 文字列を 空白 で 分割 した 字句 列 の 各要素 に x を パラメータ として x が B と 等 しい かどうか を返す関数 を適用した 列 の 総 和 だけ 増加 させる <eos>
3257
src = ( A , B ) = merge_sort ( C )
trg = merge _ sort ( C ) を ( A 、 B ) の 組 とする
rst = merge _ sort ( C ) を ( A 、 B ) の 組 とする <eos>
3258
src = A = [ [ 1 ] * [ ( B + 4 ) for C in range ( D + 4 ) ] ]
trg = ( (1) からなる 列 の 0 から D に 4 を加えた 値 未 満 までの 数 列 の 各要素 を C とし 、 B に 4 を加えた 値の 列 回 分 の 列 ) からなる 列 を A とする
rst = ( (1) からなる 列 の 0 から D に 4 を加えた 値 未 満 までの 数 列 の 各要素 を C とし 、 B に 4 を加えた 値の 列 回 分 の 列 ) からなる 列 を A とする <eos>
3259
src = global time
trg = time は グローバル変数 とする
rst = time を 36 50 で 割 った 余 り <eos>
3260
src = D . pop ( B )
trg = D の B を取り 出した 値
rst = D の B を取り 出した 値 <eos>
3261
src = A = math . sqrt ( B ** 2 + C ** 2 - 2 * B * C * math . cos ( math . pi * D / 180 ) )
trg = B の 2 乗 に C の 2 乗 を加えた 値 から 2 に B を 掛 け た 値に C を 掛 け た 値に math . pi * D を 1 80 で 割 った 値の 余 弦 を 掛 け た 値を 引 いた 値の 平 方 根 を A とする
rst = B の 2 乗 に C の 2 乗 を加えた 値 から 2 に B を 掛 け た 値に C を 掛 け た 値に math . pi を 掛 け た 値を 引 いた 値の 平 方 根 を A とする <eos>
3262
src = A . s_roll ( )
trg = A . s _ roll ()
rst = A . <unk> () <eos>
3263
src = A += 4
trg = A を 4 だけ 増加 させる
rst = A を 4 だけ 増加 させる <eos>
3264
src = return A / 9.8
trg = A を 9 . 8 で 割 った 値を返す
rst = A を 9 . 8 で 割 った 値を返す <eos>
3265
src = A [ 2 ] = B // 360 % 20
trg = B を 3 60 で 割 った 商 を 20 で 割 った 余 り を A の 2 番 目 にする
rst = B を 3 60 で 割 った 商 を 20 で 割 った 余 り を A の 2 番 目 にする <eos>
3266
src = A = len ( B . GetNodes ( ) )
trg = B . GetNodes () の長さ を A とする
rst = B . GetNodes () の長さ を A とする <eos>
3267
src = A . print ( B , C )
trg = A . print ( B , C )
rst = A . miny ( B , C ) を出力する <eos>
3268
src = A . official_house [ B ] [ C ] [ D ] -= E
trg = A の official _ house の B 番目の C 番目の D 番 目 を E だけ 減少 させる
rst = A の official _ house の B 番目の C 番目の D 番 目 を E だけ 減少 させる <eos>
3269
src = if A [ B ] . count ( A [ B ] [ C ] ) == 1 :
trg = A の B 番 目 内の A の B 番目の C 番目の 出現 回数 が 1 と 等 しい とき 、
rst = A の B 番 目 内の A の B 番目の C 番目の 出現 回数 が 1 と 等 しい とき 、 <eos>
3270
src = A , B = C [ D * 2 + 2 ]
trg = C の D に 2 を 掛 け た 値に 2 を加えた 値 番 目 を 展開 し 、 それぞれ A 、 B とする
rst = C の D に 2 を 掛 け た 値に 2 を加えた 値 番 目 を 展開 し 、 それぞれ A 、 B とする <eos>
3271
src = print ( '' , ' ' . join ( map ( str , A . root . prewalk ( ) ) ) )
trg = 空文字列 、 空白 文字 を 間 に 入れ て A . root . prewalk () の 各要素 に 整数 を適用した 列 を 連結 した 文字列 を出力する
rst = 空文字列 、 空白 文字 を 間 に 入れ て A . root . inwalk () の 各要素 に 整数 を適用した 列 を 連結 した 文字列 を出力する <eos>
3272
src = if A <= B < ( A ** 2 + 1 ) ** .5 :
trg = A が B 以下 かどうか が A の 2 乗 に 1 を加えた 値の . 5 乗 より 小さい とき 、
rst = A が B 以下 かどうか が A の 2 乗 に 1 を加えた 値の . 5 乗 より 小さい とき 、 <eos>
3273
src = A = sorted ( map ( int , input ( ) . split ( ) ) , reverse = True )
trg = 逆 順に 入力された 文字列を 空白 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 を ソート した 列 を A とする
rst = 逆 順に 入力された 文字列を 空白 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 を ソート した 列 を A とする <eos>
3274
src = A += ( B - C ) * ( D + E )
trg = A を B から C を 引 いた 値に D に E を加えた 値を 掛 け た 値 だけ 増加 させる
rst = A を B から C を 引 いた 値に D に E を加えた 値を 掛 け た 値 だけ 増加 させる <eos>
3275
src = A = answer ( )
trg = answer () を A とする
rst = <unk> () を A とする <eos>
3276
src = A = ( B [ C + 1 ] - B [ C ] ) // 2
trg = B の C に 1 を加えた 値 番 目 から B の C 番 目 を 引 いた 値を 2 で 割 った 商 を A とする
rst = B の C に 1 を加えた 値 番 目 から B の C 番 目 を 引 いた 値を 2 で 割 った 商 を A とする <eos>
3277
src = A = A + B [ 0 ] + str ( B [ 1 ] ) + ' '
trg = A に B の 0 番 目 を加えた 値に B の 1 番目の 文字列 を加えた 値に 空白 文字 を加えた 値を A とする
rst = A に B の 0 番 目 を加えた 値に B の 1 番目の 文字列 を加えた 値に 空白 文字 を加えた 値を A とする <eos>
3278
src = A = set ( B [ C : C + 3 ] )
trg = B の C 番 目 から C に 3 を加えた 値 までの 部分 列 の集合 を A とする
rst = B の C 番 目 から C に 3 を加えた 値 までの 部分 列 の集合 を A とする <eos>
3279
src = A = B * 10 ** - 5
trg = B に 10 の - 5 乗 を 掛 け た 値を A とする
rst = B に 10 の - 5 乗 を 掛 け た 値を A とする <eos>
3280
src = A . bit1 . add ( B + 1 , C * ( B + 1 ) )
trg = A の bit 1 に B に 1 を加えた 値 、 C に B に 1 を加えた 値を 掛 け た 値 を追加した 集 ま り
rst = A の bit 1 に B に 1 を加えた 値 、 C に B に 1 を加えた 値を 掛 け た 値 を追加した 集 ま り <eos>
3281
src = A = [ readline ( ) . strip ( ) for B in range ( C ) ]
trg = 0 から C 未 満 までの 数 列 の 各要素 を B とし 、 readline () の 両 端 から 空白 改行 を取り 除 いた 文字列 の 列 を A とする
rst = 0 から C 未 満 までの 数 列 の 各要素 を B とし 、 readline () の 両 端 から 空白 改行 を取り 除 いた 文字列 の 列 を A とする <eos>
3282
src = return A . code == B . code
trg = A の code が B の code と 等 しい かどうか を返す
rst = A の code が B の code と 等 しい かどうか を返す <eos>
3283
src = if A % ( B + 1 ) == 0 :
trg = A を B に 1 を加えた 値 で 割 った 余 り が 0 と 等 しい とき 、
rst = A を B に 1 を加えた 値 で 割 った 余 り が 0 と 等 しい とき 、 <eos>
3284
src = if A [ B * 3 : B * 3 + 3 ] . count ( C ) == 3 or A [ B : : 3 ] . count ( C ) == 3 :
trg = A の B に 3 を 掛 け た 値 から B * 3 に 3 を加えた 値 までの 部分 列 内の C の 出現 回数 が 3 と 等 しく または A の B 番 目 から 、 つまり 末 尾 までの 3 間隔 による 部分 列 内の C の 出現 回数 が 3 と 等 しい とき 、
rst = A の B に 3 を 掛 け た 値 から B に 3 を 掛 け た 値に 3 を加えた 値 までの 部分 列 内の C の 出現 回数 が 3 と 等 しく または A の B 番 目 から 3 番 目 までの 部分 列 内の C
3285
src = print ( '' . join ( [ A [ ( B + C ) % 2 ] for B in range ( D ) ] ) )
trg = 空文字列 を 間 に 入れ て 0 から D 未 満 までの 数 列 の 各要素 を B とし 、 A の ( B + C ) を 2 で 割 った 余 り 番目の 列 を 連結 した 文字列 を出力する
rst = 空文字列 を 間 に 入れ て 0 から D 未 満 までの 数 列 の 各要素 を B とし 、 A の ( B + C ) を 2 で 割 った 余 り 番目の 列 を 連結 した 文字列 を出力する <eos>
3286
src = A = date ( 2004 , B , C ) . weekday ( )
trg = date ( 2004 , B , C ) の 週 を A とする
rst = date ( 2004 , B , C ) . date ( 日付 ) を A とする <eos>
3287
src = print ( str ( A + 1 ) + B + str ( C + 1 ) + D + str ( ( A + 1 ) * ( C + 1 ) ) )
trg = str ( A + 1 ) に B を加えた 値に C + 1 の 文字列 を加えた 値に D を加えた 値に A に 1 を加えた 値に C に 1 を加えた 値を 掛 け た 値の 文字列 を加えた 値 を出力する
rst = str ( A + 1 ) に B を加えた 値に str ( C + 1 ) を加えた 値に D を加えた 値に A + 1 の 文字列 を加えた 値に C に 1 を加えた 値を 掛 け た 値の 文字列 を加えた 値 を出力する <eos>
3288
src = A %= 26
trg = A を 26 で 割 った 余 り にする
rst = A を 26 で 割 った 余 り にする <eos>
3289
src = if A [ 0 ] < A [ 1 ] and A [ 1 ] < A [ 2 ] :
trg = A の先頭 が A の 1 番 目 より 小さく かつ A の 1 番 目 が A の 2 番 目 より 小さい とき 、
rst = A の 0 番 目 が A の 1 番 目 より 小さく かつ A の 1 番 目 が A の 2 番 目 より 小さい とき 、 <eos>
3290
src = id_lower_search ( A , B , 0 , A . index ( 0 ) , None , C )
trg = id _ lower _ search ( A , B , 0 , A . index ( 0 ) , None , C )
rst = <unk> _ <unk> _ <unk> ( A , B , 0 , A . index ( 0 ) , None , C ) <eos>
3291
src = while A . count ( 1 ) < B :
trg = A 内の 1 の 出現 回数 が B より 小さい 間 、 次 を 繰り返す
rst = A 内の 1 の 出現 回数 が B より 小さい 間 、 次 を 繰り返す <eos>
3292
src = A , B = merge_sort ( A [ : ] , 0 , len ( A ) , B )
trg = merge _ sort ( A [ : ] , 0 , len ( A ) , B ) を 展開 し 、 それぞれ A 、 B とする
rst = merge _ sort ( A [ : ] , 0 , len ( A ) , B ) を 展開 し 、 それぞれ A 、 B とする <eos>
3293
src = A [ B ] = C [ D : ] [ : : - 1 ]
trg = C の D 番 目 から 、 つまり 末 尾 までの 部分 列 の 逆 順 を A の B 番 目 にする
rst = C の D 番 目 から 、 つまり 末 尾 までの 部分 列 の 逆 順 を A の B 番 目 にする <eos>
3294
src = A = sorted ( [ int ( input ( ) ) for B in [ 0 ] * int ( input ( ) ) ] ) [ : 4 ]
trg = ( 0 ) からなる 列 の input () の 整数値 回 分 の 列 の 各要素 を B とし 、 、 つまり 入力された 文字列 の 整数値 の 列 を ソート した 列 の 、 つまり 先頭 から 4 番 目 までの 部分 列 を A とする
rst = ( 0 ) からなる 列 の 、 つまり 入力された 文字列 の 整数値 回 分 の 列 の 各要素 を B とし 、 、 つまり 入力された 文字列 の 整数値 の 列 を ソート した 列 の 、 つまり 先頭 から 4 番 目 までの 部分 列 を A とする <eos>
3295
src = while A . limit > 0 :
trg = A の limit が 0 より 大きい 間 、 次 を 繰り返す
rst = A の limit が 0 より 大きい 間 、 次 を 繰り返す <eos>
3296
src = if A != len ( B ) :
trg = A が B の長さ と 等 しく ない とき 、
rst = A が B の長さ と 等 しく ない とき 、 <eos>
3297
src = time += ( A [ B ] - now ) / C
trg = time を A の B 番 目 から 、 つまり 現在の 日 時 を 引 いた 値を C で 割 った 値 だけ 増加 させる
rst = time を A の B 番 目 から 、 つまり 現在の 日 時 を 引 いた 値を C で 割 った 値 だけ 増加 させる <eos>
3298
src = E = F + G * D
trg = F に G に D を 掛 け た 値 を加えた 値を E とする
rst = F に G に D を 掛 け た 値 を加えた 値を E とする <eos>
3299
src = if abs ( ( A - B ) * ( C - D ) + ( E - F ) * ( G - H ) ) < 1.e-10 :
trg = A から B を 引 いた 値に C から D を 引 いた 値を 掛 け た 値に E から F を 引 いた 値に G から H を 引 いた 値を 掛 け た 値 を加えた 値の 絶対 値が 1. e -10 より 小さい とき 、
rst = A から B を 引 いた 値に C から D を 引 いた 値を 掛 け た 値に E から F を 引 いた 値に G から H を 引 いた 値を 掛 け た 値 を加えた 値の 絶対 値が 1 e - 4 より 小さい とき 、 <eos>
3300
src = if e != A :
trg = ネ イ ピ ア 数が A と 等 しく ない とき 、
rst = ネ イ ピ ア 数が A と 等 しく ない とき 、 <eos>
3301
src = for A in B [ 2 : 2 + C ] :
trg = B の 2 番 目 から 2 に C を加えた 値 までの 部分 列 を 順に A として 、 繰り返す
rst = B の 2 番 目 から 2 に C を加えた 値 までの 部分 列 を 順に A として 、 繰り返す <eos>
3302
src = A = ( B [ 0 ] [ 1 ] - C [ 0 ] [ 1 ] ) * ( D [ 0 ] [ 1 ] - E [ 0 ] [ 1 ] )
trg = B の先頭 の 1 番 目 から C の先頭 の 1 番 目 を 引 いた 値に D の先頭 の 1 番 目 から E の先頭 の 1 番 目 を 引 いた 値を 掛 け た 値を A とする
rst = B の先頭 の 1 番 目 から C の先頭 の 1 番 目 を 引 いた 値に D の 0 番 目 から E の先頭 の 1 番 目 を 引 いた 値を 掛 け た 値を A とする <eos>
3303
src = A = B . real - B . imag
trg = B の real から B の imag を 引 いた 値を A とする
rst = B の real から B の imag を 引 いた 値を A とする <eos>
3304
src = print ( {i}x{j}={i*j} )
trg = " { } x { } = { } " を出力する
rst = " T { } " を出力する <eos>
3305
src = A . insert ( int ( B ) )
trg = A の B の 整数値 に [MASK] を挿入する
rst = A の B の 整数値 に [MASK] を挿入する <eos>
3306
src = A = dfs ( B | ( 1 << C ) , C , tuple ( D ) )
trg = dfs ( B | ( 1 < < C ) , C , tuple ( D ) ) を A とする
rst = dfs ( B | ( 1 < C ) , C , tuple ( D ) ) を A とする <eos>
3307
src = if A == B or C == D :
trg = A が B と 等 しく または C が D と 等 しい とき 、
rst = A が B と 等 しく または C が D と 等 しい とき 、 <eos>
3308
src = A = ( B << 9 ) + ( C << 5 ) + D
trg = B を 9 だけ 左 シフト した 値に C を 5 だけ 左 シフト した 値 を加えた 値に D を加えた 値を A とする
rst = B を 9 だけ 左 シフト した 値に C を 5 だけ 左 シフト した 値 を加えた 値に D を加えた 値を A とする <eos>
3309
src = for A in range ( 1 , B // 3 + 1 ) :
trg = 1 から B を 3 で 割 った 商 に 1 を加えた 値 未 満 までの 数 列 を 順に A として 、 繰り返す
rst = 1 から B を 3 で 割 った 商 に 1 を加えた 値 未 満 までの 数 列 を 順に A として 、 繰り返す <eos>
3310
src = for A in range ( 8 - B + 1 ) :
trg = 0 から 8 から B を 引 いた 値に 1 を加えた 値 未 満 までの 数 列 を 順に A として 、 繰り返す
rst = 0 から 8 から B を 引 いた 値に 1 を加えた 値 未 満 までの 数 列 を 順に A として 、 繰り返す <eos>
3311
src = A [ B ] = C [ : D ]
trg = C の 、 つまり 先頭 から D 番 目 までの 部分 列 を A の B 番 目 にする
rst = C の 、 つまり 先頭 から D 番 目 までの 部分 列 を A の B 番 目 にする <eos>
3312
src = A = 7 if 4 in B else ( 6 if 3 in B and 2 in B else ( 4 if 3 in B else ( 3 if B . count ( 2 ) == 2 else 2 ) ) )
trg = 4 が B に含まれる とき 7 、 そうでなければ 3 が B に 含まれ かつ 2 が B に含まれる とき 6 、 そうでなければ 3 が B に含まれる とき 4 、 そうでなければ B . count ( 2 ) が 2 と 等 しい とき 3 、 そうでなければ 2 を A とする
rst = B が 3 に含まれる とき 7 、 そうでなければ B が 2 に 含まれ かつ B が 3 に含まれる とき 4 、 そうでなければ B が 3 、 そうでなければ B . count が 2 と 等 しい とき 3 、 そうでなければ B の 出現 回数 、 そうでなければ 2 と 等 しい とき
3313
src = if A [ B ] > A [ B + 1 ] :
trg = A の B 番 目 が A の B に 1 を加えた 値 番 目 より 大きい とき 、
rst = A の B 番 目 が A の B に 1 を加えた 値 番 目 より 大きい とき 、 <eos>
3314
src = A = B [ C + 1 ] [ D - 1 ]
trg = B の C に 1 を加えた 値 番目の D から 1 を 引 いた 値 番 目 を A とする
rst = B の C に 1 を加えた 値 番目の D から 1 を 引 いた 値 番 目 を A とする <eos>
3315
src = if not 0 <= A < B or not 0 <= C < D or E [ C ] [ A ] == F :
trg = 0 が A 以下 かどうか が B より 小さく なく または 0 が C 以下 かどうか が D より 小さく なく または E の C 番目の A 番 目 が F と 等 しい とき 、
rst = 0 が A 以下 かどうか が B より 小さく なく または 0 が C 以下 かどうか が D より 小さく なく または E の C 番目の A 番 目 が F と 等 しい とき 、 <eos>
3316
src = if A [ B ] [ C + D ] :
trg = A の B 番目の C に D を加えた 値 番目の とき 、
rst = A の B 番目の C に D を加えた 値 番目の とき 、 <eos>
3317
src = A += math . sin ( math . radians ( B ) ) * C
trg = A を B の ラ ジ アン の 正 弦 に C を 掛 け た 値 だけ 増加 させる
rst = A を B の ラ ジ アン の 正 弦 に C を 掛 け た 値 だけ 増加 させる <eos>
3318
src = A . append ( ( 0 , B , C ) )
trg = A の 末 尾 に ( 0 、 B 、 C ) の 組 を追加する
rst = A の 末 尾 に ( 0 、 B 、 C ) の 組 を追加する <eos>
3319
src = A = max ( A , ( ( B - min ( [ C [ D ] for D in E ] ) ) * ( F - min ( [ G [ D ] for D in E ] ) ) ) )
trg = A 、 B から E の 各要素 を D とし 、 C [ D ] の 列 の 最小 値を 引 いた 値に F から E の 各要素 を D とし 、 G [ D ] の 列 の 最小 値を 引 いた 値を 掛 け た 値の 最大 値を A とする
rst = A 、 E の 各要素 を D とし 、 B から ( C [ D ] の 最小 値を 引 いた 値に F から G の D 番 目 を 引 いた 値を 掛 け た 値の 列 の 最大 値を A とする <eos>
3320
src = A [ B ] [ C ] = A [ B - 1 ] [ C - 1 ] + A [ B ] [ C ]
trg = A の B から 1 を 引 いた 値 番目の C から 1 を 引 いた 値 番 目 に A の B 番目の C 番 目 を加えた 値を A の B 番目の C 番 目 にする
rst = A の B から 1 を 引 いた 値 番目の C から 1 を 引 いた 値 番 目 に A の B 番目の C 番 目 を加えた 値を A の B 番目の C 番 目 にする <eos>
3321
src = print ( A . index ( B [ int ( C ) ] ) + 1 )
trg = A の B の C の 整数値 番 目 と 等 しい 要素 の最初の 位置 に 1 を加えた 値 を出力する
rst = A の B の C の 整数値 番 目 と 等 しい 要素 の最初の 位置 に 1 を加えた 値 を出力する <eos>
3322
src = A . primes = [ ]
trg = 空 列 を A の primes にする
rst = 空 列 を A の primes にする <eos>
3323
src = return [ A [ 3 ] , A [ 1 ] , A [ 0 ] , A [ 5 ] , A [ 4 ] , A [ 2 ] ]
trg = ( A の 3 番 目 、 A の 1 番 目 、 A の先頭 、 A の 5 番 目 、 A の 4 番 目 、 A の 2 番 目 ) からなる 列 を返す
rst = ( A の 3 番 目 、 A の 1 番 目 、 A の先頭 、 A の 5 番 目 、 A の 4 番 目 、 A の 2 番 目 ) からなる 列 を返す <eos>
3324
src = A -= 60 * B
trg = A を 60 に B を 掛 け た 値 だけ 減少 させる
rst = A を 60 に B を 掛 け た 値 だけ 減少 させる <eos>
3325
src = D = ( B + C * 2 ) / 3
trg = B に C に 2 を 掛 け た 値 を加えた 値を 3 で 割 った 値を D とする
rst = B に C に 2 を 掛 け た 値 を加えた 値を 3 で 割 った 値を D とする <eos>
3326
src = A . remove ( B + 26 )
trg = A 内の B に 26 を加えた 値 と 等 しい 要素を 取り除く
rst = A 内の B に 26 を加えた 値 と 等 しい 要素を 取り除く <eos>
3327
src = A = max ( A , e + B [ 0 ] + B [ 1 ] )
trg = A 、 ネ イ ピ ア 数 に B の 0 番 目 を加えた 値に B の 1 番 目 を加えた 値の 最大 値を A とする
rst = A 、 ネ イ ピ ア 数 に B の 0 番 目 を加えた 値に B の 1 番 目 を加えた 値の 最大 値を A とする <eos>
3328
src = heappush ( A , ( 0 , B , C , D ) )
trg = heappush ( A , ( 0 , B , C , D ) )
rst = heappush ( A , ( 0 , B , C , D ) ) <eos>
3329
src = A . reverse ( )
trg = A を 逆 順に する
rst = A を 逆 順に する <eos>
3330
src = fill ( A , B )
trg = fill ( A , B )
rst = fill ( A , B ) <eos>
3331
src = A = min ( B ) + 1
trg = B の 最小 値に 1 を加えた 値を A とする
rst = B の 最小 値に 1 を加えた 値を A とする <eos>
3332
src = A [ ( 0 , 0 ) ] = 0
trg = 0 を A の ( 0 、 0 ) の 組 番 目 にする
rst = 0 を A の ( 0 、 0 ) の 組 番 目 にする <eos>
3333
src = A = HashMap ( )
trg = HashMap () を A とする
rst = <unk> () を A とする <eos>
3334
src = G_choice ( A )
trg = G _ choice ( A )
rst = <unk> ( A ) <eos>
3335
src = A = extgcd ( B , C % B , D , E )
trg = extgcd ( B , C % B , D , E ) を A とする
rst = extgcd ( B , C % B , D , E ) を A とする <eos>
3336
src = if A > B / 2 :
trg = A が B を 2 で 割 った 値 より 大きい とき 、
rst = A が B を 2 で 割 った 値 より 大きい とき 、 <eos>
3337
src = A [ B ] , A [ C ] , A [ D ] = 1 , 1 , 1
trg = 1 、 1 、 1 を A の B 番 目 、 A の C 番 目 、 A の D 番 目 とする
rst = 1 、 1 を A の B 番 目 、 A の C 番 目 、 A の D 番 目 とする <eos>
3338
src = A = paint ( A , B + 1 , C )
trg = paint ( A , B + 1, C ) を A とする
rst = paint ( A , B + 1, C ) を A とする <eos>
3339
src = A = [ int ( B [ 1 ] ) , 0 , 1 ]
trg = ( B の 1 番目の 整数値 、 0 、 1 ) からなる 列 を A とする
rst = ( B の 1 番目の 整数値 、 0 、 1 ) からなる 列 を A とする <eos>
3340
src = if A [ B ] is True :
trg = A の B 番 目 が 、 つまり 真 と 等 しく ない とき 、
rst = A の B 番 目 が 、 つまり 真 と 等 しく ない とき 、 <eos>
3341
src = A = min ( A , dfs ( 0 , B , 0 ) )
trg = A 、 dfs ( 0 , B , 0 ) の 最小 値を A とする
rst = A 、 dfs ( 0 , B , 0 ) の 最小 値を A とする <eos>
3342
src = A = deque ( [ ] )
trg = 空 列 の 両 端 キュー を A とする
rst = 空 列 の 両 端 キュー を A とする <eos>
3343
src = print ( A % max ( B [ C - 1 ] ) )
trg = A を B の C から 1 を 引 いた 値 番目の 最大 値 で 割 った 余 り を出力する
rst = A を B の C から 1 を 引 いた 値 番目の 最大 値 で 割 った 余 り を出力する <eos>
3344
src = _in_walk ( A . nodes [ B ] . right_child )
trg = _ in _ walk ( A . nodes [ B ] . right _ child )
rst = _ in _ walk ( A . nodes [ B ] . right _ child ) <eos>
3345
src = A = bisect_right ( B , C + D , A , E + 1 ) - 1
trg = ソート された 順序 を 保 った まま C に D を加えた 値を A から E に 1 を加えた 値 まで の範囲 で B に 挿入 できる 位置 から 1 を 引 いた 値を A とする
rst = ソート された 順序 を 保 った まま C に D を加えた 値を A から E に 1 を加えた 値 まで の範囲 で B に 挿入 できる 位置 から 1 を 引 いた 値を A とする <eos>
3346
src = A |= 1 << ( B - 1 )
trg = A を 1 を B から 1 を 引 いた 値 だけ 左 シフト した 値 と の 論理 和 にする
rst = A を 1 を B から 1 を 引 いた 値 だけ 左 シフト した 値 と の 論理 和 にする <eos>
3347
src = A += B * f ( C )
trg = A を B に f ( C ) を 掛 け た 値 だけ 増加 させる
rst = A を B に f ( C ) を 掛 け た 値 だけ 増加 させる <eos>
3348
src = A = B * C * D / 2.0
trg = B に C を 掛 け た 値に D を 掛 け た 値を 2.0 で 割 った 値を A とする
rst = B に C を 掛 け た 値に D を 掛 け た 値を 2.0 で 割 った 値を A とする <eos>
3349
src = A [ B ] = par ( A [ B ] )
trg = par ( A [ B ] ) を A の B 番 目 にする
rst = par ( A [ B ] ) を A の B 番 目 にする <eos>
3350
src = for A in sorted ( B . nodes . keys ( ) ) :
trg = B の nodes の キー の集まり を ソート した 列 を 順に A として 、 繰り返す
rst = B の nodes の キー の集まり を ソート した 列 を 順に A として 、 繰り返す <eos>
3351
src = A = copy . deepcopy ( B [ C ] )
trg = B の C 番 目 を 深く コピー した結果 を A とする
rst = B の C 番 目 を 深く コピー した結果 を A とする <eos>
3352
src = A . val = B . val
trg = B の val を A の val にする
rst = B の val を A の val にする <eos>
3353
src = A . down ( B [ 0 ] )
trg = A . down ( B [ 0 ] )
rst = A . up ( B [ 0 ] ) <eos>
3354
src = A . pip [ 0 ] , A . pip [ 2 ] , A . pip [ 3 ] , A . pip [ 5 ] = A . pip [ 3 ] , A . pip [ 0 ] , A . pip [ 5 ] , A . pip [ 2 ]
trg = A の pip の 3 番 目 、 A の pip の先頭 、 A の pip の 5 番 目 、 A の pip の 2 番 目 を A の pip の先頭 、 A の pip の 2 番 目 、 A の pip の 3 番 目 、 A の pip の 5 番 目 とする
rst = A の pip の 3 番 目 、 A の pip の 5 番 目 、 A の pip の先頭 、 A の pip の 2 番 目 を A の pip の先頭 、 A の pip の 2 番 目 、 A の pip の 3 番 目 、
3355
src = A = { 'insert' : C . appendleft , 'delete' : C . remove , 'deleteFirst' : C . popleft , 'deleteLast' : C . pop }
trg = ( ( B , C の 先頭に [MASK] を追加する ) 、 ( D , C 内の [MASK] と 等 しい 要素を 取り除く ) 、 ( E , C の popleft ) 、 ( F , C の先頭 を取り 出した 値 ) ) からなる 辞書 を A とする
rst = ( ( B , C の 先頭に [MASK] を追加した 集 ま り ) 、 ( D , C の 組 ) 、 ( E , C の mul ) 、 ( F , C の popleft ) 、 ( K , C の popleft ) ) からなる 辞書 を A
3356
src = A = ( B + C ) % D . size
trg = B に C を加えた 値を D の size で 割 った 余 り を A とする
rst = B に C を加えた 値を D の size で 割 った 余 り を A とする <eos>
3357
src = A = matpow ( A , B , C - D , E )
trg = matpow ( A , B , C - D , E ) を A とする
rst = <unk> ( A , B , C - D , E ) を A とする <eos>
3358
src = for A in range ( B // 2 + 1 ) :
trg = 0 から B を 2 で 割 った 商 に 1 を加えた 値 未 満 までの 数 列 を 順に A として 、 繰り返す
rst = 0 から B を 2 で 割 った 商 に 1 を加えた 値 未 満 までの 数 列 を 順に A として 、 繰り返す <eos>
3359
src = print ( wa ( A ) )
trg = wa ( A ) を出力する
rst = <unk> ( A ) を出力する <eos>
3360
src = A = [ inf for B in range ( C ) ]
trg = 0 から C 未 満 までの 数 列 の 各要素 を B とし 、 、 つまり 無限大 の 列 を A とする
rst = 0 から C 未 満 までの 数 列 の 各要素 を B とし 、 、 つまり 無限大 の 列 を A とする <eos>
3361
src = return hash ( A )
trg = A の ハッシュ 値を返す
rst = A の ハッシュ 値を返す <eos>
3362
src = A = A + 2 * ( B - 999 ) * ( B - 1000 ) if B > 1000 else 0
trg = B が 1000 より 大きい とき A に 2 に B から 9 99 を 引 いた 値を 掛 け た 値に B から 1000 を 引 いた 値を 掛 け た 値 を加えた 値 、 そうでなければ 0 を A とする
rst = A が B より 大きい とき A に 2 に B から 9 を 引 いた 値を 掛 け た 値 を加えた 値に B から 1000 を 引 いた 値を 掛 け た 値 、 そうでなければ 0 を加えた 値を A とする <eos>
3363
src = swap ( tuple ( map ( int , input ( ) . split ( A ) ) ) )
trg = swap ( tuple ( map ( int , input () . split ( A ) ) ) )
rst = swap ( int ( input () . split () ) ) の 組 を A で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 の 組 <eos>
3364
src = if A . f [ B ] == 9 :
trg = A の f の B 番 目 が 9 と 等 しい とき 、
rst = A の f の B 番 目 が 9 と 等 しい とき 、 <eos>
3365
src = A [ B + C ] -= C
trg = A の B に C を加えた 値 番 目 を C だけ 減少 させる
rst = A の B に C を加えた 値 番 目 を C だけ 減少 させる <eos>
3366
src = if A < B [ C ] [ D ] :
trg = A が B の C 番目の D 番 目 より 小さい とき 、
rst = A が B の C 番目の D 番 目 より 小さい とき 、 <eos>
3367
src = from operator import A
trg = operator モジュール を用いる
rst = string モジュール を用いる <eos>
3368
src = if is_intersected ( A , B , C , D ) :
trg = is _ intersected ( A , B , C , D ) の とき 、
rst = <unk> ( A , B , C , D ) の とき 、 <eos>
3369
src = A , B , e , C , D = map ( int , input ( ) . split ( ) )
trg = 入力された 文字列を 空白 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 を 展開 し 、 それぞれ A 、 B 、 ネ イ ピ ア 数 、 C 、 D とする
rst = 入力された 文字列を 空白 で 分割 した 字句 列 の 各要素 に 整数 を適用した 列 を 展開 し 、 それぞれ A 、 B 、 ネ イ ピ ア 数 、 C 、 D とする <eos>
3370
src = A = - 1 * float ( B )
trg = -1 に B の 浮動小数点数 を 掛 け た 値を A とする
rst = -1 に B の 浮動小数点数 を 掛 け た 値を A とする <eos>
3371
src = A = [ B + C for B in [ D [ 0 ] for C in D [ 1 ] ] ]
trg = D の 1 番目の 各要素 を C とし 、 D の 0 番目の 列 の 各要素 を B とし 、 B に C を加えた 値の 列 を A とする
rst = D の 1 番目の 各要素 を C とし 、 D の 0 番目の 列 の 各要素 を B とし 、 B に C を加えた 値の 列 を A とする <eos>
3372
src = A = B . readline ( ) . split ( ) + [ C , C ]
trg = B から 読み 込 んだ 一行 を 空白 で 分割 した 字句 列 に ( C 、 C ) からなる 列 を加えた 値を A とする
rst = B から 読み 込 んだ 一行 を 空白 で 分割 した 字句 列 に ( C 、 C ) からなる 列 を加えた 値を A とする <eos>
3373
src = for A in range ( B + 1 , B + C + 1 ) :
trg = B に 1 を加えた 値 から B に C を加えた 値に 1 を加えた 値 未 満 までの 数 列 を 順に A として 、 繰り返す
rst = B に 1 を加えた 値 から B に C を加えた 値に 1 を加えた 値 未 満 までの 数 列 を 順に A として 、 繰り返す <eos>
3374
src = A . cnt_mp [ B ] [ C ] [ D ] -= 1
trg = A の cnt _ mp の B 番目の C 番目の D 番 目 を 1 だけ 減少 させる
rst = A の cnt _ mp の B 番目の C 番目の D 番 目 を 1 だけ 減少 させる <eos>
3375
src = while count <= A :
trg = 無限 の 整数 列 が A 以下の 間 、 次 を 繰り返す
rst = 無限 の 整数 列 が A 以下の 間 、 次 を 繰り返す <eos>
3376
src = A = [ B [ C ] for C in D . strip ( ) ]
trg = D の 両 端 から 空白 改行 を取り 除 いた 文字列 の 各要素 を C とし 、 B の C 番目の 列 を A とする
rst = D の 両 端 から 空白 改行 を取り 除 いた 文字列 の 各要素 を C とし 、 B の C 番目の 列 を A とする <eos>
3377
src = if A [ 2 ] and ( ( not A [ 0 ] ) or A [ 1 ] ) :
trg = A の 2 番 目 かつ A の先頭 で なく または A の 1 番目の とき 、
rst = A の 2 番 目 かつ A の 0 番 目 で なく または A の 1 番 目 でない とき 、 <eos>
3378
src = A [ B ] [ C ] = ( D // E , F // E )
trg = ( D を E で 割 った 商 、 F を E で 割 った 商 ) の 組 を A の B 番目の C 番 目 にする
rst = ( D を E で 割 った 商 、 F を E で 割 った 商 ) の 組 を A の B 番目の C 番 目 にする <eos>
3379
src = A = list ( str ( B ) . zfill ( C ) )
trg = B の 文字列を 長さ C になる ように ' 0 ' 左 詰 め した 文字列 の リストを A とする
rst = B の 文字列を 長さ C になる ように ' 0 ' 左 詰 め した 文字列 の リストを A とする <eos>
3380
src = A . heappush ( B [ C [ 1 ] ] , - C [ 2 ] )
trg = A . heappush ( B [ C [ 1 ]] , - C [ 2 ] )
rst = A . heappush ( B [ C [ 1 ]] , - C [ 2 ] ) <eos>
3381
src = if A [ B ] [ C ] != D and A [ C ] [ E ] != D :
trg = A の B 番目の C 番 目 が D と 等 しく なく かつ A の C 番目の E 番 目 が D と 等 しく ない とき 、
rst = A の B 番目の C 番 目 が D と 等 しく なく かつ A の C 番目の E 番 目 が D と 等 しく ない とき 、 <eos>
3382
src = super ( ) . __init__ ( A , B )
trg = super () . __ init __ ( A , B )
rst = super () . __ init __ ( A , B ) <eos>
3383
src = A = int ( math . sqrt ( B ) ) + 1
trg = B の 平 方 根 の 整数値 に 1 を加えた 値を A とする
rst = B の 平 方 根 の 整数値 に 1 を加えた 値を A とする <eos>
3384
src = while ( A [ B ] > 0 ) :
trg = A の B 番 目 が 0 より 大きい 間 、 次 を 繰り返す
rst = A の B 番 目 が 0 より 大きい 間 、 次 を 繰り返す <eos>
3385
src = A = 100000000000000
trg = 100 0000 0000 0000 を A とする
rst = 10 4 6 5 27 を A とする <eos>
3386
src = A = B [ C ] [ 0 ] + 1
trg = B の C 番目の 0 番 目 に 1 を加えた 値を A とする
rst = B の C 番目の 0 番 目 に 1 を加えた 値を A とする <eos>
3387
src = A . append ( B . to )
trg = A の 末 尾 に B の to を追加する
rst = A の 末 尾 に B の to を追加する <eos>
3388
src = return ( A , B , C , count )
trg = ( A 、 B 、 C 、 無限 の 整数 列 ) の 組 を返す
rst = ( A 、 B 、 C 、 無限 の 整数 列 ) の 組 を返す <eos>
3389
src = A = 1868 + B - 1
trg = 18 68 に B を加えた 値 から 1 を 引 いた 値を A とする
rst = 18 68 に B を加えた 値 から 1 を 引 いた 値を A とする <eos>
3390
src = ( A , B ) = bubble_sort ( C )
trg = bubble _ sort ( C ) を ( A 、 B ) の 組 とする
rst = bubble _ sort ( C ) を ( A 、 B ) の 組 とする <eos>
3391
src = A . extend ( B [ 2 : ] )
trg = B の 2 番 目 から 、 つまり 末 尾 までの 部分 列 を追加し て A を拡張する
rst = B の 2 番 目 から 、 つまり 末 尾 までの 部分 列 を追加し て A を拡張する <eos>
3392
src = if find ( A . root , B ) :
trg = find ( A . root , B ) の とき 、
rst = find ( A . root , B ) の とき 、 <eos>
3393
src = A = B . back
trg = B の back を A とする
rst = B の back を A とする <eos>
3394
src = print ( 100.00000000 , 0.00000000 )
trg = 100 . 0000 0000 、 0 . 0000 0000 を出力する
rst = " ( 0 . 0000 0000 、 0 . 0000 0000 ) の 組 <eos>
3395
src = A = [ int ( B ) for B in str ( C ) ]
trg = C の 文字列 の 各要素 を B とし 、 B の 整数値 の 列 を A とする
rst = C の 文字列 の 各要素 を B とし 、 B の 整数値 の 列 を A とする <eos>
3396
src = A [ 2 ] -= B [ 1 ] * B [ 7 ]
trg = A の 2 番 目 を B の 1 番 目 に B の 7 番 目 を 掛 け た 値 だけ 減少 させる
rst = A の 2 番 目 を B の 1 番 目 に B の 7 番 目 を 掛 け た 値 だけ 減少 させる <eos>
3397
src = A . penalty = 0
trg = 0 を A の penalty にする
rst = 0 を A の time にする <eos>
3398
src = A = B * 30 + ( C / 60 * 30 )
trg = B に 30 を 掛 け た 値に C を 60 で 割 った 値に 30 を 掛 け た 値 を加えた 値を A とする
rst = B に 30 を 掛 け た 値に C を 60 で 割 った 値に 30 を 掛 け た 値 を加えた 値を A とする <eos>
3399
src = A += dfs ( B + 1 , C , D ) * D % E
trg = A を dfs ( B + 1, C , D ) に D を 掛 け た 値を E で 割 った 余 り だけ 増加 させる
rst = A を dfs ( B + 1, C , D ) に D を 掛 け た 値を E で 割 った 余 り だけ 増加 させる <eos>
3400
src = A [ bin5 ( 26 + B ) ] = C [ B ]
trg = C の B 番 目 を A の bin 5 ( 26 + B ) 番 目 にする
rst = C の B 番 目 を A の <unk> _ <unk> に B を加えた 値 番 目 にする <eos>
